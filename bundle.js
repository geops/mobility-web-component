(() => {
  var __create = Object.create;
  var __defProp = Object.defineProperty;
  var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
  var __getOwnPropNames = Object.getOwnPropertyNames;
  var __getProtoOf = Object.getPrototypeOf;
  var __hasOwnProp = Object.prototype.hasOwnProperty;
  var __commonJS = (cb, mod) => function __require() {
    return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
  };
  var __export = (target, all3) => {
    for (var name in all3)
      __defProp(target, name, { get: all3[name], enumerable: true });
  };
  var __copyProps = (to, from, except, desc) => {
    if (from && typeof from === "object" || typeof from === "function") {
      for (let key of __getOwnPropNames(from))
        if (!__hasOwnProp.call(to, key) && key !== except)
          __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
    }
    return to;
  };
  var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
    // If the importer is in node compatibility mode or this is not an ESM
    // file that has been converted to a CommonJS file using a Babel-
    // compatible transform (i.e. "__esModule" has not been set), then set
    // "default" to the CommonJS "module.exports" for node compatibility.
    isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
    mod
  ));

  // node_modules/rbush/rbush.min.js
  var require_rbush_min = __commonJS({
    "node_modules/rbush/rbush.min.js"(exports, module) {
      !function(t3, i4) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = i4() : "function" == typeof define && define.amd ? define(i4) : (t3 = t3 || self).RBush = i4();
      }(exports, function() {
        "use strict";
        function t3(t4, r5, e4, a5, h4) {
          !function t5(n3, r6, e5, a6, h5) {
            for (; a6 > e5; ) {
              if (a6 - e5 > 600) {
                var o5 = a6 - e5 + 1, s5 = r6 - e5 + 1, l5 = Math.log(o5), f4 = 0.5 * Math.exp(2 * l5 / 3), u5 = 0.5 * Math.sqrt(l5 * f4 * (o5 - f4) / o5) * (s5 - o5 / 2 < 0 ? -1 : 1), m4 = Math.max(e5, Math.floor(r6 - s5 * f4 / o5 + u5)), c5 = Math.min(a6, Math.floor(r6 + (o5 - s5) * f4 / o5 + u5));
                t5(n3, r6, m4, c5, h5);
              }
              var p7 = n3[r6], d4 = e5, x2 = a6;
              for (i4(n3, e5, r6), h5(n3[a6], p7) > 0 && i4(n3, e5, a6); d4 < x2; ) {
                for (i4(n3, d4, x2), d4++, x2--; h5(n3[d4], p7) < 0; )
                  d4++;
                for (; h5(n3[x2], p7) > 0; )
                  x2--;
              }
              0 === h5(n3[e5], p7) ? i4(n3, e5, x2) : i4(n3, ++x2, a6), x2 <= r6 && (e5 = x2 + 1), r6 <= x2 && (a6 = x2 - 1);
            }
          }(t4, r5, e4 || 0, a5 || t4.length - 1, h4 || n2);
        }
        function i4(t4, i5, n3) {
          var r5 = t4[i5];
          t4[i5] = t4[n3], t4[n3] = r5;
        }
        function n2(t4, i5) {
          return t4 < i5 ? -1 : t4 > i5 ? 1 : 0;
        }
        var r4 = function(t4) {
          void 0 === t4 && (t4 = 9), this._maxEntries = Math.max(4, t4), this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries)), this.clear();
        };
        function e3(t4, i5, n3) {
          if (!n3)
            return i5.indexOf(t4);
          for (var r5 = 0; r5 < i5.length; r5++)
            if (n3(t4, i5[r5]))
              return r5;
          return -1;
        }
        function a4(t4, i5) {
          h3(t4, 0, t4.children.length, i5, t4);
        }
        function h3(t4, i5, n3, r5, e4) {
          e4 || (e4 = p6(null)), e4.minX = 1 / 0, e4.minY = 1 / 0, e4.maxX = -1 / 0, e4.maxY = -1 / 0;
          for (var a5 = i5; a5 < n3; a5++) {
            var h4 = t4.children[a5];
            o4(e4, t4.leaf ? r5(h4) : h4);
          }
          return e4;
        }
        function o4(t4, i5) {
          return t4.minX = Math.min(t4.minX, i5.minX), t4.minY = Math.min(t4.minY, i5.minY), t4.maxX = Math.max(t4.maxX, i5.maxX), t4.maxY = Math.max(t4.maxY, i5.maxY), t4;
        }
        function s4(t4, i5) {
          return t4.minX - i5.minX;
        }
        function l4(t4, i5) {
          return t4.minY - i5.minY;
        }
        function f3(t4) {
          return (t4.maxX - t4.minX) * (t4.maxY - t4.minY);
        }
        function u4(t4) {
          return t4.maxX - t4.minX + (t4.maxY - t4.minY);
        }
        function m3(t4, i5) {
          return t4.minX <= i5.minX && t4.minY <= i5.minY && i5.maxX <= t4.maxX && i5.maxY <= t4.maxY;
        }
        function c4(t4, i5) {
          return i5.minX <= t4.maxX && i5.minY <= t4.maxY && i5.maxX >= t4.minX && i5.maxY >= t4.minY;
        }
        function p6(t4) {
          return { children: t4, height: 1, leaf: true, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
        }
        function d3(i5, n3, r5, e4, a5) {
          for (var h4 = [n3, r5]; h4.length; )
            if (!((r5 = h4.pop()) - (n3 = h4.pop()) <= e4)) {
              var o5 = n3 + Math.ceil((r5 - n3) / e4 / 2) * e4;
              t3(i5, o5, n3, r5, a5), h4.push(n3, o5, o5, r5);
            }
        }
        return r4.prototype.all = function() {
          return this._all(this.data, []);
        }, r4.prototype.search = function(t4) {
          var i5 = this.data, n3 = [];
          if (!c4(t4, i5))
            return n3;
          for (var r5 = this.toBBox, e4 = []; i5; ) {
            for (var a5 = 0; a5 < i5.children.length; a5++) {
              var h4 = i5.children[a5], o5 = i5.leaf ? r5(h4) : h4;
              c4(t4, o5) && (i5.leaf ? n3.push(h4) : m3(t4, o5) ? this._all(h4, n3) : e4.push(h4));
            }
            i5 = e4.pop();
          }
          return n3;
        }, r4.prototype.collides = function(t4) {
          var i5 = this.data;
          if (!c4(t4, i5))
            return false;
          for (var n3 = []; i5; ) {
            for (var r5 = 0; r5 < i5.children.length; r5++) {
              var e4 = i5.children[r5], a5 = i5.leaf ? this.toBBox(e4) : e4;
              if (c4(t4, a5)) {
                if (i5.leaf || m3(t4, a5))
                  return true;
                n3.push(e4);
              }
            }
            i5 = n3.pop();
          }
          return false;
        }, r4.prototype.load = function(t4) {
          if (!t4 || !t4.length)
            return this;
          if (t4.length < this._minEntries) {
            for (var i5 = 0; i5 < t4.length; i5++)
              this.insert(t4[i5]);
            return this;
          }
          var n3 = this._build(t4.slice(), 0, t4.length - 1, 0);
          if (this.data.children.length)
            if (this.data.height === n3.height)
              this._splitRoot(this.data, n3);
            else {
              if (this.data.height < n3.height) {
                var r5 = this.data;
                this.data = n3, n3 = r5;
              }
              this._insert(n3, this.data.height - n3.height - 1, true);
            }
          else
            this.data = n3;
          return this;
        }, r4.prototype.insert = function(t4) {
          return t4 && this._insert(t4, this.data.height - 1), this;
        }, r4.prototype.clear = function() {
          return this.data = p6([]), this;
        }, r4.prototype.remove = function(t4, i5) {
          if (!t4)
            return this;
          for (var n3, r5, a5, h4 = this.data, o5 = this.toBBox(t4), s5 = [], l5 = []; h4 || s5.length; ) {
            if (h4 || (h4 = s5.pop(), r5 = s5[s5.length - 1], n3 = l5.pop(), a5 = true), h4.leaf) {
              var f4 = e3(t4, h4.children, i5);
              if (-1 !== f4)
                return h4.children.splice(f4, 1), s5.push(h4), this._condense(s5), this;
            }
            a5 || h4.leaf || !m3(h4, o5) ? r5 ? (n3++, h4 = r5.children[n3], a5 = false) : h4 = null : (s5.push(h4), l5.push(n3), n3 = 0, r5 = h4, h4 = h4.children[0]);
          }
          return this;
        }, r4.prototype.toBBox = function(t4) {
          return t4;
        }, r4.prototype.compareMinX = function(t4, i5) {
          return t4.minX - i5.minX;
        }, r4.prototype.compareMinY = function(t4, i5) {
          return t4.minY - i5.minY;
        }, r4.prototype.toJSON = function() {
          return this.data;
        }, r4.prototype.fromJSON = function(t4) {
          return this.data = t4, this;
        }, r4.prototype._all = function(t4, i5) {
          for (var n3 = []; t4; )
            t4.leaf ? i5.push.apply(i5, t4.children) : n3.push.apply(n3, t4.children), t4 = n3.pop();
          return i5;
        }, r4.prototype._build = function(t4, i5, n3, r5) {
          var e4, h4 = n3 - i5 + 1, o5 = this._maxEntries;
          if (h4 <= o5)
            return a4(e4 = p6(t4.slice(i5, n3 + 1)), this.toBBox), e4;
          r5 || (r5 = Math.ceil(Math.log(h4) / Math.log(o5)), o5 = Math.ceil(h4 / Math.pow(o5, r5 - 1))), (e4 = p6([])).leaf = false, e4.height = r5;
          var s5 = Math.ceil(h4 / o5), l5 = s5 * Math.ceil(Math.sqrt(o5));
          d3(t4, i5, n3, l5, this.compareMinX);
          for (var f4 = i5; f4 <= n3; f4 += l5) {
            var u5 = Math.min(f4 + l5 - 1, n3);
            d3(t4, f4, u5, s5, this.compareMinY);
            for (var m4 = f4; m4 <= u5; m4 += s5) {
              var c5 = Math.min(m4 + s5 - 1, u5);
              e4.children.push(this._build(t4, m4, c5, r5 - 1));
            }
          }
          return a4(e4, this.toBBox), e4;
        }, r4.prototype._chooseSubtree = function(t4, i5, n3, r5) {
          for (; r5.push(i5), !i5.leaf && r5.length - 1 !== n3; ) {
            for (var e4 = 1 / 0, a5 = 1 / 0, h4 = void 0, o5 = 0; o5 < i5.children.length; o5++) {
              var s5 = i5.children[o5], l5 = f3(s5), u5 = (m4 = t4, c5 = s5, (Math.max(c5.maxX, m4.maxX) - Math.min(c5.minX, m4.minX)) * (Math.max(c5.maxY, m4.maxY) - Math.min(c5.minY, m4.minY)) - l5);
              u5 < a5 ? (a5 = u5, e4 = l5 < e4 ? l5 : e4, h4 = s5) : u5 === a5 && l5 < e4 && (e4 = l5, h4 = s5);
            }
            i5 = h4 || i5.children[0];
          }
          var m4, c5;
          return i5;
        }, r4.prototype._insert = function(t4, i5, n3) {
          var r5 = n3 ? t4 : this.toBBox(t4), e4 = [], a5 = this._chooseSubtree(r5, this.data, i5, e4);
          for (a5.children.push(t4), o4(a5, r5); i5 >= 0 && e4[i5].children.length > this._maxEntries; )
            this._split(e4, i5), i5--;
          this._adjustParentBBoxes(r5, e4, i5);
        }, r4.prototype._split = function(t4, i5) {
          var n3 = t4[i5], r5 = n3.children.length, e4 = this._minEntries;
          this._chooseSplitAxis(n3, e4, r5);
          var h4 = this._chooseSplitIndex(n3, e4, r5), o5 = p6(n3.children.splice(h4, n3.children.length - h4));
          o5.height = n3.height, o5.leaf = n3.leaf, a4(n3, this.toBBox), a4(o5, this.toBBox), i5 ? t4[i5 - 1].children.push(o5) : this._splitRoot(n3, o5);
        }, r4.prototype._splitRoot = function(t4, i5) {
          this.data = p6([t4, i5]), this.data.height = t4.height + 1, this.data.leaf = false, a4(this.data, this.toBBox);
        }, r4.prototype._chooseSplitIndex = function(t4, i5, n3) {
          for (var r5, e4, a5, o5, s5, l5, u5, m4 = 1 / 0, c5 = 1 / 0, p7 = i5; p7 <= n3 - i5; p7++) {
            var d4 = h3(t4, 0, p7, this.toBBox), x2 = h3(t4, p7, n3, this.toBBox), v3 = (e4 = d4, a5 = x2, o5 = void 0, s5 = void 0, l5 = void 0, u5 = void 0, o5 = Math.max(e4.minX, a5.minX), s5 = Math.max(e4.minY, a5.minY), l5 = Math.min(e4.maxX, a5.maxX), u5 = Math.min(e4.maxY, a5.maxY), Math.max(0, l5 - o5) * Math.max(0, u5 - s5)), M2 = f3(d4) + f3(x2);
            v3 < m4 ? (m4 = v3, r5 = p7, c5 = M2 < c5 ? M2 : c5) : v3 === m4 && M2 < c5 && (c5 = M2, r5 = p7);
          }
          return r5 || n3 - i5;
        }, r4.prototype._chooseSplitAxis = function(t4, i5, n3) {
          var r5 = t4.leaf ? this.compareMinX : s4, e4 = t4.leaf ? this.compareMinY : l4;
          this._allDistMargin(t4, i5, n3, r5) < this._allDistMargin(t4, i5, n3, e4) && t4.children.sort(r5);
        }, r4.prototype._allDistMargin = function(t4, i5, n3, r5) {
          t4.children.sort(r5);
          for (var e4 = this.toBBox, a5 = h3(t4, 0, i5, e4), s5 = h3(t4, n3 - i5, n3, e4), l5 = u4(a5) + u4(s5), f4 = i5; f4 < n3 - i5; f4++) {
            var m4 = t4.children[f4];
            o4(a5, t4.leaf ? e4(m4) : m4), l5 += u4(a5);
          }
          for (var c5 = n3 - i5 - 1; c5 >= i5; c5--) {
            var p7 = t4.children[c5];
            o4(s5, t4.leaf ? e4(p7) : p7), l5 += u4(s5);
          }
          return l5;
        }, r4.prototype._adjustParentBBoxes = function(t4, i5, n3) {
          for (var r5 = n3; r5 >= 0; r5--)
            o4(i5[r5], t4);
        }, r4.prototype._condense = function(t4) {
          for (var i5 = t4.length - 1, n3 = void 0; i5 >= 0; i5--)
            0 === t4[i5].children.length ? i5 > 0 ? (n3 = t4[i5 - 1].children).splice(n3.indexOf(t4[i5]), 1) : this.clear() : a4(t4[i5], this.toBBox);
        }, r4;
      });
    }
  });

  // node_modules/maplibre-gl/dist/maplibre-gl.js
  var require_maplibre_gl = __commonJS({
    "node_modules/maplibre-gl/dist/maplibre-gl.js"(exports, module) {
      (function(global2, factory) {
        typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (global2 = typeof globalThis !== "undefined" ? globalThis : global2 || self, global2.maplibregl = factory());
      })(exports, function() {
        "use strict";
        var shared2, worker, maplibregl;
        function define2(_3, chunk) {
          if (!shared2) {
            shared2 = chunk;
          } else if (!worker) {
            worker = chunk;
          } else {
            var workerBundleString = "var sharedChunk = {}; (" + shared2 + ")(sharedChunk); (" + worker + ")(sharedChunk);";
            var sharedChunk = {};
            shared2(sharedChunk);
            maplibregl = chunk(sharedChunk);
            if (typeof window !== "undefined") {
              maplibregl.workerUrl = window.URL.createObjectURL(new Blob([workerBundleString], { type: "text/javascript" }));
            }
          }
        }
        define2(["exports"], function(t3) {
          "use strict";
          function e3(t4) {
            return t4 && t4.__esModule && Object.prototype.hasOwnProperty.call(t4, "default") ? t4.default : t4;
          }
          var r4 = n2;
          function n2(t4, e4) {
            this.x = t4, this.y = e4;
          }
          n2.prototype = { clone: function() {
            return new n2(this.x, this.y);
          }, add: function(t4) {
            return this.clone()._add(t4);
          }, sub: function(t4) {
            return this.clone()._sub(t4);
          }, multByPoint: function(t4) {
            return this.clone()._multByPoint(t4);
          }, divByPoint: function(t4) {
            return this.clone()._divByPoint(t4);
          }, mult: function(t4) {
            return this.clone()._mult(t4);
          }, div: function(t4) {
            return this.clone()._div(t4);
          }, rotate: function(t4) {
            return this.clone()._rotate(t4);
          }, rotateAround: function(t4, e4) {
            return this.clone()._rotateAround(t4, e4);
          }, matMult: function(t4) {
            return this.clone()._matMult(t4);
          }, unit: function() {
            return this.clone()._unit();
          }, perp: function() {
            return this.clone()._perp();
          }, round: function() {
            return this.clone()._round();
          }, mag: function() {
            return Math.sqrt(this.x * this.x + this.y * this.y);
          }, equals: function(t4) {
            return this.x === t4.x && this.y === t4.y;
          }, dist: function(t4) {
            return Math.sqrt(this.distSqr(t4));
          }, distSqr: function(t4) {
            var e4 = t4.x - this.x, r5 = t4.y - this.y;
            return e4 * e4 + r5 * r5;
          }, angle: function() {
            return Math.atan2(this.y, this.x);
          }, angleTo: function(t4) {
            return Math.atan2(this.y - t4.y, this.x - t4.x);
          }, angleWith: function(t4) {
            return this.angleWithSep(t4.x, t4.y);
          }, angleWithSep: function(t4, e4) {
            return Math.atan2(this.x * e4 - this.y * t4, this.x * t4 + this.y * e4);
          }, _matMult: function(t4) {
            var e4 = t4[2] * this.x + t4[3] * this.y;
            return this.x = t4[0] * this.x + t4[1] * this.y, this.y = e4, this;
          }, _add: function(t4) {
            return this.x += t4.x, this.y += t4.y, this;
          }, _sub: function(t4) {
            return this.x -= t4.x, this.y -= t4.y, this;
          }, _mult: function(t4) {
            return this.x *= t4, this.y *= t4, this;
          }, _div: function(t4) {
            return this.x /= t4, this.y /= t4, this;
          }, _multByPoint: function(t4) {
            return this.x *= t4.x, this.y *= t4.y, this;
          }, _divByPoint: function(t4) {
            return this.x /= t4.x, this.y /= t4.y, this;
          }, _unit: function() {
            return this._div(this.mag()), this;
          }, _perp: function() {
            var t4 = this.y;
            return this.y = this.x, this.x = -t4, this;
          }, _rotate: function(t4) {
            var e4 = Math.cos(t4), r5 = Math.sin(t4), n3 = r5 * this.x + e4 * this.y;
            return this.x = e4 * this.x - r5 * this.y, this.y = n3, this;
          }, _rotateAround: function(t4, e4) {
            var r5 = Math.cos(t4), n3 = Math.sin(t4), i5 = e4.y + n3 * (this.x - e4.x) + r5 * (this.y - e4.y);
            return this.x = e4.x + r5 * (this.x - e4.x) - n3 * (this.y - e4.y), this.y = i5, this;
          }, _round: function() {
            return this.x = Math.round(this.x), this.y = Math.round(this.y), this;
          } }, n2.convert = function(t4) {
            return t4 instanceof n2 ? t4 : Array.isArray(t4) ? new n2(t4[0], t4[1]) : t4;
          };
          var i4 = e3(r4), a4 = s4;
          function s4(t4, e4, r5, n3) {
            this.cx = 3 * t4, this.bx = 3 * (r5 - t4) - this.cx, this.ax = 1 - this.cx - this.bx, this.cy = 3 * e4, this.by = 3 * (n3 - e4) - this.cy, this.ay = 1 - this.cy - this.by, this.p1x = t4, this.p1y = e4, this.p2x = r5, this.p2y = n3;
          }
          s4.prototype = { sampleCurveX: function(t4) {
            return ((this.ax * t4 + this.bx) * t4 + this.cx) * t4;
          }, sampleCurveY: function(t4) {
            return ((this.ay * t4 + this.by) * t4 + this.cy) * t4;
          }, sampleCurveDerivativeX: function(t4) {
            return (3 * this.ax * t4 + 2 * this.bx) * t4 + this.cx;
          }, solveCurveX: function(t4, e4) {
            if (void 0 === e4 && (e4 = 1e-6), t4 < 0)
              return 0;
            if (t4 > 1)
              return 1;
            for (var r5 = t4, n3 = 0; n3 < 8; n3++) {
              var i5 = this.sampleCurveX(r5) - t4;
              if (Math.abs(i5) < e4)
                return r5;
              var a5 = this.sampleCurveDerivativeX(r5);
              if (Math.abs(a5) < 1e-6)
                break;
              r5 -= i5 / a5;
            }
            var s5 = 0, o5 = 1;
            for (r5 = t4, n3 = 0; n3 < 20 && (i5 = this.sampleCurveX(r5), !(Math.abs(i5 - t4) < e4)); n3++)
              t4 > i5 ? s5 = r5 : o5 = r5, r5 = 0.5 * (o5 - s5) + s5;
            return r5;
          }, solve: function(t4, e4) {
            return this.sampleCurveY(this.solveCurveX(t4, e4));
          } };
          var o4 = e3(a4);
          let l4, u4;
          function c4() {
            return null == l4 && (l4 = "undefined" != typeof OffscreenCanvas && new OffscreenCanvas(1, 1).getContext("2d") && "function" == typeof createImageBitmap), l4;
          }
          function h3() {
            if (null == u4 && (u4 = false, c4())) {
              const t4 = 5, e4 = new OffscreenCanvas(t4, t4).getContext("2d", { willReadFrequently: true });
              if (e4) {
                for (let r6 = 0; r6 < t4 * t4; r6++) {
                  const n3 = 4 * r6;
                  e4.fillStyle = `rgb(${n3},${n3 + 1},${n3 + 2})`, e4.fillRect(r6 % t4, Math.floor(r6 / t4), 1, 1);
                }
                const r5 = e4.getImageData(0, 0, t4, t4).data;
                for (let e5 = 0; e5 < t4 * t4 * 4; e5++)
                  if (e5 % 4 != 3 && r5[e5] !== e5) {
                    u4 = true;
                    break;
                  }
              }
            }
            return u4 || false;
          }
          function p6(t4, e4, r5, n3) {
            const i5 = new o4(t4, e4, r5, n3);
            return function(t5) {
              return i5.solve(t5);
            };
          }
          const f3 = p6(0.25, 0.1, 0.25, 1);
          function d3(t4, e4, r5) {
            return Math.min(r5, Math.max(e4, t4));
          }
          function y2(t4, e4, r5) {
            const n3 = r5 - e4, i5 = ((t4 - e4) % n3 + n3) % n3 + e4;
            return i5 === e4 ? r5 : i5;
          }
          function m3(t4, ...e4) {
            for (const r5 of e4)
              for (const e5 in r5)
                t4[e5] = r5[e5];
            return t4;
          }
          let g3 = 1;
          function x2(t4, e4, r5) {
            const n3 = {};
            for (const i5 in t4)
              n3[i5] = e4.call(r5 || this, t4[i5], i5, t4);
            return n3;
          }
          function v3(t4, e4, r5) {
            const n3 = {};
            for (const i5 in t4)
              e4.call(r5 || this, t4[i5], i5, t4) && (n3[i5] = t4[i5]);
            return n3;
          }
          function b3(t4) {
            return Array.isArray(t4) ? t4.map(b3) : "object" == typeof t4 && t4 ? x2(t4, b3) : t4;
          }
          const w3 = {};
          function _3(t4) {
            w3[t4] || ("undefined" != typeof console && console.warn(t4), w3[t4] = true);
          }
          function A2(t4, e4, r5) {
            return (r5.y - t4.y) * (e4.x - t4.x) > (e4.y - t4.y) * (r5.x - t4.x);
          }
          function S2(t4) {
            let e4 = 0;
            for (let r5, n3, i5 = 0, a5 = t4.length, s5 = a5 - 1; i5 < a5; s5 = i5++)
              r5 = t4[i5], n3 = t4[s5], e4 += (n3.x - r5.x) * (r5.y + n3.y);
            return e4;
          }
          function k3() {
            return "undefined" != typeof WorkerGlobalScope && "undefined" != typeof self && self instanceof WorkerGlobalScope;
          }
          let I2 = null;
          function z3(t4) {
            if (null == I2) {
              const e4 = t4.navigator ? t4.navigator.userAgent : null;
              I2 = !!t4.safari || !(!e4 || !(/\b(iPad|iPhone|iPod)\b/.test(e4) || e4.match("Safari") && !e4.match("Chrome")));
            }
            return I2;
          }
          function M2(t4) {
            return "undefined" != typeof ImageBitmap && t4 instanceof ImageBitmap;
          }
          const P2 = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
          async function C(t4, e4, r5, n3, i5) {
            if ("undefined" == typeof VideoFrame)
              throw new Error("VideoFrame not supported");
            const a5 = new VideoFrame(t4, { timestamp: 0 });
            try {
              const s5 = null == a5 ? void 0 : a5.format;
              if (!s5 || !s5.startsWith("BGR") && !s5.startsWith("RGB"))
                throw new Error(`Unrecognized format ${s5}`);
              const o5 = s5.startsWith("BGR"), l5 = new Uint8ClampedArray(n3 * i5 * 4);
              if (await a5.copyTo(l5, function(t5, e5, r6, n4, i6) {
                const a6 = 4 * Math.max(-e5, 0), s6 = (Math.max(0, r6) - r6) * n4 * 4 + a6, o6 = 4 * n4, l6 = Math.max(0, e5), u5 = Math.max(0, r6);
                return { rect: { x: l6, y: u5, width: Math.min(t5.width, e5 + n4) - l6, height: Math.min(t5.height, r6 + i6) - u5 }, layout: [{ offset: s6, stride: o6 }] };
              }(t4, e4, r5, n3, i5)), o5)
                for (let t5 = 0; t5 < l5.length; t5 += 4) {
                  const e5 = l5[t5];
                  l5[t5] = l5[t5 + 2], l5[t5 + 2] = e5;
                }
              return l5;
            } finally {
              a5.close();
            }
          }
          let B3, V, E2, F3;
          const T2 = { now: "undefined" != typeof performance && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date), frame(t4) {
            const e4 = requestAnimationFrame(t4);
            return { cancel: () => cancelAnimationFrame(e4) };
          }, getImageData(t4, e4 = 0) {
            return this.getImageCanvasContext(t4).getImageData(-e4, -e4, t4.width + 2 * e4, t4.height + 2 * e4);
          }, getImageCanvasContext(t4) {
            const e4 = window.document.createElement("canvas"), r5 = e4.getContext("2d", { willReadFrequently: true });
            if (!r5)
              throw new Error("failed to create canvas 2d context");
            return e4.width = t4.width, e4.height = t4.height, r5.drawImage(t4, 0, 0, t4.width, t4.height), r5;
          }, resolveURL: (t4) => (E2 || (E2 = document.createElement("a")), E2.href = t4, E2.href), hardwareConcurrency: "undefined" != typeof navigator && navigator.hardwareConcurrency || 4, get prefersReducedMotion() {
            return !!matchMedia && (null == F3 && (F3 = matchMedia("(prefers-reduced-motion: reduce)")), F3.matches);
          } }, $2 = { MAX_PARALLEL_IMAGE_REQUESTS: 16, MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8, MAX_TILE_CACHE_ZOOM_LEVELS: 5, REGISTERED_PROTOCOLS: {}, WORKER_URL: "" };
          class L2 extends Error {
            constructor(t4, e4, r5, n3) {
              super(`AJAXError: ${e4} (${t4}): ${r5}`), this.status = t4, this.statusText = e4, this.url = r5, this.body = n3;
            }
          }
          const D2 = k3() ? () => self.worker && self.worker.referrer : () => ("blob:" === window.location.protocol ? window.parent : window).location.href, O2 = (t4) => $2.REGISTERED_PROTOCOLS[t4.substring(0, t4.indexOf("://"))];
          function U(t4, e4) {
            const r5 = new AbortController(), n3 = new Request(t4.url, { method: t4.method || "GET", body: t4.body, credentials: t4.credentials, headers: t4.headers, cache: t4.cache, referrer: D2(), signal: r5.signal });
            let i5 = false, a5 = false;
            "json" === t4.type && n3.headers.set("Accept", "application/json");
            return a5 || fetch(n3).then((r6) => r6.ok ? ((r7) => {
              ("arrayBuffer" === t4.type || "image" === t4.type ? r7.arrayBuffer() : "json" === t4.type ? r7.json() : r7.text()).then((t5) => {
                a5 || (i5 = true, e4(null, t5, r7.headers.get("Cache-Control"), r7.headers.get("Expires")));
              }).catch((t5) => {
                a5 || e4(new Error(t5.message));
              });
            })(r6) : r6.blob().then((n4) => e4(new L2(r6.status, r6.statusText, t4.url, n4)))).catch((t5) => {
              20 !== t5.code && e4(new Error(t5.message));
            }), { cancel: () => {
              a5 = true, i5 || r5.abort();
            } };
          }
          const R = function(t4, e4) {
            if (/:\/\//.test(t4.url) && !/^https?:|^file:/.test(t4.url)) {
              if (k3() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t4, e4);
              if (!k3())
                return (O2(t4.url) || U)(t4, e4);
            }
            if (!(/^file:/.test(r5 = t4.url) || /^file:/.test(D2()) && !/^\w+:/.test(r5))) {
              if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                return U(t4, e4);
              if (k3() && self.worker && self.worker.actor)
                return self.worker.actor.send("getResource", t4, e4, void 0, true);
            }
            var r5;
            return function(t5, e5) {
              const r6 = new XMLHttpRequest();
              r6.open(t5.method || "GET", t5.url, true), "arrayBuffer" !== t5.type && "image" !== t5.type || (r6.responseType = "arraybuffer");
              for (const e6 in t5.headers)
                r6.setRequestHeader(e6, t5.headers[e6]);
              return "json" === t5.type && (r6.responseType = "text", r6.setRequestHeader("Accept", "application/json")), r6.withCredentials = "include" === t5.credentials, r6.onerror = () => {
                e5(new Error(r6.statusText));
              }, r6.onload = () => {
                if ((r6.status >= 200 && r6.status < 300 || 0 === r6.status) && null !== r6.response) {
                  let n3 = r6.response;
                  if ("json" === t5.type)
                    try {
                      n3 = JSON.parse(r6.response);
                    } catch (t6) {
                      return e5(t6);
                    }
                  e5(null, n3, r6.getResponseHeader("Cache-Control"), r6.getResponseHeader("Expires"));
                } else {
                  const n3 = new Blob([r6.response], { type: r6.getResponseHeader("Content-Type") });
                  e5(new L2(r6.status, r6.statusText, t5.url, n3));
                }
              }, r6.send(t5.body), { cancel: () => r6.abort() };
            }(t4, e4);
          }, q3 = function(t4, e4) {
            return R(m3(t4, { type: "arrayBuffer" }), e4);
          };
          function j3(t4) {
            if (!t4 || t4.indexOf("://") <= 0 || 0 === t4.indexOf("data:image/") || 0 === t4.indexOf("blob:"))
              return true;
            const e4 = new URL(t4), r5 = window.location;
            return e4.protocol === r5.protocol && e4.host === r5.host;
          }
          function N2(t4, e4, r5) {
            r5[t4] && -1 !== r5[t4].indexOf(e4) || (r5[t4] = r5[t4] || [], r5[t4].push(e4));
          }
          function Z(t4, e4, r5) {
            if (r5 && r5[t4]) {
              const n3 = r5[t4].indexOf(e4);
              -1 !== n3 && r5[t4].splice(n3, 1);
            }
          }
          class K {
            constructor(t4, e4 = {}) {
              m3(this, e4), this.type = t4;
            }
          }
          class G2 extends K {
            constructor(t4, e4 = {}) {
              super("error", m3({ error: t4 }, e4));
            }
          }
          class J {
            on(t4, e4) {
              return this._listeners = this._listeners || {}, N2(t4, e4, this._listeners), this;
            }
            off(t4, e4) {
              return Z(t4, e4, this._listeners), Z(t4, e4, this._oneTimeListeners), this;
            }
            once(t4, e4) {
              return e4 ? (this._oneTimeListeners = this._oneTimeListeners || {}, N2(t4, e4, this._oneTimeListeners), this) : new Promise((e5) => this.once(t4, e5));
            }
            fire(t4, e4) {
              "string" == typeof t4 && (t4 = new K(t4, e4 || {}));
              const r5 = t4.type;
              if (this.listens(r5)) {
                t4.target = this;
                const e5 = this._listeners && this._listeners[r5] ? this._listeners[r5].slice() : [];
                for (const r6 of e5)
                  r6.call(this, t4);
                const n3 = this._oneTimeListeners && this._oneTimeListeners[r5] ? this._oneTimeListeners[r5].slice() : [];
                for (const e6 of n3)
                  Z(r5, e6, this._oneTimeListeners), e6.call(this, t4);
                const i5 = this._eventedParent;
                i5 && (m3(t4, "function" == typeof this._eventedParentData ? this._eventedParentData() : this._eventedParentData), i5.fire(t4));
              } else
                t4 instanceof G2 && console.error(t4.error);
              return this;
            }
            listens(t4) {
              return this._listeners && this._listeners[t4] && this._listeners[t4].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t4] && this._oneTimeListeners[t4].length > 0 || this._eventedParent && this._eventedParent.listens(t4);
            }
            setEventedParent(t4, e4) {
              return this._eventedParent = t4, this._eventedParentData = e4, this;
            }
          }
          var X = { $version: 8, $root: { version: { required: true, type: "enum", values: [8] }, name: { type: "string" }, metadata: { type: "*" }, center: { type: "array", value: "number" }, zoom: { type: "number" }, bearing: { type: "number", default: 0, period: 360, units: "degrees" }, pitch: { type: "number", default: 0, units: "degrees" }, light: { type: "light" }, terrain: { type: "terrain" }, sources: { required: true, type: "sources" }, sprite: { type: "sprite" }, glyphs: { type: "string" }, transition: { type: "transition" }, layers: { required: true, type: "array", value: "layer" } }, sources: { "*": { type: "source" } }, source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"], source_vector: { type: { required: true, type: "enum", values: { vector: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, attribution: { type: "string" }, promoteId: { type: "promoteId" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster: { type: { required: true, type: "enum", values: { raster: {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, scheme: { type: "enum", values: { xyz: {}, tms: {} }, default: "xyz" }, attribution: { type: "string" }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_raster_dem: { type: { required: true, type: "enum", values: { "raster-dem": {} } }, url: { type: "string" }, tiles: { type: "array", value: "string" }, bounds: { type: "array", value: "number", length: 4, default: [-180, -85.051129, 180, 85.051129] }, minzoom: { type: "number", default: 0 }, maxzoom: { type: "number", default: 22 }, tileSize: { type: "number", default: 512, units: "pixels" }, attribution: { type: "string" }, encoding: { type: "enum", values: { terrarium: {}, mapbox: {}, custom: {} }, default: "mapbox" }, redFactor: { type: "number", default: 1 }, blueFactor: { type: "number", default: 1 }, greenFactor: { type: "number", default: 1 }, baseShift: { type: "number", default: 0 }, volatile: { type: "boolean", default: false }, "*": { type: "*" } }, source_geojson: { type: { required: true, type: "enum", values: { geojson: {} } }, data: { required: true, type: "*" }, maxzoom: { type: "number", default: 18 }, attribution: { type: "string" }, buffer: { type: "number", default: 128, maximum: 512, minimum: 0 }, filter: { type: "*" }, tolerance: { type: "number", default: 0.375 }, cluster: { type: "boolean", default: false }, clusterRadius: { type: "number", default: 50, minimum: 0 }, clusterMaxZoom: { type: "number" }, clusterMinPoints: { type: "number" }, clusterProperties: { type: "*" }, lineMetrics: { type: "boolean", default: false }, generateId: { type: "boolean", default: false }, promoteId: { type: "promoteId" } }, source_video: { type: { required: true, type: "enum", values: { video: {} } }, urls: { required: true, type: "array", value: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, source_image: { type: { required: true, type: "enum", values: { image: {} } }, url: { required: true, type: "string" }, coordinates: { required: true, type: "array", length: 4, value: { type: "array", length: 2, value: "number" } } }, layer: { id: { type: "string", required: true }, type: { type: "enum", values: { fill: {}, line: {}, symbol: {}, circle: {}, heatmap: {}, "fill-extrusion": {}, raster: {}, hillshade: {}, background: {} }, required: true }, metadata: { type: "*" }, source: { type: "string" }, "source-layer": { type: "string" }, minzoom: { type: "number", minimum: 0, maximum: 24 }, maxzoom: { type: "number", minimum: 0, maximum: 24 }, filter: { type: "filter" }, layout: { type: "layout" }, paint: { type: "paint" } }, layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"], layout_background: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_fill: { "fill-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_circle: { "circle-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_heatmap: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, "layout_fill-extrusion": { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_line: { "line-cap": { type: "enum", values: { butt: {}, round: {}, square: {} }, default: "butt", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-join": { type: "enum", values: { bevel: {}, round: {}, miter: {} }, default: "miter", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "line-miter-limit": { type: "number", default: 2, requires: [{ "line-join": "miter" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-round-limit": { type: "number", default: 1.05, requires: [{ "line-join": "round" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_symbol: { "symbol-placement": { type: "enum", values: { point: {}, line: {}, "line-center": {} }, default: "point", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-spacing": { type: "number", default: 250, minimum: 1, units: "pixels", requires: [{ "symbol-placement": "line" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-avoid-edges": { type: "boolean", default: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "symbol-sort-key": { type: "number", expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "symbol-z-order": { type: "enum", values: { auto: {}, "viewport-y": {}, source: {} }, default: "auto", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-allow-overlap": { type: "boolean", default: false, requires: ["icon-image", { "!": "icon-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-ignore-placement": { type: "boolean", default: false, requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-optional": { type: "boolean", default: false, requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-size": { type: "number", default: 1, minimum: 0, units: "factor of the original icon size", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-text-fit": { type: "enum", values: { none: {}, width: {}, height: {}, both: {} }, default: "none", requires: ["icon-image", "text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-text-fit-padding": { type: "array", value: "number", length: 4, default: [0, 0, 0, 0], units: "pixels", requires: ["icon-image", "text-field", { "icon-text-fit": ["both", "width", "height"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-image": { type: "resolvedImage", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-padding": { type: "padding", default: [2], units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-keep-upright": { type: "boolean", default: false, requires: ["icon-image", { "icon-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-offset": { type: "array", value: "number", length: 2, default: [0, 0], requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "icon-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-pitch-alignment": { type: "enum", values: { map: {}, viewport: {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotation-alignment": { type: "enum", values: { map: {}, viewport: {}, "viewport-glyph": {}, auto: {} }, default: "auto", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-field": { type: "formatted", default: "", tokens: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-font": { type: "array", value: "string", default: ["Open Sans Regular", "Arial Unicode MS Regular"], requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-size": { type: "number", default: 16, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-width": { type: "number", default: 10, minimum: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-line-height": { type: "number", default: 1.2, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-letter-spacing": { type: "number", default: 0, units: "ems", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-justify": { type: "enum", values: { auto: {}, left: {}, center: {}, right: {} }, default: "center", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-radial-offset": { type: "number", units: "ems", default: 0, requires: ["text-field"], "property-type": "data-driven", expression: { interpolated: true, parameters: ["zoom", "feature"] } }, "text-variable-anchor": { type: "array", value: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-variable-anchor-offset": { type: "variableAnchorOffsetCollection", requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-anchor": { type: "enum", values: { center: {}, left: {}, right: {}, top: {}, bottom: {}, "top-left": {}, "top-right": {}, "bottom-left": {}, "bottom-right": {} }, default: "center", requires: ["text-field", { "!": "text-variable-anchor" }], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-max-angle": { type: "number", default: 45, units: "degrees", requires: ["text-field", { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-writing-mode": { type: "array", value: "enum", values: { horizontal: {}, vertical: {} }, requires: ["text-field", { "symbol-placement": ["point"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-rotate": { type: "number", default: 0, period: 360, units: "degrees", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-padding": { type: "number", default: 2, minimum: 0, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-keep-upright": { type: "boolean", default: true, requires: ["text-field", { "text-rotation-alignment": "map" }, { "symbol-placement": ["line", "line-center"] }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-transform": { type: "enum", values: { none: {}, uppercase: {}, lowercase: {} }, default: "none", requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-offset": { type: "array", value: "number", units: "ems", length: 2, default: [0, 0], requires: ["text-field", { "!": "text-radial-offset" }], expression: { interpolated: true, parameters: ["zoom", "feature"] }, "property-type": "data-driven" }, "text-allow-overlap": { type: "boolean", default: false, requires: ["text-field", { "!": "text-overlap" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-overlap": { type: "enum", values: { never: {}, always: {}, cooperative: {} }, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-ignore-placement": { type: "boolean", default: false, requires: ["text-field"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-optional": { type: "boolean", default: false, requires: ["text-field", "icon-image"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_raster: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, layout_hillshade: { visibility: { type: "enum", values: { visible: {}, none: {} }, default: "visible", "property-type": "constant" } }, filter: { type: "array", value: "*" }, filter_operator: { type: "enum", values: { "==": {}, "!=": {}, ">": {}, ">=": {}, "<": {}, "<=": {}, in: {}, "!in": {}, all: {}, any: {}, none: {}, has: {}, "!has": {}, within: {} } }, geometry_type: { type: "enum", values: { Point: {}, LineString: {}, Polygon: {} } }, function: { expression: { type: "expression" }, stops: { type: "array", value: "function_stop" }, base: { type: "number", default: 1, minimum: 0 }, property: { type: "string", default: "$zoom" }, type: { type: "enum", values: { identity: {}, exponential: {}, interval: {}, categorical: {} }, default: "exponential" }, colorSpace: { type: "enum", values: { rgb: {}, lab: {}, hcl: {} }, default: "rgb" }, default: { type: "*", required: false } }, function_stop: { type: "array", minimum: 0, maximum: 24, value: ["number", "color"], length: 2 }, expression: { type: "array", value: "*", minimum: 1 }, light: { anchor: { type: "enum", default: "viewport", values: { map: {}, viewport: {} }, "property-type": "data-constant", transition: false, expression: { interpolated: false, parameters: ["zoom"] } }, position: { type: "array", default: [1.15, 210, 30], length: 3, value: "number", "property-type": "data-constant", transition: true, expression: { interpolated: true, parameters: ["zoom"] } }, color: { type: "color", "property-type": "data-constant", default: "#ffffff", expression: { interpolated: true, parameters: ["zoom"] }, transition: true }, intensity: { type: "number", "property-type": "data-constant", default: 0.5, minimum: 0, maximum: 1, expression: { interpolated: true, parameters: ["zoom"] }, transition: true } }, terrain: { source: { type: "string", required: true }, exaggeration: { type: "number", minimum: 0, default: 1 } }, paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"], paint_fill: { "fill-antialias": { type: "boolean", default: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-outline-color": { type: "color", transition: true, requires: [{ "!": "fill-pattern" }, { "fill-antialias": true }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" } }, "paint_fill-extrusion": { "fill-extrusion-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "fill-extrusion-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["fill-extrusion-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "fill-extrusion-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "fill-extrusion-height": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-base": { type: "number", default: 0, minimum: 0, units: "meters", transition: true, requires: ["fill-extrusion-height"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "fill-extrusion-vertical-gradient": { type: "boolean", default: true, transition: false, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_line: { "line-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "line-pattern" }], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["line-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "line-width": { type: "number", default: 1, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-gap-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-offset": { type: "number", default: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "line-dasharray": { type: "array", value: "number", minimum: 0, transition: true, units: "line widths", requires: [{ "!": "line-pattern" }], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "line-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom", "feature"] }, "property-type": "cross-faded-data-driven" }, "line-gradient": { type: "color", transition: false, requires: [{ "!": "line-dasharray" }, { "!": "line-pattern" }, { source: "geojson", has: { lineMetrics: true } }], expression: { interpolated: true, parameters: ["line-progress"] }, "property-type": "color-ramp" } }, paint_circle: { "circle-radius": { type: "number", default: 5, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-blur": { type: "number", default: 0, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["circle-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-scale": { type: "enum", values: { map: {}, viewport: {} }, default: "map", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-pitch-alignment": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "circle-stroke-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "circle-stroke-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" } }, paint_heatmap: { "heatmap-radius": { type: "number", default: 30, minimum: 1, transition: true, units: "pixels", expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-weight": { type: "number", default: 1, minimum: 0, transition: false, expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "heatmap-intensity": { type: "number", default: 1, minimum: 0, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "heatmap-color": { type: "color", default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", 0.1, "royalblue", 0.3, "cyan", 0.5, "lime", 0.7, "yellow", 1, "red"], transition: false, expression: { interpolated: true, parameters: ["heatmap-density"] }, "property-type": "color-ramp" }, "heatmap-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_symbol: { "icon-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-color": { type: "color", default: "#000000", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "icon-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["icon-image"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "icon-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["icon-image", "icon-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-color": { type: "color", default: "#000000", transition: true, overridable: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-color": { type: "color", default: "rgba(0, 0, 0, 0)", transition: true, requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-width": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-halo-blur": { type: "number", default: 0, minimum: 0, transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom", "feature", "feature-state"] }, "property-type": "data-driven" }, "text-translate": { type: "array", value: "number", length: 2, default: [0, 0], transition: true, units: "pixels", requires: ["text-field"], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "text-translate-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "map", requires: ["text-field", "text-translate"], expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_raster: { "raster-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-hue-rotate": { type: "number", default: 0, period: 360, transition: true, units: "degrees", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-min": { type: "number", default: 0, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-brightness-max": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-saturation": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-contrast": { type: "number", default: 0, minimum: -1, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-resampling": { type: "enum", values: { linear: {}, nearest: {} }, default: "linear", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "raster-fade-duration": { type: "number", default: 300, minimum: 0, transition: false, units: "milliseconds", expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_hillshade: { "hillshade-illumination-direction": { type: "number", default: 335, minimum: 0, maximum: 359, transition: false, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-illumination-anchor": { type: "enum", values: { map: {}, viewport: {} }, default: "viewport", expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-exaggeration": { type: "number", default: 0.5, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-shadow-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-highlight-color": { type: "color", default: "#FFFFFF", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "hillshade-accent-color": { type: "color", default: "#000000", transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, paint_background: { "background-color": { type: "color", default: "#000000", transition: true, requires: [{ "!": "background-pattern" }], expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" }, "background-pattern": { type: "resolvedImage", transition: true, expression: { interpolated: false, parameters: ["zoom"] }, "property-type": "cross-faded" }, "background-opacity": { type: "number", default: 1, minimum: 0, maximum: 1, transition: true, expression: { interpolated: true, parameters: ["zoom"] }, "property-type": "data-constant" } }, transition: { duration: { type: "number", default: 300, minimum: 0, units: "milliseconds" }, delay: { type: "number", default: 0, minimum: 0, units: "milliseconds" } }, "property-type": { "data-driven": { type: "property-type" }, "cross-faded": { type: "property-type" }, "cross-faded-data-driven": { type: "property-type" }, "color-ramp": { type: "property-type" }, "data-constant": { type: "property-type" }, constant: { type: "property-type" } }, promoteId: { "*": { type: "string" } } };
          const Y = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
          function H2(t4, e4) {
            const r5 = {};
            for (const e5 in t4)
              "ref" !== e5 && (r5[e5] = t4[e5]);
            return Y.forEach((t5) => {
              t5 in e4 && (r5[t5] = e4[t5]);
            }), r5;
          }
          function W(t4, e4) {
            if (Array.isArray(t4)) {
              if (!Array.isArray(e4) || t4.length !== e4.length)
                return false;
              for (let r5 = 0; r5 < t4.length; r5++)
                if (!W(t4[r5], e4[r5]))
                  return false;
              return true;
            }
            if ("object" == typeof t4 && null !== t4 && null !== e4) {
              if ("object" != typeof e4)
                return false;
              if (Object.keys(t4).length !== Object.keys(e4).length)
                return false;
              for (const r5 in t4)
                if (!W(t4[r5], e4[r5]))
                  return false;
              return true;
            }
            return t4 === e4;
          }
          const Q = { setStyle: "setStyle", addLayer: "addLayer", removeLayer: "removeLayer", setPaintProperty: "setPaintProperty", setLayoutProperty: "setLayoutProperty", setFilter: "setFilter", addSource: "addSource", removeSource: "removeSource", setGeoJSONSourceData: "setGeoJSONSourceData", setLayerZoomRange: "setLayerZoomRange", setLayerProperty: "setLayerProperty", setCenter: "setCenter", setZoom: "setZoom", setBearing: "setBearing", setPitch: "setPitch", setSprite: "setSprite", setGlyphs: "setGlyphs", setTransition: "setTransition", setLight: "setLight" };
          function tt(t4, e4, r5) {
            r5.push({ command: Q.addSource, args: [t4, e4[t4]] });
          }
          function et(t4, e4, r5) {
            e4.push({ command: Q.removeSource, args: [t4] }), r5[t4] = true;
          }
          function rt(t4, e4, r5, n3) {
            et(t4, r5, n3), tt(t4, e4, r5);
          }
          function nt(t4, e4, r5) {
            let n3;
            for (n3 in t4[r5])
              if (Object.prototype.hasOwnProperty.call(t4[r5], n3) && "data" !== n3 && !W(t4[r5][n3], e4[r5][n3]))
                return false;
            for (n3 in e4[r5])
              if (Object.prototype.hasOwnProperty.call(e4[r5], n3) && "data" !== n3 && !W(t4[r5][n3], e4[r5][n3]))
                return false;
            return true;
          }
          function it(t4, e4, r5, n3, i5, a5) {
            let s5;
            for (s5 in e4 = e4 || {}, t4 = t4 || {})
              Object.prototype.hasOwnProperty.call(t4, s5) && (W(t4[s5], e4[s5]) || r5.push({ command: a5, args: [n3, s5, e4[s5], i5] }));
            for (s5 in e4)
              Object.prototype.hasOwnProperty.call(e4, s5) && !Object.prototype.hasOwnProperty.call(t4, s5) && (W(t4[s5], e4[s5]) || r5.push({ command: a5, args: [n3, s5, e4[s5], i5] }));
          }
          function at(t4) {
            return t4.id;
          }
          function st(t4, e4) {
            return t4[e4.id] = e4, t4;
          }
          class ot {
            constructor(t4, e4, r5, n3) {
              this.message = (t4 ? `${t4}: ` : "") + r5, n3 && (this.identifier = n3), null != e4 && e4.__line__ && (this.line = e4.__line__);
            }
          }
          function lt(t4, ...e4) {
            for (const r5 of e4)
              for (const e5 in r5)
                t4[e5] = r5[e5];
            return t4;
          }
          class ut extends Error {
            constructor(t4, e4) {
              super(e4), this.message = e4, this.key = t4;
            }
          }
          class ct {
            constructor(t4, e4 = []) {
              this.parent = t4, this.bindings = {};
              for (const [t5, r5] of e4)
                this.bindings[t5] = r5;
            }
            concat(t4) {
              return new ct(this, t4);
            }
            get(t4) {
              if (this.bindings[t4])
                return this.bindings[t4];
              if (this.parent)
                return this.parent.get(t4);
              throw new Error(`${t4} not found in scope.`);
            }
            has(t4) {
              return !!this.bindings[t4] || !!this.parent && this.parent.has(t4);
            }
          }
          const ht = { kind: "null" }, pt = { kind: "number" }, ft = { kind: "string" }, dt = { kind: "boolean" }, yt = { kind: "color" }, mt = { kind: "object" }, gt = { kind: "value" }, xt = { kind: "collator" }, vt = { kind: "formatted" }, bt = { kind: "padding" }, wt = { kind: "resolvedImage" }, _t = { kind: "variableAnchorOffsetCollection" };
          function At(t4, e4) {
            return { kind: "array", itemType: t4, N: e4 };
          }
          function St(t4) {
            if ("array" === t4.kind) {
              const e4 = St(t4.itemType);
              return "number" == typeof t4.N ? `array<${e4}, ${t4.N}>` : "value" === t4.itemType.kind ? "array" : `array<${e4}>`;
            }
            return t4.kind;
          }
          const kt = [ht, pt, ft, dt, yt, vt, mt, At(gt), bt, wt, _t];
          function It(t4, e4) {
            if ("error" === e4.kind)
              return null;
            if ("array" === t4.kind) {
              if ("array" === e4.kind && (0 === e4.N && "value" === e4.itemType.kind || !It(t4.itemType, e4.itemType)) && ("number" != typeof t4.N || t4.N === e4.N))
                return null;
            } else {
              if (t4.kind === e4.kind)
                return null;
              if ("value" === t4.kind) {
                for (const t5 of kt)
                  if (!It(t5, e4))
                    return null;
              }
            }
            return `Expected ${St(t4)} but found ${St(e4)} instead.`;
          }
          function zt(t4, e4) {
            return e4.some((e5) => e5.kind === t4.kind);
          }
          function Mt(t4, e4) {
            return e4.some((e5) => "null" === e5 ? null === t4 : "array" === e5 ? Array.isArray(t4) : "object" === e5 ? t4 && !Array.isArray(t4) && "object" == typeof t4 : e5 === typeof t4);
          }
          function Pt(t4, e4) {
            return "array" === t4.kind && "array" === e4.kind ? t4.itemType.kind === e4.itemType.kind && "number" == typeof t4.N : t4.kind === e4.kind;
          }
          const Ct = 0.96422, Bt = 0.82521, Vt = 4 / 29, Et = 6 / 29, Ft = 3 * Et * Et, Tt = Et * Et * Et, $t = Math.PI / 180, Lt = 180 / Math.PI;
          function Dt(t4) {
            return (t4 %= 360) < 0 && (t4 += 360), t4;
          }
          function Ot([t4, e4, r5, n3]) {
            let i5, a5;
            const s5 = Rt((0.2225045 * (t4 = Ut(t4)) + 0.7168786 * (e4 = Ut(e4)) + 0.0606169 * (r5 = Ut(r5))) / 1);
            t4 === e4 && e4 === r5 ? i5 = a5 = s5 : (i5 = Rt((0.4360747 * t4 + 0.3850649 * e4 + 0.1430804 * r5) / Ct), a5 = Rt((0.0139322 * t4 + 0.0971045 * e4 + 0.7141733 * r5) / Bt));
            const o5 = 116 * s5 - 16;
            return [o5 < 0 ? 0 : o5, 500 * (i5 - s5), 200 * (s5 - a5), n3];
          }
          function Ut(t4) {
            return t4 <= 0.04045 ? t4 / 12.92 : Math.pow((t4 + 0.055) / 1.055, 2.4);
          }
          function Rt(t4) {
            return t4 > Tt ? Math.pow(t4, 1 / 3) : t4 / Ft + Vt;
          }
          function qt([t4, e4, r5, n3]) {
            let i5 = (t4 + 16) / 116, a5 = isNaN(e4) ? i5 : i5 + e4 / 500, s5 = isNaN(r5) ? i5 : i5 - r5 / 200;
            return i5 = 1 * Nt(i5), a5 = Ct * Nt(a5), s5 = Bt * Nt(s5), [jt(3.1338561 * a5 - 1.6168667 * i5 - 0.4906146 * s5), jt(-0.9787684 * a5 + 1.9161415 * i5 + 0.033454 * s5), jt(0.0719453 * a5 - 0.2289914 * i5 + 1.4052427 * s5), n3];
          }
          function jt(t4) {
            return (t4 = t4 <= 304e-5 ? 12.92 * t4 : 1.055 * Math.pow(t4, 1 / 2.4) - 0.055) < 0 ? 0 : t4 > 1 ? 1 : t4;
          }
          function Nt(t4) {
            return t4 > Et ? t4 * t4 * t4 : Ft * (t4 - Vt);
          }
          function Zt(t4) {
            return parseInt(t4.padEnd(2, t4), 16) / 255;
          }
          function Kt(t4, e4) {
            return Gt(e4 ? t4 / 100 : t4, 0, 1);
          }
          function Gt(t4, e4, r5) {
            return Math.min(Math.max(e4, t4), r5);
          }
          function Jt(t4) {
            return !t4.some(Number.isNaN);
          }
          const Xt = { aliceblue: [240, 248, 255], antiquewhite: [250, 235, 215], aqua: [0, 255, 255], aquamarine: [127, 255, 212], azure: [240, 255, 255], beige: [245, 245, 220], bisque: [255, 228, 196], black: [0, 0, 0], blanchedalmond: [255, 235, 205], blue: [0, 0, 255], blueviolet: [138, 43, 226], brown: [165, 42, 42], burlywood: [222, 184, 135], cadetblue: [95, 158, 160], chartreuse: [127, 255, 0], chocolate: [210, 105, 30], coral: [255, 127, 80], cornflowerblue: [100, 149, 237], cornsilk: [255, 248, 220], crimson: [220, 20, 60], cyan: [0, 255, 255], darkblue: [0, 0, 139], darkcyan: [0, 139, 139], darkgoldenrod: [184, 134, 11], darkgray: [169, 169, 169], darkgreen: [0, 100, 0], darkgrey: [169, 169, 169], darkkhaki: [189, 183, 107], darkmagenta: [139, 0, 139], darkolivegreen: [85, 107, 47], darkorange: [255, 140, 0], darkorchid: [153, 50, 204], darkred: [139, 0, 0], darksalmon: [233, 150, 122], darkseagreen: [143, 188, 143], darkslateblue: [72, 61, 139], darkslategray: [47, 79, 79], darkslategrey: [47, 79, 79], darkturquoise: [0, 206, 209], darkviolet: [148, 0, 211], deeppink: [255, 20, 147], deepskyblue: [0, 191, 255], dimgray: [105, 105, 105], dimgrey: [105, 105, 105], dodgerblue: [30, 144, 255], firebrick: [178, 34, 34], floralwhite: [255, 250, 240], forestgreen: [34, 139, 34], fuchsia: [255, 0, 255], gainsboro: [220, 220, 220], ghostwhite: [248, 248, 255], gold: [255, 215, 0], goldenrod: [218, 165, 32], gray: [128, 128, 128], green: [0, 128, 0], greenyellow: [173, 255, 47], grey: [128, 128, 128], honeydew: [240, 255, 240], hotpink: [255, 105, 180], indianred: [205, 92, 92], indigo: [75, 0, 130], ivory: [255, 255, 240], khaki: [240, 230, 140], lavender: [230, 230, 250], lavenderblush: [255, 240, 245], lawngreen: [124, 252, 0], lemonchiffon: [255, 250, 205], lightblue: [173, 216, 230], lightcoral: [240, 128, 128], lightcyan: [224, 255, 255], lightgoldenrodyellow: [250, 250, 210], lightgray: [211, 211, 211], lightgreen: [144, 238, 144], lightgrey: [211, 211, 211], lightpink: [255, 182, 193], lightsalmon: [255, 160, 122], lightseagreen: [32, 178, 170], lightskyblue: [135, 206, 250], lightslategray: [119, 136, 153], lightslategrey: [119, 136, 153], lightsteelblue: [176, 196, 222], lightyellow: [255, 255, 224], lime: [0, 255, 0], limegreen: [50, 205, 50], linen: [250, 240, 230], magenta: [255, 0, 255], maroon: [128, 0, 0], mediumaquamarine: [102, 205, 170], mediumblue: [0, 0, 205], mediumorchid: [186, 85, 211], mediumpurple: [147, 112, 219], mediumseagreen: [60, 179, 113], mediumslateblue: [123, 104, 238], mediumspringgreen: [0, 250, 154], mediumturquoise: [72, 209, 204], mediumvioletred: [199, 21, 133], midnightblue: [25, 25, 112], mintcream: [245, 255, 250], mistyrose: [255, 228, 225], moccasin: [255, 228, 181], navajowhite: [255, 222, 173], navy: [0, 0, 128], oldlace: [253, 245, 230], olive: [128, 128, 0], olivedrab: [107, 142, 35], orange: [255, 165, 0], orangered: [255, 69, 0], orchid: [218, 112, 214], palegoldenrod: [238, 232, 170], palegreen: [152, 251, 152], paleturquoise: [175, 238, 238], palevioletred: [219, 112, 147], papayawhip: [255, 239, 213], peachpuff: [255, 218, 185], peru: [205, 133, 63], pink: [255, 192, 203], plum: [221, 160, 221], powderblue: [176, 224, 230], purple: [128, 0, 128], rebeccapurple: [102, 51, 153], red: [255, 0, 0], rosybrown: [188, 143, 143], royalblue: [65, 105, 225], saddlebrown: [139, 69, 19], salmon: [250, 128, 114], sandybrown: [244, 164, 96], seagreen: [46, 139, 87], seashell: [255, 245, 238], sienna: [160, 82, 45], silver: [192, 192, 192], skyblue: [135, 206, 235], slateblue: [106, 90, 205], slategray: [112, 128, 144], slategrey: [112, 128, 144], snow: [255, 250, 250], springgreen: [0, 255, 127], steelblue: [70, 130, 180], tan: [210, 180, 140], teal: [0, 128, 128], thistle: [216, 191, 216], tomato: [255, 99, 71], turquoise: [64, 224, 208], violet: [238, 130, 238], wheat: [245, 222, 179], white: [255, 255, 255], whitesmoke: [245, 245, 245], yellow: [255, 255, 0], yellowgreen: [154, 205, 50] };
          class Yt {
            constructor(t4, e4, r5, n3 = 1, i5 = true) {
              this.r = t4, this.g = e4, this.b = r5, this.a = n3, i5 || (this.r *= n3, this.g *= n3, this.b *= n3, n3 || this.overwriteGetter("rgb", [t4, e4, r5, n3]));
            }
            static parse(t4) {
              if (t4 instanceof Yt)
                return t4;
              if ("string" != typeof t4)
                return;
              const e4 = function(t5) {
                if ("transparent" === (t5 = t5.toLowerCase().trim()))
                  return [0, 0, 0, 0];
                const e5 = Xt[t5];
                if (e5) {
                  const [t6, r6, n3] = e5;
                  return [t6 / 255, r6 / 255, n3 / 255, 1];
                }
                if (t5.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(t5)) {
                  const e6 = t5.length < 6 ? 1 : 2;
                  let r6 = 1;
                  return [Zt(t5.slice(r6, r6 += e6)), Zt(t5.slice(r6, r6 += e6)), Zt(t5.slice(r6, r6 += e6)), Zt(t5.slice(r6, r6 + e6) || "ff")];
                }
                if (t5.startsWith("rgb")) {
                  const e6 = t5.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                  if (e6) {
                    const [t6, r6, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7] = e6, f4 = [i5 || " ", o5 || " ", c5].join("");
                    if ("  " === f4 || "  /" === f4 || ",," === f4 || ",,," === f4) {
                      const t7 = [n3, s5, u5].join(""), e7 = "%%%" === t7 ? 100 : "" === t7 ? 255 : 0;
                      if (e7) {
                        const t8 = [Gt(+r6 / e7, 0, 1), Gt(+a5 / e7, 0, 1), Gt(+l5 / e7, 0, 1), h4 ? Kt(+h4, p7) : 1];
                        if (Jt(t8))
                          return t8;
                      }
                    }
                    return;
                  }
                }
                const r5 = t5.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                if (r5) {
                  const [t6, e6, n3, i5, a5, s5, o5, l5, u5] = r5, c5 = [n3 || " ", a5 || " ", o5].join("");
                  if ("  " === c5 || "  /" === c5 || ",," === c5 || ",,," === c5) {
                    const t7 = [+e6, Gt(+i5, 0, 100), Gt(+s5, 0, 100), l5 ? Kt(+l5, u5) : 1];
                    if (Jt(t7))
                      return function([t8, e7, r6, n4]) {
                        function i6(n5) {
                          const i7 = (n5 + t8 / 30) % 12, a6 = e7 * Math.min(r6, 1 - r6);
                          return r6 - a6 * Math.max(-1, Math.min(i7 - 3, 9 - i7, 1));
                        }
                        return t8 = Dt(t8), e7 /= 100, r6 /= 100, [i6(0), i6(8), i6(4), n4];
                      }(t7);
                  }
                }
              }(t4);
              return e4 ? new Yt(...e4, false) : void 0;
            }
            get rgb() {
              const { r: t4, g: e4, b: r5, a: n3 } = this, i5 = n3 || 1 / 0;
              return this.overwriteGetter("rgb", [t4 / i5, e4 / i5, r5 / i5, n3]);
            }
            get hcl() {
              return this.overwriteGetter("hcl", function(t4) {
                const [e4, r5, n3, i5] = Ot(t4), a5 = Math.sqrt(r5 * r5 + n3 * n3);
                return [Math.round(1e4 * a5) ? Dt(Math.atan2(n3, r5) * Lt) : NaN, a5, e4, i5];
              }(this.rgb));
            }
            get lab() {
              return this.overwriteGetter("lab", Ot(this.rgb));
            }
            overwriteGetter(t4, e4) {
              return Object.defineProperty(this, t4, { value: e4 }), e4;
            }
            toString() {
              const [t4, e4, r5, n3] = this.rgb;
              return `rgba(${[t4, e4, r5].map((t5) => Math.round(255 * t5)).join(",")},${n3})`;
            }
          }
          Yt.black = new Yt(0, 0, 0, 1), Yt.white = new Yt(1, 1, 1, 1), Yt.transparent = new Yt(0, 0, 0, 0), Yt.red = new Yt(1, 0, 0, 1);
          class Ht {
            constructor(t4, e4, r5) {
              this.sensitivity = t4 ? e4 ? "variant" : "case" : e4 ? "accent" : "base", this.locale = r5, this.collator = new Intl.Collator(this.locale ? this.locale : [], { sensitivity: this.sensitivity, usage: "search" });
            }
            compare(t4, e4) {
              return this.collator.compare(t4, e4);
            }
            resolvedLocale() {
              return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale;
            }
          }
          class Wt {
            constructor(t4, e4, r5, n3, i5) {
              this.text = t4, this.image = e4, this.scale = r5, this.fontStack = n3, this.textColor = i5;
            }
          }
          class Qt {
            constructor(t4) {
              this.sections = t4;
            }
            static fromString(t4) {
              return new Qt([new Wt(t4, null, null, null, null)]);
            }
            isEmpty() {
              return 0 === this.sections.length || !this.sections.some((t4) => 0 !== t4.text.length || t4.image && 0 !== t4.image.name.length);
            }
            static factory(t4) {
              return t4 instanceof Qt ? t4 : Qt.fromString(t4);
            }
            toString() {
              return 0 === this.sections.length ? "" : this.sections.map((t4) => t4.text).join("");
            }
          }
          class te {
            constructor(t4) {
              this.values = t4.slice();
            }
            static parse(t4) {
              if (t4 instanceof te)
                return t4;
              if ("number" == typeof t4)
                return new te([t4, t4, t4, t4]);
              if (Array.isArray(t4) && !(t4.length < 1 || t4.length > 4)) {
                for (const e4 of t4)
                  if ("number" != typeof e4)
                    return;
                switch (t4.length) {
                  case 1:
                    t4 = [t4[0], t4[0], t4[0], t4[0]];
                    break;
                  case 2:
                    t4 = [t4[0], t4[1], t4[0], t4[1]];
                    break;
                  case 3:
                    t4 = [t4[0], t4[1], t4[2], t4[1]];
                }
                return new te(t4);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
          }
          const ee = /* @__PURE__ */ new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
          class re {
            constructor(t4) {
              this.values = t4.slice();
            }
            static parse(t4) {
              if (t4 instanceof re)
                return t4;
              if (Array.isArray(t4) && !(t4.length < 1) && t4.length % 2 == 0) {
                for (let e4 = 0; e4 < t4.length; e4 += 2) {
                  const r5 = t4[e4], n3 = t4[e4 + 1];
                  if ("string" != typeof r5 || !ee.has(r5))
                    return;
                  if (!Array.isArray(n3) || 2 !== n3.length || "number" != typeof n3[0] || "number" != typeof n3[1])
                    return;
                }
                return new re(t4);
              }
            }
            toString() {
              return JSON.stringify(this.values);
            }
          }
          class ne {
            constructor(t4) {
              this.name = t4.name, this.available = t4.available;
            }
            toString() {
              return this.name;
            }
            static fromString(t4) {
              return t4 ? new ne({ name: t4, available: false }) : null;
            }
          }
          function ie(t4, e4, r5, n3) {
            return "number" == typeof t4 && t4 >= 0 && t4 <= 255 && "number" == typeof e4 && e4 >= 0 && e4 <= 255 && "number" == typeof r5 && r5 >= 0 && r5 <= 255 ? void 0 === n3 || "number" == typeof n3 && n3 >= 0 && n3 <= 1 ? null : `Invalid rgba value [${[t4, e4, r5, n3].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${("number" == typeof n3 ? [t4, e4, r5, n3] : [t4, e4, r5]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`;
          }
          function ae(t4) {
            if (null === t4 || "string" == typeof t4 || "boolean" == typeof t4 || "number" == typeof t4 || t4 instanceof Yt || t4 instanceof Ht || t4 instanceof Qt || t4 instanceof te || t4 instanceof re || t4 instanceof ne)
              return true;
            if (Array.isArray(t4)) {
              for (const e4 of t4)
                if (!ae(e4))
                  return false;
              return true;
            }
            if ("object" == typeof t4) {
              for (const e4 in t4)
                if (!ae(t4[e4]))
                  return false;
              return true;
            }
            return false;
          }
          function se(t4) {
            if (null === t4)
              return ht;
            if ("string" == typeof t4)
              return ft;
            if ("boolean" == typeof t4)
              return dt;
            if ("number" == typeof t4)
              return pt;
            if (t4 instanceof Yt)
              return yt;
            if (t4 instanceof Ht)
              return xt;
            if (t4 instanceof Qt)
              return vt;
            if (t4 instanceof te)
              return bt;
            if (t4 instanceof re)
              return _t;
            if (t4 instanceof ne)
              return wt;
            if (Array.isArray(t4)) {
              const e4 = t4.length;
              let r5;
              for (const e5 of t4) {
                const t5 = se(e5);
                if (r5) {
                  if (r5 === t5)
                    continue;
                  r5 = gt;
                  break;
                }
                r5 = t5;
              }
              return At(r5 || gt, e4);
            }
            return mt;
          }
          function oe(t4) {
            const e4 = typeof t4;
            return null === t4 ? "" : "string" === e4 || "number" === e4 || "boolean" === e4 ? String(t4) : t4 instanceof Yt || t4 instanceof Qt || t4 instanceof te || t4 instanceof re || t4 instanceof ne ? t4.toString() : JSON.stringify(t4);
          }
          class le {
            constructor(t4, e4) {
              this.type = t4, this.value = e4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length)
                return e4.error(`'literal' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
              if (!ae(t4[1]))
                return e4.error("invalid value");
              const r5 = t4[1];
              let n3 = se(r5);
              const i5 = e4.expectedType;
              return "array" !== n3.kind || 0 !== n3.N || !i5 || "array" !== i5.kind || "number" == typeof i5.N && 0 !== i5.N || (n3 = i5), new le(n3, r5);
            }
            evaluate() {
              return this.value;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class ue {
            constructor(t4) {
              this.name = "ExpressionEvaluationError", this.message = t4;
            }
            toJSON() {
              return this.message;
            }
          }
          const ce = { string: ft, number: pt, boolean: dt, object: mt };
          class he {
            constructor(t4, e4) {
              this.type = t4, this.args = e4;
            }
            static parse(t4, e4) {
              if (t4.length < 2)
                return e4.error("Expected at least one argument.");
              let r5, n3 = 1;
              const i5 = t4[0];
              if ("array" === i5) {
                let i6, a6;
                if (t4.length > 2) {
                  const r6 = t4[1];
                  if ("string" != typeof r6 || !(r6 in ce) || "object" === r6)
                    return e4.error('The item type argument of "array" must be one of string, number, boolean', 1);
                  i6 = ce[r6], n3++;
                } else
                  i6 = gt;
                if (t4.length > 3) {
                  if (null !== t4[2] && ("number" != typeof t4[2] || t4[2] < 0 || t4[2] !== Math.floor(t4[2])))
                    return e4.error('The length argument to "array" must be a positive integer literal', 2);
                  a6 = t4[2], n3++;
                }
                r5 = At(i6, a6);
              } else {
                if (!ce[i5])
                  throw new Error(`Types doesn't contain name = ${i5}`);
                r5 = ce[i5];
              }
              const a5 = [];
              for (; n3 < t4.length; n3++) {
                const r6 = e4.parse(t4[n3], n3, gt);
                if (!r6)
                  return null;
                a5.push(r6);
              }
              return new he(r5, a5);
            }
            evaluate(t4) {
              for (let e4 = 0; e4 < this.args.length; e4++) {
                const r5 = this.args[e4].evaluate(t4);
                if (!It(this.type, se(r5)))
                  return r5;
                if (e4 === this.args.length - 1)
                  throw new ue(`Expected value to be of type ${St(this.type)}, but found ${St(se(r5))} instead.`);
              }
              throw new Error();
            }
            eachChild(t4) {
              this.args.forEach(t4);
            }
            outputDefined() {
              return this.args.every((t4) => t4.outputDefined());
            }
          }
          const pe = { "to-boolean": dt, "to-color": yt, "to-number": pt, "to-string": ft };
          class fe {
            constructor(t4, e4) {
              this.type = t4, this.args = e4;
            }
            static parse(t4, e4) {
              if (t4.length < 2)
                return e4.error("Expected at least one argument.");
              const r5 = t4[0];
              if (!pe[r5])
                throw new Error(`Can't parse ${r5} as it is not part of the known types`);
              if (("to-boolean" === r5 || "to-string" === r5) && 2 !== t4.length)
                return e4.error("Expected one argument.");
              const n3 = pe[r5], i5 = [];
              for (let r6 = 1; r6 < t4.length; r6++) {
                const n4 = e4.parse(t4[r6], r6, gt);
                if (!n4)
                  return null;
                i5.push(n4);
              }
              return new fe(n3, i5);
            }
            evaluate(t4) {
              switch (this.type.kind) {
                case "boolean":
                  return Boolean(this.args[0].evaluate(t4));
                case "color": {
                  let e4, r5;
                  for (const n3 of this.args) {
                    if (e4 = n3.evaluate(t4), r5 = null, e4 instanceof Yt)
                      return e4;
                    if ("string" == typeof e4) {
                      const r6 = t4.parseColor(e4);
                      if (r6)
                        return r6;
                    } else if (Array.isArray(e4) && (r5 = e4.length < 3 || e4.length > 4 ? `Invalid rbga value ${JSON.stringify(e4)}: expected an array containing either three or four numeric values.` : ie(e4[0], e4[1], e4[2], e4[3]), !r5))
                      return new Yt(e4[0] / 255, e4[1] / 255, e4[2] / 255, e4[3]);
                  }
                  throw new ue(r5 || `Could not parse color from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
                }
                case "padding": {
                  let e4;
                  for (const r5 of this.args) {
                    e4 = r5.evaluate(t4);
                    const n3 = te.parse(e4);
                    if (n3)
                      return n3;
                  }
                  throw new ue(`Could not parse padding from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
                }
                case "variableAnchorOffsetCollection": {
                  let e4;
                  for (const r5 of this.args) {
                    e4 = r5.evaluate(t4);
                    const n3 = re.parse(e4);
                    if (n3)
                      return n3;
                  }
                  throw new ue(`Could not parse variableAnchorOffsetCollection from value '${"string" == typeof e4 ? e4 : JSON.stringify(e4)}'`);
                }
                case "number": {
                  let e4 = null;
                  for (const r5 of this.args) {
                    if (e4 = r5.evaluate(t4), null === e4)
                      return 0;
                    const n3 = Number(e4);
                    if (!isNaN(n3))
                      return n3;
                  }
                  throw new ue(`Could not convert ${JSON.stringify(e4)} to number.`);
                }
                case "formatted":
                  return Qt.fromString(oe(this.args[0].evaluate(t4)));
                case "resolvedImage":
                  return ne.fromString(oe(this.args[0].evaluate(t4)));
                default:
                  return oe(this.args[0].evaluate(t4));
              }
            }
            eachChild(t4) {
              this.args.forEach(t4);
            }
            outputDefined() {
              return this.args.every((t4) => t4.outputDefined());
            }
          }
          const de = ["Unknown", "Point", "LineString", "Polygon"];
          class ye {
            constructor() {
              this.globals = null, this.feature = null, this.featureState = null, this.formattedSection = null, this._parseColorCache = {}, this.availableImages = null, this.canonical = null;
            }
            id() {
              return this.feature && "id" in this.feature ? this.feature.id : null;
            }
            geometryType() {
              return this.feature ? "number" == typeof this.feature.type ? de[this.feature.type] : this.feature.type : null;
            }
            geometry() {
              return this.feature && "geometry" in this.feature ? this.feature.geometry : null;
            }
            canonicalID() {
              return this.canonical;
            }
            properties() {
              return this.feature && this.feature.properties || {};
            }
            parseColor(t4) {
              let e4 = this._parseColorCache[t4];
              return e4 || (e4 = this._parseColorCache[t4] = Yt.parse(t4)), e4;
            }
          }
          class me {
            constructor(t4, e4, r5 = [], n3, i5 = new ct(), a5 = []) {
              this.registry = t4, this.path = r5, this.key = r5.map((t5) => `[${t5}]`).join(""), this.scope = i5, this.errors = a5, this.expectedType = n3, this._isConstant = e4;
            }
            parse(t4, e4, r5, n3, i5 = {}) {
              return e4 ? this.concat(e4, r5, n3)._parse(t4, i5) : this._parse(t4, i5);
            }
            _parse(t4, e4) {
              function r5(t5, e5, r6) {
                return "assert" === r6 ? new he(e5, [t5]) : "coerce" === r6 ? new fe(e5, [t5]) : t5;
              }
              if (null !== t4 && "string" != typeof t4 && "boolean" != typeof t4 && "number" != typeof t4 || (t4 = ["literal", t4]), Array.isArray(t4)) {
                if (0 === t4.length)
                  return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                const n3 = t4[0];
                if ("string" != typeof n3)
                  return this.error(`Expression name must be a string, but found ${typeof n3} instead. If you wanted a literal array, use ["literal", [...]].`, 0), null;
                const i5 = this.registry[n3];
                if (i5) {
                  let n4 = i5.parse(t4, this);
                  if (!n4)
                    return null;
                  if (this.expectedType) {
                    const t5 = this.expectedType, i6 = n4.type;
                    if ("string" !== t5.kind && "number" !== t5.kind && "boolean" !== t5.kind && "object" !== t5.kind && "array" !== t5.kind || "value" !== i6.kind)
                      if ("color" !== t5.kind && "formatted" !== t5.kind && "resolvedImage" !== t5.kind || "value" !== i6.kind && "string" !== i6.kind)
                        if ("padding" !== t5.kind || "value" !== i6.kind && "number" !== i6.kind && "array" !== i6.kind)
                          if ("variableAnchorOffsetCollection" !== t5.kind || "value" !== i6.kind && "array" !== i6.kind) {
                            if (this.checkSubtype(t5, i6))
                              return null;
                          } else
                            n4 = r5(n4, t5, e4.typeAnnotation || "coerce");
                        else
                          n4 = r5(n4, t5, e4.typeAnnotation || "coerce");
                      else
                        n4 = r5(n4, t5, e4.typeAnnotation || "coerce");
                    else
                      n4 = r5(n4, t5, e4.typeAnnotation || "assert");
                  }
                  if (!(n4 instanceof le) && "resolvedImage" !== n4.type.kind && this._isConstant(n4)) {
                    const t5 = new ye();
                    try {
                      n4 = new le(n4.type, n4.evaluate(t5));
                    } catch (t6) {
                      return this.error(t6.message), null;
                    }
                  }
                  return n4;
                }
                return this.error(`Unknown expression "${n3}". If you wanted a literal array, use ["literal", [...]].`, 0);
              }
              return this.error(void 0 === t4 ? "'undefined' value invalid. Use null instead." : "object" == typeof t4 ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t4} instead.`);
            }
            concat(t4, e4, r5) {
              const n3 = "number" == typeof t4 ? this.path.concat(t4) : this.path, i5 = r5 ? this.scope.concat(r5) : this.scope;
              return new me(this.registry, this._isConstant, n3, e4 || null, i5, this.errors);
            }
            error(t4, ...e4) {
              const r5 = `${this.key}${e4.map((t5) => `[${t5}]`).join("")}`;
              this.errors.push(new ut(r5, t4));
            }
            checkSubtype(t4, e4) {
              const r5 = It(t4, e4);
              return r5 && this.error(r5), r5;
            }
          }
          class ge {
            constructor(t4, e4, r5) {
              this.type = xt, this.locale = r5, this.caseSensitive = t4, this.diacriticSensitive = e4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length)
                return e4.error("Expected one argument.");
              const r5 = t4[1];
              if ("object" != typeof r5 || Array.isArray(r5))
                return e4.error("Collator options argument must be an object.");
              const n3 = e4.parse(void 0 !== r5["case-sensitive"] && r5["case-sensitive"], 1, dt);
              if (!n3)
                return null;
              const i5 = e4.parse(void 0 !== r5["diacritic-sensitive"] && r5["diacritic-sensitive"], 1, dt);
              if (!i5)
                return null;
              let a5 = null;
              return r5.locale && (a5 = e4.parse(r5.locale, 1, ft), !a5) ? null : new ge(n3, i5, a5);
            }
            evaluate(t4) {
              return new Ht(this.caseSensitive.evaluate(t4), this.diacriticSensitive.evaluate(t4), this.locale ? this.locale.evaluate(t4) : null);
            }
            eachChild(t4) {
              t4(this.caseSensitive), t4(this.diacriticSensitive), this.locale && t4(this.locale);
            }
            outputDefined() {
              return false;
            }
          }
          const xe = 8192;
          function ve(t4, e4) {
            t4[0] = Math.min(t4[0], e4[0]), t4[1] = Math.min(t4[1], e4[1]), t4[2] = Math.max(t4[2], e4[0]), t4[3] = Math.max(t4[3], e4[1]);
          }
          function be(t4, e4) {
            return !(t4[0] <= e4[0] || t4[2] >= e4[2] || t4[1] <= e4[1] || t4[3] >= e4[3]);
          }
          function we(t4, e4) {
            const r5 = (180 + t4[0]) / 360, n3 = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4[1] * Math.PI / 360))) / 360, i5 = Math.pow(2, e4.z);
            return [Math.round(r5 * i5 * xe), Math.round(n3 * i5 * xe)];
          }
          function _e(t4, e4, r5) {
            const n3 = t4[0] - e4[0], i5 = t4[1] - e4[1], a5 = t4[0] - r5[0], s5 = t4[1] - r5[1];
            return n3 * s5 - a5 * i5 == 0 && n3 * a5 <= 0 && i5 * s5 <= 0;
          }
          function Ae(t4, e4) {
            let r5 = false;
            for (let s5 = 0, o5 = e4.length; s5 < o5; s5++) {
              const o6 = e4[s5];
              for (let e5 = 0, s6 = o6.length; e5 < s6 - 1; e5++) {
                if (_e(t4, o6[e5], o6[e5 + 1]))
                  return false;
                (i5 = o6[e5])[1] > (n3 = t4)[1] != (a5 = o6[e5 + 1])[1] > n3[1] && n3[0] < (a5[0] - i5[0]) * (n3[1] - i5[1]) / (a5[1] - i5[1]) + i5[0] && (r5 = !r5);
              }
            }
            var n3, i5, a5;
            return r5;
          }
          function Se(t4, e4) {
            for (let r5 = 0; r5 < e4.length; r5++)
              if (Ae(t4, e4[r5]))
                return true;
            return false;
          }
          function ke(t4, e4, r5, n3) {
            const i5 = n3[0] - r5[0], a5 = n3[1] - r5[1], s5 = (t4[0] - r5[0]) * a5 - i5 * (t4[1] - r5[1]), o5 = (e4[0] - r5[0]) * a5 - i5 * (e4[1] - r5[1]);
            return s5 > 0 && o5 < 0 || s5 < 0 && o5 > 0;
          }
          function Ie(t4, e4, r5) {
            for (const u5 of r5)
              for (let r6 = 0; r6 < u5.length - 1; ++r6)
                if (0 != (o5 = [(s5 = u5[r6 + 1])[0] - (a5 = u5[r6])[0], s5[1] - a5[1]])[0] * (l5 = [(i5 = e4)[0] - (n3 = t4)[0], i5[1] - n3[1]])[1] - o5[1] * l5[0] && ke(n3, i5, a5, s5) && ke(a5, s5, n3, i5))
                  return true;
            var n3, i5, a5, s5, o5, l5;
            return false;
          }
          function ze(t4, e4) {
            for (let r5 = 0; r5 < t4.length; ++r5)
              if (!Ae(t4[r5], e4))
                return false;
            for (let r5 = 0; r5 < t4.length - 1; ++r5)
              if (Ie(t4[r5], t4[r5 + 1], e4))
                return false;
            return true;
          }
          function Me(t4, e4) {
            for (let r5 = 0; r5 < e4.length; r5++)
              if (ze(t4, e4[r5]))
                return true;
            return false;
          }
          function Pe(t4, e4, r5) {
            const n3 = [];
            for (let i5 = 0; i5 < t4.length; i5++) {
              const a5 = [];
              for (let n4 = 0; n4 < t4[i5].length; n4++) {
                const s5 = we(t4[i5][n4], r5);
                ve(e4, s5), a5.push(s5);
              }
              n3.push(a5);
            }
            return n3;
          }
          function Ce(t4, e4, r5) {
            const n3 = [];
            for (let i5 = 0; i5 < t4.length; i5++) {
              const a5 = Pe(t4[i5], e4, r5);
              n3.push(a5);
            }
            return n3;
          }
          function Be(t4, e4, r5, n3) {
            if (t4[0] < r5[0] || t4[0] > r5[2]) {
              const e5 = 0.5 * n3;
              let i5 = t4[0] - r5[0] > e5 ? -n3 : r5[0] - t4[0] > e5 ? n3 : 0;
              0 === i5 && (i5 = t4[0] - r5[2] > e5 ? -n3 : r5[2] - t4[0] > e5 ? n3 : 0), t4[0] += i5;
            }
            ve(e4, t4);
          }
          function Ve(t4, e4, r5, n3) {
            const i5 = Math.pow(2, n3.z) * xe, a5 = [n3.x * xe, n3.y * xe], s5 = [];
            for (const n4 of t4)
              for (const t5 of n4) {
                const n5 = [t5.x + a5[0], t5.y + a5[1]];
                Be(n5, e4, r5, i5), s5.push(n5);
              }
            return s5;
          }
          function Ee(t4, e4, r5, n3) {
            const i5 = Math.pow(2, n3.z) * xe, a5 = [n3.x * xe, n3.y * xe], s5 = [];
            for (const r6 of t4) {
              const t5 = [];
              for (const n4 of r6) {
                const r7 = [n4.x + a5[0], n4.y + a5[1]];
                ve(e4, r7), t5.push(r7);
              }
              s5.push(t5);
            }
            if (e4[2] - e4[0] <= i5 / 2) {
              (o5 = e4)[0] = o5[1] = 1 / 0, o5[2] = o5[3] = -1 / 0;
              for (const t5 of s5)
                for (const n4 of t5)
                  Be(n4, e4, r5, i5);
            }
            var o5;
            return s5;
          }
          class Fe {
            constructor(t4, e4) {
              this.type = dt, this.geojson = t4, this.geometries = e4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length)
                return e4.error(`'within' expression requires exactly one argument, but found ${t4.length - 1} instead.`);
              if (ae(t4[1])) {
                const e5 = t4[1];
                if ("FeatureCollection" === e5.type)
                  for (let t5 = 0; t5 < e5.features.length; ++t5) {
                    const r5 = e5.features[t5].geometry.type;
                    if ("Polygon" === r5 || "MultiPolygon" === r5)
                      return new Fe(e5, e5.features[t5].geometry);
                  }
                else if ("Feature" === e5.type) {
                  const t5 = e5.geometry.type;
                  if ("Polygon" === t5 || "MultiPolygon" === t5)
                    return new Fe(e5, e5.geometry);
                } else if ("Polygon" === e5.type || "MultiPolygon" === e5.type)
                  return new Fe(e5, e5);
              }
              return e4.error("'within' expression requires valid geojson object that contains polygon geometry type.");
            }
            evaluate(t4) {
              if (null != t4.geometry() && null != t4.canonicalID()) {
                if ("Point" === t4.geometryType())
                  return function(t5, e4) {
                    const r5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i5 = t5.canonicalID();
                    if ("Polygon" === e4.type) {
                      const a5 = Pe(e4.coordinates, n3, i5), s5 = Ve(t5.geometry(), r5, n3, i5);
                      if (!be(r5, n3))
                        return false;
                      for (const t6 of s5)
                        if (!Ae(t6, a5))
                          return false;
                    }
                    if ("MultiPolygon" === e4.type) {
                      const a5 = Ce(e4.coordinates, n3, i5), s5 = Ve(t5.geometry(), r5, n3, i5);
                      if (!be(r5, n3))
                        return false;
                      for (const t6 of s5)
                        if (!Se(t6, a5))
                          return false;
                    }
                    return true;
                  }(t4, this.geometries);
                if ("LineString" === t4.geometryType())
                  return function(t5, e4) {
                    const r5 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], n3 = [1 / 0, 1 / 0, -1 / 0, -1 / 0], i5 = t5.canonicalID();
                    if ("Polygon" === e4.type) {
                      const a5 = Pe(e4.coordinates, n3, i5), s5 = Ee(t5.geometry(), r5, n3, i5);
                      if (!be(r5, n3))
                        return false;
                      for (const t6 of s5)
                        if (!ze(t6, a5))
                          return false;
                    }
                    if ("MultiPolygon" === e4.type) {
                      const a5 = Ce(e4.coordinates, n3, i5), s5 = Ee(t5.geometry(), r5, n3, i5);
                      if (!be(r5, n3))
                        return false;
                      for (const t6 of s5)
                        if (!Me(t6, a5))
                          return false;
                    }
                    return true;
                  }(t4, this.geometries);
              }
              return false;
            }
            eachChild() {
            }
            outputDefined() {
              return true;
            }
          }
          class Te {
            constructor(t4, e4) {
              this.type = e4.type, this.name = t4, this.boundExpression = e4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length || "string" != typeof t4[1])
                return e4.error("'var' expression requires exactly one string literal argument.");
              const r5 = t4[1];
              return e4.scope.has(r5) ? new Te(r5, e4.scope.get(r5)) : e4.error(`Unknown variable "${r5}". Make sure "${r5}" has been bound in an enclosing "let" expression before using it.`, 1);
            }
            evaluate(t4) {
              return this.boundExpression.evaluate(t4);
            }
            eachChild() {
            }
            outputDefined() {
              return false;
            }
          }
          class $e {
            constructor(t4, e4, r5, n3) {
              this.name = t4, this.type = e4, this._evaluate = r5, this.args = n3;
            }
            evaluate(t4) {
              return this._evaluate(t4, this.args);
            }
            eachChild(t4) {
              this.args.forEach(t4);
            }
            outputDefined() {
              return false;
            }
            static parse(t4, e4) {
              const r5 = t4[0], n3 = $e.definitions[r5];
              if (!n3)
                return e4.error(`Unknown expression "${r5}". If you wanted a literal array, use ["literal", [...]].`, 0);
              const i5 = Array.isArray(n3) ? n3[0] : n3.type, a5 = Array.isArray(n3) ? [[n3[1], n3[2]]] : n3.overloads, s5 = a5.filter(([e5]) => !Array.isArray(e5) || e5.length === t4.length - 1);
              let o5 = null;
              for (const [n4, a6] of s5) {
                o5 = new me(e4.registry, Le, e4.path, null, e4.scope);
                const s6 = [];
                let l5 = false;
                for (let e5 = 1; e5 < t4.length; e5++) {
                  const r6 = t4[e5], i6 = Array.isArray(n4) ? n4[e5 - 1] : n4.type, a7 = o5.parse(r6, 1 + s6.length, i6);
                  if (!a7) {
                    l5 = true;
                    break;
                  }
                  s6.push(a7);
                }
                if (!l5)
                  if (Array.isArray(n4) && n4.length !== s6.length)
                    o5.error(`Expected ${n4.length} arguments, but found ${s6.length} instead.`);
                  else {
                    for (let t5 = 0; t5 < s6.length; t5++) {
                      const e5 = Array.isArray(n4) ? n4[t5] : n4.type, r6 = s6[t5];
                      o5.concat(t5 + 1).checkSubtype(e5, r6.type);
                    }
                    if (0 === o5.errors.length)
                      return new $e(r5, i5, a6, s6);
                  }
              }
              if (1 === s5.length)
                e4.errors.push(...o5.errors);
              else {
                const r6 = (s5.length ? s5 : a5).map(([t5]) => {
                  return e5 = t5, Array.isArray(e5) ? `(${e5.map(St).join(", ")})` : `(${St(e5.type)}...)`;
                  var e5;
                }).join(" | "), n4 = [];
                for (let r7 = 1; r7 < t4.length; r7++) {
                  const i6 = e4.parse(t4[r7], 1 + n4.length);
                  if (!i6)
                    return null;
                  n4.push(St(i6.type));
                }
                e4.error(`Expected arguments of type ${r6}, but found (${n4.join(", ")}) instead.`);
              }
              return null;
            }
            static register(t4, e4) {
              $e.definitions = e4;
              for (const r5 in e4)
                t4[r5] = $e;
            }
          }
          function Le(t4) {
            if (t4 instanceof Te)
              return Le(t4.boundExpression);
            if (t4 instanceof $e && "error" === t4.name)
              return false;
            if (t4 instanceof ge)
              return false;
            if (t4 instanceof Fe)
              return false;
            const e4 = t4 instanceof fe || t4 instanceof he;
            let r5 = true;
            return t4.eachChild((t5) => {
              r5 = e4 ? r5 && Le(t5) : r5 && t5 instanceof le;
            }), !!r5 && De(t4) && Ue(t4, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"]);
          }
          function De(t4) {
            if (t4 instanceof $e) {
              if ("get" === t4.name && 1 === t4.args.length)
                return false;
              if ("feature-state" === t4.name)
                return false;
              if ("has" === t4.name && 1 === t4.args.length)
                return false;
              if ("properties" === t4.name || "geometry-type" === t4.name || "id" === t4.name)
                return false;
              if (/^filter-/.test(t4.name))
                return false;
            }
            if (t4 instanceof Fe)
              return false;
            let e4 = true;
            return t4.eachChild((t5) => {
              e4 && !De(t5) && (e4 = false);
            }), e4;
          }
          function Oe(t4) {
            if (t4 instanceof $e && "feature-state" === t4.name)
              return false;
            let e4 = true;
            return t4.eachChild((t5) => {
              e4 && !Oe(t5) && (e4 = false);
            }), e4;
          }
          function Ue(t4, e4) {
            if (t4 instanceof $e && e4.indexOf(t4.name) >= 0)
              return false;
            let r5 = true;
            return t4.eachChild((t5) => {
              r5 && !Ue(t5, e4) && (r5 = false);
            }), r5;
          }
          function Re(t4, e4) {
            const r5 = t4.length - 1;
            let n3, i5, a5 = 0, s5 = r5, o5 = 0;
            for (; a5 <= s5; )
              if (o5 = Math.floor((a5 + s5) / 2), n3 = t4[o5], i5 = t4[o5 + 1], n3 <= e4) {
                if (o5 === r5 || e4 < i5)
                  return o5;
                a5 = o5 + 1;
              } else {
                if (!(n3 > e4))
                  throw new ue("Input is not a number.");
                s5 = o5 - 1;
              }
            return 0;
          }
          class qe {
            constructor(t4, e4, r5) {
              this.type = t4, this.input = e4, this.labels = [], this.outputs = [];
              for (const [t5, e5] of r5)
                this.labels.push(t5), this.outputs.push(e5);
            }
            static parse(t4, e4) {
              if (t4.length - 1 < 4)
                return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
              if ((t4.length - 1) % 2 != 0)
                return e4.error("Expected an even number of arguments.");
              const r5 = e4.parse(t4[1], 1, pt);
              if (!r5)
                return null;
              const n3 = [];
              let i5 = null;
              e4.expectedType && "value" !== e4.expectedType.kind && (i5 = e4.expectedType);
              for (let r6 = 1; r6 < t4.length; r6 += 2) {
                const a5 = 1 === r6 ? -1 / 0 : t4[r6], s5 = t4[r6 + 1], o5 = r6, l5 = r6 + 1;
                if ("number" != typeof a5)
                  return e4.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', o5);
                if (n3.length && n3[n3.length - 1][0] >= a5)
                  return e4.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', o5);
                const u5 = e4.parse(s5, l5, i5);
                if (!u5)
                  return null;
                i5 = i5 || u5.type, n3.push([a5, u5]);
              }
              return new qe(i5, r5, n3);
            }
            evaluate(t4) {
              const e4 = this.labels, r5 = this.outputs;
              if (1 === e4.length)
                return r5[0].evaluate(t4);
              const n3 = this.input.evaluate(t4);
              if (n3 <= e4[0])
                return r5[0].evaluate(t4);
              const i5 = e4.length;
              return n3 >= e4[i5 - 1] ? r5[i5 - 1].evaluate(t4) : r5[Re(e4, n3)].evaluate(t4);
            }
            eachChild(t4) {
              t4(this.input);
              for (const e4 of this.outputs)
                t4(e4);
            }
            outputDefined() {
              return this.outputs.every((t4) => t4.outputDefined());
            }
          }
          function je(t4, e4, r5) {
            return t4 + r5 * (e4 - t4);
          }
          function Ne(t4, e4, r5) {
            return t4.map((t5, n3) => je(t5, e4[n3], r5));
          }
          const Ze = { number: je, color: function(t4, e4, r5, n3 = "rgb") {
            switch (n3) {
              case "rgb": {
                const [n4, i5, a5, s5] = Ne(t4.rgb, e4.rgb, r5);
                return new Yt(n4, i5, a5, s5, false);
              }
              case "hcl": {
                const [n4, i5, a5, s5] = t4.hcl, [o5, l5, u5, c5] = e4.hcl;
                let h4, p7;
                if (isNaN(n4) || isNaN(o5))
                  isNaN(n4) ? isNaN(o5) ? h4 = NaN : (h4 = o5, 1 !== a5 && 0 !== a5 || (p7 = l5)) : (h4 = n4, 1 !== u5 && 0 !== u5 || (p7 = i5));
                else {
                  let t5 = o5 - n4;
                  o5 > n4 && t5 > 180 ? t5 -= 360 : o5 < n4 && n4 - o5 > 180 && (t5 += 360), h4 = n4 + r5 * t5;
                }
                const [f4, d4, y3, m4] = function([t5, e5, r6, n5]) {
                  return t5 = isNaN(t5) ? 0 : t5 * $t, qt([r6, Math.cos(t5) * e5, Math.sin(t5) * e5, n5]);
                }([h4, null != p7 ? p7 : je(i5, l5, r5), je(a5, u5, r5), je(s5, c5, r5)]);
                return new Yt(f4, d4, y3, m4, false);
              }
              case "lab": {
                const [n4, i5, a5, s5] = qt(Ne(t4.lab, e4.lab, r5));
                return new Yt(n4, i5, a5, s5, false);
              }
            }
          }, array: Ne, padding: function(t4, e4, r5) {
            return new te(Ne(t4.values, e4.values, r5));
          }, variableAnchorOffsetCollection: function(t4, e4, r5) {
            const n3 = t4.values, i5 = e4.values;
            if (n3.length !== i5.length)
              throw new ue(`Cannot interpolate values of different length. from: ${t4.toString()}, to: ${e4.toString()}`);
            const a5 = [];
            for (let t5 = 0; t5 < n3.length; t5 += 2) {
              if (n3[t5] !== i5[t5])
                throw new ue(`Cannot interpolate values containing mismatched anchors. from[${t5}]: ${n3[t5]}, to[${t5}]: ${i5[t5]}`);
              a5.push(n3[t5]);
              const [e5, s5] = n3[t5 + 1], [o5, l5] = i5[t5 + 1];
              a5.push([je(e5, o5, r5), je(s5, l5, r5)]);
            }
            return new re(a5);
          } };
          class Ke {
            constructor(t4, e4, r5, n3, i5) {
              this.type = t4, this.operator = e4, this.interpolation = r5, this.input = n3, this.labels = [], this.outputs = [];
              for (const [t5, e5] of i5)
                this.labels.push(t5), this.outputs.push(e5);
            }
            static interpolationFactor(t4, e4, r5, n3) {
              let i5 = 0;
              if ("exponential" === t4.name)
                i5 = Ge(e4, t4.base, r5, n3);
              else if ("linear" === t4.name)
                i5 = Ge(e4, 1, r5, n3);
              else if ("cubic-bezier" === t4.name) {
                const a5 = t4.controlPoints;
                i5 = new o4(a5[0], a5[1], a5[2], a5[3]).solve(Ge(e4, 1, r5, n3));
              }
              return i5;
            }
            static parse(t4, e4) {
              let [r5, n3, i5, ...a5] = t4;
              if (!Array.isArray(n3) || 0 === n3.length)
                return e4.error("Expected an interpolation type expression.", 1);
              if ("linear" === n3[0])
                n3 = { name: "linear" };
              else if ("exponential" === n3[0]) {
                const t5 = n3[1];
                if ("number" != typeof t5)
                  return e4.error("Exponential interpolation requires a numeric base.", 1, 1);
                n3 = { name: "exponential", base: t5 };
              } else {
                if ("cubic-bezier" !== n3[0])
                  return e4.error(`Unknown interpolation type ${String(n3[0])}`, 1, 0);
                {
                  const t5 = n3.slice(1);
                  if (4 !== t5.length || t5.some((t6) => "number" != typeof t6 || t6 < 0 || t6 > 1))
                    return e4.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                  n3 = { name: "cubic-bezier", controlPoints: t5 };
                }
              }
              if (t4.length - 1 < 4)
                return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
              if ((t4.length - 1) % 2 != 0)
                return e4.error("Expected an even number of arguments.");
              if (i5 = e4.parse(i5, 2, pt), !i5)
                return null;
              const s5 = [];
              let o5 = null;
              "interpolate-hcl" === r5 || "interpolate-lab" === r5 ? o5 = yt : e4.expectedType && "value" !== e4.expectedType.kind && (o5 = e4.expectedType);
              for (let t5 = 0; t5 < a5.length; t5 += 2) {
                const r6 = a5[t5], n4 = a5[t5 + 1], i6 = t5 + 3, l5 = t5 + 4;
                if ("number" != typeof r6)
                  return e4.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', i6);
                if (s5.length && s5[s5.length - 1][0] >= r6)
                  return e4.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', i6);
                const u5 = e4.parse(n4, l5, o5);
                if (!u5)
                  return null;
                o5 = o5 || u5.type, s5.push([r6, u5]);
              }
              return Pt(o5, pt) || Pt(o5, yt) || Pt(o5, bt) || Pt(o5, _t) || Pt(o5, At(pt)) ? new Ke(o5, r5, n3, i5, s5) : e4.error(`Type ${St(o5)} is not interpolatable.`);
            }
            evaluate(t4) {
              const e4 = this.labels, r5 = this.outputs;
              if (1 === e4.length)
                return r5[0].evaluate(t4);
              const n3 = this.input.evaluate(t4);
              if (n3 <= e4[0])
                return r5[0].evaluate(t4);
              const i5 = e4.length;
              if (n3 >= e4[i5 - 1])
                return r5[i5 - 1].evaluate(t4);
              const a5 = Re(e4, n3), s5 = Ke.interpolationFactor(this.interpolation, n3, e4[a5], e4[a5 + 1]), o5 = r5[a5].evaluate(t4), l5 = r5[a5 + 1].evaluate(t4);
              switch (this.operator) {
                case "interpolate":
                  return Ze[this.type.kind](o5, l5, s5);
                case "interpolate-hcl":
                  return Ze.color(o5, l5, s5, "hcl");
                case "interpolate-lab":
                  return Ze.color(o5, l5, s5, "lab");
              }
            }
            eachChild(t4) {
              t4(this.input);
              for (const e4 of this.outputs)
                t4(e4);
            }
            outputDefined() {
              return this.outputs.every((t4) => t4.outputDefined());
            }
          }
          function Ge(t4, e4, r5, n3) {
            const i5 = n3 - r5, a5 = t4 - r5;
            return 0 === i5 ? 0 : 1 === e4 ? a5 / i5 : (Math.pow(e4, a5) - 1) / (Math.pow(e4, i5) - 1);
          }
          class Je {
            constructor(t4, e4) {
              this.type = t4, this.args = e4;
            }
            static parse(t4, e4) {
              if (t4.length < 2)
                return e4.error("Expectected at least one argument.");
              let r5 = null;
              const n3 = e4.expectedType;
              n3 && "value" !== n3.kind && (r5 = n3);
              const i5 = [];
              for (const n4 of t4.slice(1)) {
                const t5 = e4.parse(n4, 1 + i5.length, r5, void 0, { typeAnnotation: "omit" });
                if (!t5)
                  return null;
                r5 = r5 || t5.type, i5.push(t5);
              }
              if (!r5)
                throw new Error("No output type");
              const a5 = n3 && i5.some((t5) => It(n3, t5.type));
              return new Je(a5 ? gt : r5, i5);
            }
            evaluate(t4) {
              let e4, r5 = null, n3 = 0;
              for (const i5 of this.args)
                if (n3++, r5 = i5.evaluate(t4), r5 && r5 instanceof ne && !r5.available && (e4 || (e4 = r5.name), r5 = null, n3 === this.args.length && (r5 = e4)), null !== r5)
                  break;
              return r5;
            }
            eachChild(t4) {
              this.args.forEach(t4);
            }
            outputDefined() {
              return this.args.every((t4) => t4.outputDefined());
            }
          }
          class Xe {
            constructor(t4, e4) {
              this.type = e4.type, this.bindings = [].concat(t4), this.result = e4;
            }
            evaluate(t4) {
              return this.result.evaluate(t4);
            }
            eachChild(t4) {
              for (const e4 of this.bindings)
                t4(e4[1]);
              t4(this.result);
            }
            static parse(t4, e4) {
              if (t4.length < 4)
                return e4.error(`Expected at least 3 arguments, but found ${t4.length - 1} instead.`);
              const r5 = [];
              for (let n4 = 1; n4 < t4.length - 1; n4 += 2) {
                const i5 = t4[n4];
                if ("string" != typeof i5)
                  return e4.error(`Expected string, but found ${typeof i5} instead.`, n4);
                if (/[^a-zA-Z0-9_]/.test(i5))
                  return e4.error("Variable names must contain only alphanumeric characters or '_'.", n4);
                const a5 = e4.parse(t4[n4 + 1], n4 + 1);
                if (!a5)
                  return null;
                r5.push([i5, a5]);
              }
              const n3 = e4.parse(t4[t4.length - 1], t4.length - 1, e4.expectedType, r5);
              return n3 ? new Xe(r5, n3) : null;
            }
            outputDefined() {
              return this.result.outputDefined();
            }
          }
          class Ye {
            constructor(t4, e4, r5) {
              this.type = t4, this.index = e4, this.input = r5;
            }
            static parse(t4, e4) {
              if (3 !== t4.length)
                return e4.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
              const r5 = e4.parse(t4[1], 1, pt), n3 = e4.parse(t4[2], 2, At(e4.expectedType || gt));
              return r5 && n3 ? new Ye(n3.type.itemType, r5, n3) : null;
            }
            evaluate(t4) {
              const e4 = this.index.evaluate(t4), r5 = this.input.evaluate(t4);
              if (e4 < 0)
                throw new ue(`Array index out of bounds: ${e4} < 0.`);
              if (e4 >= r5.length)
                throw new ue(`Array index out of bounds: ${e4} > ${r5.length - 1}.`);
              if (e4 !== Math.floor(e4))
                throw new ue(`Array index must be an integer, but found ${e4} instead.`);
              return r5[e4];
            }
            eachChild(t4) {
              t4(this.index), t4(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class He {
            constructor(t4, e4) {
              this.type = dt, this.needle = t4, this.haystack = e4;
            }
            static parse(t4, e4) {
              if (3 !== t4.length)
                return e4.error(`Expected 2 arguments, but found ${t4.length - 1} instead.`);
              const r5 = e4.parse(t4[1], 1, gt), n3 = e4.parse(t4[2], 2, gt);
              return r5 && n3 ? zt(r5.type, [dt, ft, pt, ht, gt]) ? new He(r5, n3) : e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r5.type)} instead`) : null;
            }
            evaluate(t4) {
              const e4 = this.needle.evaluate(t4), r5 = this.haystack.evaluate(t4);
              if (!r5)
                return false;
              if (!Mt(e4, ["boolean", "string", "number", "null"]))
                throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${St(se(e4))} instead.`);
              if (!Mt(r5, ["string", "array"]))
                throw new ue(`Expected second argument to be of type array or string, but found ${St(se(r5))} instead.`);
              return r5.indexOf(e4) >= 0;
            }
            eachChild(t4) {
              t4(this.needle), t4(this.haystack);
            }
            outputDefined() {
              return true;
            }
          }
          class We {
            constructor(t4, e4, r5) {
              this.type = pt, this.needle = t4, this.haystack = e4, this.fromIndex = r5;
            }
            static parse(t4, e4) {
              if (t4.length <= 2 || t4.length >= 5)
                return e4.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
              const r5 = e4.parse(t4[1], 1, gt), n3 = e4.parse(t4[2], 2, gt);
              if (!r5 || !n3)
                return null;
              if (!zt(r5.type, [dt, ft, pt, ht, gt]))
                return e4.error(`Expected first argument to be of type boolean, string, number or null, but found ${St(r5.type)} instead`);
              if (4 === t4.length) {
                const i5 = e4.parse(t4[3], 3, pt);
                return i5 ? new We(r5, n3, i5) : null;
              }
              return new We(r5, n3);
            }
            evaluate(t4) {
              const e4 = this.needle.evaluate(t4), r5 = this.haystack.evaluate(t4);
              if (!Mt(e4, ["boolean", "string", "number", "null"]))
                throw new ue(`Expected first argument to be of type boolean, string, number or null, but found ${St(se(e4))} instead.`);
              if (!Mt(r5, ["string", "array"]))
                throw new ue(`Expected second argument to be of type array or string, but found ${St(se(r5))} instead.`);
              if (this.fromIndex) {
                const n3 = this.fromIndex.evaluate(t4);
                return r5.indexOf(e4, n3);
              }
              return r5.indexOf(e4);
            }
            eachChild(t4) {
              t4(this.needle), t4(this.haystack), this.fromIndex && t4(this.fromIndex);
            }
            outputDefined() {
              return false;
            }
          }
          class Qe {
            constructor(t4, e4, r5, n3, i5, a5) {
              this.inputType = t4, this.type = e4, this.input = r5, this.cases = n3, this.outputs = i5, this.otherwise = a5;
            }
            static parse(t4, e4) {
              if (t4.length < 5)
                return e4.error(`Expected at least 4 arguments, but found only ${t4.length - 1}.`);
              if (t4.length % 2 != 1)
                return e4.error("Expected an even number of arguments.");
              let r5, n3;
              e4.expectedType && "value" !== e4.expectedType.kind && (n3 = e4.expectedType);
              const i5 = {}, a5 = [];
              for (let s6 = 2; s6 < t4.length - 1; s6 += 2) {
                let o6 = t4[s6];
                const l5 = t4[s6 + 1];
                Array.isArray(o6) || (o6 = [o6]);
                const u5 = e4.concat(s6);
                if (0 === o6.length)
                  return u5.error("Expected at least one branch label.");
                for (const t5 of o6) {
                  if ("number" != typeof t5 && "string" != typeof t5)
                    return u5.error("Branch labels must be numbers or strings.");
                  if ("number" == typeof t5 && Math.abs(t5) > Number.MAX_SAFE_INTEGER)
                    return u5.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                  if ("number" == typeof t5 && Math.floor(t5) !== t5)
                    return u5.error("Numeric branch labels must be integer values.");
                  if (r5) {
                    if (u5.checkSubtype(r5, se(t5)))
                      return null;
                  } else
                    r5 = se(t5);
                  if (void 0 !== i5[String(t5)])
                    return u5.error("Branch labels must be unique.");
                  i5[String(t5)] = a5.length;
                }
                const c5 = e4.parse(l5, s6, n3);
                if (!c5)
                  return null;
                n3 = n3 || c5.type, a5.push(c5);
              }
              const s5 = e4.parse(t4[1], 1, gt);
              if (!s5)
                return null;
              const o5 = e4.parse(t4[t4.length - 1], t4.length - 1, n3);
              return o5 ? "value" !== s5.type.kind && e4.concat(1).checkSubtype(r5, s5.type) ? null : new Qe(r5, n3, s5, i5, a5, o5) : null;
            }
            evaluate(t4) {
              const e4 = this.input.evaluate(t4);
              return (se(e4) === this.inputType && this.outputs[this.cases[e4]] || this.otherwise).evaluate(t4);
            }
            eachChild(t4) {
              t4(this.input), this.outputs.forEach(t4), t4(this.otherwise);
            }
            outputDefined() {
              return this.outputs.every((t4) => t4.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class tr {
            constructor(t4, e4, r5) {
              this.type = t4, this.branches = e4, this.otherwise = r5;
            }
            static parse(t4, e4) {
              if (t4.length < 4)
                return e4.error(`Expected at least 3 arguments, but found only ${t4.length - 1}.`);
              if (t4.length % 2 != 0)
                return e4.error("Expected an odd number of arguments.");
              let r5;
              e4.expectedType && "value" !== e4.expectedType.kind && (r5 = e4.expectedType);
              const n3 = [];
              for (let i6 = 1; i6 < t4.length - 1; i6 += 2) {
                const a5 = e4.parse(t4[i6], i6, dt);
                if (!a5)
                  return null;
                const s5 = e4.parse(t4[i6 + 1], i6 + 1, r5);
                if (!s5)
                  return null;
                n3.push([a5, s5]), r5 = r5 || s5.type;
              }
              const i5 = e4.parse(t4[t4.length - 1], t4.length - 1, r5);
              if (!i5)
                return null;
              if (!r5)
                throw new Error("Can't infer output type");
              return new tr(r5, n3, i5);
            }
            evaluate(t4) {
              for (const [e4, r5] of this.branches)
                if (e4.evaluate(t4))
                  return r5.evaluate(t4);
              return this.otherwise.evaluate(t4);
            }
            eachChild(t4) {
              for (const [e4, r5] of this.branches)
                t4(e4), t4(r5);
              t4(this.otherwise);
            }
            outputDefined() {
              return this.branches.every(([t4, e4]) => e4.outputDefined()) && this.otherwise.outputDefined();
            }
          }
          class er {
            constructor(t4, e4, r5, n3) {
              this.type = t4, this.input = e4, this.beginIndex = r5, this.endIndex = n3;
            }
            static parse(t4, e4) {
              if (t4.length <= 2 || t4.length >= 5)
                return e4.error(`Expected 3 or 4 arguments, but found ${t4.length - 1} instead.`);
              const r5 = e4.parse(t4[1], 1, gt), n3 = e4.parse(t4[2], 2, pt);
              if (!r5 || !n3)
                return null;
              if (!zt(r5.type, [At(gt), ft, gt]))
                return e4.error(`Expected first argument to be of type array or string, but found ${St(r5.type)} instead`);
              if (4 === t4.length) {
                const i5 = e4.parse(t4[3], 3, pt);
                return i5 ? new er(r5.type, r5, n3, i5) : null;
              }
              return new er(r5.type, r5, n3);
            }
            evaluate(t4) {
              const e4 = this.input.evaluate(t4), r5 = this.beginIndex.evaluate(t4);
              if (!Mt(e4, ["string", "array"]))
                throw new ue(`Expected first argument to be of type array or string, but found ${St(se(e4))} instead.`);
              if (this.endIndex) {
                const n3 = this.endIndex.evaluate(t4);
                return e4.slice(r5, n3);
              }
              return e4.slice(r5);
            }
            eachChild(t4) {
              t4(this.input), t4(this.beginIndex), this.endIndex && t4(this.endIndex);
            }
            outputDefined() {
              return false;
            }
          }
          function rr(t4, e4) {
            return "==" === t4 || "!=" === t4 ? "boolean" === e4.kind || "string" === e4.kind || "number" === e4.kind || "null" === e4.kind || "value" === e4.kind : "string" === e4.kind || "number" === e4.kind || "value" === e4.kind;
          }
          function nr(t4, e4, r5, n3) {
            return 0 === n3.compare(e4, r5);
          }
          function ir(t4, e4, r5) {
            const n3 = "==" !== t4 && "!=" !== t4;
            return class i5 {
              constructor(t5, e5, r6) {
                this.type = dt, this.lhs = t5, this.rhs = e5, this.collator = r6, this.hasUntypedArgument = "value" === t5.type.kind || "value" === e5.type.kind;
              }
              static parse(t5, e5) {
                if (3 !== t5.length && 4 !== t5.length)
                  return e5.error("Expected two or three arguments.");
                const r6 = t5[0];
                let a5 = e5.parse(t5[1], 1, gt);
                if (!a5)
                  return null;
                if (!rr(r6, a5.type))
                  return e5.concat(1).error(`"${r6}" comparisons are not supported for type '${St(a5.type)}'.`);
                let s5 = e5.parse(t5[2], 2, gt);
                if (!s5)
                  return null;
                if (!rr(r6, s5.type))
                  return e5.concat(2).error(`"${r6}" comparisons are not supported for type '${St(s5.type)}'.`);
                if (a5.type.kind !== s5.type.kind && "value" !== a5.type.kind && "value" !== s5.type.kind)
                  return e5.error(`Cannot compare types '${St(a5.type)}' and '${St(s5.type)}'.`);
                n3 && ("value" === a5.type.kind && "value" !== s5.type.kind ? a5 = new he(s5.type, [a5]) : "value" !== a5.type.kind && "value" === s5.type.kind && (s5 = new he(a5.type, [s5])));
                let o5 = null;
                if (4 === t5.length) {
                  if ("string" !== a5.type.kind && "string" !== s5.type.kind && "value" !== a5.type.kind && "value" !== s5.type.kind)
                    return e5.error("Cannot use collator to compare non-string types.");
                  if (o5 = e5.parse(t5[3], 3, xt), !o5)
                    return null;
                }
                return new i5(a5, s5, o5);
              }
              evaluate(i6) {
                const a5 = this.lhs.evaluate(i6), s5 = this.rhs.evaluate(i6);
                if (n3 && this.hasUntypedArgument) {
                  const e5 = se(a5), r6 = se(s5);
                  if (e5.kind !== r6.kind || "string" !== e5.kind && "number" !== e5.kind)
                    throw new ue(`Expected arguments for "${t4}" to be (string, string) or (number, number), but found (${e5.kind}, ${r6.kind}) instead.`);
                }
                if (this.collator && !n3 && this.hasUntypedArgument) {
                  const t5 = se(a5), r6 = se(s5);
                  if ("string" !== t5.kind || "string" !== r6.kind)
                    return e4(i6, a5, s5);
                }
                return this.collator ? r5(i6, a5, s5, this.collator.evaluate(i6)) : e4(i6, a5, s5);
              }
              eachChild(t5) {
                t5(this.lhs), t5(this.rhs), this.collator && t5(this.collator);
              }
              outputDefined() {
                return true;
              }
            };
          }
          const ar = ir("==", function(t4, e4, r5) {
            return e4 === r5;
          }, nr), sr = ir("!=", function(t4, e4, r5) {
            return e4 !== r5;
          }, function(t4, e4, r5, n3) {
            return !nr(0, e4, r5, n3);
          }), or = ir("<", function(t4, e4, r5) {
            return e4 < r5;
          }, function(t4, e4, r5, n3) {
            return n3.compare(e4, r5) < 0;
          }), lr = ir(">", function(t4, e4, r5) {
            return e4 > r5;
          }, function(t4, e4, r5, n3) {
            return n3.compare(e4, r5) > 0;
          }), ur = ir("<=", function(t4, e4, r5) {
            return e4 <= r5;
          }, function(t4, e4, r5, n3) {
            return n3.compare(e4, r5) <= 0;
          }), cr = ir(">=", function(t4, e4, r5) {
            return e4 >= r5;
          }, function(t4, e4, r5, n3) {
            return n3.compare(e4, r5) >= 0;
          });
          class hr {
            constructor(t4, e4, r5, n3, i5) {
              this.type = ft, this.number = t4, this.locale = e4, this.currency = r5, this.minFractionDigits = n3, this.maxFractionDigits = i5;
            }
            static parse(t4, e4) {
              if (3 !== t4.length)
                return e4.error("Expected two arguments.");
              const r5 = e4.parse(t4[1], 1, pt);
              if (!r5)
                return null;
              const n3 = t4[2];
              if ("object" != typeof n3 || Array.isArray(n3))
                return e4.error("NumberFormat options argument must be an object.");
              let i5 = null;
              if (n3.locale && (i5 = e4.parse(n3.locale, 1, ft), !i5))
                return null;
              let a5 = null;
              if (n3.currency && (a5 = e4.parse(n3.currency, 1, ft), !a5))
                return null;
              let s5 = null;
              if (n3["min-fraction-digits"] && (s5 = e4.parse(n3["min-fraction-digits"], 1, pt), !s5))
                return null;
              let o5 = null;
              return n3["max-fraction-digits"] && (o5 = e4.parse(n3["max-fraction-digits"], 1, pt), !o5) ? null : new hr(r5, i5, a5, s5, o5);
            }
            evaluate(t4) {
              return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t4) : [], { style: this.currency ? "currency" : "decimal", currency: this.currency ? this.currency.evaluate(t4) : void 0, minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t4) : void 0, maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t4) : void 0 }).format(this.number.evaluate(t4));
            }
            eachChild(t4) {
              t4(this.number), this.locale && t4(this.locale), this.currency && t4(this.currency), this.minFractionDigits && t4(this.minFractionDigits), this.maxFractionDigits && t4(this.maxFractionDigits);
            }
            outputDefined() {
              return false;
            }
          }
          class pr {
            constructor(t4) {
              this.type = vt, this.sections = t4;
            }
            static parse(t4, e4) {
              if (t4.length < 2)
                return e4.error("Expected at least one argument.");
              const r5 = t4[1];
              if (!Array.isArray(r5) && "object" == typeof r5)
                return e4.error("First argument must be an image or text section.");
              const n3 = [];
              let i5 = false;
              for (let r6 = 1; r6 <= t4.length - 1; ++r6) {
                const a5 = t4[r6];
                if (i5 && "object" == typeof a5 && !Array.isArray(a5)) {
                  i5 = false;
                  let t5 = null;
                  if (a5["font-scale"] && (t5 = e4.parse(a5["font-scale"], 1, pt), !t5))
                    return null;
                  let r7 = null;
                  if (a5["text-font"] && (r7 = e4.parse(a5["text-font"], 1, At(ft)), !r7))
                    return null;
                  let s5 = null;
                  if (a5["text-color"] && (s5 = e4.parse(a5["text-color"], 1, yt), !s5))
                    return null;
                  const o5 = n3[n3.length - 1];
                  o5.scale = t5, o5.font = r7, o5.textColor = s5;
                } else {
                  const a6 = e4.parse(t4[r6], 1, gt);
                  if (!a6)
                    return null;
                  const s5 = a6.type.kind;
                  if ("string" !== s5 && "value" !== s5 && "null" !== s5 && "resolvedImage" !== s5)
                    return e4.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                  i5 = true, n3.push({ content: a6, scale: null, font: null, textColor: null });
                }
              }
              return new pr(n3);
            }
            evaluate(t4) {
              return new Qt(this.sections.map((e4) => {
                const r5 = e4.content.evaluate(t4);
                return se(r5) === wt ? new Wt("", r5, null, null, null) : new Wt(oe(r5), null, e4.scale ? e4.scale.evaluate(t4) : null, e4.font ? e4.font.evaluate(t4).join(",") : null, e4.textColor ? e4.textColor.evaluate(t4) : null);
              }));
            }
            eachChild(t4) {
              for (const e4 of this.sections)
                t4(e4.content), e4.scale && t4(e4.scale), e4.font && t4(e4.font), e4.textColor && t4(e4.textColor);
            }
            outputDefined() {
              return false;
            }
          }
          class fr {
            constructor(t4) {
              this.type = wt, this.input = t4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length)
                return e4.error("Expected two arguments.");
              const r5 = e4.parse(t4[1], 1, ft);
              return r5 ? new fr(r5) : e4.error("No image name provided.");
            }
            evaluate(t4) {
              const e4 = this.input.evaluate(t4), r5 = ne.fromString(e4);
              return r5 && t4.availableImages && (r5.available = t4.availableImages.indexOf(e4) > -1), r5;
            }
            eachChild(t4) {
              t4(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          class dr {
            constructor(t4) {
              this.type = pt, this.input = t4;
            }
            static parse(t4, e4) {
              if (2 !== t4.length)
                return e4.error(`Expected 1 argument, but found ${t4.length - 1} instead.`);
              const r5 = e4.parse(t4[1], 1);
              return r5 ? "array" !== r5.type.kind && "string" !== r5.type.kind && "value" !== r5.type.kind ? e4.error(`Expected argument of type string or array, but found ${St(r5.type)} instead.`) : new dr(r5) : null;
            }
            evaluate(t4) {
              const e4 = this.input.evaluate(t4);
              if ("string" == typeof e4)
                return e4.length;
              if (Array.isArray(e4))
                return e4.length;
              throw new ue(`Expected value to be of type string or array, but found ${St(se(e4))} instead.`);
            }
            eachChild(t4) {
              t4(this.input);
            }
            outputDefined() {
              return false;
            }
          }
          const yr = { "==": ar, "!=": sr, ">": lr, "<": or, ">=": cr, "<=": ur, array: he, at: Ye, boolean: he, case: tr, coalesce: Je, collator: ge, format: pr, image: fr, in: He, "index-of": We, interpolate: Ke, "interpolate-hcl": Ke, "interpolate-lab": Ke, length: dr, let: Xe, literal: le, match: Qe, number: he, "number-format": hr, object: he, slice: er, step: qe, string: he, "to-boolean": fe, "to-color": fe, "to-number": fe, "to-string": fe, var: Te, within: Fe };
          function mr(t4, [e4, r5, n3, i5]) {
            e4 = e4.evaluate(t4), r5 = r5.evaluate(t4), n3 = n3.evaluate(t4);
            const a5 = i5 ? i5.evaluate(t4) : 1, s5 = ie(e4, r5, n3, a5);
            if (s5)
              throw new ue(s5);
            return new Yt(e4 / 255, r5 / 255, n3 / 255, a5, false);
          }
          function gr(t4, e4) {
            return t4 in e4;
          }
          function xr(t4, e4) {
            const r5 = e4[t4];
            return void 0 === r5 ? null : r5;
          }
          function vr(t4) {
            return { type: t4 };
          }
          function br(t4) {
            return { result: "success", value: t4 };
          }
          function wr(t4) {
            return { result: "error", value: t4 };
          }
          function _r(t4) {
            return "data-driven" === t4["property-type"] || "cross-faded-data-driven" === t4["property-type"];
          }
          function Ar(t4) {
            return !!t4.expression && t4.expression.parameters.indexOf("zoom") > -1;
          }
          function Sr(t4) {
            return !!t4.expression && t4.expression.interpolated;
          }
          function kr(t4) {
            return t4 instanceof Number ? "number" : t4 instanceof String ? "string" : t4 instanceof Boolean ? "boolean" : Array.isArray(t4) ? "array" : null === t4 ? "null" : typeof t4;
          }
          function Ir(t4) {
            return "object" == typeof t4 && null !== t4 && !Array.isArray(t4);
          }
          function zr(t4) {
            return t4;
          }
          function Mr(t4, e4) {
            const r5 = "color" === e4.type, n3 = t4.stops && "object" == typeof t4.stops[0][0], i5 = n3 || !(n3 || void 0 !== t4.property), a5 = t4.type || (Sr(e4) ? "exponential" : "interval");
            if (r5 || "padding" === e4.type) {
              const n4 = r5 ? Yt.parse : te.parse;
              (t4 = lt({}, t4)).stops && (t4.stops = t4.stops.map((t5) => [t5[0], n4(t5[1])])), t4.default = n4(t4.default ? t4.default : e4.default);
            }
            if (t4.colorSpace && "rgb" !== (s5 = t4.colorSpace) && "hcl" !== s5 && "lab" !== s5)
              throw new Error(`Unknown color space: "${t4.colorSpace}"`);
            var s5;
            let o5, l5, u5;
            if ("exponential" === a5)
              o5 = Vr;
            else if ("interval" === a5)
              o5 = Br;
            else if ("categorical" === a5) {
              o5 = Cr, l5 = /* @__PURE__ */ Object.create(null);
              for (const e5 of t4.stops)
                l5[e5[0]] = e5[1];
              u5 = typeof t4.stops[0][0];
            } else {
              if ("identity" !== a5)
                throw new Error(`Unknown function type "${a5}"`);
              o5 = Er;
            }
            if (n3) {
              const r6 = {}, n4 = [];
              for (let e5 = 0; e5 < t4.stops.length; e5++) {
                const i7 = t4.stops[e5], a7 = i7[0].zoom;
                void 0 === r6[a7] && (r6[a7] = { zoom: a7, type: t4.type, property: t4.property, default: t4.default, stops: [] }, n4.push(a7)), r6[a7].stops.push([i7[0].value, i7[1]]);
              }
              const i6 = [];
              for (const t5 of n4)
                i6.push([r6[t5].zoom, Mr(r6[t5], e4)]);
              const a6 = { name: "linear" };
              return { kind: "composite", interpolationType: a6, interpolationFactor: Ke.interpolationFactor.bind(void 0, a6), zoomStops: i6.map((t5) => t5[0]), evaluate: ({ zoom: r7 }, n5) => Vr({ stops: i6, base: t4.base }, e4, r7).evaluate(r7, n5) };
            }
            if (i5) {
              const r6 = "exponential" === a5 ? { name: "exponential", base: void 0 !== t4.base ? t4.base : 1 } : null;
              return { kind: "camera", interpolationType: r6, interpolationFactor: Ke.interpolationFactor.bind(void 0, r6), zoomStops: t4.stops.map((t5) => t5[0]), evaluate: ({ zoom: r7 }) => o5(t4, e4, r7, l5, u5) };
            }
            return { kind: "source", evaluate(r6, n4) {
              const i6 = n4 && n4.properties ? n4.properties[t4.property] : void 0;
              return void 0 === i6 ? Pr(t4.default, e4.default) : o5(t4, e4, i6, l5, u5);
            } };
          }
          function Pr(t4, e4, r5) {
            return void 0 !== t4 ? t4 : void 0 !== e4 ? e4 : void 0 !== r5 ? r5 : void 0;
          }
          function Cr(t4, e4, r5, n3, i5) {
            return Pr(typeof r5 === i5 ? n3[r5] : void 0, t4.default, e4.default);
          }
          function Br(t4, e4, r5) {
            if ("number" !== kr(r5))
              return Pr(t4.default, e4.default);
            const n3 = t4.stops.length;
            if (1 === n3)
              return t4.stops[0][1];
            if (r5 <= t4.stops[0][0])
              return t4.stops[0][1];
            if (r5 >= t4.stops[n3 - 1][0])
              return t4.stops[n3 - 1][1];
            const i5 = Re(t4.stops.map((t5) => t5[0]), r5);
            return t4.stops[i5][1];
          }
          function Vr(t4, e4, r5) {
            const n3 = void 0 !== t4.base ? t4.base : 1;
            if ("number" !== kr(r5))
              return Pr(t4.default, e4.default);
            const i5 = t4.stops.length;
            if (1 === i5)
              return t4.stops[0][1];
            if (r5 <= t4.stops[0][0])
              return t4.stops[0][1];
            if (r5 >= t4.stops[i5 - 1][0])
              return t4.stops[i5 - 1][1];
            const a5 = Re(t4.stops.map((t5) => t5[0]), r5), s5 = function(t5, e5, r6, n4) {
              const i6 = n4 - r6, a6 = t5 - r6;
              return 0 === i6 ? 0 : 1 === e5 ? a6 / i6 : (Math.pow(e5, a6) - 1) / (Math.pow(e5, i6) - 1);
            }(r5, n3, t4.stops[a5][0], t4.stops[a5 + 1][0]), o5 = t4.stops[a5][1], l5 = t4.stops[a5 + 1][1], u5 = Ze[e4.type] || zr;
            return "function" == typeof o5.evaluate ? { evaluate(...e5) {
              const r6 = o5.evaluate.apply(void 0, e5), n4 = l5.evaluate.apply(void 0, e5);
              if (void 0 !== r6 && void 0 !== n4)
                return u5(r6, n4, s5, t4.colorSpace);
            } } : u5(o5, l5, s5, t4.colorSpace);
          }
          function Er(t4, e4, r5) {
            switch (e4.type) {
              case "color":
                r5 = Yt.parse(r5);
                break;
              case "formatted":
                r5 = Qt.fromString(r5.toString());
                break;
              case "resolvedImage":
                r5 = ne.fromString(r5.toString());
                break;
              case "padding":
                r5 = te.parse(r5);
                break;
              default:
                kr(r5) === e4.type || "enum" === e4.type && e4.values[r5] || (r5 = void 0);
            }
            return Pr(r5, t4.default, e4.default);
          }
          $e.register(yr, { error: [{ kind: "error" }, [ft], (t4, [e4]) => {
            throw new ue(e4.evaluate(t4));
          }], typeof: [ft, [gt], (t4, [e4]) => St(se(e4.evaluate(t4)))], "to-rgba": [At(pt, 4), [yt], (t4, [e4]) => {
            const [r5, n3, i5, a5] = e4.evaluate(t4).rgb;
            return [255 * r5, 255 * n3, 255 * i5, a5];
          }], rgb: [yt, [pt, pt, pt], mr], rgba: [yt, [pt, pt, pt, pt], mr], has: { type: dt, overloads: [[[ft], (t4, [e4]) => gr(e4.evaluate(t4), t4.properties())], [[ft, mt], (t4, [e4, r5]) => gr(e4.evaluate(t4), r5.evaluate(t4))]] }, get: { type: gt, overloads: [[[ft], (t4, [e4]) => xr(e4.evaluate(t4), t4.properties())], [[ft, mt], (t4, [e4, r5]) => xr(e4.evaluate(t4), r5.evaluate(t4))]] }, "feature-state": [gt, [ft], (t4, [e4]) => xr(e4.evaluate(t4), t4.featureState || {})], properties: [mt, [], (t4) => t4.properties()], "geometry-type": [ft, [], (t4) => t4.geometryType()], id: [gt, [], (t4) => t4.id()], zoom: [pt, [], (t4) => t4.globals.zoom], "heatmap-density": [pt, [], (t4) => t4.globals.heatmapDensity || 0], "line-progress": [pt, [], (t4) => t4.globals.lineProgress || 0], accumulated: [gt, [], (t4) => void 0 === t4.globals.accumulated ? null : t4.globals.accumulated], "+": [pt, vr(pt), (t4, e4) => {
            let r5 = 0;
            for (const n3 of e4)
              r5 += n3.evaluate(t4);
            return r5;
          }], "*": [pt, vr(pt), (t4, e4) => {
            let r5 = 1;
            for (const n3 of e4)
              r5 *= n3.evaluate(t4);
            return r5;
          }], "-": { type: pt, overloads: [[[pt, pt], (t4, [e4, r5]) => e4.evaluate(t4) - r5.evaluate(t4)], [[pt], (t4, [e4]) => -e4.evaluate(t4)]] }, "/": [pt, [pt, pt], (t4, [e4, r5]) => e4.evaluate(t4) / r5.evaluate(t4)], "%": [pt, [pt, pt], (t4, [e4, r5]) => e4.evaluate(t4) % r5.evaluate(t4)], ln2: [pt, [], () => Math.LN2], pi: [pt, [], () => Math.PI], e: [pt, [], () => Math.E], "^": [pt, [pt, pt], (t4, [e4, r5]) => Math.pow(e4.evaluate(t4), r5.evaluate(t4))], sqrt: [pt, [pt], (t4, [e4]) => Math.sqrt(e4.evaluate(t4))], log10: [pt, [pt], (t4, [e4]) => Math.log(e4.evaluate(t4)) / Math.LN10], ln: [pt, [pt], (t4, [e4]) => Math.log(e4.evaluate(t4))], log2: [pt, [pt], (t4, [e4]) => Math.log(e4.evaluate(t4)) / Math.LN2], sin: [pt, [pt], (t4, [e4]) => Math.sin(e4.evaluate(t4))], cos: [pt, [pt], (t4, [e4]) => Math.cos(e4.evaluate(t4))], tan: [pt, [pt], (t4, [e4]) => Math.tan(e4.evaluate(t4))], asin: [pt, [pt], (t4, [e4]) => Math.asin(e4.evaluate(t4))], acos: [pt, [pt], (t4, [e4]) => Math.acos(e4.evaluate(t4))], atan: [pt, [pt], (t4, [e4]) => Math.atan(e4.evaluate(t4))], min: [pt, vr(pt), (t4, e4) => Math.min(...e4.map((e5) => e5.evaluate(t4)))], max: [pt, vr(pt), (t4, e4) => Math.max(...e4.map((e5) => e5.evaluate(t4)))], abs: [pt, [pt], (t4, [e4]) => Math.abs(e4.evaluate(t4))], round: [pt, [pt], (t4, [e4]) => {
            const r5 = e4.evaluate(t4);
            return r5 < 0 ? -Math.round(-r5) : Math.round(r5);
          }], floor: [pt, [pt], (t4, [e4]) => Math.floor(e4.evaluate(t4))], ceil: [pt, [pt], (t4, [e4]) => Math.ceil(e4.evaluate(t4))], "filter-==": [dt, [ft, gt], (t4, [e4, r5]) => t4.properties()[e4.value] === r5.value], "filter-id-==": [dt, [gt], (t4, [e4]) => t4.id() === e4.value], "filter-type-==": [dt, [ft], (t4, [e4]) => t4.geometryType() === e4.value], "filter-<": [dt, [ft, gt], (t4, [e4, r5]) => {
            const n3 = t4.properties()[e4.value], i5 = r5.value;
            return typeof n3 == typeof i5 && n3 < i5;
          }], "filter-id-<": [dt, [gt], (t4, [e4]) => {
            const r5 = t4.id(), n3 = e4.value;
            return typeof r5 == typeof n3 && r5 < n3;
          }], "filter->": [dt, [ft, gt], (t4, [e4, r5]) => {
            const n3 = t4.properties()[e4.value], i5 = r5.value;
            return typeof n3 == typeof i5 && n3 > i5;
          }], "filter-id->": [dt, [gt], (t4, [e4]) => {
            const r5 = t4.id(), n3 = e4.value;
            return typeof r5 == typeof n3 && r5 > n3;
          }], "filter-<=": [dt, [ft, gt], (t4, [e4, r5]) => {
            const n3 = t4.properties()[e4.value], i5 = r5.value;
            return typeof n3 == typeof i5 && n3 <= i5;
          }], "filter-id-<=": [dt, [gt], (t4, [e4]) => {
            const r5 = t4.id(), n3 = e4.value;
            return typeof r5 == typeof n3 && r5 <= n3;
          }], "filter->=": [dt, [ft, gt], (t4, [e4, r5]) => {
            const n3 = t4.properties()[e4.value], i5 = r5.value;
            return typeof n3 == typeof i5 && n3 >= i5;
          }], "filter-id->=": [dt, [gt], (t4, [e4]) => {
            const r5 = t4.id(), n3 = e4.value;
            return typeof r5 == typeof n3 && r5 >= n3;
          }], "filter-has": [dt, [gt], (t4, [e4]) => e4.value in t4.properties()], "filter-has-id": [dt, [], (t4) => null !== t4.id() && void 0 !== t4.id()], "filter-type-in": [dt, [At(ft)], (t4, [e4]) => e4.value.indexOf(t4.geometryType()) >= 0], "filter-id-in": [dt, [At(gt)], (t4, [e4]) => e4.value.indexOf(t4.id()) >= 0], "filter-in-small": [dt, [ft, At(gt)], (t4, [e4, r5]) => r5.value.indexOf(t4.properties()[e4.value]) >= 0], "filter-in-large": [dt, [ft, At(gt)], (t4, [e4, r5]) => function(t5, e5, r6, n3) {
            for (; r6 <= n3; ) {
              const i5 = r6 + n3 >> 1;
              if (e5[i5] === t5)
                return true;
              e5[i5] > t5 ? n3 = i5 - 1 : r6 = i5 + 1;
            }
            return false;
          }(t4.properties()[e4.value], r5.value, 0, r5.value.length - 1)], all: { type: dt, overloads: [[[dt, dt], (t4, [e4, r5]) => e4.evaluate(t4) && r5.evaluate(t4)], [vr(dt), (t4, e4) => {
            for (const r5 of e4)
              if (!r5.evaluate(t4))
                return false;
            return true;
          }]] }, any: { type: dt, overloads: [[[dt, dt], (t4, [e4, r5]) => e4.evaluate(t4) || r5.evaluate(t4)], [vr(dt), (t4, e4) => {
            for (const r5 of e4)
              if (r5.evaluate(t4))
                return true;
            return false;
          }]] }, "!": [dt, [dt], (t4, [e4]) => !e4.evaluate(t4)], "is-supported-script": [dt, [ft], (t4, [e4]) => {
            const r5 = t4.globals && t4.globals.isSupportedScript;
            return !r5 || r5(e4.evaluate(t4));
          }], upcase: [ft, [ft], (t4, [e4]) => e4.evaluate(t4).toUpperCase()], downcase: [ft, [ft], (t4, [e4]) => e4.evaluate(t4).toLowerCase()], concat: [ft, vr(gt), (t4, e4) => e4.map((e5) => oe(e5.evaluate(t4))).join("")], "resolved-locale": [ft, [xt], (t4, [e4]) => e4.evaluate(t4).resolvedLocale()] });
          class Fr {
            constructor(t4, e4) {
              var r5;
              this.expression = t4, this._warningHistory = {}, this._evaluator = new ye(), this._defaultValue = e4 ? "color" === (r5 = e4).type && Ir(r5.default) ? new Yt(0, 0, 0, 0) : "color" === r5.type ? Yt.parse(r5.default) || null : "padding" === r5.type ? te.parse(r5.default) || null : "variableAnchorOffsetCollection" === r5.type ? re.parse(r5.default) || null : void 0 === r5.default ? null : r5.default : null, this._enumValues = e4 && "enum" === e4.type ? e4.values : null;
            }
            evaluateWithoutErrorHandling(t4, e4, r5, n3, i5, a5) {
              return this._evaluator.globals = t4, this._evaluator.feature = e4, this._evaluator.featureState = r5, this._evaluator.canonical = n3, this._evaluator.availableImages = i5 || null, this._evaluator.formattedSection = a5, this.expression.evaluate(this._evaluator);
            }
            evaluate(t4, e4, r5, n3, i5, a5) {
              this._evaluator.globals = t4, this._evaluator.feature = e4 || null, this._evaluator.featureState = r5 || null, this._evaluator.canonical = n3, this._evaluator.availableImages = i5 || null, this._evaluator.formattedSection = a5 || null;
              try {
                const t5 = this.expression.evaluate(this._evaluator);
                if (null == t5 || "number" == typeof t5 && t5 != t5)
                  return this._defaultValue;
                if (this._enumValues && !(t5 in this._enumValues))
                  throw new ue(`Expected value to be one of ${Object.keys(this._enumValues).map((t6) => JSON.stringify(t6)).join(", ")}, but found ${JSON.stringify(t5)} instead.`);
                return t5;
              } catch (t5) {
                return this._warningHistory[t5.message] || (this._warningHistory[t5.message] = true, "undefined" != typeof console && console.warn(t5.message)), this._defaultValue;
              }
            }
          }
          function Tr(t4) {
            return Array.isArray(t4) && t4.length > 0 && "string" == typeof t4[0] && t4[0] in yr;
          }
          function $r(t4, e4) {
            const r5 = new me(yr, Le, [], e4 ? function(t5) {
              const e5 = { color: yt, string: ft, number: pt, enum: ft, boolean: dt, formatted: vt, padding: bt, resolvedImage: wt, variableAnchorOffsetCollection: _t };
              return "array" === t5.type ? At(e5[t5.value] || gt, t5.length) : e5[t5.type];
            }(e4) : void 0), n3 = r5.parse(t4, void 0, void 0, void 0, e4 && "string" === e4.type ? { typeAnnotation: "coerce" } : void 0);
            return n3 ? br(new Fr(n3, e4)) : wr(r5.errors);
          }
          class Lr {
            constructor(t4, e4) {
              this.kind = t4, this._styleExpression = e4, this.isStateDependent = "constant" !== t4 && !Oe(e4.expression);
            }
            evaluateWithoutErrorHandling(t4, e4, r5, n3, i5, a5) {
              return this._styleExpression.evaluateWithoutErrorHandling(t4, e4, r5, n3, i5, a5);
            }
            evaluate(t4, e4, r5, n3, i5, a5) {
              return this._styleExpression.evaluate(t4, e4, r5, n3, i5, a5);
            }
          }
          class Dr {
            constructor(t4, e4, r5, n3) {
              this.kind = t4, this.zoomStops = r5, this._styleExpression = e4, this.isStateDependent = "camera" !== t4 && !Oe(e4.expression), this.interpolationType = n3;
            }
            evaluateWithoutErrorHandling(t4, e4, r5, n3, i5, a5) {
              return this._styleExpression.evaluateWithoutErrorHandling(t4, e4, r5, n3, i5, a5);
            }
            evaluate(t4, e4, r5, n3, i5, a5) {
              return this._styleExpression.evaluate(t4, e4, r5, n3, i5, a5);
            }
            interpolationFactor(t4, e4, r5) {
              return this.interpolationType ? Ke.interpolationFactor(this.interpolationType, t4, e4, r5) : 0;
            }
          }
          function Or(t4, e4) {
            const r5 = $r(t4, e4);
            if ("error" === r5.result)
              return r5;
            const n3 = r5.value.expression, i5 = De(n3);
            if (!i5 && !_r(e4))
              return wr([new ut("", "data expressions not supported")]);
            const a5 = Ue(n3, ["zoom"]);
            if (!a5 && !Ar(e4))
              return wr([new ut("", "zoom expressions not supported")]);
            const s5 = Rr(n3);
            return s5 || a5 ? s5 instanceof ut ? wr([s5]) : s5 instanceof Ke && !Sr(e4) ? wr([new ut("", '"interpolate" expressions cannot be used with this property')]) : br(s5 ? new Dr(i5 ? "camera" : "composite", r5.value, s5.labels, s5 instanceof Ke ? s5.interpolation : void 0) : new Lr(i5 ? "constant" : "source", r5.value)) : wr([new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')]);
          }
          class Ur {
            constructor(t4, e4) {
              this._parameters = t4, this._specification = e4, lt(this, Mr(this._parameters, this._specification));
            }
            static deserialize(t4) {
              return new Ur(t4._parameters, t4._specification);
            }
            static serialize(t4) {
              return { _parameters: t4._parameters, _specification: t4._specification };
            }
          }
          function Rr(t4) {
            let e4 = null;
            if (t4 instanceof Xe)
              e4 = Rr(t4.result);
            else if (t4 instanceof Je) {
              for (const r5 of t4.args)
                if (e4 = Rr(r5), e4)
                  break;
            } else
              (t4 instanceof qe || t4 instanceof Ke) && t4.input instanceof $e && "zoom" === t4.input.name && (e4 = t4);
            return e4 instanceof ut || t4.eachChild((t5) => {
              const r5 = Rr(t5);
              r5 instanceof ut ? e4 = r5 : !e4 && r5 ? e4 = new ut("", '"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : e4 && r5 && e4 !== r5 && (e4 = new ut("", 'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'));
            }), e4;
          }
          function qr(t4) {
            if (true === t4 || false === t4)
              return true;
            if (!Array.isArray(t4) || 0 === t4.length)
              return false;
            switch (t4[0]) {
              case "has":
                return t4.length >= 2 && "$id" !== t4[1] && "$type" !== t4[1];
              case "in":
                return t4.length >= 3 && ("string" != typeof t4[1] || Array.isArray(t4[2]));
              case "!in":
              case "!has":
              case "none":
                return false;
              case "==":
              case "!=":
              case ">":
              case ">=":
              case "<":
              case "<=":
                return 3 !== t4.length || Array.isArray(t4[1]) || Array.isArray(t4[2]);
              case "any":
              case "all":
                for (const e4 of t4.slice(1))
                  if (!qr(e4) && "boolean" != typeof e4)
                    return false;
                return true;
              default:
                return true;
            }
          }
          const jr = { type: "boolean", default: false, transition: false, "property-type": "data-driven", expression: { interpolated: false, parameters: ["zoom", "feature"] } };
          function Nr(t4) {
            if (null == t4)
              return { filter: () => true, needGeometry: false };
            qr(t4) || (t4 = Gr(t4));
            const e4 = $r(t4, jr);
            if ("error" === e4.result)
              throw new Error(e4.value.map((t5) => `${t5.key}: ${t5.message}`).join(", "));
            return { filter: (t5, r5, n3) => e4.value.evaluate(t5, r5, {}, n3), needGeometry: Kr(t4) };
          }
          function Zr(t4, e4) {
            return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
          }
          function Kr(t4) {
            if (!Array.isArray(t4))
              return false;
            if ("within" === t4[0])
              return true;
            for (let e4 = 1; e4 < t4.length; e4++)
              if (Kr(t4[e4]))
                return true;
            return false;
          }
          function Gr(t4) {
            if (!t4)
              return true;
            const e4 = t4[0];
            return t4.length <= 1 ? "any" !== e4 : "==" === e4 ? Jr(t4[1], t4[2], "==") : "!=" === e4 ? Hr(Jr(t4[1], t4[2], "==")) : "<" === e4 || ">" === e4 || "<=" === e4 || ">=" === e4 ? Jr(t4[1], t4[2], e4) : "any" === e4 ? (r5 = t4.slice(1), ["any"].concat(r5.map(Gr))) : "all" === e4 ? ["all"].concat(t4.slice(1).map(Gr)) : "none" === e4 ? ["all"].concat(t4.slice(1).map(Gr).map(Hr)) : "in" === e4 ? Xr(t4[1], t4.slice(2)) : "!in" === e4 ? Hr(Xr(t4[1], t4.slice(2))) : "has" === e4 ? Yr(t4[1]) : "!has" === e4 ? Hr(Yr(t4[1])) : "within" !== e4 || t4;
            var r5;
          }
          function Jr(t4, e4, r5) {
            switch (t4) {
              case "$type":
                return [`filter-type-${r5}`, e4];
              case "$id":
                return [`filter-id-${r5}`, e4];
              default:
                return [`filter-${r5}`, t4, e4];
            }
          }
          function Xr(t4, e4) {
            if (0 === e4.length)
              return false;
            switch (t4) {
              case "$type":
                return ["filter-type-in", ["literal", e4]];
              case "$id":
                return ["filter-id-in", ["literal", e4]];
              default:
                return e4.length > 200 && !e4.some((t5) => typeof t5 != typeof e4[0]) ? ["filter-in-large", t4, ["literal", e4.sort(Zr)]] : ["filter-in-small", t4, ["literal", e4]];
            }
          }
          function Yr(t4) {
            switch (t4) {
              case "$type":
                return true;
              case "$id":
                return ["filter-has-id"];
              default:
                return ["filter-has", t4];
            }
          }
          function Hr(t4) {
            return ["!", t4];
          }
          function Wr(t4) {
            const e4 = typeof t4;
            if ("number" === e4 || "boolean" === e4 || "string" === e4 || null == t4)
              return JSON.stringify(t4);
            if (Array.isArray(t4)) {
              let e5 = "[";
              for (const r6 of t4)
                e5 += `${Wr(r6)},`;
              return `${e5}]`;
            }
            const r5 = Object.keys(t4).sort();
            let n3 = "{";
            for (let e5 = 0; e5 < r5.length; e5++)
              n3 += `${JSON.stringify(r5[e5])}:${Wr(t4[r5[e5]])},`;
            return `${n3}}`;
          }
          function Qr(t4) {
            let e4 = "";
            for (const r5 of Y)
              e4 += `/${Wr(t4[r5])}`;
            return e4;
          }
          function tn(t4) {
            const e4 = t4.value;
            return e4 ? [new ot(t4.key, e4, "constants have been deprecated as of v8")] : [];
          }
          function en(t4) {
            return t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean ? t4.valueOf() : t4;
          }
          function rn(t4) {
            if (Array.isArray(t4))
              return t4.map(rn);
            if (t4 instanceof Object && !(t4 instanceof Number || t4 instanceof String || t4 instanceof Boolean)) {
              const e4 = {};
              for (const r5 in t4)
                e4[r5] = rn(t4[r5]);
              return e4;
            }
            return en(t4);
          }
          function nn(t4) {
            const e4 = t4.key, r5 = t4.value, n3 = t4.valueSpec || {}, i5 = t4.objectElementValidators || {}, a5 = t4.style, s5 = t4.styleSpec, o5 = t4.validateSpec;
            let l5 = [];
            const u5 = kr(r5);
            if ("object" !== u5)
              return [new ot(e4, r5, `object expected, ${u5} found`)];
            for (const t5 in r5) {
              const u6 = t5.split(".")[0], c5 = n3[u6] || n3["*"];
              let h4;
              if (i5[u6])
                h4 = i5[u6];
              else if (n3[u6])
                h4 = o5;
              else if (i5["*"])
                h4 = i5["*"];
              else {
                if (!n3["*"]) {
                  l5.push(new ot(e4, r5[t5], `unknown property "${t5}"`));
                  continue;
                }
                h4 = o5;
              }
              l5 = l5.concat(h4({ key: (e4 ? `${e4}.` : e4) + t5, value: r5[t5], valueSpec: c5, style: a5, styleSpec: s5, object: r5, objectKey: t5, validateSpec: o5 }, r5));
            }
            for (const t5 in n3)
              i5[t5] || n3[t5].required && void 0 === n3[t5].default && void 0 === r5[t5] && l5.push(new ot(e4, r5, `missing required property "${t5}"`));
            return l5;
          }
          function an(t4) {
            const e4 = t4.value, r5 = t4.valueSpec, n3 = t4.style, i5 = t4.styleSpec, a5 = t4.key, s5 = t4.arrayElementValidator || t4.validateSpec;
            if ("array" !== kr(e4))
              return [new ot(a5, e4, `array expected, ${kr(e4)} found`)];
            if (r5.length && e4.length !== r5.length)
              return [new ot(a5, e4, `array length ${r5.length} expected, length ${e4.length} found`)];
            if (r5["min-length"] && e4.length < r5["min-length"])
              return [new ot(a5, e4, `array length at least ${r5["min-length"]} expected, length ${e4.length} found`)];
            let o5 = { type: r5.value, values: r5.values };
            i5.$version < 7 && (o5.function = r5.function), "object" === kr(r5.value) && (o5 = r5.value);
            let l5 = [];
            for (let r6 = 0; r6 < e4.length; r6++)
              l5 = l5.concat(s5({ array: e4, arrayIndex: r6, value: e4[r6], valueSpec: o5, validateSpec: t4.validateSpec, style: n3, styleSpec: i5, key: `${a5}[${r6}]` }));
            return l5;
          }
          function sn(t4) {
            const e4 = t4.key, r5 = t4.value, n3 = t4.valueSpec;
            let i5 = kr(r5);
            return "number" === i5 && r5 != r5 && (i5 = "NaN"), "number" !== i5 ? [new ot(e4, r5, `number expected, ${i5} found`)] : "minimum" in n3 && r5 < n3.minimum ? [new ot(e4, r5, `${r5} is less than the minimum value ${n3.minimum}`)] : "maximum" in n3 && r5 > n3.maximum ? [new ot(e4, r5, `${r5} is greater than the maximum value ${n3.maximum}`)] : [];
          }
          function on(t4) {
            const e4 = t4.valueSpec, r5 = en(t4.value.type);
            let n3, i5, a5, s5 = {};
            const o5 = "categorical" !== r5 && void 0 === t4.value.property, l5 = !o5, u5 = "array" === kr(t4.value.stops) && "array" === kr(t4.value.stops[0]) && "object" === kr(t4.value.stops[0][0]), c5 = nn({ key: t4.key, value: t4.value, valueSpec: t4.styleSpec.function, validateSpec: t4.validateSpec, style: t4.style, styleSpec: t4.styleSpec, objectElementValidators: { stops: function(t5) {
              if ("identity" === r5)
                return [new ot(t5.key, t5.value, 'identity function may not have a "stops" property')];
              let e5 = [];
              const n4 = t5.value;
              return e5 = e5.concat(an({ key: t5.key, value: n4, valueSpec: t5.valueSpec, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, arrayElementValidator: h4 })), "array" === kr(n4) && 0 === n4.length && e5.push(new ot(t5.key, n4, "array must have at least one stop")), e5;
            }, default: function(t5) {
              return t5.validateSpec({ key: t5.key, value: t5.value, valueSpec: e4, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec });
            } } });
            return "identity" === r5 && o5 && c5.push(new ot(t4.key, t4.value, 'missing required property "property"')), "identity" === r5 || t4.value.stops || c5.push(new ot(t4.key, t4.value, 'missing required property "stops"')), "exponential" === r5 && t4.valueSpec.expression && !Sr(t4.valueSpec) && c5.push(new ot(t4.key, t4.value, "exponential functions not supported")), t4.styleSpec.$version >= 8 && (l5 && !_r(t4.valueSpec) ? c5.push(new ot(t4.key, t4.value, "property functions not supported")) : o5 && !Ar(t4.valueSpec) && c5.push(new ot(t4.key, t4.value, "zoom functions not supported"))), "categorical" !== r5 && !u5 || void 0 !== t4.value.property || c5.push(new ot(t4.key, t4.value, '"property" property is required')), c5;
            function h4(t5) {
              let r6 = [];
              const n4 = t5.value, o6 = t5.key;
              if ("array" !== kr(n4))
                return [new ot(o6, n4, `array expected, ${kr(n4)} found`)];
              if (2 !== n4.length)
                return [new ot(o6, n4, `array length 2 expected, length ${n4.length} found`)];
              if (u5) {
                if ("object" !== kr(n4[0]))
                  return [new ot(o6, n4, `object expected, ${kr(n4[0])} found`)];
                if (void 0 === n4[0].zoom)
                  return [new ot(o6, n4, "object stop key must have zoom")];
                if (void 0 === n4[0].value)
                  return [new ot(o6, n4, "object stop key must have value")];
                if (a5 && a5 > en(n4[0].zoom))
                  return [new ot(o6, n4[0].zoom, "stop zoom values must appear in ascending order")];
                en(n4[0].zoom) !== a5 && (a5 = en(n4[0].zoom), i5 = void 0, s5 = {}), r6 = r6.concat(nn({ key: `${o6}[0]`, value: n4[0], valueSpec: { zoom: {} }, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec, objectElementValidators: { zoom: sn, value: p7 } }));
              } else
                r6 = r6.concat(p7({ key: `${o6}[0]`, value: n4[0], valueSpec: {}, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec }, n4));
              return Tr(rn(n4[1])) ? r6.concat([new ot(`${o6}[1]`, n4[1], "expressions are not allowed in function stops.")]) : r6.concat(t5.validateSpec({ key: `${o6}[1]`, value: n4[1], valueSpec: e4, validateSpec: t5.validateSpec, style: t5.style, styleSpec: t5.styleSpec }));
            }
            function p7(t5, a6) {
              const o6 = kr(t5.value), l6 = en(t5.value), u6 = null !== t5.value ? t5.value : a6;
              if (n3) {
                if (o6 !== n3)
                  return [new ot(t5.key, u6, `${o6} stop domain type must match previous stop domain type ${n3}`)];
              } else
                n3 = o6;
              if ("number" !== o6 && "string" !== o6 && "boolean" !== o6)
                return [new ot(t5.key, u6, "stop domain value must be a number, string, or boolean")];
              if ("number" !== o6 && "categorical" !== r5) {
                let n4 = `number expected, ${o6} found`;
                return _r(e4) && void 0 === r5 && (n4 += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'), [new ot(t5.key, u6, n4)];
              }
              return "categorical" !== r5 || "number" !== o6 || isFinite(l6) && Math.floor(l6) === l6 ? "categorical" !== r5 && "number" === o6 && void 0 !== i5 && l6 < i5 ? [new ot(t5.key, u6, "stop domain values must appear in ascending order")] : (i5 = l6, "categorical" === r5 && l6 in s5 ? [new ot(t5.key, u6, "stop domain values must be unique")] : (s5[l6] = true, [])) : [new ot(t5.key, u6, `integer expected, found ${l6}`)];
            }
          }
          function ln(t4) {
            const e4 = ("property" === t4.expressionContext ? Or : $r)(rn(t4.value), t4.valueSpec);
            if ("error" === e4.result)
              return e4.value.map((e5) => new ot(`${t4.key}${e5.key}`, t4.value, e5.message));
            const r5 = e4.value.expression || e4.value._styleExpression.expression;
            if ("property" === t4.expressionContext && "text-font" === t4.propertyKey && !r5.outputDefined())
              return [new ot(t4.key, t4.value, `Invalid data expression for "${t4.propertyKey}". Output values must be contained as literals within the expression.`)];
            if ("property" === t4.expressionContext && "layout" === t4.propertyType && !Oe(r5))
              return [new ot(t4.key, t4.value, '"feature-state" data expressions are not supported with layout properties.')];
            if ("filter" === t4.expressionContext && !Oe(r5))
              return [new ot(t4.key, t4.value, '"feature-state" data expressions are not supported with filters.')];
            if (t4.expressionContext && 0 === t4.expressionContext.indexOf("cluster")) {
              if (!Ue(r5, ["zoom", "feature-state"]))
                return [new ot(t4.key, t4.value, '"zoom" and "feature-state" expressions are not supported with cluster properties.')];
              if ("cluster-initial" === t4.expressionContext && !De(r5))
                return [new ot(t4.key, t4.value, "Feature data expressions are not supported with initial expression part of cluster properties.")];
            }
            return [];
          }
          function un(t4) {
            const e4 = t4.key, r5 = t4.value, n3 = t4.valueSpec, i5 = [];
            return Array.isArray(n3.values) ? -1 === n3.values.indexOf(en(r5)) && i5.push(new ot(e4, r5, `expected one of [${n3.values.join(", ")}], ${JSON.stringify(r5)} found`)) : -1 === Object.keys(n3.values).indexOf(en(r5)) && i5.push(new ot(e4, r5, `expected one of [${Object.keys(n3.values).join(", ")}], ${JSON.stringify(r5)} found`)), i5;
          }
          function cn(t4) {
            return qr(rn(t4.value)) ? ln(lt({}, t4, { expressionContext: "filter", valueSpec: { value: "boolean" } })) : hn(t4);
          }
          function hn(t4) {
            const e4 = t4.value, r5 = t4.key;
            if ("array" !== kr(e4))
              return [new ot(r5, e4, `array expected, ${kr(e4)} found`)];
            const n3 = t4.styleSpec;
            let i5, a5 = [];
            if (e4.length < 1)
              return [new ot(r5, e4, "filter array must have at least 1 element")];
            switch (a5 = a5.concat(un({ key: `${r5}[0]`, value: e4[0], valueSpec: n3.filter_operator, style: t4.style, styleSpec: t4.styleSpec })), en(e4[0])) {
              case "<":
              case "<=":
              case ">":
              case ">=":
                e4.length >= 2 && "$type" === en(e4[1]) && a5.push(new ot(r5, e4, `"$type" cannot be use with operator "${e4[0]}"`));
              case "==":
              case "!=":
                3 !== e4.length && a5.push(new ot(r5, e4, `filter array for operator "${e4[0]}" must have 3 elements`));
              case "in":
              case "!in":
                e4.length >= 2 && (i5 = kr(e4[1]), "string" !== i5 && a5.push(new ot(`${r5}[1]`, e4[1], `string expected, ${i5} found`)));
                for (let s5 = 2; s5 < e4.length; s5++)
                  i5 = kr(e4[s5]), "$type" === en(e4[1]) ? a5 = a5.concat(un({ key: `${r5}[${s5}]`, value: e4[s5], valueSpec: n3.geometry_type, style: t4.style, styleSpec: t4.styleSpec })) : "string" !== i5 && "number" !== i5 && "boolean" !== i5 && a5.push(new ot(`${r5}[${s5}]`, e4[s5], `string, number, or boolean expected, ${i5} found`));
                break;
              case "any":
              case "all":
              case "none":
                for (let n4 = 1; n4 < e4.length; n4++)
                  a5 = a5.concat(hn({ key: `${r5}[${n4}]`, value: e4[n4], style: t4.style, styleSpec: t4.styleSpec }));
                break;
              case "has":
              case "!has":
                i5 = kr(e4[1]), 2 !== e4.length ? a5.push(new ot(r5, e4, `filter array for "${e4[0]}" operator must have 2 elements`)) : "string" !== i5 && a5.push(new ot(`${r5}[1]`, e4[1], `string expected, ${i5} found`));
                break;
              case "within":
                i5 = kr(e4[1]), 2 !== e4.length ? a5.push(new ot(r5, e4, `filter array for "${e4[0]}" operator must have 2 elements`)) : "object" !== i5 && a5.push(new ot(`${r5}[1]`, e4[1], `object expected, ${i5} found`));
            }
            return a5;
          }
          function pn(t4, e4) {
            const r5 = t4.key, n3 = t4.validateSpec, i5 = t4.style, a5 = t4.styleSpec, s5 = t4.value, o5 = t4.objectKey, l5 = a5[`${e4}_${t4.layerType}`];
            if (!l5)
              return [];
            const u5 = o5.match(/^(.*)-transition$/);
            if ("paint" === e4 && u5 && l5[u5[1]] && l5[u5[1]].transition)
              return n3({ key: r5, value: s5, valueSpec: a5.transition, style: i5, styleSpec: a5 });
            const c5 = t4.valueSpec || l5[o5];
            if (!c5)
              return [new ot(r5, s5, `unknown property "${o5}"`)];
            let h4;
            if ("string" === kr(s5) && _r(c5) && !c5.tokens && (h4 = /^{([^}]+)}$/.exec(s5)))
              return [new ot(r5, s5, `"${o5}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(h4[1])} }\`.`)];
            const p7 = [];
            return "symbol" === t4.layerType && ("text-field" === o5 && i5 && !i5.glyphs && p7.push(new ot(r5, s5, 'use of "text-field" requires a style "glyphs" property')), "text-font" === o5 && Ir(rn(s5)) && "identity" === en(s5.type) && p7.push(new ot(r5, s5, '"text-font" does not support identity functions'))), p7.concat(n3({ key: t4.key, value: s5, valueSpec: c5, style: i5, styleSpec: a5, expressionContext: "property", propertyType: e4, propertyKey: o5 }));
          }
          function fn(t4) {
            return pn(t4, "paint");
          }
          function dn(t4) {
            return pn(t4, "layout");
          }
          function yn(t4) {
            let e4 = [];
            const r5 = t4.value, n3 = t4.key, i5 = t4.style, a5 = t4.styleSpec;
            r5.type || r5.ref || e4.push(new ot(n3, r5, 'either "type" or "ref" is required'));
            let s5 = en(r5.type);
            const o5 = en(r5.ref);
            if (r5.id) {
              const a6 = en(r5.id);
              for (let s6 = 0; s6 < t4.arrayIndex; s6++) {
                const t5 = i5.layers[s6];
                en(t5.id) === a6 && e4.push(new ot(n3, r5.id, `duplicate layer id "${r5.id}", previously used at line ${t5.id.__line__}`));
              }
            }
            if ("ref" in r5) {
              let t5;
              ["type", "source", "source-layer", "filter", "layout"].forEach((t6) => {
                t6 in r5 && e4.push(new ot(n3, r5[t6], `"${t6}" is prohibited for ref layers`));
              }), i5.layers.forEach((e5) => {
                en(e5.id) === o5 && (t5 = e5);
              }), t5 ? t5.ref ? e4.push(new ot(n3, r5.ref, "ref cannot reference another ref layer")) : s5 = en(t5.type) : e4.push(new ot(n3, r5.ref, `ref layer "${o5}" not found`));
            } else if ("background" !== s5)
              if (r5.source) {
                const t5 = i5.sources && i5.sources[r5.source], a6 = t5 && en(t5.type);
                t5 ? "vector" === a6 && "raster" === s5 ? e4.push(new ot(n3, r5.source, `layer "${r5.id}" requires a raster source`)) : "raster-dem" !== a6 && "hillshade" === s5 ? e4.push(new ot(n3, r5.source, `layer "${r5.id}" requires a raster-dem source`)) : "raster" === a6 && "raster" !== s5 ? e4.push(new ot(n3, r5.source, `layer "${r5.id}" requires a vector source`)) : "vector" !== a6 || r5["source-layer"] ? "raster-dem" === a6 && "hillshade" !== s5 ? e4.push(new ot(n3, r5.source, "raster-dem source can only be used with layer type 'hillshade'.")) : "line" !== s5 || !r5.paint || !r5.paint["line-gradient"] || "geojson" === a6 && t5.lineMetrics || e4.push(new ot(n3, r5, `layer "${r5.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : e4.push(new ot(n3, r5, `layer "${r5.id}" must specify a "source-layer"`)) : e4.push(new ot(n3, r5.source, `source "${r5.source}" not found`));
              } else
                e4.push(new ot(n3, r5, 'missing required property "source"'));
            return e4 = e4.concat(nn({ key: n3, value: r5, valueSpec: a5.layer, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, objectElementValidators: { "*": () => [], type: () => t4.validateSpec({ key: `${n3}.type`, value: r5.type, valueSpec: a5.layer.type, style: t4.style, styleSpec: t4.styleSpec, validateSpec: t4.validateSpec, object: r5, objectKey: "type" }), filter: cn, layout: (t5) => nn({ layer: r5, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": (t6) => dn(lt({ layerType: s5 }, t6)) } }), paint: (t5) => nn({ layer: r5, key: t5.key, value: t5.value, style: t5.style, styleSpec: t5.styleSpec, validateSpec: t5.validateSpec, objectElementValidators: { "*": (t6) => fn(lt({ layerType: s5 }, t6)) } }) } })), e4;
          }
          function mn(t4) {
            const e4 = t4.value, r5 = t4.key, n3 = kr(e4);
            return "string" !== n3 ? [new ot(r5, e4, `string expected, ${n3} found`)] : [];
          }
          const gn = { promoteId: function({ key: t4, value: e4 }) {
            if ("string" === kr(e4))
              return mn({ key: t4, value: e4 });
            {
              const r5 = [];
              for (const n3 in e4)
                r5.push(...mn({ key: `${t4}.${n3}`, value: e4[n3] }));
              return r5;
            }
          } };
          function xn(t4) {
            const e4 = t4.value, r5 = t4.key, n3 = t4.styleSpec, i5 = t4.style, a5 = t4.validateSpec;
            if (!e4.type)
              return [new ot(r5, e4, '"type" is required')];
            const s5 = en(e4.type);
            let o5;
            switch (s5) {
              case "vector":
              case "raster":
                return o5 = nn({ key: r5, value: e4, valueSpec: n3[`source_${s5.replace("-", "_")}`], style: t4.style, styleSpec: n3, objectElementValidators: gn, validateSpec: a5 }), o5;
              case "raster-dem":
                return o5 = function(t5) {
                  var e5;
                  const r6 = null !== (e5 = t5.sourceName) && void 0 !== e5 ? e5 : "", n4 = t5.value, i6 = t5.styleSpec, a6 = i6.source_raster_dem, s6 = t5.style;
                  let o6 = [];
                  const l5 = kr(n4);
                  if (void 0 === n4)
                    return o6;
                  if ("object" !== l5)
                    return o6.push(new ot("source_raster_dem", n4, `object expected, ${l5} found`)), o6;
                  const u5 = "custom" === en(n4.encoding), c5 = ["redFactor", "greenFactor", "blueFactor", "baseShift"], h4 = t5.value.encoding ? `"${t5.value.encoding}"` : "Default";
                  for (const e6 in n4)
                    !u5 && c5.includes(e6) ? o6.push(new ot(e6, n4[e6], `In "${r6}": "${e6}" is only valid when "encoding" is set to "custom". ${h4} encoding found`)) : a6[e6] ? o6 = o6.concat(t5.validateSpec({ key: e6, value: n4[e6], valueSpec: a6[e6], validateSpec: t5.validateSpec, style: s6, styleSpec: i6 })) : o6.push(new ot(e6, n4[e6], `unknown property "${e6}"`));
                  return o6;
                }({ sourceName: r5, value: e4, style: t4.style, styleSpec: n3, validateSpec: a5 }), o5;
              case "geojson":
                if (o5 = nn({ key: r5, value: e4, valueSpec: n3.source_geojson, style: i5, styleSpec: n3, validateSpec: a5, objectElementValidators: gn }), e4.cluster)
                  for (const t5 in e4.clusterProperties) {
                    const [n4, i6] = e4.clusterProperties[t5], s6 = "string" == typeof n4 ? [n4, ["accumulated"], ["get", t5]] : n4;
                    o5.push(...ln({ key: `${r5}.${t5}.map`, value: i6, validateSpec: a5, expressionContext: "cluster-map" })), o5.push(...ln({ key: `${r5}.${t5}.reduce`, value: s6, validateSpec: a5, expressionContext: "cluster-reduce" }));
                  }
                return o5;
              case "video":
                return nn({ key: r5, value: e4, valueSpec: n3.source_video, style: i5, validateSpec: a5, styleSpec: n3 });
              case "image":
                return nn({ key: r5, value: e4, valueSpec: n3.source_image, style: i5, validateSpec: a5, styleSpec: n3 });
              case "canvas":
                return [new ot(r5, null, "Please use runtime APIs to add canvas sources, rather than including them in stylesheets.", "source.canvas")];
              default:
                return un({ key: `${r5}.type`, value: e4.type, valueSpec: { values: ["vector", "raster", "raster-dem", "geojson", "video", "image"] }, style: i5, validateSpec: a5, styleSpec: n3 });
            }
          }
          function vn(t4) {
            const e4 = t4.value, r5 = t4.styleSpec, n3 = r5.light, i5 = t4.style;
            let a5 = [];
            const s5 = kr(e4);
            if (void 0 === e4)
              return a5;
            if ("object" !== s5)
              return a5 = a5.concat([new ot("light", e4, `object expected, ${s5} found`)]), a5;
            for (const s6 in e4) {
              const o5 = s6.match(/^(.*)-transition$/);
              a5 = a5.concat(o5 && n3[o5[1]] && n3[o5[1]].transition ? t4.validateSpec({ key: s6, value: e4[s6], valueSpec: r5.transition, validateSpec: t4.validateSpec, style: i5, styleSpec: r5 }) : n3[s6] ? t4.validateSpec({ key: s6, value: e4[s6], valueSpec: n3[s6], validateSpec: t4.validateSpec, style: i5, styleSpec: r5 }) : [new ot(s6, e4[s6], `unknown property "${s6}"`)]);
            }
            return a5;
          }
          function bn(t4) {
            const e4 = t4.value, r5 = t4.styleSpec, n3 = r5.terrain, i5 = t4.style;
            let a5 = [];
            const s5 = kr(e4);
            if (void 0 === e4)
              return a5;
            if ("object" !== s5)
              return a5 = a5.concat([new ot("terrain", e4, `object expected, ${s5} found`)]), a5;
            for (const s6 in e4)
              a5 = a5.concat(n3[s6] ? t4.validateSpec({ key: s6, value: e4[s6], valueSpec: n3[s6], validateSpec: t4.validateSpec, style: i5, styleSpec: r5 }) : [new ot(s6, e4[s6], `unknown property "${s6}"`)]);
            return a5;
          }
          function wn(t4) {
            let e4 = [];
            const r5 = t4.value, n3 = t4.key;
            if (Array.isArray(r5)) {
              const i5 = [], a5 = [];
              for (const s5 in r5)
                r5[s5].id && i5.includes(r5[s5].id) && e4.push(new ot(n3, r5, `all the sprites' ids must be unique, but ${r5[s5].id} is duplicated`)), i5.push(r5[s5].id), r5[s5].url && a5.includes(r5[s5].url) && e4.push(new ot(n3, r5, `all the sprites' URLs must be unique, but ${r5[s5].url} is duplicated`)), a5.push(r5[s5].url), e4 = e4.concat(nn({ key: `${n3}[${s5}]`, value: r5[s5], valueSpec: { id: { type: "string", required: true }, url: { type: "string", required: true } }, validateSpec: t4.validateSpec }));
              return e4;
            }
            return mn({ key: n3, value: r5 });
          }
          const _n = { "*": () => [], array: an, boolean: function(t4) {
            const e4 = t4.value, r5 = t4.key, n3 = kr(e4);
            return "boolean" !== n3 ? [new ot(r5, e4, `boolean expected, ${n3} found`)] : [];
          }, number: sn, color: function(t4) {
            const e4 = t4.key, r5 = t4.value, n3 = kr(r5);
            return "string" !== n3 ? [new ot(e4, r5, `color expected, ${n3} found`)] : Yt.parse(String(r5)) ? [] : [new ot(e4, r5, `color expected, "${r5}" found`)];
          }, constants: tn, enum: un, filter: cn, function: on, layer: yn, object: nn, source: xn, light: vn, terrain: bn, string: mn, formatted: function(t4) {
            return 0 === mn(t4).length ? [] : ln(t4);
          }, resolvedImage: function(t4) {
            return 0 === mn(t4).length ? [] : ln(t4);
          }, padding: function(t4) {
            const e4 = t4.key, r5 = t4.value;
            if ("array" === kr(r5)) {
              if (r5.length < 1 || r5.length > 4)
                return [new ot(e4, r5, `padding requires 1 to 4 values; ${r5.length} values found`)];
              const n3 = { type: "number" };
              let i5 = [];
              for (let a5 = 0; a5 < r5.length; a5++)
                i5 = i5.concat(t4.validateSpec({ key: `${e4}[${a5}]`, value: r5[a5], validateSpec: t4.validateSpec, valueSpec: n3 }));
              return i5;
            }
            return sn({ key: e4, value: r5, valueSpec: {} });
          }, variableAnchorOffsetCollection: function(t4) {
            const e4 = t4.key, r5 = t4.value, n3 = kr(r5), i5 = t4.styleSpec;
            if ("array" !== n3 || r5.length < 1 || r5.length % 2 != 0)
              return [new ot(e4, r5, "variableAnchorOffsetCollection requires a non-empty array of even length")];
            let a5 = [];
            for (let n4 = 0; n4 < r5.length; n4 += 2)
              a5 = a5.concat(un({ key: `${e4}[${n4}]`, value: r5[n4], valueSpec: i5.layout_symbol["text-anchor"] })), a5 = a5.concat(an({ key: `${e4}[${n4 + 1}]`, value: r5[n4 + 1], valueSpec: { length: 2, value: "number" }, validateSpec: t4.validateSpec, style: t4.style, styleSpec: i5 }));
            return a5;
          }, sprite: wn };
          function An(t4) {
            const e4 = t4.value, r5 = t4.valueSpec, n3 = t4.styleSpec;
            return t4.validateSpec = An, r5.expression && Ir(en(e4)) ? on(t4) : r5.expression && Tr(rn(e4)) ? ln(t4) : r5.type && _n[r5.type] ? _n[r5.type](t4) : nn(lt({}, t4, { valueSpec: r5.type ? n3[r5.type] : r5 }));
          }
          function Sn(t4) {
            const e4 = t4.value, r5 = t4.key, n3 = mn(t4);
            return n3.length || (-1 === e4.indexOf("{fontstack}") && n3.push(new ot(r5, e4, '"glyphs" url must include a "{fontstack}" token')), -1 === e4.indexOf("{range}") && n3.push(new ot(r5, e4, '"glyphs" url must include a "{range}" token'))), n3;
          }
          function kn(t4, e4 = X) {
            let r5 = [];
            return r5 = r5.concat(An({ key: "", value: t4, valueSpec: e4.$root, styleSpec: e4, style: t4, validateSpec: An, objectElementValidators: { glyphs: Sn, "*": () => [] } })), t4.constants && (r5 = r5.concat(tn({ key: "constants", value: t4.constants, style: t4, styleSpec: e4, validateSpec: An }))), zn(r5);
          }
          function In(t4) {
            return function(e4) {
              return t4({ ...e4, validateSpec: An });
            };
          }
          function zn(t4) {
            return [].concat(t4).sort((t5, e4) => t5.line - e4.line);
          }
          function Mn(t4) {
            return function(...e4) {
              return zn(t4.apply(this, e4));
            };
          }
          kn.source = Mn(In(xn)), kn.sprite = Mn(In(wn)), kn.glyphs = Mn(In(Sn)), kn.light = Mn(In(vn)), kn.terrain = Mn(In(bn)), kn.layer = Mn(In(yn)), kn.filter = Mn(In(cn)), kn.paintProperty = Mn(In(fn)), kn.layoutProperty = Mn(In(dn));
          const Pn = kn, Cn = Pn.light, Bn = Pn.paintProperty, Vn = Pn.layoutProperty;
          function En(t4, e4) {
            let r5 = false;
            if (e4 && e4.length)
              for (const n3 of e4)
                t4.fire(new G2(new Error(n3.message))), r5 = true;
            return r5;
          }
          class Fn {
            constructor(t4, e4, r5) {
              const n3 = this.cells = [];
              if (t4 instanceof ArrayBuffer) {
                this.arrayBuffer = t4;
                const i6 = new Int32Array(this.arrayBuffer);
                t4 = i6[0], this.d = (e4 = i6[1]) + 2 * (r5 = i6[2]);
                for (let t5 = 0; t5 < this.d * this.d; t5++) {
                  const e5 = i6[3 + t5], r6 = i6[3 + t5 + 1];
                  n3.push(e5 === r6 ? null : i6.subarray(e5, r6));
                }
                const a5 = i6[3 + n3.length + 1];
                this.keys = i6.subarray(i6[3 + n3.length], a5), this.bboxes = i6.subarray(a5), this.insert = this._insertReadonly;
              } else {
                this.d = e4 + 2 * r5;
                for (let t5 = 0; t5 < this.d * this.d; t5++)
                  n3.push([]);
                this.keys = [], this.bboxes = [];
              }
              this.n = e4, this.extent = t4, this.padding = r5, this.scale = e4 / t4, this.uid = 0;
              const i5 = r5 / e4 * t4;
              this.min = -i5, this.max = t4 + i5;
            }
            insert(t4, e4, r5, n3, i5) {
              this._forEachCell(e4, r5, n3, i5, this._insertCell, this.uid++, void 0, void 0), this.keys.push(t4), this.bboxes.push(e4), this.bboxes.push(r5), this.bboxes.push(n3), this.bboxes.push(i5);
            }
            _insertReadonly() {
              throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.");
            }
            _insertCell(t4, e4, r5, n3, i5, a5) {
              this.cells[i5].push(a5);
            }
            query(t4, e4, r5, n3, i5) {
              const a5 = this.min, s5 = this.max;
              if (t4 <= a5 && e4 <= a5 && s5 <= r5 && s5 <= n3 && !i5)
                return Array.prototype.slice.call(this.keys);
              {
                const a6 = [];
                return this._forEachCell(t4, e4, r5, n3, this._queryCell, a6, {}, i5), a6;
              }
            }
            _queryCell(t4, e4, r5, n3, i5, a5, s5, o5) {
              const l5 = this.cells[i5];
              if (null !== l5) {
                const i6 = this.keys, u5 = this.bboxes;
                for (let c5 = 0; c5 < l5.length; c5++) {
                  const h4 = l5[c5];
                  if (void 0 === s5[h4]) {
                    const l6 = 4 * h4;
                    (o5 ? o5(u5[l6 + 0], u5[l6 + 1], u5[l6 + 2], u5[l6 + 3]) : t4 <= u5[l6 + 2] && e4 <= u5[l6 + 3] && r5 >= u5[l6 + 0] && n3 >= u5[l6 + 1]) ? (s5[h4] = true, a5.push(i6[h4])) : s5[h4] = false;
                  }
                }
              }
            }
            _forEachCell(t4, e4, r5, n3, i5, a5, s5, o5) {
              const l5 = this._convertToCellCoord(t4), u5 = this._convertToCellCoord(e4), c5 = this._convertToCellCoord(r5), h4 = this._convertToCellCoord(n3);
              for (let p7 = l5; p7 <= c5; p7++)
                for (let l6 = u5; l6 <= h4; l6++) {
                  const u6 = this.d * l6 + p7;
                  if ((!o5 || o5(this._convertFromCellCoord(p7), this._convertFromCellCoord(l6), this._convertFromCellCoord(p7 + 1), this._convertFromCellCoord(l6 + 1))) && i5.call(this, t4, e4, r5, n3, u6, a5, s5, o5))
                    return;
                }
            }
            _convertFromCellCoord(t4) {
              return (t4 - this.padding) / this.scale;
            }
            _convertToCellCoord(t4) {
              return Math.max(0, Math.min(this.d - 1, Math.floor(t4 * this.scale) + this.padding));
            }
            toArrayBuffer() {
              if (this.arrayBuffer)
                return this.arrayBuffer;
              const t4 = this.cells, e4 = 3 + this.cells.length + 1 + 1;
              let r5 = 0;
              for (let t5 = 0; t5 < this.cells.length; t5++)
                r5 += this.cells[t5].length;
              const n3 = new Int32Array(e4 + r5 + this.keys.length + this.bboxes.length);
              n3[0] = this.extent, n3[1] = this.n, n3[2] = this.padding;
              let i5 = e4;
              for (let e5 = 0; e5 < t4.length; e5++) {
                const r6 = t4[e5];
                n3[3 + e5] = i5, n3.set(r6, i5), i5 += r6.length;
              }
              return n3[3 + t4.length] = i5, n3.set(this.keys, i5), i5 += this.keys.length, n3[3 + t4.length + 1] = i5, n3.set(this.bboxes, i5), i5 += this.bboxes.length, n3.buffer;
            }
            static serialize(t4, e4) {
              const r5 = t4.toArrayBuffer();
              return e4 && e4.push(r5), { buffer: r5 };
            }
            static deserialize(t4) {
              return new Fn(t4.buffer);
            }
          }
          const Tn = {};
          function $n(t4, e4, r5 = {}) {
            if (Tn[t4])
              throw new Error(`${t4} is already registered.`);
            Object.defineProperty(e4, "_classRegistryKey", { value: t4, writeable: false }), Tn[t4] = { klass: e4, omit: r5.omit || [], shallow: r5.shallow || [] };
          }
          $n("Object", Object), $n("TransferableGridIndex", Fn), $n("Color", Yt), $n("Error", Error), $n("AJAXError", L2), $n("ResolvedImage", ne), $n("StylePropertyFunction", Ur), $n("StyleExpression", Fr, { omit: ["_evaluator"] }), $n("ZoomDependentExpression", Dr), $n("ZoomConstantExpression", Lr), $n("CompoundExpression", $e, { omit: ["_evaluate"] });
          for (const t4 in yr)
            yr[t4]._classRegistryKey || $n(`Expression_${t4}`, yr[t4]);
          function Ln(t4) {
            return t4 && "undefined" != typeof ArrayBuffer && (t4 instanceof ArrayBuffer || t4.constructor && "ArrayBuffer" === t4.constructor.name);
          }
          function Dn(t4, e4) {
            if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || t4 instanceof Blob)
              return t4;
            if (Ln(t4))
              return e4 && e4.push(t4), t4;
            if (M2(t4))
              return e4 && e4.push(t4), t4;
            if (ArrayBuffer.isView(t4)) {
              const r5 = t4;
              return e4 && e4.push(r5.buffer), r5;
            }
            if (t4 instanceof ImageData)
              return e4 && e4.push(t4.data.buffer), t4;
            if (Array.isArray(t4)) {
              const r5 = [];
              for (const n3 of t4)
                r5.push(Dn(n3, e4));
              return r5;
            }
            if ("object" == typeof t4) {
              const r5 = t4.constructor, n3 = r5._classRegistryKey;
              if (!n3)
                throw new Error("can't serialize object of unregistered class");
              if (!Tn[n3])
                throw new Error(`${n3} is not registered.`);
              const i5 = r5.serialize ? r5.serialize(t4, e4) : {};
              if (r5.serialize) {
                if (e4 && i5 === e4[e4.length - 1])
                  throw new Error("statically serialized object won't survive transfer of $name property");
              } else {
                for (const r6 in t4) {
                  if (!t4.hasOwnProperty(r6))
                    continue;
                  if (Tn[n3].omit.indexOf(r6) >= 0)
                    continue;
                  const a5 = t4[r6];
                  i5[r6] = Tn[n3].shallow.indexOf(r6) >= 0 ? a5 : Dn(a5, e4);
                }
                t4 instanceof Error && (i5.message = t4.message);
              }
              if (i5.$name)
                throw new Error("$name property is reserved for worker serialization logic.");
              return "Object" !== n3 && (i5.$name = n3), i5;
            }
            throw new Error("can't serialize object of type " + typeof t4);
          }
          function On(t4) {
            if (null == t4 || "boolean" == typeof t4 || "number" == typeof t4 || "string" == typeof t4 || t4 instanceof Boolean || t4 instanceof Number || t4 instanceof String || t4 instanceof Date || t4 instanceof RegExp || t4 instanceof Blob || Ln(t4) || M2(t4) || ArrayBuffer.isView(t4) || t4 instanceof ImageData)
              return t4;
            if (Array.isArray(t4))
              return t4.map(On);
            if ("object" == typeof t4) {
              const e4 = t4.$name || "Object";
              if (!Tn[e4])
                throw new Error(`can't deserialize unregistered class ${e4}`);
              const { klass: r5 } = Tn[e4];
              if (!r5)
                throw new Error(`can't deserialize unregistered class ${e4}`);
              if (r5.deserialize)
                return r5.deserialize(t4);
              const n3 = Object.create(r5.prototype);
              for (const r6 of Object.keys(t4)) {
                if ("$name" === r6)
                  continue;
                const i5 = t4[r6];
                n3[r6] = Tn[e4].shallow.indexOf(r6) >= 0 ? i5 : On(i5);
              }
              return n3;
            }
            throw new Error("can't deserialize object of type " + typeof t4);
          }
          class Un {
            constructor() {
              this.first = true;
            }
            update(t4, e4) {
              const r5 = Math.floor(t4);
              return this.first ? (this.first = false, this.lastIntegerZoom = r5, this.lastIntegerZoomTime = 0, this.lastZoom = t4, this.lastFloorZoom = r5, true) : (this.lastFloorZoom > r5 ? (this.lastIntegerZoom = r5 + 1, this.lastIntegerZoomTime = e4) : this.lastFloorZoom < r5 && (this.lastIntegerZoom = r5, this.lastIntegerZoomTime = e4), t4 !== this.lastZoom && (this.lastZoom = t4, this.lastFloorZoom = r5, true));
            }
          }
          const Rn = { "Latin-1 Supplement": (t4) => t4 >= 128 && t4 <= 255, Arabic: (t4) => t4 >= 1536 && t4 <= 1791, "Arabic Supplement": (t4) => t4 >= 1872 && t4 <= 1919, "Arabic Extended-A": (t4) => t4 >= 2208 && t4 <= 2303, "Hangul Jamo": (t4) => t4 >= 4352 && t4 <= 4607, "Unified Canadian Aboriginal Syllabics": (t4) => t4 >= 5120 && t4 <= 5759, Khmer: (t4) => t4 >= 6016 && t4 <= 6143, "Unified Canadian Aboriginal Syllabics Extended": (t4) => t4 >= 6320 && t4 <= 6399, "General Punctuation": (t4) => t4 >= 8192 && t4 <= 8303, "Letterlike Symbols": (t4) => t4 >= 8448 && t4 <= 8527, "Number Forms": (t4) => t4 >= 8528 && t4 <= 8591, "Miscellaneous Technical": (t4) => t4 >= 8960 && t4 <= 9215, "Control Pictures": (t4) => t4 >= 9216 && t4 <= 9279, "Optical Character Recognition": (t4) => t4 >= 9280 && t4 <= 9311, "Enclosed Alphanumerics": (t4) => t4 >= 9312 && t4 <= 9471, "Geometric Shapes": (t4) => t4 >= 9632 && t4 <= 9727, "Miscellaneous Symbols": (t4) => t4 >= 9728 && t4 <= 9983, "Miscellaneous Symbols and Arrows": (t4) => t4 >= 11008 && t4 <= 11263, "CJK Radicals Supplement": (t4) => t4 >= 11904 && t4 <= 12031, "Kangxi Radicals": (t4) => t4 >= 12032 && t4 <= 12255, "Ideographic Description Characters": (t4) => t4 >= 12272 && t4 <= 12287, "CJK Symbols and Punctuation": (t4) => t4 >= 12288 && t4 <= 12351, Hiragana: (t4) => t4 >= 12352 && t4 <= 12447, Katakana: (t4) => t4 >= 12448 && t4 <= 12543, Bopomofo: (t4) => t4 >= 12544 && t4 <= 12591, "Hangul Compatibility Jamo": (t4) => t4 >= 12592 && t4 <= 12687, Kanbun: (t4) => t4 >= 12688 && t4 <= 12703, "Bopomofo Extended": (t4) => t4 >= 12704 && t4 <= 12735, "CJK Strokes": (t4) => t4 >= 12736 && t4 <= 12783, "Katakana Phonetic Extensions": (t4) => t4 >= 12784 && t4 <= 12799, "Enclosed CJK Letters and Months": (t4) => t4 >= 12800 && t4 <= 13055, "CJK Compatibility": (t4) => t4 >= 13056 && t4 <= 13311, "CJK Unified Ideographs Extension A": (t4) => t4 >= 13312 && t4 <= 19903, "Yijing Hexagram Symbols": (t4) => t4 >= 19904 && t4 <= 19967, "CJK Unified Ideographs": (t4) => t4 >= 19968 && t4 <= 40959, "Yi Syllables": (t4) => t4 >= 40960 && t4 <= 42127, "Yi Radicals": (t4) => t4 >= 42128 && t4 <= 42191, "Hangul Jamo Extended-A": (t4) => t4 >= 43360 && t4 <= 43391, "Hangul Syllables": (t4) => t4 >= 44032 && t4 <= 55215, "Hangul Jamo Extended-B": (t4) => t4 >= 55216 && t4 <= 55295, "Private Use Area": (t4) => t4 >= 57344 && t4 <= 63743, "CJK Compatibility Ideographs": (t4) => t4 >= 63744 && t4 <= 64255, "Arabic Presentation Forms-A": (t4) => t4 >= 64336 && t4 <= 65023, "Vertical Forms": (t4) => t4 >= 65040 && t4 <= 65055, "CJK Compatibility Forms": (t4) => t4 >= 65072 && t4 <= 65103, "Small Form Variants": (t4) => t4 >= 65104 && t4 <= 65135, "Arabic Presentation Forms-B": (t4) => t4 >= 65136 && t4 <= 65279, "Halfwidth and Fullwidth Forms": (t4) => t4 >= 65280 && t4 <= 65519 };
          function qn(t4) {
            for (const e4 of t4)
              if (Zn(e4.charCodeAt(0)))
                return true;
            return false;
          }
          function jn(t4) {
            for (const e4 of t4)
              if (!Nn(e4.charCodeAt(0)))
                return false;
            return true;
          }
          function Nn(t4) {
            return !(Rn.Arabic(t4) || Rn["Arabic Supplement"](t4) || Rn["Arabic Extended-A"](t4) || Rn["Arabic Presentation Forms-A"](t4) || Rn["Arabic Presentation Forms-B"](t4));
          }
          function Zn(t4) {
            return !(746 !== t4 && 747 !== t4 && (t4 < 4352 || !(Rn["Bopomofo Extended"](t4) || Rn.Bopomofo(t4) || Rn["CJK Compatibility Forms"](t4) && !(t4 >= 65097 && t4 <= 65103) || Rn["CJK Compatibility Ideographs"](t4) || Rn["CJK Compatibility"](t4) || Rn["CJK Radicals Supplement"](t4) || Rn["CJK Strokes"](t4) || !(!Rn["CJK Symbols and Punctuation"](t4) || t4 >= 12296 && t4 <= 12305 || t4 >= 12308 && t4 <= 12319 || 12336 === t4) || Rn["CJK Unified Ideographs Extension A"](t4) || Rn["CJK Unified Ideographs"](t4) || Rn["Enclosed CJK Letters and Months"](t4) || Rn["Hangul Compatibility Jamo"](t4) || Rn["Hangul Jamo Extended-A"](t4) || Rn["Hangul Jamo Extended-B"](t4) || Rn["Hangul Jamo"](t4) || Rn["Hangul Syllables"](t4) || Rn.Hiragana(t4) || Rn["Ideographic Description Characters"](t4) || Rn.Kanbun(t4) || Rn["Kangxi Radicals"](t4) || Rn["Katakana Phonetic Extensions"](t4) || Rn.Katakana(t4) && 12540 !== t4 || !(!Rn["Halfwidth and Fullwidth Forms"](t4) || 65288 === t4 || 65289 === t4 || 65293 === t4 || t4 >= 65306 && t4 <= 65310 || 65339 === t4 || 65341 === t4 || 65343 === t4 || t4 >= 65371 && t4 <= 65503 || 65507 === t4 || t4 >= 65512 && t4 <= 65519) || !(!Rn["Small Form Variants"](t4) || t4 >= 65112 && t4 <= 65118 || t4 >= 65123 && t4 <= 65126) || Rn["Unified Canadian Aboriginal Syllabics"](t4) || Rn["Unified Canadian Aboriginal Syllabics Extended"](t4) || Rn["Vertical Forms"](t4) || Rn["Yijing Hexagram Symbols"](t4) || Rn["Yi Syllables"](t4) || Rn["Yi Radicals"](t4))));
          }
          function Kn(t4) {
            return !(Zn(t4) || function(t5) {
              return !!(Rn["Latin-1 Supplement"](t5) && (167 === t5 || 169 === t5 || 174 === t5 || 177 === t5 || 188 === t5 || 189 === t5 || 190 === t5 || 215 === t5 || 247 === t5) || Rn["General Punctuation"](t5) && (8214 === t5 || 8224 === t5 || 8225 === t5 || 8240 === t5 || 8241 === t5 || 8251 === t5 || 8252 === t5 || 8258 === t5 || 8263 === t5 || 8264 === t5 || 8265 === t5 || 8273 === t5) || Rn["Letterlike Symbols"](t5) || Rn["Number Forms"](t5) || Rn["Miscellaneous Technical"](t5) && (t5 >= 8960 && t5 <= 8967 || t5 >= 8972 && t5 <= 8991 || t5 >= 8996 && t5 <= 9e3 || 9003 === t5 || t5 >= 9085 && t5 <= 9114 || t5 >= 9150 && t5 <= 9165 || 9167 === t5 || t5 >= 9169 && t5 <= 9179 || t5 >= 9186 && t5 <= 9215) || Rn["Control Pictures"](t5) && 9251 !== t5 || Rn["Optical Character Recognition"](t5) || Rn["Enclosed Alphanumerics"](t5) || Rn["Geometric Shapes"](t5) || Rn["Miscellaneous Symbols"](t5) && !(t5 >= 9754 && t5 <= 9759) || Rn["Miscellaneous Symbols and Arrows"](t5) && (t5 >= 11026 && t5 <= 11055 || t5 >= 11088 && t5 <= 11097 || t5 >= 11192 && t5 <= 11243) || Rn["CJK Symbols and Punctuation"](t5) || Rn.Katakana(t5) || Rn["Private Use Area"](t5) || Rn["CJK Compatibility Forms"](t5) || Rn["Small Form Variants"](t5) || Rn["Halfwidth and Fullwidth Forms"](t5) || 8734 === t5 || 8756 === t5 || 8757 === t5 || t5 >= 9984 && t5 <= 10087 || t5 >= 10102 && t5 <= 10131 || 65532 === t5 || 65533 === t5);
            }(t4));
          }
          function Gn(t4) {
            return t4 >= 1424 && t4 <= 2303 || Rn["Arabic Presentation Forms-A"](t4) || Rn["Arabic Presentation Forms-B"](t4);
          }
          function Jn(t4, e4) {
            return !(!e4 && Gn(t4) || t4 >= 2304 && t4 <= 3583 || t4 >= 3840 && t4 <= 4255 || Rn.Khmer(t4));
          }
          function Xn(t4) {
            for (const e4 of t4)
              if (Gn(e4.charCodeAt(0)))
                return true;
            return false;
          }
          const Yn = "deferred", Hn = "loading", Wn = "loaded";
          let Qn = null, ti = "unavailable", ei = null;
          const ri = function(t4) {
            t4 && "string" == typeof t4 && t4.indexOf("NetworkError") > -1 && (ti = "error"), Qn && Qn(t4);
          };
          function ni() {
            ii.fire(new K("pluginStateChange", { pluginStatus: ti, pluginURL: ei }));
          }
          const ii = new J(), ai = function() {
            return ti;
          }, si = function() {
            if (ti !== Yn || !ei)
              throw new Error("rtl-text-plugin cannot be downloaded unless a pluginURL is specified");
            ti = Hn, ni(), ei && q3({ url: ei }, (t4) => {
              t4 ? ri(t4) : (ti = Wn, ni());
            });
          }, oi = { applyArabicShaping: null, processBidirectionalText: null, processStyledBidirectionalText: null, isLoaded: () => ti === Wn || null != oi.applyArabicShaping, isLoading: () => ti === Hn, setState(t4) {
            if (!k3())
              throw new Error("Cannot set the state of the rtl-text-plugin when not in the web-worker context");
            ti = t4.pluginStatus, ei = t4.pluginURL;
          }, isParsed() {
            if (!k3())
              throw new Error("rtl-text-plugin is only parsed on the worker-threads");
            return null != oi.applyArabicShaping && null != oi.processBidirectionalText && null != oi.processStyledBidirectionalText;
          }, getPluginURL() {
            if (!k3())
              throw new Error("rtl-text-plugin url can only be queried from the worker threads");
            return ei;
          } };
          class li {
            constructor(t4, e4) {
              this.zoom = t4, e4 ? (this.now = e4.now, this.fadeDuration = e4.fadeDuration, this.zoomHistory = e4.zoomHistory, this.transition = e4.transition) : (this.now = 0, this.fadeDuration = 0, this.zoomHistory = new Un(), this.transition = {});
            }
            isSupportedScript(t4) {
              return function(t5, e4) {
                for (const r5 of t5)
                  if (!Jn(r5.charCodeAt(0), e4))
                    return false;
                return true;
              }(t4, oi.isLoaded());
            }
            crossFadingFactor() {
              return 0 === this.fadeDuration ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1);
            }
            getCrossfadeParameters() {
              const t4 = this.zoom, e4 = t4 - Math.floor(t4), r5 = this.crossFadingFactor();
              return t4 > this.zoomHistory.lastIntegerZoom ? { fromScale: 2, toScale: 1, t: e4 + (1 - e4) * r5 } : { fromScale: 0.5, toScale: 1, t: 1 - (1 - r5) * e4 };
            }
          }
          class ui {
            constructor(t4, e4) {
              this.property = t4, this.value = e4, this.expression = function(t5, e5) {
                if (Ir(t5))
                  return new Ur(t5, e5);
                if (Tr(t5)) {
                  const r5 = Or(t5, e5);
                  if ("error" === r5.result)
                    throw new Error(r5.value.map((t6) => `${t6.key}: ${t6.message}`).join(", "));
                  return r5.value;
                }
                {
                  let r5 = t5;
                  return "color" === e5.type && "string" == typeof t5 ? r5 = Yt.parse(t5) : "padding" !== e5.type || "number" != typeof t5 && !Array.isArray(t5) ? "variableAnchorOffsetCollection" === e5.type && Array.isArray(t5) && (r5 = re.parse(t5)) : r5 = te.parse(t5), { kind: "constant", evaluate: () => r5 };
                }
              }(void 0 === e4 ? t4.specification.default : e4, t4.specification);
            }
            isDataDriven() {
              return "source" === this.expression.kind || "composite" === this.expression.kind;
            }
            possiblyEvaluate(t4, e4, r5) {
              return this.property.possiblyEvaluate(this, t4, e4, r5);
            }
          }
          class ci {
            constructor(t4) {
              this.property = t4, this.value = new ui(t4, void 0);
            }
            transitioned(t4, e4) {
              return new pi(this.property, this.value, e4, m3({}, t4.transition, this.transition), t4.now);
            }
            untransitioned() {
              return new pi(this.property, this.value, null, {}, 0);
            }
          }
          class hi {
            constructor(t4) {
              this._properties = t4, this._values = Object.create(t4.defaultTransitionablePropertyValues);
            }
            getValue(t4) {
              return b3(this._values[t4].value.value);
            }
            setValue(t4, e4) {
              Object.prototype.hasOwnProperty.call(this._values, t4) || (this._values[t4] = new ci(this._values[t4].property)), this._values[t4].value = new ui(this._values[t4].property, null === e4 ? void 0 : b3(e4));
            }
            getTransition(t4) {
              return b3(this._values[t4].transition);
            }
            setTransition(t4, e4) {
              Object.prototype.hasOwnProperty.call(this._values, t4) || (this._values[t4] = new ci(this._values[t4].property)), this._values[t4].transition = b3(e4) || void 0;
            }
            serialize() {
              const t4 = {};
              for (const e4 of Object.keys(this._values)) {
                const r5 = this.getValue(e4);
                void 0 !== r5 && (t4[e4] = r5);
                const n3 = this.getTransition(e4);
                void 0 !== n3 && (t4[`${e4}-transition`] = n3);
              }
              return t4;
            }
            transitioned(t4, e4) {
              const r5 = new fi(this._properties);
              for (const n3 of Object.keys(this._values))
                r5._values[n3] = this._values[n3].transitioned(t4, e4._values[n3]);
              return r5;
            }
            untransitioned() {
              const t4 = new fi(this._properties);
              for (const e4 of Object.keys(this._values))
                t4._values[e4] = this._values[e4].untransitioned();
              return t4;
            }
          }
          class pi {
            constructor(t4, e4, r5, n3, i5) {
              this.property = t4, this.value = e4, this.begin = i5 + n3.delay || 0, this.end = this.begin + n3.duration || 0, t4.specification.transition && (n3.delay || n3.duration) && (this.prior = r5);
            }
            possiblyEvaluate(t4, e4, r5) {
              const n3 = t4.now || 0, i5 = this.value.possiblyEvaluate(t4, e4, r5), a5 = this.prior;
              if (a5) {
                if (n3 > this.end)
                  return this.prior = null, i5;
                if (this.value.isDataDriven())
                  return this.prior = null, i5;
                if (n3 < this.begin)
                  return a5.possiblyEvaluate(t4, e4, r5);
                {
                  const s5 = (n3 - this.begin) / (this.end - this.begin);
                  return this.property.interpolate(a5.possiblyEvaluate(t4, e4, r5), i5, function(t5) {
                    if (t5 <= 0)
                      return 0;
                    if (t5 >= 1)
                      return 1;
                    const e5 = t5 * t5, r6 = e5 * t5;
                    return 4 * (t5 < 0.5 ? r6 : 3 * (t5 - e5) + r6 - 0.75);
                  }(s5));
                }
              }
              return i5;
            }
          }
          class fi {
            constructor(t4) {
              this._properties = t4, this._values = Object.create(t4.defaultTransitioningPropertyValues);
            }
            possiblyEvaluate(t4, e4, r5) {
              const n3 = new mi(this._properties);
              for (const i5 of Object.keys(this._values))
                n3._values[i5] = this._values[i5].possiblyEvaluate(t4, e4, r5);
              return n3;
            }
            hasTransition() {
              for (const t4 of Object.keys(this._values))
                if (this._values[t4].prior)
                  return true;
              return false;
            }
          }
          class di {
            constructor(t4) {
              this._properties = t4, this._values = Object.create(t4.defaultPropertyValues);
            }
            hasValue(t4) {
              return void 0 !== this._values[t4].value;
            }
            getValue(t4) {
              return b3(this._values[t4].value);
            }
            setValue(t4, e4) {
              this._values[t4] = new ui(this._values[t4].property, null === e4 ? void 0 : b3(e4));
            }
            serialize() {
              const t4 = {};
              for (const e4 of Object.keys(this._values)) {
                const r5 = this.getValue(e4);
                void 0 !== r5 && (t4[e4] = r5);
              }
              return t4;
            }
            possiblyEvaluate(t4, e4, r5) {
              const n3 = new mi(this._properties);
              for (const i5 of Object.keys(this._values))
                n3._values[i5] = this._values[i5].possiblyEvaluate(t4, e4, r5);
              return n3;
            }
          }
          class yi {
            constructor(t4, e4, r5) {
              this.property = t4, this.value = e4, this.parameters = r5;
            }
            isConstant() {
              return "constant" === this.value.kind;
            }
            constantOr(t4) {
              return "constant" === this.value.kind ? this.value.value : t4;
            }
            evaluate(t4, e4, r5, n3) {
              return this.property.evaluate(this.value, this.parameters, t4, e4, r5, n3);
            }
          }
          class mi {
            constructor(t4) {
              this._properties = t4, this._values = Object.create(t4.defaultPossiblyEvaluatedValues);
            }
            get(t4) {
              return this._values[t4];
            }
          }
          class gi {
            constructor(t4) {
              this.specification = t4;
            }
            possiblyEvaluate(t4, e4) {
              if (t4.isDataDriven())
                throw new Error("Value should not be data driven");
              return t4.expression.evaluate(e4);
            }
            interpolate(t4, e4, r5) {
              const n3 = Ze[this.specification.type];
              return n3 ? n3(t4, e4, r5) : t4;
            }
          }
          class xi {
            constructor(t4, e4) {
              this.specification = t4, this.overrides = e4;
            }
            possiblyEvaluate(t4, e4, r5, n3) {
              return new yi(this, "constant" === t4.expression.kind || "camera" === t4.expression.kind ? { kind: "constant", value: t4.expression.evaluate(e4, null, {}, r5, n3) } : t4.expression, e4);
            }
            interpolate(t4, e4, r5) {
              if ("constant" !== t4.value.kind || "constant" !== e4.value.kind)
                return t4;
              if (void 0 === t4.value.value || void 0 === e4.value.value)
                return new yi(this, { kind: "constant", value: void 0 }, t4.parameters);
              const n3 = Ze[this.specification.type];
              if (n3) {
                const i5 = n3(t4.value.value, e4.value.value, r5);
                return new yi(this, { kind: "constant", value: i5 }, t4.parameters);
              }
              return t4;
            }
            evaluate(t4, e4, r5, n3, i5, a5) {
              return "constant" === t4.kind ? t4.value : t4.evaluate(e4, r5, n3, i5, a5);
            }
          }
          class vi extends xi {
            possiblyEvaluate(t4, e4, r5, n3) {
              if (void 0 === t4.value)
                return new yi(this, { kind: "constant", value: void 0 }, e4);
              if ("constant" === t4.expression.kind) {
                const i5 = t4.expression.evaluate(e4, null, {}, r5, n3), a5 = "resolvedImage" === t4.property.specification.type && "string" != typeof i5 ? i5.name : i5, s5 = this._calculate(a5, a5, a5, e4);
                return new yi(this, { kind: "constant", value: s5 }, e4);
              }
              if ("camera" === t4.expression.kind) {
                const r6 = this._calculate(t4.expression.evaluate({ zoom: e4.zoom - 1 }), t4.expression.evaluate({ zoom: e4.zoom }), t4.expression.evaluate({ zoom: e4.zoom + 1 }), e4);
                return new yi(this, { kind: "constant", value: r6 }, e4);
              }
              return new yi(this, t4.expression, e4);
            }
            evaluate(t4, e4, r5, n3, i5, a5) {
              if ("source" === t4.kind) {
                const s5 = t4.evaluate(e4, r5, n3, i5, a5);
                return this._calculate(s5, s5, s5, e4);
              }
              return "composite" === t4.kind ? this._calculate(t4.evaluate({ zoom: Math.floor(e4.zoom) - 1 }, r5, n3), t4.evaluate({ zoom: Math.floor(e4.zoom) }, r5, n3), t4.evaluate({ zoom: Math.floor(e4.zoom) + 1 }, r5, n3), e4) : t4.value;
            }
            _calculate(t4, e4, r5, n3) {
              return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t4, to: e4 } : { from: r5, to: e4 };
            }
            interpolate(t4) {
              return t4;
            }
          }
          class bi {
            constructor(t4) {
              this.specification = t4;
            }
            possiblyEvaluate(t4, e4, r5, n3) {
              if (void 0 !== t4.value) {
                if ("constant" === t4.expression.kind) {
                  const i5 = t4.expression.evaluate(e4, null, {}, r5, n3);
                  return this._calculate(i5, i5, i5, e4);
                }
                return this._calculate(t4.expression.evaluate(new li(Math.floor(e4.zoom - 1), e4)), t4.expression.evaluate(new li(Math.floor(e4.zoom), e4)), t4.expression.evaluate(new li(Math.floor(e4.zoom + 1), e4)), e4);
              }
            }
            _calculate(t4, e4, r5, n3) {
              return n3.zoom > n3.zoomHistory.lastIntegerZoom ? { from: t4, to: e4 } : { from: r5, to: e4 };
            }
            interpolate(t4) {
              return t4;
            }
          }
          class wi {
            constructor(t4) {
              this.specification = t4;
            }
            possiblyEvaluate(t4, e4, r5, n3) {
              return !!t4.expression.evaluate(e4, null, {}, r5, n3);
            }
            interpolate() {
              return false;
            }
          }
          class _i {
            constructor(t4) {
              this.properties = t4, this.defaultPropertyValues = {}, this.defaultTransitionablePropertyValues = {}, this.defaultTransitioningPropertyValues = {}, this.defaultPossiblyEvaluatedValues = {}, this.overridableProperties = [];
              for (const e4 in t4) {
                const r5 = t4[e4];
                r5.specification.overridable && this.overridableProperties.push(e4);
                const n3 = this.defaultPropertyValues[e4] = new ui(r5, void 0), i5 = this.defaultTransitionablePropertyValues[e4] = new ci(r5);
                this.defaultTransitioningPropertyValues[e4] = i5.untransitioned(), this.defaultPossiblyEvaluatedValues[e4] = n3.possiblyEvaluate({});
              }
            }
          }
          $n("DataDrivenProperty", xi), $n("DataConstantProperty", gi), $n("CrossFadedDataDrivenProperty", vi), $n("CrossFadedProperty", bi), $n("ColorRampProperty", wi);
          const Ai = "-transition";
          class Si extends J {
            constructor(t4, e4) {
              if (super(), this.id = t4.id, this.type = t4.type, this._featureFilter = { filter: () => true, needGeometry: false }, "custom" !== t4.type && (this.metadata = t4.metadata, this.minzoom = t4.minzoom, this.maxzoom = t4.maxzoom, "background" !== t4.type && (this.source = t4.source, this.sourceLayer = t4["source-layer"], this.filter = t4.filter), e4.layout && (this._unevaluatedLayout = new di(e4.layout)), e4.paint)) {
                this._transitionablePaint = new hi(e4.paint);
                for (const e5 in t4.paint)
                  this.setPaintProperty(e5, t4.paint[e5], { validate: false });
                for (const e5 in t4.layout)
                  this.setLayoutProperty(e5, t4.layout[e5], { validate: false });
                this._transitioningPaint = this._transitionablePaint.untransitioned(), this.paint = new mi(e4.paint);
              }
            }
            getCrossfadeParameters() {
              return this._crossfadeParameters;
            }
            getLayoutProperty(t4) {
              return "visibility" === t4 ? this.visibility : this._unevaluatedLayout.getValue(t4);
            }
            setLayoutProperty(t4, e4, r5 = {}) {
              null != e4 && this._validate(Vn, `layers.${this.id}.layout.${t4}`, t4, e4, r5) || ("visibility" !== t4 ? this._unevaluatedLayout.setValue(t4, e4) : this.visibility = e4);
            }
            getPaintProperty(t4) {
              return t4.endsWith(Ai) ? this._transitionablePaint.getTransition(t4.slice(0, -11)) : this._transitionablePaint.getValue(t4);
            }
            setPaintProperty(t4, e4, r5 = {}) {
              if (null != e4 && this._validate(Bn, `layers.${this.id}.paint.${t4}`, t4, e4, r5))
                return false;
              if (t4.endsWith(Ai))
                return this._transitionablePaint.setTransition(t4.slice(0, -11), e4 || void 0), false;
              {
                const r6 = this._transitionablePaint._values[t4], n3 = "cross-faded-data-driven" === r6.property.specification["property-type"], i5 = r6.value.isDataDriven(), a5 = r6.value;
                this._transitionablePaint.setValue(t4, e4), this._handleSpecialPaintPropertyUpdate(t4);
                const s5 = this._transitionablePaint._values[t4].value;
                return s5.isDataDriven() || i5 || n3 || this._handleOverridablePaintPropertyUpdate(t4, a5, s5);
              }
            }
            _handleSpecialPaintPropertyUpdate(t4) {
            }
            _handleOverridablePaintPropertyUpdate(t4, e4, r5) {
              return false;
            }
            isHidden(t4) {
              return !!(this.minzoom && t4 < this.minzoom) || !!(this.maxzoom && t4 >= this.maxzoom) || "none" === this.visibility;
            }
            updateTransitions(t4) {
              this._transitioningPaint = this._transitionablePaint.transitioned(t4, this._transitioningPaint);
            }
            hasTransition() {
              return this._transitioningPaint.hasTransition();
            }
            recalculate(t4, e4) {
              t4.getCrossfadeParameters && (this._crossfadeParameters = t4.getCrossfadeParameters()), this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t4, void 0, e4)), this.paint = this._transitioningPaint.possiblyEvaluate(t4, void 0, e4);
            }
            serialize() {
              const t4 = { id: this.id, type: this.type, source: this.source, "source-layer": this.sourceLayer, metadata: this.metadata, minzoom: this.minzoom, maxzoom: this.maxzoom, filter: this.filter, layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(), paint: this._transitionablePaint && this._transitionablePaint.serialize() };
              return this.visibility && (t4.layout = t4.layout || {}, t4.layout.visibility = this.visibility), v3(t4, (t5, e4) => !(void 0 === t5 || "layout" === e4 && !Object.keys(t5).length || "paint" === e4 && !Object.keys(t5).length));
            }
            _validate(t4, e4, r5, n3, i5 = {}) {
              return (!i5 || false !== i5.validate) && En(this, t4.call(Pn, { key: e4, layerType: this.type, objectKey: r5, value: n3, styleSpec: X, style: { glyphs: true, sprite: true } }));
            }
            is3D() {
              return false;
            }
            isTileClipped() {
              return false;
            }
            hasOffscreenPass() {
              return false;
            }
            resize() {
            }
            isStateDependent() {
              for (const t4 in this.paint._values) {
                const e4 = this.paint.get(t4);
                if (e4 instanceof yi && _r(e4.property.specification) && ("source" === e4.value.kind || "composite" === e4.value.kind) && e4.value.isStateDependent)
                  return true;
              }
              return false;
            }
          }
          const ki = { Int8: Int8Array, Uint8: Uint8Array, Int16: Int16Array, Uint16: Uint16Array, Int32: Int32Array, Uint32: Uint32Array, Float32: Float32Array };
          class Ii {
            constructor(t4, e4) {
              this._structArray = t4, this._pos1 = e4 * this.size, this._pos2 = this._pos1 / 2, this._pos4 = this._pos1 / 4, this._pos8 = this._pos1 / 8;
            }
          }
          class zi {
            constructor() {
              this.isTransferred = false, this.capacity = -1, this.resize(0);
            }
            static serialize(t4, e4) {
              return t4._trim(), e4 && (t4.isTransferred = true, e4.push(t4.arrayBuffer)), { length: t4.length, arrayBuffer: t4.arrayBuffer };
            }
            static deserialize(t4) {
              const e4 = Object.create(this.prototype);
              return e4.arrayBuffer = t4.arrayBuffer, e4.length = t4.length, e4.capacity = t4.arrayBuffer.byteLength / e4.bytesPerElement, e4._refreshViews(), e4;
            }
            _trim() {
              this.length !== this.capacity && (this.capacity = this.length, this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement), this._refreshViews());
            }
            clear() {
              this.length = 0;
            }
            resize(t4) {
              this.reserve(t4), this.length = t4;
            }
            reserve(t4) {
              if (t4 > this.capacity) {
                this.capacity = Math.max(t4, Math.floor(5 * this.capacity), 128), this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                const e4 = this.uint8;
                this._refreshViews(), e4 && this.uint8.set(e4);
              }
            }
            _refreshViews() {
              throw new Error("_refreshViews() must be implemented by each concrete StructArray layout");
            }
          }
          function Mi(t4, e4 = 1) {
            let r5 = 0, n3 = 0;
            return { members: t4.map((t5) => {
              const i5 = ki[t5.type].BYTES_PER_ELEMENT, a5 = r5 = Pi(r5, Math.max(e4, i5)), s5 = t5.components || 1;
              return n3 = Math.max(n3, i5), r5 += i5 * s5, { name: t5.name, type: t5.type, components: s5, offset: a5 };
            }), size: Pi(r5, Math.max(n3, e4)), alignment: e4 };
          }
          function Pi(t4, e4) {
            return Math.ceil(t4 / e4) * e4;
          }
          class Ci extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4) {
              const r5 = this.length;
              return this.resize(r5 + 1), this.emplace(r5, t4, e4);
            }
            emplace(t4, e4, r5) {
              const n3 = 2 * t4;
              return this.int16[n3 + 0] = e4, this.int16[n3 + 1] = r5, t4;
            }
          }
          Ci.prototype.bytesPerElement = 4, $n("StructArrayLayout2i4", Ci);
          class Bi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t4, e4, r5);
            }
            emplace(t4, e4, r5, n3) {
              const i5 = 3 * t4;
              return this.int16[i5 + 0] = e4, this.int16[i5 + 1] = r5, this.int16[i5 + 2] = n3, t4;
            }
          }
          Bi.prototype.bytesPerElement = 6, $n("StructArrayLayout3i6", Bi);
          class Vi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3) {
              const i5 = this.length;
              return this.resize(i5 + 1), this.emplace(i5, t4, e4, r5, n3);
            }
            emplace(t4, e4, r5, n3, i5) {
              const a5 = 4 * t4;
              return this.int16[a5 + 0] = e4, this.int16[a5 + 1] = r5, this.int16[a5 + 2] = n3, this.int16[a5 + 3] = i5, t4;
            }
          }
          Vi.prototype.bytesPerElement = 8, $n("StructArrayLayout4i8", Vi);
          class Ei extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5) {
              const s5 = this.length;
              return this.resize(s5 + 1), this.emplace(s5, t4, e4, r5, n3, i5, a5);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5) {
              const o5 = 6 * t4;
              return this.int16[o5 + 0] = e4, this.int16[o5 + 1] = r5, this.int16[o5 + 2] = n3, this.int16[o5 + 3] = i5, this.int16[o5 + 4] = a5, this.int16[o5 + 5] = s5, t4;
            }
          }
          Ei.prototype.bytesPerElement = 12, $n("StructArrayLayout2i4i12", Ei);
          class Fi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5) {
              const s5 = this.length;
              return this.resize(s5 + 1), this.emplace(s5, t4, e4, r5, n3, i5, a5);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5) {
              const o5 = 4 * t4, l5 = 8 * t4;
              return this.int16[o5 + 0] = e4, this.int16[o5 + 1] = r5, this.uint8[l5 + 4] = n3, this.uint8[l5 + 5] = i5, this.uint8[l5 + 6] = a5, this.uint8[l5 + 7] = s5, t4;
            }
          }
          Fi.prototype.bytesPerElement = 8, $n("StructArrayLayout2i4ub8", Fi);
          class Ti extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4) {
              const r5 = this.length;
              return this.resize(r5 + 1), this.emplace(r5, t4, e4);
            }
            emplace(t4, e4, r5) {
              const n3 = 2 * t4;
              return this.float32[n3 + 0] = e4, this.float32[n3 + 1] = r5, t4;
            }
          }
          Ti.prototype.bytesPerElement = 8, $n("StructArrayLayout2f8", Ti);
          class $i extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5) {
              const c5 = this.length;
              return this.resize(c5 + 1), this.emplace(c5, t4, e4, r5, n3, i5, a5, s5, o5, l5, u5);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5) {
              const h4 = 10 * t4;
              return this.uint16[h4 + 0] = e4, this.uint16[h4 + 1] = r5, this.uint16[h4 + 2] = n3, this.uint16[h4 + 3] = i5, this.uint16[h4 + 4] = a5, this.uint16[h4 + 5] = s5, this.uint16[h4 + 6] = o5, this.uint16[h4 + 7] = l5, this.uint16[h4 + 8] = u5, this.uint16[h4 + 9] = c5, t4;
            }
          }
          $i.prototype.bytesPerElement = 20, $n("StructArrayLayout10ui20", $i);
          class Li extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4) {
              const p7 = this.length;
              return this.resize(p7 + 1), this.emplace(p7, t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7) {
              const f4 = 12 * t4;
              return this.int16[f4 + 0] = e4, this.int16[f4 + 1] = r5, this.int16[f4 + 2] = n3, this.int16[f4 + 3] = i5, this.uint16[f4 + 4] = a5, this.uint16[f4 + 5] = s5, this.uint16[f4 + 6] = o5, this.uint16[f4 + 7] = l5, this.int16[f4 + 8] = u5, this.int16[f4 + 9] = c5, this.int16[f4 + 10] = h4, this.int16[f4 + 11] = p7, t4;
            }
          }
          Li.prototype.bytesPerElement = 24, $n("StructArrayLayout4i4ui4i24", Li);
          class Di extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t4, e4, r5);
            }
            emplace(t4, e4, r5, n3) {
              const i5 = 3 * t4;
              return this.float32[i5 + 0] = e4, this.float32[i5 + 1] = r5, this.float32[i5 + 2] = n3, t4;
            }
          }
          Di.prototype.bytesPerElement = 12, $n("StructArrayLayout3f12", Di);
          class Oi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer);
            }
            emplaceBack(t4) {
              const e4 = this.length;
              return this.resize(e4 + 1), this.emplace(e4, t4);
            }
            emplace(t4, e4) {
              return this.uint32[1 * t4 + 0] = e4, t4;
            }
          }
          Oi.prototype.bytesPerElement = 4, $n("StructArrayLayout1ul4", Oi);
          class Ui extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5, s5, o5, l5) {
              const u5 = this.length;
              return this.resize(u5 + 1), this.emplace(u5, t4, e4, r5, n3, i5, a5, s5, o5, l5);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5) {
              const c5 = 10 * t4, h4 = 5 * t4;
              return this.int16[c5 + 0] = e4, this.int16[c5 + 1] = r5, this.int16[c5 + 2] = n3, this.int16[c5 + 3] = i5, this.int16[c5 + 4] = a5, this.int16[c5 + 5] = s5, this.uint32[h4 + 3] = o5, this.uint16[c5 + 8] = l5, this.uint16[c5 + 9] = u5, t4;
            }
          }
          Ui.prototype.bytesPerElement = 20, $n("StructArrayLayout6i1ul2ui20", Ui);
          class Ri extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5) {
              const s5 = this.length;
              return this.resize(s5 + 1), this.emplace(s5, t4, e4, r5, n3, i5, a5);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5) {
              const o5 = 6 * t4;
              return this.int16[o5 + 0] = e4, this.int16[o5 + 1] = r5, this.int16[o5 + 2] = n3, this.int16[o5 + 3] = i5, this.int16[o5 + 4] = a5, this.int16[o5 + 5] = s5, t4;
            }
          }
          Ri.prototype.bytesPerElement = 12, $n("StructArrayLayout2i2i2i12", Ri);
          class qi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5) {
              const a5 = this.length;
              return this.resize(a5 + 1), this.emplace(a5, t4, e4, r5, n3, i5);
            }
            emplace(t4, e4, r5, n3, i5, a5) {
              const s5 = 4 * t4, o5 = 8 * t4;
              return this.float32[s5 + 0] = e4, this.float32[s5 + 1] = r5, this.float32[s5 + 2] = n3, this.int16[o5 + 6] = i5, this.int16[o5 + 7] = a5, t4;
            }
          }
          qi.prototype.bytesPerElement = 16, $n("StructArrayLayout2f1f2i16", qi);
          class ji extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3) {
              const i5 = this.length;
              return this.resize(i5 + 1), this.emplace(i5, t4, e4, r5, n3);
            }
            emplace(t4, e4, r5, n3, i5) {
              const a5 = 12 * t4, s5 = 3 * t4;
              return this.uint8[a5 + 0] = e4, this.uint8[a5 + 1] = r5, this.float32[s5 + 1] = n3, this.float32[s5 + 2] = i5, t4;
            }
          }
          ji.prototype.bytesPerElement = 12, $n("StructArrayLayout2ub2f12", ji);
          class Ni extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t4, e4, r5);
            }
            emplace(t4, e4, r5, n3) {
              const i5 = 3 * t4;
              return this.uint16[i5 + 0] = e4, this.uint16[i5 + 1] = r5, this.uint16[i5 + 2] = n3, t4;
            }
          }
          Ni.prototype.bytesPerElement = 6, $n("StructArrayLayout3ui6", Ni);
          class Zi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4) {
              const g4 = this.length;
              return this.resize(g4 + 1), this.emplace(g4, t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4, g4) {
              const x3 = 24 * t4, v5 = 12 * t4, b4 = 48 * t4;
              return this.int16[x3 + 0] = e4, this.int16[x3 + 1] = r5, this.uint16[x3 + 2] = n3, this.uint16[x3 + 3] = i5, this.uint32[v5 + 2] = a5, this.uint32[v5 + 3] = s5, this.uint32[v5 + 4] = o5, this.uint16[x3 + 10] = l5, this.uint16[x3 + 11] = u5, this.uint16[x3 + 12] = c5, this.float32[v5 + 7] = h4, this.float32[v5 + 8] = p7, this.uint8[b4 + 36] = f4, this.uint8[b4 + 37] = d4, this.uint8[b4 + 38] = y3, this.uint32[v5 + 10] = m4, this.int16[x3 + 22] = g4, t4;
            }
          }
          Zi.prototype.bytesPerElement = 48, $n("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Zi);
          class Ki extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.int16 = new Int16Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4, g4, x3, v5, b4, w4, _4, A3, S3, k4, I3, z4) {
              const M3 = this.length;
              return this.resize(M3 + 1), this.emplace(M3, t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4, g4, x3, v5, b4, w4, _4, A3, S3, k4, I3, z4);
            }
            emplace(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4, g4, x3, v5, b4, w4, _4, A3, S3, k4, I3, z4, M3) {
              const P3 = 32 * t4, C2 = 16 * t4;
              return this.int16[P3 + 0] = e4, this.int16[P3 + 1] = r5, this.int16[P3 + 2] = n3, this.int16[P3 + 3] = i5, this.int16[P3 + 4] = a5, this.int16[P3 + 5] = s5, this.int16[P3 + 6] = o5, this.int16[P3 + 7] = l5, this.uint16[P3 + 8] = u5, this.uint16[P3 + 9] = c5, this.uint16[P3 + 10] = h4, this.uint16[P3 + 11] = p7, this.uint16[P3 + 12] = f4, this.uint16[P3 + 13] = d4, this.uint16[P3 + 14] = y3, this.uint16[P3 + 15] = m4, this.uint16[P3 + 16] = g4, this.uint16[P3 + 17] = x3, this.uint16[P3 + 18] = v5, this.uint16[P3 + 19] = b4, this.uint16[P3 + 20] = w4, this.uint16[P3 + 21] = _4, this.uint16[P3 + 22] = A3, this.uint32[C2 + 12] = S3, this.float32[C2 + 13] = k4, this.float32[C2 + 14] = I3, this.uint16[P3 + 30] = z4, this.uint16[P3 + 31] = M3, t4;
            }
          }
          Ki.prototype.bytesPerElement = 64, $n("StructArrayLayout8i15ui1ul2f2ui64", Ki);
          class Gi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4) {
              const e4 = this.length;
              return this.resize(e4 + 1), this.emplace(e4, t4);
            }
            emplace(t4, e4) {
              return this.float32[1 * t4 + 0] = e4, t4;
            }
          }
          Gi.prototype.bytesPerElement = 4, $n("StructArrayLayout1f4", Gi);
          class Ji extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t4, e4, r5);
            }
            emplace(t4, e4, r5, n3) {
              const i5 = 3 * t4;
              return this.uint16[6 * t4 + 0] = e4, this.float32[i5 + 1] = r5, this.float32[i5 + 2] = n3, t4;
            }
          }
          Ji.prototype.bytesPerElement = 12, $n("StructArrayLayout1ui2f12", Ji);
          class Xi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint32 = new Uint32Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5) {
              const n3 = this.length;
              return this.resize(n3 + 1), this.emplace(n3, t4, e4, r5);
            }
            emplace(t4, e4, r5, n3) {
              const i5 = 4 * t4;
              return this.uint32[2 * t4 + 0] = e4, this.uint16[i5 + 2] = r5, this.uint16[i5 + 3] = n3, t4;
            }
          }
          Xi.prototype.bytesPerElement = 8, $n("StructArrayLayout1ul2ui8", Xi);
          class Yi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4) {
              const r5 = this.length;
              return this.resize(r5 + 1), this.emplace(r5, t4, e4);
            }
            emplace(t4, e4, r5) {
              const n3 = 2 * t4;
              return this.uint16[n3 + 0] = e4, this.uint16[n3 + 1] = r5, t4;
            }
          }
          Yi.prototype.bytesPerElement = 4, $n("StructArrayLayout2ui4", Yi);
          class Hi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.uint16 = new Uint16Array(this.arrayBuffer);
            }
            emplaceBack(t4) {
              const e4 = this.length;
              return this.resize(e4 + 1), this.emplace(e4, t4);
            }
            emplace(t4, e4) {
              return this.uint16[1 * t4 + 0] = e4, t4;
            }
          }
          Hi.prototype.bytesPerElement = 2, $n("StructArrayLayout1ui2", Hi);
          class Wi extends zi {
            _refreshViews() {
              this.uint8 = new Uint8Array(this.arrayBuffer), this.float32 = new Float32Array(this.arrayBuffer);
            }
            emplaceBack(t4, e4, r5, n3) {
              const i5 = this.length;
              return this.resize(i5 + 1), this.emplace(i5, t4, e4, r5, n3);
            }
            emplace(t4, e4, r5, n3, i5) {
              const a5 = 4 * t4;
              return this.float32[a5 + 0] = e4, this.float32[a5 + 1] = r5, this.float32[a5 + 2] = n3, this.float32[a5 + 3] = i5, t4;
            }
          }
          Wi.prototype.bytesPerElement = 16, $n("StructArrayLayout4f16", Wi);
          class Qi extends Ii {
            get anchorPointX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorPointY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get x1() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get y1() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get x2() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get y2() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get anchorPoint() {
              return new i4(this.anchorPointX, this.anchorPointY);
            }
          }
          Qi.prototype.size = 20;
          class ta extends Ui {
            get(t4) {
              return new Qi(this, t4);
            }
          }
          $n("CollisionBoxArray", ta);
          class ea extends Ii {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get glyphStartIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get numGlyphs() {
              return this._structArray.uint16[this._pos2 + 3];
            }
            get vertexStartIndex() {
              return this._structArray.uint32[this._pos4 + 2];
            }
            get lineStartIndex() {
              return this._structArray.uint32[this._pos4 + 3];
            }
            get lineLength() {
              return this._structArray.uint32[this._pos4 + 4];
            }
            get segment() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get lowerSize() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get upperSize() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get lineOffsetX() {
              return this._structArray.float32[this._pos4 + 7];
            }
            get lineOffsetY() {
              return this._structArray.float32[this._pos4 + 8];
            }
            get writingMode() {
              return this._structArray.uint8[this._pos1 + 36];
            }
            get placedOrientation() {
              return this._structArray.uint8[this._pos1 + 37];
            }
            set placedOrientation(t4) {
              this._structArray.uint8[this._pos1 + 37] = t4;
            }
            get hidden() {
              return this._structArray.uint8[this._pos1 + 38];
            }
            set hidden(t4) {
              this._structArray.uint8[this._pos1 + 38] = t4;
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 10];
            }
            set crossTileID(t4) {
              this._structArray.uint32[this._pos4 + 10] = t4;
            }
            get associatedIconIndex() {
              return this._structArray.int16[this._pos2 + 22];
            }
          }
          ea.prototype.size = 48;
          class ra extends Zi {
            get(t4) {
              return new ea(this, t4);
            }
          }
          $n("PlacedSymbolArray", ra);
          class na extends Ii {
            get anchorX() {
              return this._structArray.int16[this._pos2 + 0];
            }
            get anchorY() {
              return this._structArray.int16[this._pos2 + 1];
            }
            get rightJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 2];
            }
            get centerJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 3];
            }
            get leftJustifiedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 4];
            }
            get verticalPlacedTextSymbolIndex() {
              return this._structArray.int16[this._pos2 + 5];
            }
            get placedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 6];
            }
            get verticalPlacedIconSymbolIndex() {
              return this._structArray.int16[this._pos2 + 7];
            }
            get key() {
              return this._structArray.uint16[this._pos2 + 8];
            }
            get textBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 9];
            }
            get textBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 10];
            }
            get verticalTextBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 11];
            }
            get verticalTextBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 12];
            }
            get iconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 13];
            }
            get iconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 14];
            }
            get verticalIconBoxStartIndex() {
              return this._structArray.uint16[this._pos2 + 15];
            }
            get verticalIconBoxEndIndex() {
              return this._structArray.uint16[this._pos2 + 16];
            }
            get featureIndex() {
              return this._structArray.uint16[this._pos2 + 17];
            }
            get numHorizontalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 18];
            }
            get numVerticalGlyphVertices() {
              return this._structArray.uint16[this._pos2 + 19];
            }
            get numIconVertices() {
              return this._structArray.uint16[this._pos2 + 20];
            }
            get numVerticalIconVertices() {
              return this._structArray.uint16[this._pos2 + 21];
            }
            get useRuntimeCollisionCircles() {
              return this._structArray.uint16[this._pos2 + 22];
            }
            get crossTileID() {
              return this._structArray.uint32[this._pos4 + 12];
            }
            set crossTileID(t4) {
              this._structArray.uint32[this._pos4 + 12] = t4;
            }
            get textBoxScale() {
              return this._structArray.float32[this._pos4 + 13];
            }
            get collisionCircleDiameter() {
              return this._structArray.float32[this._pos4 + 14];
            }
            get textAnchorOffsetStartIndex() {
              return this._structArray.uint16[this._pos2 + 30];
            }
            get textAnchorOffsetEndIndex() {
              return this._structArray.uint16[this._pos2 + 31];
            }
          }
          na.prototype.size = 64;
          class ia extends Ki {
            get(t4) {
              return new na(this, t4);
            }
          }
          $n("SymbolInstanceArray", ia);
          class aa extends Gi {
            getoffsetX(t4) {
              return this.float32[1 * t4 + 0];
            }
          }
          $n("GlyphOffsetArray", aa);
          class sa extends Bi {
            getx(t4) {
              return this.int16[3 * t4 + 0];
            }
            gety(t4) {
              return this.int16[3 * t4 + 1];
            }
            gettileUnitDistanceFromAnchor(t4) {
              return this.int16[3 * t4 + 2];
            }
          }
          $n("SymbolLineVertexArray", sa);
          class oa extends Ii {
            get textAnchor() {
              return this._structArray.uint16[this._pos2 + 0];
            }
            get textOffset0() {
              return this._structArray.float32[this._pos4 + 1];
            }
            get textOffset1() {
              return this._structArray.float32[this._pos4 + 2];
            }
          }
          oa.prototype.size = 12;
          class la extends Ji {
            get(t4) {
              return new oa(this, t4);
            }
          }
          $n("TextAnchorOffsetArray", la);
          class ua2 extends Ii {
            get featureIndex() {
              return this._structArray.uint32[this._pos4 + 0];
            }
            get sourceLayerIndex() {
              return this._structArray.uint16[this._pos2 + 2];
            }
            get bucketIndex() {
              return this._structArray.uint16[this._pos2 + 3];
            }
          }
          ua2.prototype.size = 8;
          class ca extends Xi {
            get(t4) {
              return new ua2(this, t4);
            }
          }
          $n("FeatureIndexArray", ca);
          class ha extends Ci {
          }
          class pa extends Ci {
          }
          class fa extends Ci {
          }
          class da extends Ei {
          }
          class ya extends Fi {
          }
          class ma extends Ti {
          }
          class ga extends $i {
          }
          class xa extends Li {
          }
          class va extends Di {
          }
          class ba extends Oi {
          }
          class wa extends Ri {
          }
          class _a extends ji {
          }
          class Aa extends Ni {
          }
          class Sa extends Yi {
          }
          const ka = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Ia } = ka;
          class za {
            constructor(t4 = []) {
              this.segments = t4;
            }
            prepareSegment(t4, e4, r5, n3) {
              let i5 = this.segments[this.segments.length - 1];
              return t4 > za.MAX_VERTEX_ARRAY_LENGTH && _3(`Max vertices per segment is ${za.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t4}`), (!i5 || i5.vertexLength + t4 > za.MAX_VERTEX_ARRAY_LENGTH || i5.sortKey !== n3) && (i5 = { vertexOffset: e4.length, primitiveOffset: r5.length, vertexLength: 0, primitiveLength: 0 }, void 0 !== n3 && (i5.sortKey = n3), this.segments.push(i5)), i5;
            }
            get() {
              return this.segments;
            }
            destroy() {
              for (const t4 of this.segments)
                for (const e4 in t4.vaos)
                  t4.vaos[e4].destroy();
            }
            static simpleSegment(t4, e4, r5, n3) {
              return new za([{ vertexOffset: t4, primitiveOffset: e4, vertexLength: r5, primitiveLength: n3, vaos: {}, sortKey: 0 }]);
            }
          }
          function Ma(t4, e4) {
            return 256 * (t4 = d3(Math.floor(t4), 0, 255)) + d3(Math.floor(e4), 0, 255);
          }
          za.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1, $n("SegmentVector", za);
          const Pa = Mi([{ name: "a_pattern_from", components: 4, type: "Uint16" }, { name: "a_pattern_to", components: 4, type: "Uint16" }, { name: "a_pixel_ratio_from", components: 1, type: "Uint16" }, { name: "a_pixel_ratio_to", components: 1, type: "Uint16" }]);
          var Ca = { exports: {} }, Ba = { exports: {} };
          Ba.exports = function(t4, e4) {
            var r5, n3, i5, a5, s5, o5, l5, u5;
            for (n3 = t4.length - (r5 = 3 & t4.length), i5 = e4, s5 = 3432918353, o5 = 461845907, u5 = 0; u5 < n3; )
              l5 = 255 & t4.charCodeAt(u5) | (255 & t4.charCodeAt(++u5)) << 8 | (255 & t4.charCodeAt(++u5)) << 16 | (255 & t4.charCodeAt(++u5)) << 24, ++u5, i5 = 27492 + (65535 & (a5 = 5 * (65535 & (i5 = (i5 ^= l5 = (65535 & (l5 = (l5 = (65535 & l5) * s5 + (((l5 >>> 16) * s5 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o5 + (((l5 >>> 16) * o5 & 65535) << 16) & 4294967295) << 13 | i5 >>> 19)) + ((5 * (i5 >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (a5 >>> 16) & 65535) << 16);
            switch (l5 = 0, r5) {
              case 3:
                l5 ^= (255 & t4.charCodeAt(u5 + 2)) << 16;
              case 2:
                l5 ^= (255 & t4.charCodeAt(u5 + 1)) << 8;
              case 1:
                i5 ^= l5 = (65535 & (l5 = (l5 = (65535 & (l5 ^= 255 & t4.charCodeAt(u5))) * s5 + (((l5 >>> 16) * s5 & 65535) << 16) & 4294967295) << 15 | l5 >>> 17)) * o5 + (((l5 >>> 16) * o5 & 65535) << 16) & 4294967295;
            }
            return i5 ^= t4.length, i5 = 2246822507 * (65535 & (i5 ^= i5 >>> 16)) + ((2246822507 * (i5 >>> 16) & 65535) << 16) & 4294967295, i5 = 3266489909 * (65535 & (i5 ^= i5 >>> 13)) + ((3266489909 * (i5 >>> 16) & 65535) << 16) & 4294967295, (i5 ^= i5 >>> 16) >>> 0;
          };
          var Va = Ba.exports, Ea = { exports: {} };
          Ea.exports = function(t4, e4) {
            for (var r5, n3 = t4.length, i5 = e4 ^ n3, a5 = 0; n3 >= 4; )
              r5 = 1540483477 * (65535 & (r5 = 255 & t4.charCodeAt(a5) | (255 & t4.charCodeAt(++a5)) << 8 | (255 & t4.charCodeAt(++a5)) << 16 | (255 & t4.charCodeAt(++a5)) << 24)) + ((1540483477 * (r5 >>> 16) & 65535) << 16), i5 = 1540483477 * (65535 & i5) + ((1540483477 * (i5 >>> 16) & 65535) << 16) ^ (r5 = 1540483477 * (65535 & (r5 ^= r5 >>> 24)) + ((1540483477 * (r5 >>> 16) & 65535) << 16)), n3 -= 4, ++a5;
            switch (n3) {
              case 3:
                i5 ^= (255 & t4.charCodeAt(a5 + 2)) << 16;
              case 2:
                i5 ^= (255 & t4.charCodeAt(a5 + 1)) << 8;
              case 1:
                i5 = 1540483477 * (65535 & (i5 ^= 255 & t4.charCodeAt(a5))) + ((1540483477 * (i5 >>> 16) & 65535) << 16);
            }
            return i5 = 1540483477 * (65535 & (i5 ^= i5 >>> 13)) + ((1540483477 * (i5 >>> 16) & 65535) << 16), (i5 ^= i5 >>> 15) >>> 0;
          };
          var Fa = Va, Ta = Ea.exports;
          Ca.exports = Fa, Ca.exports.murmur3 = Fa, Ca.exports.murmur2 = Ta;
          var $a = e3(Ca.exports);
          class La {
            constructor() {
              this.ids = [], this.positions = [], this.indexed = false;
            }
            add(t4, e4, r5, n3) {
              this.ids.push(Da(t4)), this.positions.push(e4, r5, n3);
            }
            getPositions(t4) {
              if (!this.indexed)
                throw new Error("Trying to get index, but feature positions are not indexed");
              const e4 = Da(t4);
              let r5 = 0, n3 = this.ids.length - 1;
              for (; r5 < n3; ) {
                const t5 = r5 + n3 >> 1;
                this.ids[t5] >= e4 ? n3 = t5 : r5 = t5 + 1;
              }
              const i5 = [];
              for (; this.ids[r5] === e4; )
                i5.push({ index: this.positions[3 * r5], start: this.positions[3 * r5 + 1], end: this.positions[3 * r5 + 2] }), r5++;
              return i5;
            }
            static serialize(t4, e4) {
              const r5 = new Float64Array(t4.ids), n3 = new Uint32Array(t4.positions);
              return Oa(r5, n3, 0, r5.length - 1), e4 && e4.push(r5.buffer, n3.buffer), { ids: r5, positions: n3 };
            }
            static deserialize(t4) {
              const e4 = new La();
              return e4.ids = t4.ids, e4.positions = t4.positions, e4.indexed = true, e4;
            }
          }
          function Da(t4) {
            const e4 = +t4;
            return !isNaN(e4) && e4 <= Number.MAX_SAFE_INTEGER ? e4 : $a(String(t4));
          }
          function Oa(t4, e4, r5, n3) {
            for (; r5 < n3; ) {
              const i5 = t4[r5 + n3 >> 1];
              let a5 = r5 - 1, s5 = n3 + 1;
              for (; ; ) {
                do {
                  a5++;
                } while (t4[a5] < i5);
                do {
                  s5--;
                } while (t4[s5] > i5);
                if (a5 >= s5)
                  break;
                Ua(t4, a5, s5), Ua(e4, 3 * a5, 3 * s5), Ua(e4, 3 * a5 + 1, 3 * s5 + 1), Ua(e4, 3 * a5 + 2, 3 * s5 + 2);
              }
              s5 - r5 < n3 - s5 ? (Oa(t4, e4, r5, s5), r5 = s5 + 1) : (Oa(t4, e4, s5 + 1, n3), n3 = s5);
            }
          }
          function Ua(t4, e4, r5) {
            const n3 = t4[e4];
            t4[e4] = t4[r5], t4[r5] = n3;
          }
          $n("FeaturePositionMap", La);
          class Ra {
            constructor(t4, e4) {
              this.gl = t4.gl, this.location = e4;
            }
          }
          class qa extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = 0;
            }
            set(t4) {
              this.current !== t4 && (this.current = t4, this.gl.uniform1f(this.location, t4));
            }
          }
          class ja extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = [0, 0, 0, 0];
            }
            set(t4) {
              t4[0] === this.current[0] && t4[1] === this.current[1] && t4[2] === this.current[2] && t4[3] === this.current[3] || (this.current = t4, this.gl.uniform4f(this.location, t4[0], t4[1], t4[2], t4[3]));
            }
          }
          class Na extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = Yt.transparent;
            }
            set(t4) {
              t4.r === this.current.r && t4.g === this.current.g && t4.b === this.current.b && t4.a === this.current.a || (this.current = t4, this.gl.uniform4f(this.location, t4.r, t4.g, t4.b, t4.a));
            }
          }
          const Za = new Float32Array(16);
          function Ka(t4) {
            return [Ma(255 * t4.r, 255 * t4.g), Ma(255 * t4.b, 255 * t4.a)];
          }
          class Ga {
            constructor(t4, e4, r5) {
              this.value = t4, this.uniformNames = e4.map((t5) => `u_${t5}`), this.type = r5;
            }
            setUniform(t4, e4, r5) {
              t4.set(r5.constantOr(this.value));
            }
            getBinding(t4, e4, r5) {
              return "color" === this.type ? new Na(t4, e4) : new qa(t4, e4);
            }
          }
          class Ja {
            constructor(t4, e4) {
              this.uniformNames = e4.map((t5) => `u_${t5}`), this.patternFrom = null, this.patternTo = null, this.pixelRatioFrom = 1, this.pixelRatioTo = 1;
            }
            setConstantPatternPositions(t4, e4) {
              this.pixelRatioFrom = e4.pixelRatio, this.pixelRatioTo = t4.pixelRatio, this.patternFrom = e4.tlbr, this.patternTo = t4.tlbr;
            }
            setUniform(t4, e4, r5, n3) {
              const i5 = "u_pattern_to" === n3 ? this.patternTo : "u_pattern_from" === n3 ? this.patternFrom : "u_pixel_ratio_to" === n3 ? this.pixelRatioTo : "u_pixel_ratio_from" === n3 ? this.pixelRatioFrom : null;
              i5 && t4.set(i5);
            }
            getBinding(t4, e4, r5) {
              return "u_pattern" === r5.substr(0, 9) ? new ja(t4, e4) : new qa(t4, e4);
            }
          }
          class Xa {
            constructor(t4, e4, r5, n3) {
              this.expression = t4, this.type = r5, this.maxValue = 0, this.paintVertexAttributes = e4.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r5 ? 2 : 1, offset: 0 })), this.paintVertexArray = new n3();
            }
            populatePaintArray(t4, e4, r5, n3, i5) {
              const a5 = this.paintVertexArray.length, s5 = this.expression.evaluate(new li(0), e4, {}, n3, [], i5);
              this.paintVertexArray.resize(t4), this._setPaintValue(a5, t4, s5);
            }
            updatePaintArray(t4, e4, r5, n3) {
              const i5 = this.expression.evaluate({ zoom: 0 }, r5, n3);
              this._setPaintValue(t4, e4, i5);
            }
            _setPaintValue(t4, e4, r5) {
              if ("color" === this.type) {
                const n3 = Ka(r5);
                for (let r6 = t4; r6 < e4; r6++)
                  this.paintVertexArray.emplace(r6, n3[0], n3[1]);
              } else {
                for (let n3 = t4; n3 < e4; n3++)
                  this.paintVertexArray.emplace(n3, r5);
                this.maxValue = Math.max(this.maxValue, Math.abs(r5));
              }
            }
            upload(t4) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
          }
          class Ya {
            constructor(t4, e4, r5, n3, i5, a5) {
              this.expression = t4, this.uniformNames = e4.map((t5) => `u_${t5}_t`), this.type = r5, this.useIntegerZoom = n3, this.zoom = i5, this.maxValue = 0, this.paintVertexAttributes = e4.map((t5) => ({ name: `a_${t5}`, type: "Float32", components: "color" === r5 ? 4 : 2, offset: 0 })), this.paintVertexArray = new a5();
            }
            populatePaintArray(t4, e4, r5, n3, i5) {
              const a5 = this.expression.evaluate(new li(this.zoom), e4, {}, n3, [], i5), s5 = this.expression.evaluate(new li(this.zoom + 1), e4, {}, n3, [], i5), o5 = this.paintVertexArray.length;
              this.paintVertexArray.resize(t4), this._setPaintValue(o5, t4, a5, s5);
            }
            updatePaintArray(t4, e4, r5, n3) {
              const i5 = this.expression.evaluate({ zoom: this.zoom }, r5, n3), a5 = this.expression.evaluate({ zoom: this.zoom + 1 }, r5, n3);
              this._setPaintValue(t4, e4, i5, a5);
            }
            _setPaintValue(t4, e4, r5, n3) {
              if ("color" === this.type) {
                const i5 = Ka(r5), a5 = Ka(n3);
                for (let r6 = t4; r6 < e4; r6++)
                  this.paintVertexArray.emplace(r6, i5[0], i5[1], a5[0], a5[1]);
              } else {
                for (let i5 = t4; i5 < e4; i5++)
                  this.paintVertexArray.emplace(i5, r5, n3);
                this.maxValue = Math.max(this.maxValue, Math.abs(r5), Math.abs(n3));
              }
            }
            upload(t4) {
              this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t4.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent));
            }
            destroy() {
              this.paintVertexBuffer && this.paintVertexBuffer.destroy();
            }
            setUniform(t4, e4) {
              const r5 = this.useIntegerZoom ? Math.floor(e4.zoom) : e4.zoom, n3 = d3(this.expression.interpolationFactor(r5, this.zoom, this.zoom + 1), 0, 1);
              t4.set(n3);
            }
            getBinding(t4, e4, r5) {
              return new qa(t4, e4);
            }
          }
          class Ha {
            constructor(t4, e4, r5, n3, i5, a5) {
              this.expression = t4, this.type = e4, this.useIntegerZoom = r5, this.zoom = n3, this.layerId = a5, this.zoomInPaintVertexArray = new i5(), this.zoomOutPaintVertexArray = new i5();
            }
            populatePaintArray(t4, e4, r5) {
              const n3 = this.zoomInPaintVertexArray.length;
              this.zoomInPaintVertexArray.resize(t4), this.zoomOutPaintVertexArray.resize(t4), this._setPaintValues(n3, t4, e4.patterns && e4.patterns[this.layerId], r5);
            }
            updatePaintArray(t4, e4, r5, n3, i5) {
              this._setPaintValues(t4, e4, r5.patterns && r5.patterns[this.layerId], i5);
            }
            _setPaintValues(t4, e4, r5, n3) {
              if (!n3 || !r5)
                return;
              const { min: i5, mid: a5, max: s5 } = r5, o5 = n3[i5], l5 = n3[a5], u5 = n3[s5];
              if (o5 && l5 && u5)
                for (let r6 = t4; r6 < e4; r6++)
                  this.zoomInPaintVertexArray.emplace(r6, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], o5.tl[0], o5.tl[1], o5.br[0], o5.br[1], l5.pixelRatio, o5.pixelRatio), this.zoomOutPaintVertexArray.emplace(r6, l5.tl[0], l5.tl[1], l5.br[0], l5.br[1], u5.tl[0], u5.tl[1], u5.br[0], u5.br[1], l5.pixelRatio, u5.pixelRatio);
            }
            upload(t4) {
              this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t4.createVertexBuffer(this.zoomInPaintVertexArray, Pa.members, this.expression.isStateDependent), this.zoomOutPaintVertexBuffer = t4.createVertexBuffer(this.zoomOutPaintVertexArray, Pa.members, this.expression.isStateDependent));
            }
            destroy() {
              this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(), this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy();
            }
          }
          class Wa {
            constructor(t4, e4, r5) {
              this.binders = {}, this._buffers = [];
              const n3 = [];
              for (const i5 in t4.paint._values) {
                if (!r5(i5))
                  continue;
                const a5 = t4.paint.get(i5);
                if (!(a5 instanceof yi && _r(a5.property.specification)))
                  continue;
                const s5 = ts(i5, t4.type), o5 = a5.value, l5 = a5.property.specification.type, u5 = a5.property.useIntegerZoom, c5 = a5.property.specification["property-type"], h4 = "cross-faded" === c5 || "cross-faded-data-driven" === c5;
                if ("constant" === o5.kind)
                  this.binders[i5] = h4 ? new Ja(o5.value, s5) : new Ga(o5.value, s5, l5), n3.push(`/u_${i5}`);
                else if ("source" === o5.kind || h4) {
                  const r6 = es(i5, l5, "source");
                  this.binders[i5] = h4 ? new Ha(o5, l5, u5, e4, r6, t4.id) : new Xa(o5, s5, l5, r6), n3.push(`/a_${i5}`);
                } else {
                  const t5 = es(i5, l5, "composite");
                  this.binders[i5] = new Ya(o5, s5, l5, u5, e4, t5), n3.push(`/z_${i5}`);
                }
              }
              this.cacheKey = n3.sort().join("");
            }
            getMaxValue(t4) {
              const e4 = this.binders[t4];
              return e4 instanceof Xa || e4 instanceof Ya ? e4.maxValue : 0;
            }
            populatePaintArrays(t4, e4, r5, n3, i5) {
              for (const a5 in this.binders) {
                const s5 = this.binders[a5];
                (s5 instanceof Xa || s5 instanceof Ya || s5 instanceof Ha) && s5.populatePaintArray(t4, e4, r5, n3, i5);
              }
            }
            setConstantPatternPositions(t4, e4) {
              for (const r5 in this.binders) {
                const n3 = this.binders[r5];
                n3 instanceof Ja && n3.setConstantPatternPositions(t4, e4);
              }
            }
            updatePaintArrays(t4, e4, r5, n3, i5) {
              let a5 = false;
              for (const s5 in t4) {
                const o5 = e4.getPositions(s5);
                for (const e5 of o5) {
                  const o6 = r5.feature(e5.index);
                  for (const r6 in this.binders) {
                    const l5 = this.binders[r6];
                    if ((l5 instanceof Xa || l5 instanceof Ya || l5 instanceof Ha) && true === l5.expression.isStateDependent) {
                      const u5 = n3.paint.get(r6);
                      l5.expression = u5.value, l5.updatePaintArray(e5.start, e5.end, o6, t4[s5], i5), a5 = true;
                    }
                  }
                }
              }
              return a5;
            }
            defines() {
              const t4 = [];
              for (const e4 in this.binders) {
                const r5 = this.binders[e4];
                (r5 instanceof Ga || r5 instanceof Ja) && t4.push(...r5.uniformNames.map((t5) => `#define HAS_UNIFORM_${t5}`));
              }
              return t4;
            }
            getBinderAttributes() {
              const t4 = [];
              for (const e4 in this.binders) {
                const r5 = this.binders[e4];
                if (r5 instanceof Xa || r5 instanceof Ya)
                  for (let e5 = 0; e5 < r5.paintVertexAttributes.length; e5++)
                    t4.push(r5.paintVertexAttributes[e5].name);
                else if (r5 instanceof Ha)
                  for (let e5 = 0; e5 < Pa.members.length; e5++)
                    t4.push(Pa.members[e5].name);
              }
              return t4;
            }
            getBinderUniforms() {
              const t4 = [];
              for (const e4 in this.binders) {
                const r5 = this.binders[e4];
                if (r5 instanceof Ga || r5 instanceof Ja || r5 instanceof Ya)
                  for (const e5 of r5.uniformNames)
                    t4.push(e5);
              }
              return t4;
            }
            getPaintVertexBuffers() {
              return this._buffers;
            }
            getUniforms(t4, e4) {
              const r5 = [];
              for (const n3 in this.binders) {
                const i5 = this.binders[n3];
                if (i5 instanceof Ga || i5 instanceof Ja || i5 instanceof Ya) {
                  for (const a5 of i5.uniformNames)
                    if (e4[a5]) {
                      const s5 = i5.getBinding(t4, e4[a5], a5);
                      r5.push({ name: a5, property: n3, binding: s5 });
                    }
                }
              }
              return r5;
            }
            setUniforms(t4, e4, r5, n3) {
              for (const { name: t5, property: i5, binding: a5 } of e4)
                this.binders[i5].setUniform(a5, n3, r5.get(i5), t5);
            }
            updatePaintBuffers(t4) {
              this._buffers = [];
              for (const e4 in this.binders) {
                const r5 = this.binders[e4];
                if (t4 && r5 instanceof Ha) {
                  const e5 = 2 === t4.fromScale ? r5.zoomInPaintVertexBuffer : r5.zoomOutPaintVertexBuffer;
                  e5 && this._buffers.push(e5);
                } else
                  (r5 instanceof Xa || r5 instanceof Ya) && r5.paintVertexBuffer && this._buffers.push(r5.paintVertexBuffer);
              }
            }
            upload(t4) {
              for (const e4 in this.binders) {
                const r5 = this.binders[e4];
                (r5 instanceof Xa || r5 instanceof Ya || r5 instanceof Ha) && r5.upload(t4);
              }
              this.updatePaintBuffers();
            }
            destroy() {
              for (const t4 in this.binders) {
                const e4 = this.binders[t4];
                (e4 instanceof Xa || e4 instanceof Ya || e4 instanceof Ha) && e4.destroy();
              }
            }
          }
          class Qa {
            constructor(t4, e4, r5 = () => true) {
              this.programConfigurations = {};
              for (const n3 of t4)
                this.programConfigurations[n3.id] = new Wa(n3, e4, r5);
              this.needsUpload = false, this._featureMap = new La(), this._bufferOffset = 0;
            }
            populatePaintArrays(t4, e4, r5, n3, i5, a5) {
              for (const r6 in this.programConfigurations)
                this.programConfigurations[r6].populatePaintArrays(t4, e4, n3, i5, a5);
              void 0 !== e4.id && this._featureMap.add(e4.id, r5, this._bufferOffset, t4), this._bufferOffset = t4, this.needsUpload = true;
            }
            updatePaintArrays(t4, e4, r5, n3) {
              for (const i5 of r5)
                this.needsUpload = this.programConfigurations[i5.id].updatePaintArrays(t4, this._featureMap, e4, i5, n3) || this.needsUpload;
            }
            get(t4) {
              return this.programConfigurations[t4];
            }
            upload(t4) {
              if (this.needsUpload) {
                for (const e4 in this.programConfigurations)
                  this.programConfigurations[e4].upload(t4);
                this.needsUpload = false;
              }
            }
            destroy() {
              for (const t4 in this.programConfigurations)
                this.programConfigurations[t4].destroy();
            }
          }
          function ts(t4, e4) {
            return { "text-opacity": ["opacity"], "icon-opacity": ["opacity"], "text-color": ["fill_color"], "icon-color": ["fill_color"], "text-halo-color": ["halo_color"], "icon-halo-color": ["halo_color"], "text-halo-blur": ["halo_blur"], "icon-halo-blur": ["halo_blur"], "text-halo-width": ["halo_width"], "icon-halo-width": ["halo_width"], "line-gap-width": ["gapwidth"], "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"], "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"] }[t4] || [t4.replace(`${e4}-`, "").replace(/-/g, "_")];
          }
          function es(t4, e4, r5) {
            const n3 = { color: { source: Ti, composite: Wi }, number: { source: Gi, composite: Ti } }, i5 = function(t5) {
              return { "line-pattern": { source: ga, composite: ga }, "fill-pattern": { source: ga, composite: ga }, "fill-extrusion-pattern": { source: ga, composite: ga } }[t5];
            }(t4);
            return i5 && i5[r5] || n3[e4][r5];
          }
          $n("ConstantBinder", Ga), $n("CrossFadedConstantBinder", Ja), $n("SourceExpressionBinder", Xa), $n("CrossFadedCompositeBinder", Ha), $n("CompositeExpressionBinder", Ya), $n("ProgramConfiguration", Wa, { omit: ["_buffers"] }), $n("ProgramConfigurationSet", Qa);
          const rs = 8192, ns = Math.pow(2, 14) - 1, is = -ns - 1;
          function as(t4) {
            const e4 = rs / t4.extent, r5 = t4.loadGeometry();
            for (let t5 = 0; t5 < r5.length; t5++) {
              const n3 = r5[t5];
              for (let t6 = 0; t6 < n3.length; t6++) {
                const r6 = n3[t6], i5 = Math.round(r6.x * e4), a5 = Math.round(r6.y * e4);
                r6.x = d3(i5, is, ns), r6.y = d3(a5, is, ns), (i5 < r6.x || i5 > r6.x + 1 || a5 < r6.y || a5 > r6.y + 1) && _3("Geometry exceeds allowed extent, reduce your vector tile buffer size");
              }
            }
            return r5;
          }
          function ss(t4, e4) {
            return { type: t4.type, id: t4.id, properties: t4.properties, geometry: e4 ? as(t4) : [] };
          }
          function os(t4, e4, r5, n3, i5) {
            t4.emplaceBack(2 * e4 + (n3 + 1) / 2, 2 * r5 + (i5 + 1) / 2);
          }
          class ls {
            constructor(t4) {
              this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new pa(), this.indexArray = new Aa(), this.segments = new za(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
            }
            populate(t4, e4, r5) {
              const n3 = this.layers[0], i5 = [];
              let a5 = null, s5 = false;
              "circle" === n3.type && (a5 = n3.layout.get("circle-sort-key"), s5 = !a5.isConstant());
              for (const { feature: e5, id: n4, index: o5, sourceLayerIndex: l5 } of t4) {
                const t5 = this.layers[0]._featureFilter.needGeometry, u5 = ss(e5, t5);
                if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u5, r5))
                  continue;
                const c5 = s5 ? a5.evaluate(u5, {}, r5) : void 0, h4 = { id: n4, properties: e5.properties, type: e5.type, sourceLayerIndex: l5, index: o5, geometry: t5 ? u5.geometry : as(e5), patterns: {}, sortKey: c5 };
                i5.push(h4);
              }
              s5 && i5.sort((t5, e5) => t5.sortKey - e5.sortKey);
              for (const n4 of i5) {
                const { geometry: i6, index: a6, sourceLayerIndex: s6 } = n4, o5 = t4[a6].feature;
                this.addFeature(n4, i6, a6, r5), e4.featureIndex.insert(o5, i6, a6, s6, this.index);
              }
            }
            update(t4, e4, r5) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e4, this.stateDependentLayers, r5);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t4) {
              this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Ia), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            addFeature(t4, e4, r5, n3) {
              for (const r6 of e4)
                for (const e5 of r6) {
                  const r7 = e5.x, n4 = e5.y;
                  if (r7 < 0 || r7 >= rs || n4 < 0 || n4 >= rs)
                    continue;
                  const i5 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray, t4.sortKey), a5 = i5.vertexLength;
                  os(this.layoutVertexArray, r7, n4, -1, -1), os(this.layoutVertexArray, r7, n4, 1, -1), os(this.layoutVertexArray, r7, n4, 1, 1), os(this.layoutVertexArray, r7, n4, -1, 1), this.indexArray.emplaceBack(a5, a5 + 1, a5 + 2), this.indexArray.emplaceBack(a5, a5 + 3, a5 + 2), i5.vertexLength += 4, i5.primitiveLength += 2;
                }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r5, {}, n3);
            }
          }
          function us(t4, e4) {
            for (let r5 = 0; r5 < t4.length; r5++)
              if (xs(e4, t4[r5]))
                return true;
            for (let r5 = 0; r5 < e4.length; r5++)
              if (xs(t4, e4[r5]))
                return true;
            return !!fs(t4, e4);
          }
          function cs(t4, e4, r5) {
            return !!xs(t4, e4) || !!ys(e4, t4, r5);
          }
          function hs(t4, e4) {
            if (1 === t4.length)
              return gs(e4, t4[0]);
            for (let r5 = 0; r5 < e4.length; r5++) {
              const n3 = e4[r5];
              for (let e5 = 0; e5 < n3.length; e5++)
                if (xs(t4, n3[e5]))
                  return true;
            }
            for (let r5 = 0; r5 < t4.length; r5++)
              if (gs(e4, t4[r5]))
                return true;
            for (let r5 = 0; r5 < e4.length; r5++)
              if (fs(t4, e4[r5]))
                return true;
            return false;
          }
          function ps(t4, e4, r5) {
            if (t4.length > 1) {
              if (fs(t4, e4))
                return true;
              for (let n3 = 0; n3 < e4.length; n3++)
                if (ys(e4[n3], t4, r5))
                  return true;
            }
            for (let n3 = 0; n3 < t4.length; n3++)
              if (ys(t4[n3], e4, r5))
                return true;
            return false;
          }
          function fs(t4, e4) {
            if (0 === t4.length || 0 === e4.length)
              return false;
            for (let r5 = 0; r5 < t4.length - 1; r5++) {
              const n3 = t4[r5], i5 = t4[r5 + 1];
              for (let t5 = 0; t5 < e4.length - 1; t5++)
                if (ds(n3, i5, e4[t5], e4[t5 + 1]))
                  return true;
            }
            return false;
          }
          function ds(t4, e4, r5, n3) {
            return A2(t4, r5, n3) !== A2(e4, r5, n3) && A2(t4, e4, r5) !== A2(t4, e4, n3);
          }
          function ys(t4, e4, r5) {
            const n3 = r5 * r5;
            if (1 === e4.length)
              return t4.distSqr(e4[0]) < n3;
            for (let r6 = 1; r6 < e4.length; r6++)
              if (ms(t4, e4[r6 - 1], e4[r6]) < n3)
                return true;
            return false;
          }
          function ms(t4, e4, r5) {
            const n3 = e4.distSqr(r5);
            if (0 === n3)
              return t4.distSqr(e4);
            const i5 = ((t4.x - e4.x) * (r5.x - e4.x) + (t4.y - e4.y) * (r5.y - e4.y)) / n3;
            return t4.distSqr(i5 < 0 ? e4 : i5 > 1 ? r5 : r5.sub(e4)._mult(i5)._add(e4));
          }
          function gs(t4, e4) {
            let r5, n3, i5, a5 = false;
            for (let s5 = 0; s5 < t4.length; s5++) {
              r5 = t4[s5];
              for (let t5 = 0, s6 = r5.length - 1; t5 < r5.length; s6 = t5++)
                n3 = r5[t5], i5 = r5[s6], n3.y > e4.y != i5.y > e4.y && e4.x < (i5.x - n3.x) * (e4.y - n3.y) / (i5.y - n3.y) + n3.x && (a5 = !a5);
            }
            return a5;
          }
          function xs(t4, e4) {
            let r5 = false;
            for (let n3 = 0, i5 = t4.length - 1; n3 < t4.length; i5 = n3++) {
              const a5 = t4[n3], s5 = t4[i5];
              a5.y > e4.y != s5.y > e4.y && e4.x < (s5.x - a5.x) * (e4.y - a5.y) / (s5.y - a5.y) + a5.x && (r5 = !r5);
            }
            return r5;
          }
          function vs(t4, e4, r5) {
            const n3 = r5[0], i5 = r5[2];
            if (t4.x < n3.x && e4.x < n3.x || t4.x > i5.x && e4.x > i5.x || t4.y < n3.y && e4.y < n3.y || t4.y > i5.y && e4.y > i5.y)
              return false;
            const a5 = A2(t4, e4, r5[0]);
            return a5 !== A2(t4, e4, r5[1]) || a5 !== A2(t4, e4, r5[2]) || a5 !== A2(t4, e4, r5[3]);
          }
          function bs(t4, e4, r5) {
            const n3 = e4.paint.get(t4).value;
            return "constant" === n3.kind ? n3.value : r5.programConfigurations.get(e4.id).getMaxValue(t4);
          }
          function ws(t4) {
            return Math.sqrt(t4[0] * t4[0] + t4[1] * t4[1]);
          }
          function _s(t4, e4, r5, n3, a5) {
            if (!e4[0] && !e4[1])
              return t4;
            const s5 = i4.convert(e4)._mult(a5);
            "viewport" === r5 && s5._rotate(-n3);
            const o5 = [];
            for (let e5 = 0; e5 < t4.length; e5++)
              o5.push(t4[e5].sub(s5));
            return o5;
          }
          let As, Ss;
          $n("CircleBucket", ls, { omit: ["layers"] });
          var ks = { get paint() {
            return Ss = Ss || new _i({ "circle-radius": new xi(X.paint_circle["circle-radius"]), "circle-color": new xi(X.paint_circle["circle-color"]), "circle-blur": new xi(X.paint_circle["circle-blur"]), "circle-opacity": new xi(X.paint_circle["circle-opacity"]), "circle-translate": new gi(X.paint_circle["circle-translate"]), "circle-translate-anchor": new gi(X.paint_circle["circle-translate-anchor"]), "circle-pitch-scale": new gi(X.paint_circle["circle-pitch-scale"]), "circle-pitch-alignment": new gi(X.paint_circle["circle-pitch-alignment"]), "circle-stroke-width": new xi(X.paint_circle["circle-stroke-width"]), "circle-stroke-color": new xi(X.paint_circle["circle-stroke-color"]), "circle-stroke-opacity": new xi(X.paint_circle["circle-stroke-opacity"]) });
          }, get layout() {
            return As = As || new _i({ "circle-sort-key": new xi(X.layout_circle["circle-sort-key"]) });
          } }, Is = 1e-6, zs = "undefined" != typeof Float32Array ? Float32Array : Array;
          function Ms(t4) {
            return t4[0] = 1, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = 1, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 1, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
          }
          function Ps(t4, e4, r5) {
            var n3 = e4[0], i5 = e4[1], a5 = e4[2], s5 = e4[3], o5 = e4[4], l5 = e4[5], u5 = e4[6], c5 = e4[7], h4 = e4[8], p7 = e4[9], f4 = e4[10], d4 = e4[11], y3 = e4[12], m4 = e4[13], g4 = e4[14], x3 = e4[15], v5 = r5[0], b4 = r5[1], w4 = r5[2], _4 = r5[3];
            return t4[0] = v5 * n3 + b4 * o5 + w4 * h4 + _4 * y3, t4[1] = v5 * i5 + b4 * l5 + w4 * p7 + _4 * m4, t4[2] = v5 * a5 + b4 * u5 + w4 * f4 + _4 * g4, t4[3] = v5 * s5 + b4 * c5 + w4 * d4 + _4 * x3, t4[4] = (v5 = r5[4]) * n3 + (b4 = r5[5]) * o5 + (w4 = r5[6]) * h4 + (_4 = r5[7]) * y3, t4[5] = v5 * i5 + b4 * l5 + w4 * p7 + _4 * m4, t4[6] = v5 * a5 + b4 * u5 + w4 * f4 + _4 * g4, t4[7] = v5 * s5 + b4 * c5 + w4 * d4 + _4 * x3, t4[8] = (v5 = r5[8]) * n3 + (b4 = r5[9]) * o5 + (w4 = r5[10]) * h4 + (_4 = r5[11]) * y3, t4[9] = v5 * i5 + b4 * l5 + w4 * p7 + _4 * m4, t4[10] = v5 * a5 + b4 * u5 + w4 * f4 + _4 * g4, t4[11] = v5 * s5 + b4 * c5 + w4 * d4 + _4 * x3, t4[12] = (v5 = r5[12]) * n3 + (b4 = r5[13]) * o5 + (w4 = r5[14]) * h4 + (_4 = r5[15]) * y3, t4[13] = v5 * i5 + b4 * l5 + w4 * p7 + _4 * m4, t4[14] = v5 * a5 + b4 * u5 + w4 * f4 + _4 * g4, t4[15] = v5 * s5 + b4 * c5 + w4 * d4 + _4 * x3, t4;
          }
          Math.hypot || (Math.hypot = function() {
            for (var t4 = 0, e4 = arguments.length; e4--; )
              t4 += arguments[e4] * arguments[e4];
            return Math.sqrt(t4);
          });
          var Cs, Bs = Ps;
          function Vs(t4, e4, r5) {
            var n3 = e4[0], i5 = e4[1], a5 = e4[2], s5 = e4[3];
            return t4[0] = r5[0] * n3 + r5[4] * i5 + r5[8] * a5 + r5[12] * s5, t4[1] = r5[1] * n3 + r5[5] * i5 + r5[9] * a5 + r5[13] * s5, t4[2] = r5[2] * n3 + r5[6] * i5 + r5[10] * a5 + r5[14] * s5, t4[3] = r5[3] * n3 + r5[7] * i5 + r5[11] * a5 + r5[15] * s5, t4;
          }
          Cs = new zs(4), zs != Float32Array && (Cs[0] = 0, Cs[1] = 0, Cs[2] = 0, Cs[3] = 0);
          class Es extends Si {
            constructor(t4) {
              super(t4, ks);
            }
            createBucket(t4) {
              return new ls(t4);
            }
            queryRadius(t4) {
              const e4 = t4;
              return bs("circle-radius", this, e4) + bs("circle-stroke-width", this, e4) + ws(this.paint.get("circle-translate"));
            }
            queryIntersectsFeature(t4, e4, r5, n3, i5, a5, s5, o5) {
              const l5 = _s(t4, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), a5.angle, s5), u5 = this.paint.get("circle-radius").evaluate(e4, r5) + this.paint.get("circle-stroke-width").evaluate(e4, r5), c5 = "map" === this.paint.get("circle-pitch-alignment"), h4 = c5 ? l5 : function(t5, e5) {
                return t5.map((t6) => Fs(t6, e5));
              }(l5, o5), p7 = c5 ? u5 * s5 : u5;
              for (const t5 of n3)
                for (const e5 of t5) {
                  const t6 = c5 ? e5 : Fs(e5, o5);
                  let r6 = p7;
                  const n4 = Vs([], [e5.x, e5.y, 0, 1], o5);
                  if ("viewport" === this.paint.get("circle-pitch-scale") && "map" === this.paint.get("circle-pitch-alignment") ? r6 *= n4[3] / a5.cameraToCenterDistance : "map" === this.paint.get("circle-pitch-scale") && "viewport" === this.paint.get("circle-pitch-alignment") && (r6 *= a5.cameraToCenterDistance / n4[3]), cs(h4, t6, r6))
                    return true;
                }
              return false;
            }
          }
          function Fs(t4, e4) {
            const r5 = Vs([], [t4.x, t4.y, 0, 1], e4);
            return new i4(r5[0] / r5[3], r5[1] / r5[3]);
          }
          class Ts extends ls {
          }
          let $s;
          $n("HeatmapBucket", Ts, { omit: ["layers"] });
          var Ls = { get paint() {
            return $s = $s || new _i({ "heatmap-radius": new xi(X.paint_heatmap["heatmap-radius"]), "heatmap-weight": new xi(X.paint_heatmap["heatmap-weight"]), "heatmap-intensity": new gi(X.paint_heatmap["heatmap-intensity"]), "heatmap-color": new wi(X.paint_heatmap["heatmap-color"]), "heatmap-opacity": new gi(X.paint_heatmap["heatmap-opacity"]) });
          } };
          function Ds(t4, { width: e4, height: r5 }, n3, i5) {
            if (i5) {
              if (i5 instanceof Uint8ClampedArray)
                i5 = new Uint8Array(i5.buffer);
              else if (i5.length !== e4 * r5 * n3)
                throw new RangeError(`mismatched image size. expected: ${i5.length} but got: ${e4 * r5 * n3}`);
            } else
              i5 = new Uint8Array(e4 * r5 * n3);
            return t4.width = e4, t4.height = r5, t4.data = i5, t4;
          }
          function Os(t4, { width: e4, height: r5 }, n3) {
            if (e4 === t4.width && r5 === t4.height)
              return;
            const i5 = Ds({}, { width: e4, height: r5 }, n3);
            Us(t4, i5, { x: 0, y: 0 }, { x: 0, y: 0 }, { width: Math.min(t4.width, e4), height: Math.min(t4.height, r5) }, n3), t4.width = e4, t4.height = r5, t4.data = i5.data;
          }
          function Us(t4, e4, r5, n3, i5, a5) {
            if (0 === i5.width || 0 === i5.height)
              return e4;
            if (i5.width > t4.width || i5.height > t4.height || r5.x > t4.width - i5.width || r5.y > t4.height - i5.height)
              throw new RangeError("out of range source coordinates for image copy");
            if (i5.width > e4.width || i5.height > e4.height || n3.x > e4.width - i5.width || n3.y > e4.height - i5.height)
              throw new RangeError("out of range destination coordinates for image copy");
            const s5 = t4.data, o5 = e4.data;
            if (s5 === o5)
              throw new Error("srcData equals dstData, so image is already copied");
            for (let l5 = 0; l5 < i5.height; l5++) {
              const u5 = ((r5.y + l5) * t4.width + r5.x) * a5, c5 = ((n3.y + l5) * e4.width + n3.x) * a5;
              for (let t5 = 0; t5 < i5.width * a5; t5++)
                o5[c5 + t5] = s5[u5 + t5];
            }
            return e4;
          }
          class Rs {
            constructor(t4, e4) {
              Ds(this, t4, 1, e4);
            }
            resize(t4) {
              Os(this, t4, 1);
            }
            clone() {
              return new Rs({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t4, e4, r5, n3, i5) {
              Us(t4, e4, r5, n3, i5, 1);
            }
          }
          class qs {
            constructor(t4, e4) {
              Ds(this, t4, 4, e4);
            }
            resize(t4) {
              Os(this, t4, 4);
            }
            replace(t4, e4) {
              e4 ? this.data.set(t4) : this.data = t4 instanceof Uint8ClampedArray ? new Uint8Array(t4.buffer) : t4;
            }
            clone() {
              return new qs({ width: this.width, height: this.height }, new Uint8Array(this.data));
            }
            static copy(t4, e4, r5, n3, i5) {
              Us(t4, e4, r5, n3, i5, 4);
            }
          }
          function js(t4) {
            const e4 = {}, r5 = t4.resolution || 256, n3 = t4.clips ? t4.clips.length : 1, i5 = t4.image || new qs({ width: r5, height: n3 });
            if (Math.log(r5) / Math.LN2 % 1 != 0)
              throw new Error(`width is not a power of 2 - ${r5}`);
            const a5 = (r6, n4, a6) => {
              e4[t4.evaluationKey] = a6;
              const s5 = t4.expression.evaluate(e4);
              i5.data[r6 + n4 + 0] = Math.floor(255 * s5.r / s5.a), i5.data[r6 + n4 + 1] = Math.floor(255 * s5.g / s5.a), i5.data[r6 + n4 + 2] = Math.floor(255 * s5.b / s5.a), i5.data[r6 + n4 + 3] = Math.floor(255 * s5.a);
            };
            if (t4.clips)
              for (let e5 = 0, i6 = 0; e5 < n3; ++e5, i6 += 4 * r5)
                for (let n4 = 0, s5 = 0; n4 < r5; n4++, s5 += 4) {
                  const o5 = n4 / (r5 - 1), { start: l5, end: u5 } = t4.clips[e5];
                  a5(i6, s5, l5 * (1 - o5) + u5 * o5);
                }
            else
              for (let t5 = 0, e5 = 0; t5 < r5; t5++, e5 += 4)
                a5(0, e5, t5 / (r5 - 1));
            return i5;
          }
          $n("AlphaImage", Rs), $n("RGBAImage", qs);
          class Ns extends Si {
            createBucket(t4) {
              return new Ts(t4);
            }
            constructor(t4) {
              super(t4, Ls), this._updateColorRamp();
            }
            _handleSpecialPaintPropertyUpdate(t4) {
              "heatmap-color" === t4 && this._updateColorRamp();
            }
            _updateColorRamp() {
              this.colorRamp = js({ expression: this._transitionablePaint._values["heatmap-color"].value.expression, evaluationKey: "heatmapDensity", image: this.colorRamp }), this.colorRampTexture = null;
            }
            resize() {
              this.heatmapFbo && (this.heatmapFbo.destroy(), this.heatmapFbo = null);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              return false;
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("heatmap-opacity") && "none" !== this.visibility;
            }
          }
          let Zs;
          var Ks = { get paint() {
            return Zs = Zs || new _i({ "hillshade-illumination-direction": new gi(X.paint_hillshade["hillshade-illumination-direction"]), "hillshade-illumination-anchor": new gi(X.paint_hillshade["hillshade-illumination-anchor"]), "hillshade-exaggeration": new gi(X.paint_hillshade["hillshade-exaggeration"]), "hillshade-shadow-color": new gi(X.paint_hillshade["hillshade-shadow-color"]), "hillshade-highlight-color": new gi(X.paint_hillshade["hillshade-highlight-color"]), "hillshade-accent-color": new gi(X.paint_hillshade["hillshade-accent-color"]) });
          } };
          class Gs extends Si {
            constructor(t4) {
              super(t4, Ks);
            }
            hasOffscreenPass() {
              return 0 !== this.paint.get("hillshade-exaggeration") && "none" !== this.visibility;
            }
          }
          const Js = Mi([{ name: "a_pos", components: 2, type: "Int16" }], 4), { members: Xs } = Js;
          var Ys = { exports: {} };
          function Hs(t4, e4, r5) {
            r5 = r5 || 2;
            var n3, i5, a5, s5, o5, l5, u5, c5 = e4 && e4.length, h4 = c5 ? e4[0] * r5 : t4.length, p7 = Ws(t4, 0, h4, r5, true), f4 = [];
            if (!p7 || p7.next === p7.prev)
              return f4;
            if (c5 && (p7 = function(t5, e5, r6, n4) {
              var i6, a6, s6, o6 = [];
              for (i6 = 0, a6 = e5.length; i6 < a6; i6++)
                (s6 = Ws(t5, e5[i6] * n4, i6 < a6 - 1 ? e5[i6 + 1] * n4 : t5.length, n4, false)) === s6.next && (s6.steiner = true), o6.push(uo(s6));
              for (o6.sort(ao), i6 = 0; i6 < o6.length; i6++)
                r6 = so(o6[i6], r6);
              return r6;
            }(t4, e4, p7, r5)), t4.length > 80 * r5) {
              n3 = a5 = t4[0], i5 = s5 = t4[1];
              for (var d4 = r5; d4 < h4; d4 += r5)
                (o5 = t4[d4]) < n3 && (n3 = o5), (l5 = t4[d4 + 1]) < i5 && (i5 = l5), o5 > a5 && (a5 = o5), l5 > s5 && (s5 = l5);
              u5 = 0 !== (u5 = Math.max(a5 - n3, s5 - i5)) ? 32767 / u5 : 0;
            }
            return to(p7, f4, r5, n3, i5, u5, 0), f4;
          }
          function Ws(t4, e4, r5, n3, i5) {
            var a5, s5;
            if (i5 === Ao(t4, e4, r5, n3) > 0)
              for (a5 = e4; a5 < r5; a5 += n3)
                s5 = bo(a5, t4[a5], t4[a5 + 1], s5);
            else
              for (a5 = r5 - n3; a5 >= e4; a5 -= n3)
                s5 = bo(a5, t4[a5], t4[a5 + 1], s5);
            return s5 && fo(s5, s5.next) && (wo(s5), s5 = s5.next), s5;
          }
          function Qs(t4, e4) {
            if (!t4)
              return t4;
            e4 || (e4 = t4);
            var r5, n3 = t4;
            do {
              if (r5 = false, n3.steiner || !fo(n3, n3.next) && 0 !== po(n3.prev, n3, n3.next))
                n3 = n3.next;
              else {
                if (wo(n3), (n3 = e4 = n3.prev) === n3.next)
                  break;
                r5 = true;
              }
            } while (r5 || n3 !== e4);
            return e4;
          }
          function to(t4, e4, r5, n3, i5, a5, s5) {
            if (t4) {
              !s5 && a5 && function(t5, e5, r6, n4) {
                var i6 = t5;
                do {
                  0 === i6.z && (i6.z = lo(i6.x, i6.y, e5, r6, n4)), i6.prevZ = i6.prev, i6.nextZ = i6.next, i6 = i6.next;
                } while (i6 !== t5);
                i6.prevZ.nextZ = null, i6.prevZ = null, function(t6) {
                  var e6, r7, n5, i7, a6, s6, o6, l6, u6 = 1;
                  do {
                    for (r7 = t6, t6 = null, a6 = null, s6 = 0; r7; ) {
                      for (s6++, n5 = r7, o6 = 0, e6 = 0; e6 < u6 && (o6++, n5 = n5.nextZ); e6++)
                        ;
                      for (l6 = u6; o6 > 0 || l6 > 0 && n5; )
                        0 !== o6 && (0 === l6 || !n5 || r7.z <= n5.z) ? (i7 = r7, r7 = r7.nextZ, o6--) : (i7 = n5, n5 = n5.nextZ, l6--), a6 ? a6.nextZ = i7 : t6 = i7, i7.prevZ = a6, a6 = i7;
                      r7 = n5;
                    }
                    a6.nextZ = null, u6 *= 2;
                  } while (s6 > 1);
                }(i6);
              }(t4, n3, i5, a5);
              for (var o5, l5, u5 = t4; t4.prev !== t4.next; )
                if (o5 = t4.prev, l5 = t4.next, a5 ? ro(t4, n3, i5, a5) : eo(t4))
                  e4.push(o5.i / r5 | 0), e4.push(t4.i / r5 | 0), e4.push(l5.i / r5 | 0), wo(t4), t4 = l5.next, u5 = l5.next;
                else if ((t4 = l5) === u5) {
                  s5 ? 1 === s5 ? to(t4 = no(Qs(t4), e4, r5), e4, r5, n3, i5, a5, 2) : 2 === s5 && io(t4, e4, r5, n3, i5, a5) : to(Qs(t4), e4, r5, n3, i5, a5, 1);
                  break;
                }
            }
          }
          function eo(t4) {
            var e4 = t4.prev, r5 = t4, n3 = t4.next;
            if (po(e4, r5, n3) >= 0)
              return false;
            for (var i5 = e4.x, a5 = r5.x, s5 = n3.x, o5 = e4.y, l5 = r5.y, u5 = n3.y, c5 = i5 < a5 ? i5 < s5 ? i5 : s5 : a5 < s5 ? a5 : s5, h4 = o5 < l5 ? o5 < u5 ? o5 : u5 : l5 < u5 ? l5 : u5, p7 = i5 > a5 ? i5 > s5 ? i5 : s5 : a5 > s5 ? a5 : s5, f4 = o5 > l5 ? o5 > u5 ? o5 : u5 : l5 > u5 ? l5 : u5, d4 = n3.next; d4 !== e4; ) {
              if (d4.x >= c5 && d4.x <= p7 && d4.y >= h4 && d4.y <= f4 && co(i5, o5, a5, l5, s5, u5, d4.x, d4.y) && po(d4.prev, d4, d4.next) >= 0)
                return false;
              d4 = d4.next;
            }
            return true;
          }
          function ro(t4, e4, r5, n3) {
            var i5 = t4.prev, a5 = t4, s5 = t4.next;
            if (po(i5, a5, s5) >= 0)
              return false;
            for (var o5 = i5.x, l5 = a5.x, u5 = s5.x, c5 = i5.y, h4 = a5.y, p7 = s5.y, f4 = o5 < l5 ? o5 < u5 ? o5 : u5 : l5 < u5 ? l5 : u5, d4 = c5 < h4 ? c5 < p7 ? c5 : p7 : h4 < p7 ? h4 : p7, y3 = o5 > l5 ? o5 > u5 ? o5 : u5 : l5 > u5 ? l5 : u5, m4 = c5 > h4 ? c5 > p7 ? c5 : p7 : h4 > p7 ? h4 : p7, g4 = lo(f4, d4, e4, r5, n3), x3 = lo(y3, m4, e4, r5, n3), v5 = t4.prevZ, b4 = t4.nextZ; v5 && v5.z >= g4 && b4 && b4.z <= x3; ) {
              if (v5.x >= f4 && v5.x <= y3 && v5.y >= d4 && v5.y <= m4 && v5 !== i5 && v5 !== s5 && co(o5, c5, l5, h4, u5, p7, v5.x, v5.y) && po(v5.prev, v5, v5.next) >= 0)
                return false;
              if (v5 = v5.prevZ, b4.x >= f4 && b4.x <= y3 && b4.y >= d4 && b4.y <= m4 && b4 !== i5 && b4 !== s5 && co(o5, c5, l5, h4, u5, p7, b4.x, b4.y) && po(b4.prev, b4, b4.next) >= 0)
                return false;
              b4 = b4.nextZ;
            }
            for (; v5 && v5.z >= g4; ) {
              if (v5.x >= f4 && v5.x <= y3 && v5.y >= d4 && v5.y <= m4 && v5 !== i5 && v5 !== s5 && co(o5, c5, l5, h4, u5, p7, v5.x, v5.y) && po(v5.prev, v5, v5.next) >= 0)
                return false;
              v5 = v5.prevZ;
            }
            for (; b4 && b4.z <= x3; ) {
              if (b4.x >= f4 && b4.x <= y3 && b4.y >= d4 && b4.y <= m4 && b4 !== i5 && b4 !== s5 && co(o5, c5, l5, h4, u5, p7, b4.x, b4.y) && po(b4.prev, b4, b4.next) >= 0)
                return false;
              b4 = b4.nextZ;
            }
            return true;
          }
          function no(t4, e4, r5) {
            var n3 = t4;
            do {
              var i5 = n3.prev, a5 = n3.next.next;
              !fo(i5, a5) && yo(i5, n3, n3.next, a5) && xo(i5, a5) && xo(a5, i5) && (e4.push(i5.i / r5 | 0), e4.push(n3.i / r5 | 0), e4.push(a5.i / r5 | 0), wo(n3), wo(n3.next), n3 = t4 = a5), n3 = n3.next;
            } while (n3 !== t4);
            return Qs(n3);
          }
          function io(t4, e4, r5, n3, i5, a5) {
            var s5 = t4;
            do {
              for (var o5 = s5.next.next; o5 !== s5.prev; ) {
                if (s5.i !== o5.i && ho(s5, o5)) {
                  var l5 = vo(s5, o5);
                  return s5 = Qs(s5, s5.next), l5 = Qs(l5, l5.next), to(s5, e4, r5, n3, i5, a5, 0), void to(l5, e4, r5, n3, i5, a5, 0);
                }
                o5 = o5.next;
              }
              s5 = s5.next;
            } while (s5 !== t4);
          }
          function ao(t4, e4) {
            return t4.x - e4.x;
          }
          function so(t4, e4) {
            var r5 = function(t5, e5) {
              var r6, n4 = e5, i5 = t5.x, a5 = t5.y, s5 = -1 / 0;
              do {
                if (a5 <= n4.y && a5 >= n4.next.y && n4.next.y !== n4.y) {
                  var o5 = n4.x + (a5 - n4.y) * (n4.next.x - n4.x) / (n4.next.y - n4.y);
                  if (o5 <= i5 && o5 > s5 && (s5 = o5, r6 = n4.x < n4.next.x ? n4 : n4.next, o5 === i5))
                    return r6;
                }
                n4 = n4.next;
              } while (n4 !== e5);
              if (!r6)
                return null;
              var l5, u5 = r6, c5 = r6.x, h4 = r6.y, p7 = 1 / 0;
              n4 = r6;
              do {
                i5 >= n4.x && n4.x >= c5 && i5 !== n4.x && co(a5 < h4 ? i5 : s5, a5, c5, h4, a5 < h4 ? s5 : i5, a5, n4.x, n4.y) && (l5 = Math.abs(a5 - n4.y) / (i5 - n4.x), xo(n4, t5) && (l5 < p7 || l5 === p7 && (n4.x > r6.x || n4.x === r6.x && oo(r6, n4))) && (r6 = n4, p7 = l5)), n4 = n4.next;
              } while (n4 !== u5);
              return r6;
            }(t4, e4);
            if (!r5)
              return e4;
            var n3 = vo(r5, t4);
            return Qs(n3, n3.next), Qs(r5, r5.next);
          }
          function oo(t4, e4) {
            return po(t4.prev, t4, e4.prev) < 0 && po(e4.next, t4, t4.next) < 0;
          }
          function lo(t4, e4, r5, n3, i5) {
            return (t4 = 1431655765 & ((t4 = 858993459 & ((t4 = 252645135 & ((t4 = 16711935 & ((t4 = (t4 - r5) * i5 | 0) | t4 << 8)) | t4 << 4)) | t4 << 2)) | t4 << 1)) | (e4 = 1431655765 & ((e4 = 858993459 & ((e4 = 252645135 & ((e4 = 16711935 & ((e4 = (e4 - n3) * i5 | 0) | e4 << 8)) | e4 << 4)) | e4 << 2)) | e4 << 1)) << 1;
          }
          function uo(t4) {
            var e4 = t4, r5 = t4;
            do {
              (e4.x < r5.x || e4.x === r5.x && e4.y < r5.y) && (r5 = e4), e4 = e4.next;
            } while (e4 !== t4);
            return r5;
          }
          function co(t4, e4, r5, n3, i5, a5, s5, o5) {
            return (i5 - s5) * (e4 - o5) >= (t4 - s5) * (a5 - o5) && (t4 - s5) * (n3 - o5) >= (r5 - s5) * (e4 - o5) && (r5 - s5) * (a5 - o5) >= (i5 - s5) * (n3 - o5);
          }
          function ho(t4, e4) {
            return t4.next.i !== e4.i && t4.prev.i !== e4.i && !function(t5, e5) {
              var r5 = t5;
              do {
                if (r5.i !== t5.i && r5.next.i !== t5.i && r5.i !== e5.i && r5.next.i !== e5.i && yo(r5, r5.next, t5, e5))
                  return true;
                r5 = r5.next;
              } while (r5 !== t5);
              return false;
            }(t4, e4) && (xo(t4, e4) && xo(e4, t4) && function(t5, e5) {
              var r5 = t5, n3 = false, i5 = (t5.x + e5.x) / 2, a5 = (t5.y + e5.y) / 2;
              do {
                r5.y > a5 != r5.next.y > a5 && r5.next.y !== r5.y && i5 < (r5.next.x - r5.x) * (a5 - r5.y) / (r5.next.y - r5.y) + r5.x && (n3 = !n3), r5 = r5.next;
              } while (r5 !== t5);
              return n3;
            }(t4, e4) && (po(t4.prev, t4, e4.prev) || po(t4, e4.prev, e4)) || fo(t4, e4) && po(t4.prev, t4, t4.next) > 0 && po(e4.prev, e4, e4.next) > 0);
          }
          function po(t4, e4, r5) {
            return (e4.y - t4.y) * (r5.x - e4.x) - (e4.x - t4.x) * (r5.y - e4.y);
          }
          function fo(t4, e4) {
            return t4.x === e4.x && t4.y === e4.y;
          }
          function yo(t4, e4, r5, n3) {
            var i5 = go(po(t4, e4, r5)), a5 = go(po(t4, e4, n3)), s5 = go(po(r5, n3, t4)), o5 = go(po(r5, n3, e4));
            return i5 !== a5 && s5 !== o5 || !(0 !== i5 || !mo(t4, r5, e4)) || !(0 !== a5 || !mo(t4, n3, e4)) || !(0 !== s5 || !mo(r5, t4, n3)) || !(0 !== o5 || !mo(r5, e4, n3));
          }
          function mo(t4, e4, r5) {
            return e4.x <= Math.max(t4.x, r5.x) && e4.x >= Math.min(t4.x, r5.x) && e4.y <= Math.max(t4.y, r5.y) && e4.y >= Math.min(t4.y, r5.y);
          }
          function go(t4) {
            return t4 > 0 ? 1 : t4 < 0 ? -1 : 0;
          }
          function xo(t4, e4) {
            return po(t4.prev, t4, t4.next) < 0 ? po(t4, e4, t4.next) >= 0 && po(t4, t4.prev, e4) >= 0 : po(t4, e4, t4.prev) < 0 || po(t4, t4.next, e4) < 0;
          }
          function vo(t4, e4) {
            var r5 = new _o(t4.i, t4.x, t4.y), n3 = new _o(e4.i, e4.x, e4.y), i5 = t4.next, a5 = e4.prev;
            return t4.next = e4, e4.prev = t4, r5.next = i5, i5.prev = r5, n3.next = r5, r5.prev = n3, a5.next = n3, n3.prev = a5, n3;
          }
          function bo(t4, e4, r5, n3) {
            var i5 = new _o(t4, e4, r5);
            return n3 ? (i5.next = n3.next, i5.prev = n3, n3.next.prev = i5, n3.next = i5) : (i5.prev = i5, i5.next = i5), i5;
          }
          function wo(t4) {
            t4.next.prev = t4.prev, t4.prev.next = t4.next, t4.prevZ && (t4.prevZ.nextZ = t4.nextZ), t4.nextZ && (t4.nextZ.prevZ = t4.prevZ);
          }
          function _o(t4, e4, r5) {
            this.i = t4, this.x = e4, this.y = r5, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = false;
          }
          function Ao(t4, e4, r5, n3) {
            for (var i5 = 0, a5 = e4, s5 = r5 - n3; a5 < r5; a5 += n3)
              i5 += (t4[s5] - t4[a5]) * (t4[a5 + 1] + t4[s5 + 1]), s5 = a5;
            return i5;
          }
          Ys.exports = Hs, Ys.exports.default = Hs, Hs.deviation = function(t4, e4, r5, n3) {
            var i5 = e4 && e4.length, a5 = Math.abs(Ao(t4, 0, i5 ? e4[0] * r5 : t4.length, r5));
            if (i5)
              for (var s5 = 0, o5 = e4.length; s5 < o5; s5++)
                a5 -= Math.abs(Ao(t4, e4[s5] * r5, s5 < o5 - 1 ? e4[s5 + 1] * r5 : t4.length, r5));
            var l5 = 0;
            for (s5 = 0; s5 < n3.length; s5 += 3) {
              var u5 = n3[s5] * r5, c5 = n3[s5 + 1] * r5, h4 = n3[s5 + 2] * r5;
              l5 += Math.abs((t4[u5] - t4[h4]) * (t4[c5 + 1] - t4[u5 + 1]) - (t4[u5] - t4[c5]) * (t4[h4 + 1] - t4[u5 + 1]));
            }
            return 0 === a5 && 0 === l5 ? 0 : Math.abs((l5 - a5) / a5);
          }, Hs.flatten = function(t4) {
            for (var e4 = t4[0][0].length, r5 = { vertices: [], holes: [], dimensions: e4 }, n3 = 0, i5 = 0; i5 < t4.length; i5++) {
              for (var a5 = 0; a5 < t4[i5].length; a5++)
                for (var s5 = 0; s5 < e4; s5++)
                  r5.vertices.push(t4[i5][a5][s5]);
              i5 > 0 && r5.holes.push(n3 += t4[i5 - 1].length);
            }
            return r5;
          };
          var So = e3(Ys.exports);
          function ko(t4, e4, r5, n3, i5) {
            Io(t4, e4, r5 || 0, n3 || t4.length - 1, i5 || Mo);
          }
          function Io(t4, e4, r5, n3, i5) {
            for (; n3 > r5; ) {
              if (n3 - r5 > 600) {
                var a5 = n3 - r5 + 1, s5 = e4 - r5 + 1, o5 = Math.log(a5), l5 = 0.5 * Math.exp(2 * o5 / 3), u5 = 0.5 * Math.sqrt(o5 * l5 * (a5 - l5) / a5) * (s5 - a5 / 2 < 0 ? -1 : 1);
                Io(t4, e4, Math.max(r5, Math.floor(e4 - s5 * l5 / a5 + u5)), Math.min(n3, Math.floor(e4 + (a5 - s5) * l5 / a5 + u5)), i5);
              }
              var c5 = t4[e4], h4 = r5, p7 = n3;
              for (zo(t4, r5, e4), i5(t4[n3], c5) > 0 && zo(t4, r5, n3); h4 < p7; ) {
                for (zo(t4, h4, p7), h4++, p7--; i5(t4[h4], c5) < 0; )
                  h4++;
                for (; i5(t4[p7], c5) > 0; )
                  p7--;
              }
              0 === i5(t4[r5], c5) ? zo(t4, r5, p7) : zo(t4, ++p7, n3), p7 <= e4 && (r5 = p7 + 1), e4 <= p7 && (n3 = p7 - 1);
            }
          }
          function zo(t4, e4, r5) {
            var n3 = t4[e4];
            t4[e4] = t4[r5], t4[r5] = n3;
          }
          function Mo(t4, e4) {
            return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
          }
          function Po(t4, e4) {
            const r5 = t4.length;
            if (r5 <= 1)
              return [t4];
            const n3 = [];
            let i5, a5;
            for (let e5 = 0; e5 < r5; e5++) {
              const r6 = S2(t4[e5]);
              0 !== r6 && (t4[e5].area = Math.abs(r6), void 0 === a5 && (a5 = r6 < 0), a5 === r6 < 0 ? (i5 && n3.push(i5), i5 = [t4[e5]]) : i5.push(t4[e5]));
            }
            if (i5 && n3.push(i5), e4 > 1)
              for (let t5 = 0; t5 < n3.length; t5++)
                n3[t5].length <= e4 || (ko(n3[t5], e4, 1, n3[t5].length - 1, Co), n3[t5] = n3[t5].slice(0, e4));
            return n3;
          }
          function Co(t4, e4) {
            return e4.area - t4.area;
          }
          function Bo(t4, e4, r5) {
            const n3 = r5.patternDependencies;
            let i5 = false;
            for (const r6 of e4) {
              const e5 = r6.paint.get(`${t4}-pattern`);
              e5.isConstant() || (i5 = true);
              const a5 = e5.constantOr(null);
              a5 && (i5 = true, n3[a5.to] = true, n3[a5.from] = true);
            }
            return i5;
          }
          function Vo(t4, e4, r5, n3, i5) {
            const a5 = i5.patternDependencies;
            for (const s5 of e4) {
              const e5 = s5.paint.get(`${t4}-pattern`).value;
              if ("constant" !== e5.kind) {
                let t5 = e5.evaluate({ zoom: n3 - 1 }, r5, {}, i5.availableImages), o5 = e5.evaluate({ zoom: n3 }, r5, {}, i5.availableImages), l5 = e5.evaluate({ zoom: n3 + 1 }, r5, {}, i5.availableImages);
                t5 = t5 && t5.name ? t5.name : t5, o5 = o5 && o5.name ? o5.name : o5, l5 = l5 && l5.name ? l5.name : l5, a5[t5] = true, a5[o5] = true, a5[l5] = true, r5.patterns[s5.id] = { min: t5, mid: o5, max: l5 };
              }
            }
            return r5;
          }
          class Eo {
            constructor(t4) {
              this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.layoutVertexArray = new fa(), this.indexArray = new Aa(), this.indexArray2 = new Sa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.segments2 = new za(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
            }
            populate(t4, e4, r5) {
              this.hasPattern = Bo("fill", this.layers, e4);
              const n3 = this.layers[0].layout.get("fill-sort-key"), i5 = !n3.isConstant(), a5 = [];
              for (const { feature: s5, id: o5, index: l5, sourceLayerIndex: u5 } of t4) {
                const t5 = this.layers[0]._featureFilter.needGeometry, c5 = ss(s5, t5);
                if (!this.layers[0]._featureFilter.filter(new li(this.zoom), c5, r5))
                  continue;
                const h4 = i5 ? n3.evaluate(c5, {}, r5, e4.availableImages) : void 0, p7 = { id: o5, properties: s5.properties, type: s5.type, sourceLayerIndex: u5, index: l5, geometry: t5 ? c5.geometry : as(s5), patterns: {}, sortKey: h4 };
                a5.push(p7);
              }
              i5 && a5.sort((t5, e5) => t5.sortKey - e5.sortKey);
              for (const n4 of a5) {
                const { geometry: i6, index: a6, sourceLayerIndex: s5 } = n4;
                if (this.hasPattern) {
                  const t5 = Vo("fill", this.layers, n4, this.zoom, e4);
                  this.patternFeatures.push(t5);
                } else
                  this.addFeature(n4, i6, a6, r5, {});
                e4.featureIndex.insert(t4[a6].feature, i6, a6, s5, this.index);
              }
            }
            update(t4, e4, r5) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e4, this.stateDependentLayers, r5);
            }
            addFeatures(t4, e4, r5) {
              for (const t5 of this.patternFeatures)
                this.addFeature(t5, t5.geometry, t5.index, e4, r5);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t4) {
              this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Xs), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.indexBuffer2 = t4.createIndexBuffer(this.indexArray2)), this.programConfigurations.upload(t4), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.indexBuffer2.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.segments2.destroy());
            }
            addFeature(t4, e4, r5, n3, i5) {
              for (const t5 of Po(e4, 500)) {
                let e5 = 0;
                for (const r7 of t5)
                  e5 += r7.length;
                const r6 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray), n4 = r6.vertexLength, i6 = [], a5 = [];
                for (const e6 of t5) {
                  if (0 === e6.length)
                    continue;
                  e6 !== t5[0] && a5.push(i6.length / 2);
                  const r7 = this.segments2.prepareSegment(e6.length, this.layoutVertexArray, this.indexArray2), n5 = r7.vertexLength;
                  this.layoutVertexArray.emplaceBack(e6[0].x, e6[0].y), this.indexArray2.emplaceBack(n5 + e6.length - 1, n5), i6.push(e6[0].x), i6.push(e6[0].y);
                  for (let t6 = 1; t6 < e6.length; t6++)
                    this.layoutVertexArray.emplaceBack(e6[t6].x, e6[t6].y), this.indexArray2.emplaceBack(n5 + t6 - 1, n5 + t6), i6.push(e6[t6].x), i6.push(e6[t6].y);
                  r7.vertexLength += e6.length, r7.primitiveLength += e6.length;
                }
                const s5 = So(i6, a5);
                for (let t6 = 0; t6 < s5.length; t6 += 3)
                  this.indexArray.emplaceBack(n4 + s5[t6], n4 + s5[t6 + 1], n4 + s5[t6 + 2]);
                r6.vertexLength += e5, r6.primitiveLength += s5.length / 3;
              }
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r5, i5, n3);
            }
          }
          let Fo, To;
          $n("FillBucket", Eo, { omit: ["layers", "patternFeatures"] });
          var $o = { get paint() {
            return To = To || new _i({ "fill-antialias": new gi(X.paint_fill["fill-antialias"]), "fill-opacity": new xi(X.paint_fill["fill-opacity"]), "fill-color": new xi(X.paint_fill["fill-color"]), "fill-outline-color": new xi(X.paint_fill["fill-outline-color"]), "fill-translate": new gi(X.paint_fill["fill-translate"]), "fill-translate-anchor": new gi(X.paint_fill["fill-translate-anchor"]), "fill-pattern": new vi(X.paint_fill["fill-pattern"]) });
          }, get layout() {
            return Fo = Fo || new _i({ "fill-sort-key": new xi(X.layout_fill["fill-sort-key"]) });
          } };
          class Lo extends Si {
            constructor(t4) {
              super(t4, $o);
            }
            recalculate(t4, e4) {
              super.recalculate(t4, e4);
              const r5 = this.paint._values["fill-outline-color"];
              "constant" === r5.value.kind && void 0 === r5.value.value && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"]);
            }
            createBucket(t4) {
              return new Eo(t4);
            }
            queryRadius() {
              return ws(this.paint.get("fill-translate"));
            }
            queryIntersectsFeature(t4, e4, r5, n3, i5, a5, s5) {
              return hs(_s(t4, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), a5.angle, s5), n3);
            }
            isTileClipped() {
              return true;
            }
          }
          const Do = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_normal_ed", components: 4, type: "Int16" }], 4), Oo = Mi([{ name: "a_centroid", components: 2, type: "Int16" }], 4), { members: Uo } = Do;
          var Ro = {}, qo = r4, jo = No;
          function No(t4, e4, r5, n3, i5) {
            this.properties = {}, this.extent = r5, this.type = 0, this._pbf = t4, this._geometry = -1, this._keys = n3, this._values = i5, t4.readFields(Zo, this, e4);
          }
          function Zo(t4, e4, r5) {
            1 == t4 ? e4.id = r5.readVarint() : 2 == t4 ? function(t5, e5) {
              for (var r6 = t5.readVarint() + t5.pos; t5.pos < r6; ) {
                var n3 = e5._keys[t5.readVarint()], i5 = e5._values[t5.readVarint()];
                e5.properties[n3] = i5;
              }
            }(r5, e4) : 3 == t4 ? e4.type = r5.readVarint() : 4 == t4 && (e4._geometry = r5.pos);
          }
          function Ko(t4) {
            for (var e4, r5, n3 = 0, i5 = 0, a5 = t4.length, s5 = a5 - 1; i5 < a5; s5 = i5++)
              n3 += ((r5 = t4[s5]).x - (e4 = t4[i5]).x) * (e4.y + r5.y);
            return n3;
          }
          No.types = ["Unknown", "Point", "LineString", "Polygon"], No.prototype.loadGeometry = function() {
            var t4 = this._pbf;
            t4.pos = this._geometry;
            for (var e4, r5 = t4.readVarint() + t4.pos, n3 = 1, i5 = 0, a5 = 0, s5 = 0, o5 = []; t4.pos < r5; ) {
              if (i5 <= 0) {
                var l5 = t4.readVarint();
                n3 = 7 & l5, i5 = l5 >> 3;
              }
              if (i5--, 1 === n3 || 2 === n3)
                a5 += t4.readSVarint(), s5 += t4.readSVarint(), 1 === n3 && (e4 && o5.push(e4), e4 = []), e4.push(new qo(a5, s5));
              else {
                if (7 !== n3)
                  throw new Error("unknown command " + n3);
                e4 && e4.push(e4[0].clone());
              }
            }
            return e4 && o5.push(e4), o5;
          }, No.prototype.bbox = function() {
            var t4 = this._pbf;
            t4.pos = this._geometry;
            for (var e4 = t4.readVarint() + t4.pos, r5 = 1, n3 = 0, i5 = 0, a5 = 0, s5 = 1 / 0, o5 = -1 / 0, l5 = 1 / 0, u5 = -1 / 0; t4.pos < e4; ) {
              if (n3 <= 0) {
                var c5 = t4.readVarint();
                r5 = 7 & c5, n3 = c5 >> 3;
              }
              if (n3--, 1 === r5 || 2 === r5)
                (i5 += t4.readSVarint()) < s5 && (s5 = i5), i5 > o5 && (o5 = i5), (a5 += t4.readSVarint()) < l5 && (l5 = a5), a5 > u5 && (u5 = a5);
              else if (7 !== r5)
                throw new Error("unknown command " + r5);
            }
            return [s5, l5, o5, u5];
          }, No.prototype.toGeoJSON = function(t4, e4, r5) {
            var n3, i5, a5 = this.extent * Math.pow(2, r5), s5 = this.extent * t4, o5 = this.extent * e4, l5 = this.loadGeometry(), u5 = No.types[this.type];
            function c5(t5) {
              for (var e5 = 0; e5 < t5.length; e5++) {
                var r6 = t5[e5];
                t5[e5] = [360 * (r6.x + s5) / a5 - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (r6.y + o5) / a5) * Math.PI / 180)) - 90];
              }
            }
            switch (this.type) {
              case 1:
                var h4 = [];
                for (n3 = 0; n3 < l5.length; n3++)
                  h4[n3] = l5[n3][0];
                c5(l5 = h4);
                break;
              case 2:
                for (n3 = 0; n3 < l5.length; n3++)
                  c5(l5[n3]);
                break;
              case 3:
                for (l5 = function(t5) {
                  var e5 = t5.length;
                  if (e5 <= 1)
                    return [t5];
                  for (var r6, n4, i6 = [], a6 = 0; a6 < e5; a6++) {
                    var s6 = Ko(t5[a6]);
                    0 !== s6 && (void 0 === n4 && (n4 = s6 < 0), n4 === s6 < 0 ? (r6 && i6.push(r6), r6 = [t5[a6]]) : r6.push(t5[a6]));
                  }
                  return r6 && i6.push(r6), i6;
                }(l5), n3 = 0; n3 < l5.length; n3++)
                  for (i5 = 0; i5 < l5[n3].length; i5++)
                    c5(l5[n3][i5]);
            }
            1 === l5.length ? l5 = l5[0] : u5 = "Multi" + u5;
            var p7 = { type: "Feature", geometry: { type: u5, coordinates: l5 }, properties: this.properties };
            return "id" in this && (p7.id = this.id), p7;
          };
          var Go = jo, Jo = Xo;
          function Xo(t4, e4) {
            this.version = 1, this.name = null, this.extent = 4096, this.length = 0, this._pbf = t4, this._keys = [], this._values = [], this._features = [], t4.readFields(Yo, this, e4), this.length = this._features.length;
          }
          function Yo(t4, e4, r5) {
            15 === t4 ? e4.version = r5.readVarint() : 1 === t4 ? e4.name = r5.readString() : 5 === t4 ? e4.extent = r5.readVarint() : 2 === t4 ? e4._features.push(r5.pos) : 3 === t4 ? e4._keys.push(r5.readString()) : 4 === t4 && e4._values.push(function(t5) {
              for (var e5 = null, r6 = t5.readVarint() + t5.pos; t5.pos < r6; ) {
                var n3 = t5.readVarint() >> 3;
                e5 = 1 === n3 ? t5.readString() : 2 === n3 ? t5.readFloat() : 3 === n3 ? t5.readDouble() : 4 === n3 ? t5.readVarint64() : 5 === n3 ? t5.readVarint() : 6 === n3 ? t5.readSVarint() : 7 === n3 ? t5.readBoolean() : null;
              }
              return e5;
            }(r5));
          }
          Xo.prototype.feature = function(t4) {
            if (t4 < 0 || t4 >= this._features.length)
              throw new Error("feature index out of bounds");
            this._pbf.pos = this._features[t4];
            var e4 = this._pbf.readVarint() + this._pbf.pos;
            return new Go(this._pbf, e4, this.extent, this._keys, this._values);
          };
          var Ho = Jo;
          function Wo(t4, e4, r5) {
            if (3 === t4) {
              var n3 = new Ho(r5, r5.readVarint() + r5.pos);
              n3.length && (e4[n3.name] = n3);
            }
          }
          Ro.VectorTile = function(t4, e4) {
            this.layers = t4.readFields(Wo, {}, e4);
          }, Ro.VectorTileFeature = jo, Ro.VectorTileLayer = Jo;
          const Qo = Ro.VectorTileFeature.types, tl = Math.pow(2, 13);
          function el(t4, e4, r5, n3, i5, a5, s5, o5) {
            t4.emplaceBack(e4, r5, 2 * Math.floor(n3 * tl) + s5, i5 * tl * 2, a5 * tl * 2, Math.round(o5));
          }
          class rl {
            constructor(t4) {
              this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.layoutVertexArray = new da(), this.centroidVertexArray = new ha(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
            }
            populate(t4, e4, r5) {
              this.features = [], this.hasPattern = Bo("fill-extrusion", this.layers, e4);
              for (const { feature: n3, id: i5, index: a5, sourceLayerIndex: s5 } of t4) {
                const t5 = this.layers[0]._featureFilter.needGeometry, o5 = ss(n3, t5);
                if (!this.layers[0]._featureFilter.filter(new li(this.zoom), o5, r5))
                  continue;
                const l5 = { id: i5, sourceLayerIndex: s5, index: a5, geometry: t5 ? o5.geometry : as(n3), properties: n3.properties, type: n3.type, patterns: {} };
                this.hasPattern ? this.features.push(Vo("fill-extrusion", this.layers, l5, this.zoom, e4)) : this.addFeature(l5, l5.geometry, a5, r5, {}), e4.featureIndex.insert(n3, l5.geometry, a5, s5, this.index, true);
              }
            }
            addFeatures(t4, e4, r5) {
              for (const t5 of this.features) {
                const { geometry: n3 } = t5;
                this.addFeature(t5, n3, t5.index, e4, r5);
              }
            }
            update(t4, e4, r5) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e4, this.stateDependentLayers, r5);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.centroidVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t4) {
              this.uploaded || (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, Uo), this.centroidVertexBuffer = t4.createVertexBuffer(this.centroidVertexArray, Oo.members, true), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.centroidVertexBuffer.destroy());
            }
            addFeature(t4, e4, r5, n3, i5) {
              const a5 = { x: 0, y: 0, vertexCount: 0 };
              for (const r6 of Po(e4, 500)) {
                let e5 = 0;
                for (const t5 of r6)
                  e5 += t5.length;
                let n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray);
                for (const t5 of r6) {
                  if (0 === t5.length)
                    continue;
                  if (il(t5))
                    continue;
                  let e6 = 0;
                  for (let r7 = 0; r7 < t5.length; r7++) {
                    const i7 = t5[r7];
                    if (r7 >= 1) {
                      const s6 = t5[r7 - 1];
                      if (!nl(i7, s6)) {
                        n4.vertexLength + 4 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                        const t6 = i7.sub(s6)._perp()._unit(), r8 = s6.dist(i7);
                        e6 + r8 > 32768 && (e6 = 0), el(this.layoutVertexArray, i7.x, i7.y, t6.x, t6.y, 0, 0, e6), el(this.layoutVertexArray, i7.x, i7.y, t6.x, t6.y, 0, 1, e6), a5.x += 2 * i7.x, a5.y += 2 * i7.y, a5.vertexCount += 2, e6 += r8, el(this.layoutVertexArray, s6.x, s6.y, t6.x, t6.y, 0, 0, e6), el(this.layoutVertexArray, s6.x, s6.y, t6.x, t6.y, 0, 1, e6), a5.x += 2 * s6.x, a5.y += 2 * s6.y, a5.vertexCount += 2;
                        const o6 = n4.vertexLength;
                        this.indexArray.emplaceBack(o6, o6 + 2, o6 + 1), this.indexArray.emplaceBack(o6 + 1, o6 + 2, o6 + 3), n4.vertexLength += 4, n4.primitiveLength += 2;
                      }
                    }
                  }
                }
                if (n4.vertexLength + e5 > za.MAX_VERTEX_ARRAY_LENGTH && (n4 = this.segments.prepareSegment(e5, this.layoutVertexArray, this.indexArray)), "Polygon" !== Qo[t4.type])
                  continue;
                const i6 = [], s5 = [], o5 = n4.vertexLength;
                for (const t5 of r6)
                  if (0 !== t5.length) {
                    t5 !== r6[0] && s5.push(i6.length / 2);
                    for (let e6 = 0; e6 < t5.length; e6++) {
                      const r7 = t5[e6];
                      el(this.layoutVertexArray, r7.x, r7.y, 0, 0, 1, 1, 0), a5.x += r7.x, a5.y += r7.y, a5.vertexCount += 1, i6.push(r7.x), i6.push(r7.y);
                    }
                  }
                const l5 = So(i6, s5);
                for (let t5 = 0; t5 < l5.length; t5 += 3)
                  this.indexArray.emplaceBack(o5 + l5[t5], o5 + l5[t5 + 2], o5 + l5[t5 + 1]);
                n4.primitiveLength += l5.length / 3, n4.vertexLength += e5;
              }
              for (let t5 = 0; t5 < a5.vertexCount; t5++)
                this.centroidVertexArray.emplaceBack(Math.floor(a5.x / a5.vertexCount), Math.floor(a5.y / a5.vertexCount));
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r5, i5, n3);
            }
          }
          function nl(t4, e4) {
            return t4.x === e4.x && (t4.x < 0 || t4.x > rs) || t4.y === e4.y && (t4.y < 0 || t4.y > rs);
          }
          function il(t4) {
            return t4.every((t5) => t5.x < 0) || t4.every((t5) => t5.x > rs) || t4.every((t5) => t5.y < 0) || t4.every((t5) => t5.y > rs);
          }
          let al;
          $n("FillExtrusionBucket", rl, { omit: ["layers", "features"] });
          var sl = { get paint() {
            return al = al || new _i({ "fill-extrusion-opacity": new gi(X["paint_fill-extrusion"]["fill-extrusion-opacity"]), "fill-extrusion-color": new xi(X["paint_fill-extrusion"]["fill-extrusion-color"]), "fill-extrusion-translate": new gi(X["paint_fill-extrusion"]["fill-extrusion-translate"]), "fill-extrusion-translate-anchor": new gi(X["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]), "fill-extrusion-pattern": new vi(X["paint_fill-extrusion"]["fill-extrusion-pattern"]), "fill-extrusion-height": new xi(X["paint_fill-extrusion"]["fill-extrusion-height"]), "fill-extrusion-base": new xi(X["paint_fill-extrusion"]["fill-extrusion-base"]), "fill-extrusion-vertical-gradient": new gi(X["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"]) });
          } };
          class ol extends Si {
            constructor(t4) {
              super(t4, sl);
            }
            createBucket(t4) {
              return new rl(t4);
            }
            queryRadius() {
              return ws(this.paint.get("fill-extrusion-translate"));
            }
            is3D() {
              return true;
            }
            queryIntersectsFeature(t4, e4, r5, n3, a5, s5, o5, l5) {
              const u5 = _s(t4, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), s5.angle, o5), c5 = this.paint.get("fill-extrusion-height").evaluate(e4, r5), h4 = this.paint.get("fill-extrusion-base").evaluate(e4, r5), p7 = function(t5, e5, r6, n4) {
                const a6 = [];
                for (const r7 of t5) {
                  const t6 = [r7.x, r7.y, 0, 1];
                  Vs(t6, t6, e5), a6.push(new i4(t6[0] / t6[3], t6[1] / t6[3]));
                }
                return a6;
              }(u5, l5), f4 = function(t5, e5, r6, n4) {
                const a6 = [], s6 = [], o6 = n4[8] * e5, l6 = n4[9] * e5, u6 = n4[10] * e5, c6 = n4[11] * e5, h5 = n4[8] * r6, p8 = n4[9] * r6, f5 = n4[10] * r6, d4 = n4[11] * r6;
                for (const e6 of t5) {
                  const t6 = [], r7 = [];
                  for (const a7 of e6) {
                    const e7 = a7.x, s7 = a7.y, y3 = n4[0] * e7 + n4[4] * s7 + n4[12], m4 = n4[1] * e7 + n4[5] * s7 + n4[13], g4 = n4[2] * e7 + n4[6] * s7 + n4[14], x3 = n4[3] * e7 + n4[7] * s7 + n4[15], v5 = g4 + u6, b4 = x3 + c6, w4 = y3 + h5, _4 = m4 + p8, A3 = g4 + f5, S3 = x3 + d4, k4 = new i4((y3 + o6) / b4, (m4 + l6) / b4);
                    k4.z = v5 / b4, t6.push(k4);
                    const I3 = new i4(w4 / S3, _4 / S3);
                    I3.z = A3 / S3, r7.push(I3);
                  }
                  a6.push(t6), s6.push(r7);
                }
                return [a6, s6];
              }(n3, h4, c5, l5);
              return function(t5, e5, r6) {
                let n4 = 1 / 0;
                hs(r6, e5) && (n4 = ul(r6, e5[0]));
                for (let i5 = 0; i5 < e5.length; i5++) {
                  const a6 = e5[i5], s6 = t5[i5];
                  for (let t6 = 0; t6 < a6.length - 1; t6++) {
                    const e6 = a6[t6], i6 = [e6, a6[t6 + 1], s6[t6 + 1], s6[t6], e6];
                    us(r6, i6) && (n4 = Math.min(n4, ul(r6, i6)));
                  }
                }
                return n4 !== 1 / 0 && n4;
              }(f4[0], f4[1], p7);
            }
          }
          function ll(t4, e4) {
            return t4.x * e4.x + t4.y * e4.y;
          }
          function ul(t4, e4) {
            if (1 === t4.length) {
              let r5 = 0;
              const n3 = e4[r5++];
              let i5;
              for (; !i5 || n3.equals(i5); )
                if (i5 = e4[r5++], !i5)
                  return 1 / 0;
              for (; r5 < e4.length; r5++) {
                const a5 = e4[r5], s5 = t4[0], o5 = i5.sub(n3), l5 = a5.sub(n3), u5 = s5.sub(n3), c5 = ll(o5, o5), h4 = ll(o5, l5), p7 = ll(l5, l5), f4 = ll(u5, o5), d4 = ll(u5, l5), y3 = c5 * p7 - h4 * h4, m4 = (p7 * f4 - h4 * d4) / y3, g4 = (c5 * d4 - h4 * f4) / y3, x3 = n3.z * (1 - m4 - g4) + i5.z * m4 + a5.z * g4;
                if (isFinite(x3))
                  return x3;
              }
              return 1 / 0;
            }
            {
              let t5 = 1 / 0;
              for (const r5 of e4)
                t5 = Math.min(t5, r5.z);
              return t5;
            }
          }
          const cl = Mi([{ name: "a_pos_normal", components: 2, type: "Int16" }, { name: "a_data", components: 4, type: "Uint8" }], 4), { members: hl } = cl, pl = Mi([{ name: "a_uv_x", components: 1, type: "Float32" }, { name: "a_split_index", components: 1, type: "Float32" }]), { members: fl } = pl, dl = Ro.VectorTileFeature.types, yl = Math.cos(Math.PI / 180 * 37.5), ml = Math.pow(2, 14) / 0.5;
          class gl {
            constructor(t4) {
              this.zoom = t4.zoom, this.overscaling = t4.overscaling, this.layers = t4.layers, this.layerIds = this.layers.map((t5) => t5.id), this.index = t4.index, this.hasPattern = false, this.patternFeatures = [], this.lineClipsArray = [], this.gradients = {}, this.layers.forEach((t5) => {
                this.gradients[t5.id] = {};
              }), this.layoutVertexArray = new ya(), this.layoutVertexArray2 = new ma(), this.indexArray = new Aa(), this.programConfigurations = new Qa(t4.layers, t4.zoom), this.segments = new za(), this.maxLineLength = 0, this.stateDependentLayerIds = this.layers.filter((t5) => t5.isStateDependent()).map((t5) => t5.id);
            }
            populate(t4, e4, r5) {
              this.hasPattern = Bo("line", this.layers, e4);
              const n3 = this.layers[0].layout.get("line-sort-key"), i5 = !n3.isConstant(), a5 = [];
              for (const { feature: e5, id: s5, index: o5, sourceLayerIndex: l5 } of t4) {
                const t5 = this.layers[0]._featureFilter.needGeometry, u5 = ss(e5, t5);
                if (!this.layers[0]._featureFilter.filter(new li(this.zoom), u5, r5))
                  continue;
                const c5 = i5 ? n3.evaluate(u5, {}, r5) : void 0, h4 = { id: s5, properties: e5.properties, type: e5.type, sourceLayerIndex: l5, index: o5, geometry: t5 ? u5.geometry : as(e5), patterns: {}, sortKey: c5 };
                a5.push(h4);
              }
              i5 && a5.sort((t5, e5) => t5.sortKey - e5.sortKey);
              for (const n4 of a5) {
                const { geometry: i6, index: a6, sourceLayerIndex: s5 } = n4;
                if (this.hasPattern) {
                  const t5 = Vo("line", this.layers, n4, this.zoom, e4);
                  this.patternFeatures.push(t5);
                } else
                  this.addFeature(n4, i6, a6, r5, {});
                e4.featureIndex.insert(t4[a6].feature, i6, a6, s5, this.index);
              }
            }
            update(t4, e4, r5) {
              this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t4, e4, this.stateDependentLayers, r5);
            }
            addFeatures(t4, e4, r5) {
              for (const t5 of this.patternFeatures)
                this.addFeature(t5, t5.geometry, t5.index, e4, r5);
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length;
            }
            uploadPending() {
              return !this.uploaded || this.programConfigurations.needsUpload;
            }
            upload(t4) {
              this.uploaded || (0 !== this.layoutVertexArray2.length && (this.layoutVertexBuffer2 = t4.createVertexBuffer(this.layoutVertexArray2, fl)), this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, hl), this.indexBuffer = t4.createIndexBuffer(this.indexArray)), this.programConfigurations.upload(t4), this.uploaded = true;
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy());
            }
            lineFeatureClips(t4) {
              if (t4.properties && Object.prototype.hasOwnProperty.call(t4.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t4.properties, "mapbox_clip_end"))
                return { start: +t4.properties.mapbox_clip_start, end: +t4.properties.mapbox_clip_end };
            }
            addFeature(t4, e4, r5, n3, i5) {
              const a5 = this.layers[0].layout, s5 = a5.get("line-join").evaluate(t4, {}), o5 = a5.get("line-cap"), l5 = a5.get("line-miter-limit"), u5 = a5.get("line-round-limit");
              this.lineClips = this.lineFeatureClips(t4);
              for (const r6 of e4)
                this.addLine(r6, t4, s5, o5, l5, u5);
              this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t4, r5, i5, n3);
            }
            addLine(t4, e4, r5, n3, i5, a5) {
              if (this.distance = 0, this.scaledDistance = 0, this.totalDistance = 0, this.lineClips) {
                this.lineClipsArray.push(this.lineClips);
                for (let e5 = 0; e5 < t4.length - 1; e5++)
                  this.totalDistance += t4[e5].dist(t4[e5 + 1]);
                this.updateScaledDistance(), this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance);
              }
              const s5 = "Polygon" === dl[e4.type];
              let o5 = t4.length;
              for (; o5 >= 2 && t4[o5 - 1].equals(t4[o5 - 2]); )
                o5--;
              let l5 = 0;
              for (; l5 < o5 - 1 && t4[l5].equals(t4[l5 + 1]); )
                l5++;
              if (o5 < (s5 ? 3 : 2))
                return;
              "bevel" === r5 && (i5 = 1.05);
              const u5 = this.overscaling <= 16 ? 15 * rs / (512 * this.overscaling) : 0, c5 = this.segments.prepareSegment(10 * o5, this.layoutVertexArray, this.indexArray);
              let h4, p7, f4, d4, y3;
              this.e1 = this.e2 = -1, s5 && (h4 = t4[o5 - 2], y3 = t4[l5].sub(h4)._unit()._perp());
              for (let e5 = l5; e5 < o5; e5++) {
                if (f4 = e5 === o5 - 1 ? s5 ? t4[l5 + 1] : void 0 : t4[e5 + 1], f4 && t4[e5].equals(f4))
                  continue;
                y3 && (d4 = y3), h4 && (p7 = h4), h4 = t4[e5], y3 = f4 ? f4.sub(h4)._unit()._perp() : d4, d4 = d4 || y3;
                let m4 = d4.add(y3);
                0 === m4.x && 0 === m4.y || m4._unit();
                const g4 = d4.x * y3.x + d4.y * y3.y, x3 = m4.x * y3.x + m4.y * y3.y, v5 = 0 !== x3 ? 1 / x3 : 1 / 0, b4 = 2 * Math.sqrt(2 - 2 * x3), w4 = x3 < yl && p7 && f4, _4 = d4.x * y3.y - d4.y * y3.x > 0;
                if (w4 && e5 > l5) {
                  const t5 = h4.dist(p7);
                  if (t5 > 2 * u5) {
                    const e6 = h4.sub(h4.sub(p7)._mult(u5 / t5)._round());
                    this.updateDistance(p7, e6), this.addCurrentVertex(e6, d4, 0, 0, c5), p7 = e6;
                  }
                }
                const A3 = p7 && f4;
                let S3 = A3 ? r5 : s5 ? "butt" : n3;
                if (A3 && "round" === S3 && (v5 < a5 ? S3 = "miter" : v5 <= 2 && (S3 = "fakeround")), "miter" === S3 && v5 > i5 && (S3 = "bevel"), "bevel" === S3 && (v5 > 2 && (S3 = "flipbevel"), v5 < i5 && (S3 = "miter")), p7 && this.updateDistance(p7, h4), "miter" === S3)
                  m4._mult(v5), this.addCurrentVertex(h4, m4, 0, 0, c5);
                else if ("flipbevel" === S3) {
                  if (v5 > 100)
                    m4 = y3.mult(-1);
                  else {
                    const t5 = v5 * d4.add(y3).mag() / d4.sub(y3).mag();
                    m4._perp()._mult(t5 * (_4 ? -1 : 1));
                  }
                  this.addCurrentVertex(h4, m4, 0, 0, c5), this.addCurrentVertex(h4, m4.mult(-1), 0, 0, c5);
                } else if ("bevel" === S3 || "fakeround" === S3) {
                  const t5 = -Math.sqrt(v5 * v5 - 1), e6 = _4 ? t5 : 0, r6 = _4 ? 0 : t5;
                  if (p7 && this.addCurrentVertex(h4, d4, e6, r6, c5), "fakeround" === S3) {
                    const t6 = Math.round(180 * b4 / Math.PI / 20);
                    for (let e7 = 1; e7 < t6; e7++) {
                      let r7 = e7 / t6;
                      if (0.5 !== r7) {
                        const t7 = r7 - 0.5;
                        r7 += r7 * t7 * (r7 - 1) * ((1.0904 + g4 * (g4 * (3.55645 - 1.43519 * g4) - 3.2452)) * t7 * t7 + (0.848013 + g4 * (0.215638 * g4 - 1.06021)));
                      }
                      const n4 = y3.sub(d4)._mult(r7)._add(d4)._unit()._mult(_4 ? -1 : 1);
                      this.addHalfVertex(h4, n4.x, n4.y, false, _4, 0, c5);
                    }
                  }
                  f4 && this.addCurrentVertex(h4, y3, -e6, -r6, c5);
                } else if ("butt" === S3)
                  this.addCurrentVertex(h4, m4, 0, 0, c5);
                else if ("square" === S3) {
                  const t5 = p7 ? 1 : -1;
                  this.addCurrentVertex(h4, m4, t5, t5, c5);
                } else
                  "round" === S3 && (p7 && (this.addCurrentVertex(h4, d4, 0, 0, c5), this.addCurrentVertex(h4, d4, 1, 1, c5, true)), f4 && (this.addCurrentVertex(h4, y3, -1, -1, c5, true), this.addCurrentVertex(h4, y3, 0, 0, c5)));
                if (w4 && e5 < o5 - 1) {
                  const t5 = h4.dist(f4);
                  if (t5 > 2 * u5) {
                    const e6 = h4.add(f4.sub(h4)._mult(u5 / t5)._round());
                    this.updateDistance(h4, e6), this.addCurrentVertex(e6, y3, 0, 0, c5), h4 = e6;
                  }
                }
              }
            }
            addCurrentVertex(t4, e4, r5, n3, i5, a5 = false) {
              const s5 = e4.y * n3 - e4.x, o5 = -e4.y - e4.x * n3;
              this.addHalfVertex(t4, e4.x + e4.y * r5, e4.y - e4.x * r5, a5, false, r5, i5), this.addHalfVertex(t4, s5, o5, a5, true, -n3, i5), this.distance > ml / 2 && 0 === this.totalDistance && (this.distance = 0, this.updateScaledDistance(), this.addCurrentVertex(t4, e4, r5, n3, i5, a5));
            }
            addHalfVertex({ x: t4, y: e4 }, r5, n3, i5, a5, s5, o5) {
              const l5 = 0.5 * (this.lineClips ? this.scaledDistance * (ml - 1) : this.scaledDistance);
              this.layoutVertexArray.emplaceBack((t4 << 1) + (i5 ? 1 : 0), (e4 << 1) + (a5 ? 1 : 0), Math.round(63 * r5) + 128, Math.round(63 * n3) + 128, 1 + (0 === s5 ? 0 : s5 < 0 ? -1 : 1) | (63 & l5) << 2, l5 >> 6), this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
              const u5 = o5.vertexLength++;
              this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, this.e2, u5), o5.primitiveLength++), a5 ? this.e2 = u5 : this.e1 = u5;
            }
            updateScaledDistance() {
              this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance;
            }
            updateDistance(t4, e4) {
              this.distance += t4.dist(e4), this.updateScaledDistance();
            }
          }
          let xl, vl;
          $n("LineBucket", gl, { omit: ["layers", "patternFeatures"] });
          var bl = { get paint() {
            return vl = vl || new _i({ "line-opacity": new xi(X.paint_line["line-opacity"]), "line-color": new xi(X.paint_line["line-color"]), "line-translate": new gi(X.paint_line["line-translate"]), "line-translate-anchor": new gi(X.paint_line["line-translate-anchor"]), "line-width": new xi(X.paint_line["line-width"]), "line-gap-width": new xi(X.paint_line["line-gap-width"]), "line-offset": new xi(X.paint_line["line-offset"]), "line-blur": new xi(X.paint_line["line-blur"]), "line-dasharray": new bi(X.paint_line["line-dasharray"]), "line-pattern": new vi(X.paint_line["line-pattern"]), "line-gradient": new wi(X.paint_line["line-gradient"]) });
          }, get layout() {
            return xl = xl || new _i({ "line-cap": new gi(X.layout_line["line-cap"]), "line-join": new xi(X.layout_line["line-join"]), "line-miter-limit": new gi(X.layout_line["line-miter-limit"]), "line-round-limit": new gi(X.layout_line["line-round-limit"]), "line-sort-key": new xi(X.layout_line["line-sort-key"]) });
          } };
          class wl extends xi {
            possiblyEvaluate(t4, e4) {
              return e4 = new li(Math.floor(e4.zoom), { now: e4.now, fadeDuration: e4.fadeDuration, zoomHistory: e4.zoomHistory, transition: e4.transition }), super.possiblyEvaluate(t4, e4);
            }
            evaluate(t4, e4, r5, n3) {
              return e4 = m3({}, e4, { zoom: Math.floor(e4.zoom) }), super.evaluate(t4, e4, r5, n3);
            }
          }
          let _l;
          class Al extends Si {
            constructor(t4) {
              super(t4, bl), this.gradientVersion = 0, _l || (_l = new wl(bl.paint.properties["line-width"].specification), _l.useIntegerZoom = true);
            }
            _handleSpecialPaintPropertyUpdate(t4) {
              if ("line-gradient" === t4) {
                const t5 = this.gradientExpression();
                this.stepInterpolant = !!function(t6) {
                  return void 0 !== t6._styleExpression;
                }(t5) && t5._styleExpression.expression instanceof qe, this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER;
              }
            }
            gradientExpression() {
              return this._transitionablePaint._values["line-gradient"].value.expression;
            }
            recalculate(t4, e4) {
              super.recalculate(t4, e4), this.paint._values["line-floorwidth"] = _l.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t4);
            }
            createBucket(t4) {
              return new gl(t4);
            }
            queryRadius(t4) {
              const e4 = t4, r5 = Sl(bs("line-width", this, e4), bs("line-gap-width", this, e4)), n3 = bs("line-offset", this, e4);
              return r5 / 2 + Math.abs(n3) + ws(this.paint.get("line-translate"));
            }
            queryIntersectsFeature(t4, e4, r5, n3, a5, s5, o5) {
              const l5 = _s(t4, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), s5.angle, o5), u5 = o5 / 2 * Sl(this.paint.get("line-width").evaluate(e4, r5), this.paint.get("line-gap-width").evaluate(e4, r5)), c5 = this.paint.get("line-offset").evaluate(e4, r5);
              return c5 && (n3 = function(t5, e5) {
                const r6 = [];
                for (let n4 = 0; n4 < t5.length; n4++) {
                  const a6 = t5[n4], s6 = [];
                  for (let t6 = 0; t6 < a6.length; t6++) {
                    const r7 = a6[t6 - 1], n5 = a6[t6], o6 = a6[t6 + 1], l6 = 0 === t6 ? new i4(0, 0) : n5.sub(r7)._unit()._perp(), u6 = t6 === a6.length - 1 ? new i4(0, 0) : o6.sub(n5)._unit()._perp(), c6 = l6._add(u6)._unit(), h4 = c6.x * u6.x + c6.y * u6.y;
                    0 !== h4 && c6._mult(1 / h4), s6.push(c6._mult(e5)._add(n5));
                  }
                  r6.push(s6);
                }
                return r6;
              }(n3, c5 * o5)), function(t5, e5, r6) {
                for (let n4 = 0; n4 < e5.length; n4++) {
                  const i5 = e5[n4];
                  if (t5.length >= 3) {
                    for (let e6 = 0; e6 < i5.length; e6++)
                      if (xs(t5, i5[e6]))
                        return true;
                  }
                  if (ps(t5, i5, r6))
                    return true;
                }
                return false;
              }(l5, n3, u5);
            }
            isTileClipped() {
              return true;
            }
          }
          function Sl(t4, e4) {
            return e4 > 0 ? e4 + 2 * t4 : t4;
          }
          const kl = Mi([{ name: "a_pos_offset", components: 4, type: "Int16" }, { name: "a_data", components: 4, type: "Uint16" }, { name: "a_pixeloffset", components: 4, type: "Int16" }], 4), Il = Mi([{ name: "a_projected_pos", components: 3, type: "Float32" }], 4);
          Mi([{ name: "a_fade_opacity", components: 1, type: "Uint32" }], 4);
          const zl = Mi([{ name: "a_placed", components: 2, type: "Uint8" }, { name: "a_shift", components: 2, type: "Float32" }]);
          Mi([{ type: "Int16", name: "anchorPointX" }, { type: "Int16", name: "anchorPointY" }, { type: "Int16", name: "x1" }, { type: "Int16", name: "y1" }, { type: "Int16", name: "x2" }, { type: "Int16", name: "y2" }, { type: "Uint32", name: "featureIndex" }, { type: "Uint16", name: "sourceLayerIndex" }, { type: "Uint16", name: "bucketIndex" }]);
          const Ml = Mi([{ name: "a_pos", components: 2, type: "Int16" }, { name: "a_anchor_pos", components: 2, type: "Int16" }, { name: "a_extrude", components: 2, type: "Int16" }], 4), Pl = Mi([{ name: "a_pos", components: 2, type: "Float32" }, { name: "a_radius", components: 1, type: "Float32" }, { name: "a_flags", components: 2, type: "Int16" }], 4);
          function Cl(t4, e4, r5) {
            return t4.sections.forEach((t5) => {
              t5.text = function(t6, e5, r6) {
                const n3 = e5.layout.get("text-transform").evaluate(r6, {});
                return "uppercase" === n3 ? t6 = t6.toLocaleUpperCase() : "lowercase" === n3 && (t6 = t6.toLocaleLowerCase()), oi.applyArabicShaping && (t6 = oi.applyArabicShaping(t6)), t6;
              }(t5.text, e4, r5);
            }), t4;
          }
          Mi([{ name: "triangle", components: 3, type: "Uint16" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Uint16", name: "glyphStartIndex" }, { type: "Uint16", name: "numGlyphs" }, { type: "Uint32", name: "vertexStartIndex" }, { type: "Uint32", name: "lineStartIndex" }, { type: "Uint32", name: "lineLength" }, { type: "Uint16", name: "segment" }, { type: "Uint16", name: "lowerSize" }, { type: "Uint16", name: "upperSize" }, { type: "Float32", name: "lineOffsetX" }, { type: "Float32", name: "lineOffsetY" }, { type: "Uint8", name: "writingMode" }, { type: "Uint8", name: "placedOrientation" }, { type: "Uint8", name: "hidden" }, { type: "Uint32", name: "crossTileID" }, { type: "Int16", name: "associatedIconIndex" }]), Mi([{ type: "Int16", name: "anchorX" }, { type: "Int16", name: "anchorY" }, { type: "Int16", name: "rightJustifiedTextSymbolIndex" }, { type: "Int16", name: "centerJustifiedTextSymbolIndex" }, { type: "Int16", name: "leftJustifiedTextSymbolIndex" }, { type: "Int16", name: "verticalPlacedTextSymbolIndex" }, { type: "Int16", name: "placedIconSymbolIndex" }, { type: "Int16", name: "verticalPlacedIconSymbolIndex" }, { type: "Uint16", name: "key" }, { type: "Uint16", name: "textBoxStartIndex" }, { type: "Uint16", name: "textBoxEndIndex" }, { type: "Uint16", name: "verticalTextBoxStartIndex" }, { type: "Uint16", name: "verticalTextBoxEndIndex" }, { type: "Uint16", name: "iconBoxStartIndex" }, { type: "Uint16", name: "iconBoxEndIndex" }, { type: "Uint16", name: "verticalIconBoxStartIndex" }, { type: "Uint16", name: "verticalIconBoxEndIndex" }, { type: "Uint16", name: "featureIndex" }, { type: "Uint16", name: "numHorizontalGlyphVertices" }, { type: "Uint16", name: "numVerticalGlyphVertices" }, { type: "Uint16", name: "numIconVertices" }, { type: "Uint16", name: "numVerticalIconVertices" }, { type: "Uint16", name: "useRuntimeCollisionCircles" }, { type: "Uint32", name: "crossTileID" }, { type: "Float32", name: "textBoxScale" }, { type: "Float32", name: "collisionCircleDiameter" }, { type: "Uint16", name: "textAnchorOffsetStartIndex" }, { type: "Uint16", name: "textAnchorOffsetEndIndex" }]), Mi([{ type: "Float32", name: "offsetX" }]), Mi([{ type: "Int16", name: "x" }, { type: "Int16", name: "y" }, { type: "Int16", name: "tileUnitDistanceFromAnchor" }]), Mi([{ type: "Uint16", name: "textAnchor" }, { type: "Float32", components: 2, name: "textOffset" }]);
          const Bl = { "!": "\uFE15", "#": "\uFF03", $: "\uFF04", "%": "\uFF05", "&": "\uFF06", "(": "\uFE35", ")": "\uFE36", "*": "\uFF0A", "+": "\uFF0B", ",": "\uFE10", "-": "\uFE32", ".": "\u30FB", "/": "\uFF0F", ":": "\uFE13", ";": "\uFE14", "<": "\uFE3F", "=": "\uFF1D", ">": "\uFE40", "?": "\uFE16", "@": "\uFF20", "[": "\uFE47", "\\": "\uFF3C", "]": "\uFE48", "^": "\uFF3E", _: "\uFE33", "`": "\uFF40", "{": "\uFE37", "|": "\u2015", "}": "\uFE38", "~": "\uFF5E", "\xA2": "\uFFE0", "\xA3": "\uFFE1", "\xA5": "\uFFE5", "\xA6": "\uFFE4", "\xAC": "\uFFE2", "\xAF": "\uFFE3", "\u2013": "\uFE32", "\u2014": "\uFE31", "\u2018": "\uFE43", "\u2019": "\uFE44", "\u201C": "\uFE41", "\u201D": "\uFE42", "\u2026": "\uFE19", "\u2027": "\u30FB", "\u20A9": "\uFFE6", "\u3001": "\uFE11", "\u3002": "\uFE12", "\u3008": "\uFE3F", "\u3009": "\uFE40", "\u300A": "\uFE3D", "\u300B": "\uFE3E", "\u300C": "\uFE41", "\u300D": "\uFE42", "\u300E": "\uFE43", "\u300F": "\uFE44", "\u3010": "\uFE3B", "\u3011": "\uFE3C", "\u3014": "\uFE39", "\u3015": "\uFE3A", "\u3016": "\uFE17", "\u3017": "\uFE18", "\uFF01": "\uFE15", "\uFF08": "\uFE35", "\uFF09": "\uFE36", "\uFF0C": "\uFE10", "\uFF0D": "\uFE32", "\uFF0E": "\u30FB", "\uFF1A": "\uFE13", "\uFF1B": "\uFE14", "\uFF1C": "\uFE3F", "\uFF1E": "\uFE40", "\uFF1F": "\uFE16", "\uFF3B": "\uFE47", "\uFF3D": "\uFE48", "\uFF3F": "\uFE33", "\uFF5B": "\uFE37", "\uFF5C": "\u2015", "\uFF5D": "\uFE38", "\uFF5F": "\uFE35", "\uFF60": "\uFE36", "\uFF61": "\uFE12", "\uFF62": "\uFE41", "\uFF63": "\uFE42" };
          var Vl = 24, El = $l, Fl = function(t4, e4, r5, n3, i5) {
            var a5, s5, o5 = 8 * i5 - n3 - 1, l5 = (1 << o5) - 1, u5 = l5 >> 1, c5 = -7, h4 = r5 ? i5 - 1 : 0, p7 = r5 ? -1 : 1, f4 = t4[e4 + h4];
            for (h4 += p7, a5 = f4 & (1 << -c5) - 1, f4 >>= -c5, c5 += o5; c5 > 0; a5 = 256 * a5 + t4[e4 + h4], h4 += p7, c5 -= 8)
              ;
            for (s5 = a5 & (1 << -c5) - 1, a5 >>= -c5, c5 += n3; c5 > 0; s5 = 256 * s5 + t4[e4 + h4], h4 += p7, c5 -= 8)
              ;
            if (0 === a5)
              a5 = 1 - u5;
            else {
              if (a5 === l5)
                return s5 ? NaN : 1 / 0 * (f4 ? -1 : 1);
              s5 += Math.pow(2, n3), a5 -= u5;
            }
            return (f4 ? -1 : 1) * s5 * Math.pow(2, a5 - n3);
          }, Tl = function(t4, e4, r5, n3, i5, a5) {
            var s5, o5, l5, u5 = 8 * a5 - i5 - 1, c5 = (1 << u5) - 1, h4 = c5 >> 1, p7 = 23 === i5 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, f4 = n3 ? 0 : a5 - 1, d4 = n3 ? 1 : -1, y3 = e4 < 0 || 0 === e4 && 1 / e4 < 0 ? 1 : 0;
            for (e4 = Math.abs(e4), isNaN(e4) || e4 === 1 / 0 ? (o5 = isNaN(e4) ? 1 : 0, s5 = c5) : (s5 = Math.floor(Math.log(e4) / Math.LN2), e4 * (l5 = Math.pow(2, -s5)) < 1 && (s5--, l5 *= 2), (e4 += s5 + h4 >= 1 ? p7 / l5 : p7 * Math.pow(2, 1 - h4)) * l5 >= 2 && (s5++, l5 /= 2), s5 + h4 >= c5 ? (o5 = 0, s5 = c5) : s5 + h4 >= 1 ? (o5 = (e4 * l5 - 1) * Math.pow(2, i5), s5 += h4) : (o5 = e4 * Math.pow(2, h4 - 1) * Math.pow(2, i5), s5 = 0)); i5 >= 8; t4[r5 + f4] = 255 & o5, f4 += d4, o5 /= 256, i5 -= 8)
              ;
            for (s5 = s5 << i5 | o5, u5 += i5; u5 > 0; t4[r5 + f4] = 255 & s5, f4 += d4, s5 /= 256, u5 -= 8)
              ;
            t4[r5 + f4 - d4] |= 128 * y3;
          };
          function $l(t4) {
            this.buf = ArrayBuffer.isView && ArrayBuffer.isView(t4) ? t4 : new Uint8Array(t4 || 0), this.pos = 0, this.type = 0, this.length = this.buf.length;
          }
          $l.Varint = 0, $l.Fixed64 = 1, $l.Bytes = 2, $l.Fixed32 = 5;
          var Ll = 4294967296, Dl = 1 / Ll, Ol = "undefined" == typeof TextDecoder ? null : new TextDecoder("utf8");
          function Ul(t4) {
            return t4.type === $l.Bytes ? t4.readVarint() + t4.pos : t4.pos + 1;
          }
          function Rl(t4, e4, r5) {
            return r5 ? 4294967296 * e4 + (t4 >>> 0) : 4294967296 * (e4 >>> 0) + (t4 >>> 0);
          }
          function ql(t4, e4, r5) {
            var n3 = e4 <= 16383 ? 1 : e4 <= 2097151 ? 2 : e4 <= 268435455 ? 3 : Math.floor(Math.log(e4) / (7 * Math.LN2));
            r5.realloc(n3);
            for (var i5 = r5.pos - 1; i5 >= t4; i5--)
              r5.buf[i5 + n3] = r5.buf[i5];
          }
          function jl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeVarint(t4[r5]);
          }
          function Nl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeSVarint(t4[r5]);
          }
          function Zl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeFloat(t4[r5]);
          }
          function Kl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeDouble(t4[r5]);
          }
          function Gl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeBoolean(t4[r5]);
          }
          function Jl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeFixed32(t4[r5]);
          }
          function Xl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeSFixed32(t4[r5]);
          }
          function Yl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeFixed64(t4[r5]);
          }
          function Hl(t4, e4) {
            for (var r5 = 0; r5 < t4.length; r5++)
              e4.writeSFixed64(t4[r5]);
          }
          function Wl(t4, e4) {
            return (t4[e4] | t4[e4 + 1] << 8 | t4[e4 + 2] << 16) + 16777216 * t4[e4 + 3];
          }
          function Ql(t4, e4, r5) {
            t4[r5] = e4, t4[r5 + 1] = e4 >>> 8, t4[r5 + 2] = e4 >>> 16, t4[r5 + 3] = e4 >>> 24;
          }
          function tu(t4, e4) {
            return (t4[e4] | t4[e4 + 1] << 8 | t4[e4 + 2] << 16) + (t4[e4 + 3] << 24);
          }
          $l.prototype = { destroy: function() {
            this.buf = null;
          }, readFields: function(t4, e4, r5) {
            for (r5 = r5 || this.length; this.pos < r5; ) {
              var n3 = this.readVarint(), i5 = n3 >> 3, a5 = this.pos;
              this.type = 7 & n3, t4(i5, e4, this), this.pos === a5 && this.skip(n3);
            }
            return e4;
          }, readMessage: function(t4, e4) {
            return this.readFields(t4, e4, this.readVarint() + this.pos);
          }, readFixed32: function() {
            var t4 = Wl(this.buf, this.pos);
            return this.pos += 4, t4;
          }, readSFixed32: function() {
            var t4 = tu(this.buf, this.pos);
            return this.pos += 4, t4;
          }, readFixed64: function() {
            var t4 = Wl(this.buf, this.pos) + Wl(this.buf, this.pos + 4) * Ll;
            return this.pos += 8, t4;
          }, readSFixed64: function() {
            var t4 = Wl(this.buf, this.pos) + tu(this.buf, this.pos + 4) * Ll;
            return this.pos += 8, t4;
          }, readFloat: function() {
            var t4 = Fl(this.buf, this.pos, true, 23, 4);
            return this.pos += 4, t4;
          }, readDouble: function() {
            var t4 = Fl(this.buf, this.pos, true, 52, 8);
            return this.pos += 8, t4;
          }, readVarint: function(t4) {
            var e4, r5, n3 = this.buf;
            return e4 = 127 & (r5 = n3[this.pos++]), r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 7, r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 14, r5 < 128 ? e4 : (e4 |= (127 & (r5 = n3[this.pos++])) << 21, r5 < 128 ? e4 : function(t5, e5, r6) {
              var n4, i5, a5 = r6.buf;
              if (n4 = (112 & (i5 = a5[r6.pos++])) >> 4, i5 < 128)
                return Rl(t5, n4, e5);
              if (n4 |= (127 & (i5 = a5[r6.pos++])) << 3, i5 < 128)
                return Rl(t5, n4, e5);
              if (n4 |= (127 & (i5 = a5[r6.pos++])) << 10, i5 < 128)
                return Rl(t5, n4, e5);
              if (n4 |= (127 & (i5 = a5[r6.pos++])) << 17, i5 < 128)
                return Rl(t5, n4, e5);
              if (n4 |= (127 & (i5 = a5[r6.pos++])) << 24, i5 < 128)
                return Rl(t5, n4, e5);
              if (n4 |= (1 & (i5 = a5[r6.pos++])) << 31, i5 < 128)
                return Rl(t5, n4, e5);
              throw new Error("Expected varint not more than 10 bytes");
            }(e4 |= (15 & (r5 = n3[this.pos])) << 28, t4, this))));
          }, readVarint64: function() {
            return this.readVarint(true);
          }, readSVarint: function() {
            var t4 = this.readVarint();
            return t4 % 2 == 1 ? (t4 + 1) / -2 : t4 / 2;
          }, readBoolean: function() {
            return Boolean(this.readVarint());
          }, readString: function() {
            var t4 = this.readVarint() + this.pos, e4 = this.pos;
            return this.pos = t4, t4 - e4 >= 12 && Ol ? function(t5, e5, r5) {
              return Ol.decode(t5.subarray(e5, r5));
            }(this.buf, e4, t4) : function(t5, e5, r5) {
              for (var n3 = "", i5 = e5; i5 < r5; ) {
                var a5, s5, o5, l5 = t5[i5], u5 = null, c5 = l5 > 239 ? 4 : l5 > 223 ? 3 : l5 > 191 ? 2 : 1;
                if (i5 + c5 > r5)
                  break;
                1 === c5 ? l5 < 128 && (u5 = l5) : 2 === c5 ? 128 == (192 & (a5 = t5[i5 + 1])) && (u5 = (31 & l5) << 6 | 63 & a5) <= 127 && (u5 = null) : 3 === c5 ? (s5 = t5[i5 + 2], 128 == (192 & (a5 = t5[i5 + 1])) && 128 == (192 & s5) && ((u5 = (15 & l5) << 12 | (63 & a5) << 6 | 63 & s5) <= 2047 || u5 >= 55296 && u5 <= 57343) && (u5 = null)) : 4 === c5 && (s5 = t5[i5 + 2], o5 = t5[i5 + 3], 128 == (192 & (a5 = t5[i5 + 1])) && 128 == (192 & s5) && 128 == (192 & o5) && ((u5 = (15 & l5) << 18 | (63 & a5) << 12 | (63 & s5) << 6 | 63 & o5) <= 65535 || u5 >= 1114112) && (u5 = null)), null === u5 ? (u5 = 65533, c5 = 1) : u5 > 65535 && (u5 -= 65536, n3 += String.fromCharCode(u5 >>> 10 & 1023 | 55296), u5 = 56320 | 1023 & u5), n3 += String.fromCharCode(u5), i5 += c5;
              }
              return n3;
            }(this.buf, e4, t4);
          }, readBytes: function() {
            var t4 = this.readVarint() + this.pos, e4 = this.buf.subarray(this.pos, t4);
            return this.pos = t4, e4;
          }, readPackedVarint: function(t4, e4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readVarint(e4));
            var r5 = Ul(this);
            for (t4 = t4 || []; this.pos < r5; )
              t4.push(this.readVarint(e4));
            return t4;
          }, readPackedSVarint: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readSVarint());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readSVarint());
            return t4;
          }, readPackedBoolean: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readBoolean());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readBoolean());
            return t4;
          }, readPackedFloat: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readFloat());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readFloat());
            return t4;
          }, readPackedDouble: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readDouble());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readDouble());
            return t4;
          }, readPackedFixed32: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readFixed32());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readFixed32());
            return t4;
          }, readPackedSFixed32: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readSFixed32());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readSFixed32());
            return t4;
          }, readPackedFixed64: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readFixed64());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readFixed64());
            return t4;
          }, readPackedSFixed64: function(t4) {
            if (this.type !== $l.Bytes)
              return t4.push(this.readSFixed64());
            var e4 = Ul(this);
            for (t4 = t4 || []; this.pos < e4; )
              t4.push(this.readSFixed64());
            return t4;
          }, skip: function(t4) {
            var e4 = 7 & t4;
            if (e4 === $l.Varint)
              for (; this.buf[this.pos++] > 127; )
                ;
            else if (e4 === $l.Bytes)
              this.pos = this.readVarint() + this.pos;
            else if (e4 === $l.Fixed32)
              this.pos += 4;
            else {
              if (e4 !== $l.Fixed64)
                throw new Error("Unimplemented type: " + e4);
              this.pos += 8;
            }
          }, writeTag: function(t4, e4) {
            this.writeVarint(t4 << 3 | e4);
          }, realloc: function(t4) {
            for (var e4 = this.length || 16; e4 < this.pos + t4; )
              e4 *= 2;
            if (e4 !== this.length) {
              var r5 = new Uint8Array(e4);
              r5.set(this.buf), this.buf = r5, this.length = e4;
            }
          }, finish: function() {
            return this.length = this.pos, this.pos = 0, this.buf.subarray(0, this.length);
          }, writeFixed32: function(t4) {
            this.realloc(4), Ql(this.buf, t4, this.pos), this.pos += 4;
          }, writeSFixed32: function(t4) {
            this.realloc(4), Ql(this.buf, t4, this.pos), this.pos += 4;
          }, writeFixed64: function(t4) {
            this.realloc(8), Ql(this.buf, -1 & t4, this.pos), Ql(this.buf, Math.floor(t4 * Dl), this.pos + 4), this.pos += 8;
          }, writeSFixed64: function(t4) {
            this.realloc(8), Ql(this.buf, -1 & t4, this.pos), Ql(this.buf, Math.floor(t4 * Dl), this.pos + 4), this.pos += 8;
          }, writeVarint: function(t4) {
            (t4 = +t4 || 0) > 268435455 || t4 < 0 ? function(t5, e4) {
              var r5, n3;
              if (t5 >= 0 ? (r5 = t5 % 4294967296 | 0, n3 = t5 / 4294967296 | 0) : (n3 = ~(-t5 / 4294967296), 4294967295 ^ (r5 = ~(-t5 % 4294967296)) ? r5 = r5 + 1 | 0 : (r5 = 0, n3 = n3 + 1 | 0)), t5 >= 18446744073709552e3 || t5 < -18446744073709552e3)
                throw new Error("Given varint doesn't fit into 10 bytes");
              e4.realloc(10), function(t6, e5, r6) {
                r6.buf[r6.pos++] = 127 & t6 | 128, t6 >>>= 7, r6.buf[r6.pos++] = 127 & t6 | 128, t6 >>>= 7, r6.buf[r6.pos++] = 127 & t6 | 128, t6 >>>= 7, r6.buf[r6.pos++] = 127 & t6 | 128, r6.buf[r6.pos] = 127 & (t6 >>>= 7);
              }(r5, 0, e4), function(t6, e5) {
                var r6 = (7 & t6) << 4;
                e5.buf[e5.pos++] |= r6 | ((t6 >>>= 3) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6 | ((t6 >>>= 7) ? 128 : 0), t6 && (e5.buf[e5.pos++] = 127 & t6)))));
              }(n3, e4);
            }(t4, this) : (this.realloc(4), this.buf[this.pos++] = 127 & t4 | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = 127 & (t4 >>>= 7) | (t4 > 127 ? 128 : 0), t4 <= 127 || (this.buf[this.pos++] = t4 >>> 7 & 127))));
          }, writeSVarint: function(t4) {
            this.writeVarint(t4 < 0 ? 2 * -t4 - 1 : 2 * t4);
          }, writeBoolean: function(t4) {
            this.writeVarint(Boolean(t4));
          }, writeString: function(t4) {
            t4 = String(t4), this.realloc(4 * t4.length), this.pos++;
            var e4 = this.pos;
            this.pos = function(t5, e5, r6) {
              for (var n3, i5, a5 = 0; a5 < e5.length; a5++) {
                if ((n3 = e5.charCodeAt(a5)) > 55295 && n3 < 57344) {
                  if (!i5) {
                    n3 > 56319 || a5 + 1 === e5.length ? (t5[r6++] = 239, t5[r6++] = 191, t5[r6++] = 189) : i5 = n3;
                    continue;
                  }
                  if (n3 < 56320) {
                    t5[r6++] = 239, t5[r6++] = 191, t5[r6++] = 189, i5 = n3;
                    continue;
                  }
                  n3 = i5 - 55296 << 10 | n3 - 56320 | 65536, i5 = null;
                } else
                  i5 && (t5[r6++] = 239, t5[r6++] = 191, t5[r6++] = 189, i5 = null);
                n3 < 128 ? t5[r6++] = n3 : (n3 < 2048 ? t5[r6++] = n3 >> 6 | 192 : (n3 < 65536 ? t5[r6++] = n3 >> 12 | 224 : (t5[r6++] = n3 >> 18 | 240, t5[r6++] = n3 >> 12 & 63 | 128), t5[r6++] = n3 >> 6 & 63 | 128), t5[r6++] = 63 & n3 | 128);
              }
              return r6;
            }(this.buf, t4, this.pos);
            var r5 = this.pos - e4;
            r5 >= 128 && ql(e4, r5, this), this.pos = e4 - 1, this.writeVarint(r5), this.pos += r5;
          }, writeFloat: function(t4) {
            this.realloc(4), Tl(this.buf, t4, this.pos, true, 23, 4), this.pos += 4;
          }, writeDouble: function(t4) {
            this.realloc(8), Tl(this.buf, t4, this.pos, true, 52, 8), this.pos += 8;
          }, writeBytes: function(t4) {
            var e4 = t4.length;
            this.writeVarint(e4), this.realloc(e4);
            for (var r5 = 0; r5 < e4; r5++)
              this.buf[this.pos++] = t4[r5];
          }, writeRawMessage: function(t4, e4) {
            this.pos++;
            var r5 = this.pos;
            t4(e4, this);
            var n3 = this.pos - r5;
            n3 >= 128 && ql(r5, n3, this), this.pos = r5 - 1, this.writeVarint(n3), this.pos += n3;
          }, writeMessage: function(t4, e4, r5) {
            this.writeTag(t4, $l.Bytes), this.writeRawMessage(e4, r5);
          }, writePackedVarint: function(t4, e4) {
            e4.length && this.writeMessage(t4, jl, e4);
          }, writePackedSVarint: function(t4, e4) {
            e4.length && this.writeMessage(t4, Nl, e4);
          }, writePackedBoolean: function(t4, e4) {
            e4.length && this.writeMessage(t4, Gl, e4);
          }, writePackedFloat: function(t4, e4) {
            e4.length && this.writeMessage(t4, Zl, e4);
          }, writePackedDouble: function(t4, e4) {
            e4.length && this.writeMessage(t4, Kl, e4);
          }, writePackedFixed32: function(t4, e4) {
            e4.length && this.writeMessage(t4, Jl, e4);
          }, writePackedSFixed32: function(t4, e4) {
            e4.length && this.writeMessage(t4, Xl, e4);
          }, writePackedFixed64: function(t4, e4) {
            e4.length && this.writeMessage(t4, Yl, e4);
          }, writePackedSFixed64: function(t4, e4) {
            e4.length && this.writeMessage(t4, Hl, e4);
          }, writeBytesField: function(t4, e4) {
            this.writeTag(t4, $l.Bytes), this.writeBytes(e4);
          }, writeFixed32Field: function(t4, e4) {
            this.writeTag(t4, $l.Fixed32), this.writeFixed32(e4);
          }, writeSFixed32Field: function(t4, e4) {
            this.writeTag(t4, $l.Fixed32), this.writeSFixed32(e4);
          }, writeFixed64Field: function(t4, e4) {
            this.writeTag(t4, $l.Fixed64), this.writeFixed64(e4);
          }, writeSFixed64Field: function(t4, e4) {
            this.writeTag(t4, $l.Fixed64), this.writeSFixed64(e4);
          }, writeVarintField: function(t4, e4) {
            this.writeTag(t4, $l.Varint), this.writeVarint(e4);
          }, writeSVarintField: function(t4, e4) {
            this.writeTag(t4, $l.Varint), this.writeSVarint(e4);
          }, writeStringField: function(t4, e4) {
            this.writeTag(t4, $l.Bytes), this.writeString(e4);
          }, writeFloatField: function(t4, e4) {
            this.writeTag(t4, $l.Fixed32), this.writeFloat(e4);
          }, writeDoubleField: function(t4, e4) {
            this.writeTag(t4, $l.Fixed64), this.writeDouble(e4);
          }, writeBooleanField: function(t4, e4) {
            this.writeVarintField(t4, Boolean(e4));
          } };
          var eu = e3(El);
          const ru = 3;
          function nu(t4, e4, r5) {
            1 === t4 && r5.readMessage(iu, e4);
          }
          function iu(t4, e4, r5) {
            if (3 === t4) {
              const { id: t5, bitmap: n3, width: i5, height: a5, left: s5, top: o5, advance: l5 } = r5.readMessage(au, {});
              e4.push({ id: t5, bitmap: new Rs({ width: i5 + 2 * ru, height: a5 + 2 * ru }, n3), metrics: { width: i5, height: a5, left: s5, top: o5, advance: l5 } });
            }
          }
          function au(t4, e4, r5) {
            1 === t4 ? e4.id = r5.readVarint() : 2 === t4 ? e4.bitmap = r5.readBytes() : 3 === t4 ? e4.width = r5.readVarint() : 4 === t4 ? e4.height = r5.readVarint() : 5 === t4 ? e4.left = r5.readSVarint() : 6 === t4 ? e4.top = r5.readSVarint() : 7 === t4 && (e4.advance = r5.readVarint());
          }
          const su = ru;
          function ou(t4) {
            let e4 = 0, r5 = 0;
            for (const n4 of t4)
              e4 += n4.w * n4.h, r5 = Math.max(r5, n4.w);
            t4.sort((t5, e5) => e5.h - t5.h);
            const n3 = [{ x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(e4 / 0.95)), r5), h: 1 / 0 }];
            let i5 = 0, a5 = 0;
            for (const e5 of t4)
              for (let t5 = n3.length - 1; t5 >= 0; t5--) {
                const r6 = n3[t5];
                if (!(e5.w > r6.w || e5.h > r6.h)) {
                  if (e5.x = r6.x, e5.y = r6.y, a5 = Math.max(a5, e5.y + e5.h), i5 = Math.max(i5, e5.x + e5.w), e5.w === r6.w && e5.h === r6.h) {
                    const e6 = n3.pop();
                    t5 < n3.length && (n3[t5] = e6);
                  } else
                    e5.h === r6.h ? (r6.x += e5.w, r6.w -= e5.w) : e5.w === r6.w ? (r6.y += e5.h, r6.h -= e5.h) : (n3.push({ x: r6.x + e5.w, y: r6.y, w: r6.w - e5.w, h: e5.h }), r6.y += e5.h, r6.h -= e5.h);
                  break;
                }
              }
            return { w: i5, h: a5, fill: e4 / (i5 * a5) || 0 };
          }
          const lu = 1;
          class uu {
            constructor(t4, { pixelRatio: e4, version: r5, stretchX: n3, stretchY: i5, content: a5 }) {
              this.paddedRect = t4, this.pixelRatio = e4, this.stretchX = n3, this.stretchY = i5, this.content = a5, this.version = r5;
            }
            get tl() {
              return [this.paddedRect.x + lu, this.paddedRect.y + lu];
            }
            get br() {
              return [this.paddedRect.x + this.paddedRect.w - lu, this.paddedRect.y + this.paddedRect.h - lu];
            }
            get tlbr() {
              return this.tl.concat(this.br);
            }
            get displaySize() {
              return [(this.paddedRect.w - 2 * lu) / this.pixelRatio, (this.paddedRect.h - 2 * lu) / this.pixelRatio];
            }
          }
          class cu {
            constructor(t4, e4) {
              const r5 = {}, n3 = {};
              this.haveRenderCallbacks = [];
              const i5 = [];
              this.addImages(t4, r5, i5), this.addImages(e4, n3, i5);
              const { w: a5, h: s5 } = ou(i5), o5 = new qs({ width: a5 || 1, height: s5 || 1 });
              for (const e5 in t4) {
                const n4 = t4[e5], i6 = r5[e5].paddedRect;
                qs.copy(n4.data, o5, { x: 0, y: 0 }, { x: i6.x + lu, y: i6.y + lu }, n4.data);
              }
              for (const t5 in e4) {
                const r6 = e4[t5], i6 = n3[t5].paddedRect, a6 = i6.x + lu, s6 = i6.y + lu, l5 = r6.data.width, u5 = r6.data.height;
                qs.copy(r6.data, o5, { x: 0, y: 0 }, { x: a6, y: s6 }, r6.data), qs.copy(r6.data, o5, { x: 0, y: u5 - 1 }, { x: a6, y: s6 - 1 }, { width: l5, height: 1 }), qs.copy(r6.data, o5, { x: 0, y: 0 }, { x: a6, y: s6 + u5 }, { width: l5, height: 1 }), qs.copy(r6.data, o5, { x: l5 - 1, y: 0 }, { x: a6 - 1, y: s6 }, { width: 1, height: u5 }), qs.copy(r6.data, o5, { x: 0, y: 0 }, { x: a6 + l5, y: s6 }, { width: 1, height: u5 });
              }
              this.image = o5, this.iconPositions = r5, this.patternPositions = n3;
            }
            addImages(t4, e4, r5) {
              for (const n3 in t4) {
                const i5 = t4[n3], a5 = { x: 0, y: 0, w: i5.data.width + 2 * lu, h: i5.data.height + 2 * lu };
                r5.push(a5), e4[n3] = new uu(a5, i5), i5.hasRenderCallback && this.haveRenderCallbacks.push(n3);
              }
            }
            patchUpdatedImages(t4, e4) {
              t4.dispatchRenderCallbacks(this.haveRenderCallbacks);
              for (const r5 in t4.updatedImages)
                this.patchUpdatedImage(this.iconPositions[r5], t4.getImage(r5), e4), this.patchUpdatedImage(this.patternPositions[r5], t4.getImage(r5), e4);
            }
            patchUpdatedImage(t4, e4, r5) {
              if (!t4 || !e4)
                return;
              if (t4.version === e4.version)
                return;
              t4.version = e4.version;
              const [n3, i5] = t4.tl;
              r5.update(e4.data, void 0, { x: n3, y: i5 });
            }
          }
          var hu;
          $n("ImagePosition", uu), $n("ImageAtlas", cu), t3.WritingMode = void 0, (hu = t3.WritingMode || (t3.WritingMode = {}))[hu.none = 0] = "none", hu[hu.horizontal = 1] = "horizontal", hu[hu.vertical = 2] = "vertical", hu[hu.horizontalOnly = 3] = "horizontalOnly";
          const pu = -17;
          class fu {
            constructor() {
              this.scale = 1, this.fontStack = "", this.imageName = null;
            }
            static forText(t4, e4) {
              const r5 = new fu();
              return r5.scale = t4 || 1, r5.fontStack = e4, r5;
            }
            static forImage(t4) {
              const e4 = new fu();
              return e4.imageName = t4, e4;
            }
          }
          class du {
            constructor() {
              this.text = "", this.sectionIndex = [], this.sections = [], this.imageSectionID = null;
            }
            static fromFeature(t4, e4) {
              const r5 = new du();
              for (let n3 = 0; n3 < t4.sections.length; n3++) {
                const i5 = t4.sections[n3];
                i5.image ? r5.addImageSection(i5) : r5.addTextSection(i5, e4);
              }
              return r5;
            }
            length() {
              return this.text.length;
            }
            getSection(t4) {
              return this.sections[this.sectionIndex[t4]];
            }
            getSectionIndex(t4) {
              return this.sectionIndex[t4];
            }
            getCharCode(t4) {
              return this.text.charCodeAt(t4);
            }
            verticalizePunctuation() {
              this.text = function(t4) {
                let e4 = "";
                for (let r5 = 0; r5 < t4.length; r5++) {
                  const n3 = t4.charCodeAt(r5 + 1) || null, i5 = t4.charCodeAt(r5 - 1) || null;
                  e4 += n3 && Kn(n3) && !Bl[t4[r5 + 1]] || i5 && Kn(i5) && !Bl[t4[r5 - 1]] || !Bl[t4[r5]] ? t4[r5] : Bl[t4[r5]];
                }
                return e4;
              }(this.text);
            }
            trim() {
              let t4 = 0;
              for (let e5 = 0; e5 < this.text.length && mu[this.text.charCodeAt(e5)]; e5++)
                t4++;
              let e4 = this.text.length;
              for (let r5 = this.text.length - 1; r5 >= 0 && r5 >= t4 && mu[this.text.charCodeAt(r5)]; r5--)
                e4--;
              this.text = this.text.substring(t4, e4), this.sectionIndex = this.sectionIndex.slice(t4, e4);
            }
            substring(t4, e4) {
              const r5 = new du();
              return r5.text = this.text.substring(t4, e4), r5.sectionIndex = this.sectionIndex.slice(t4, e4), r5.sections = this.sections, r5;
            }
            toString() {
              return this.text;
            }
            getMaxScale() {
              return this.sectionIndex.reduce((t4, e4) => Math.max(t4, this.sections[e4].scale), 0);
            }
            addTextSection(t4, e4) {
              this.text += t4.text, this.sections.push(fu.forText(t4.scale, t4.fontStack || e4));
              const r5 = this.sections.length - 1;
              for (let e5 = 0; e5 < t4.text.length; ++e5)
                this.sectionIndex.push(r5);
            }
            addImageSection(t4) {
              const e4 = t4.image ? t4.image.name : "";
              if (0 === e4.length)
                return void _3("Can't add FormattedSection with an empty image.");
              const r5 = this.getNextImageSectionCharCode();
              r5 ? (this.text += String.fromCharCode(r5), this.sections.push(fu.forImage(e4)), this.sectionIndex.push(this.sections.length - 1)) : _3("Reached maximum number of images 6401");
            }
            getNextImageSectionCharCode() {
              return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344, this.imageSectionID);
            }
          }
          function yu(e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3, m4) {
            const g4 = du.fromFeature(e4, a5);
            let x3;
            p7 === t3.WritingMode.vertical && g4.verticalizePunctuation();
            const { processBidirectionalText: v5, processStyledBidirectionalText: b4 } = oi;
            if (v5 && 1 === g4.sections.length) {
              x3 = [];
              const t4 = v5(g4.toString(), Au(g4, c5, s5, r5, i5, d4, y3));
              for (const e5 of t4) {
                const t5 = new du();
                t5.text = e5, t5.sections = g4.sections;
                for (let r6 = 0; r6 < e5.length; r6++)
                  t5.sectionIndex.push(0);
                x3.push(t5);
              }
            } else if (b4) {
              x3 = [];
              const t4 = b4(g4.text, g4.sectionIndex, Au(g4, c5, s5, r5, i5, d4, y3));
              for (const e5 of t4) {
                const t5 = new du();
                t5.text = e5[0], t5.sectionIndex = e5[1], t5.sections = g4.sections, x3.push(t5);
              }
            } else
              x3 = function(t4, e5) {
                const r6 = [], n4 = t4.text;
                let i6 = 0;
                for (const n5 of e5)
                  r6.push(t4.substring(i6, n5)), i6 = n5;
                return i6 < n4.length && r6.push(t4.substring(i6, n4.length)), r6;
              }(g4, Au(g4, c5, s5, r5, i5, d4, y3));
            const w4 = [], _4 = { positionedLines: w4, text: g4.toString(), top: h4[1], bottom: h4[1], left: h4[0], right: h4[0], writingMode: p7, iconsInText: false, verticalizable: false };
            return function(e5, r6, n4, i6, a6, s6, o6, l6, u6, c6, h5, p8) {
              let f5 = 0, d5 = pu, y4 = 0, m5 = 0;
              const g5 = "right" === l6 ? 1 : "left" === l6 ? 0 : 0.5;
              let x4 = 0;
              for (const o7 of a6) {
                o7.trim();
                const a7 = o7.getMaxScale(), l7 = (a7 - 1) * Vl, b6 = { positionedGlyphs: [], lineOffset: 0 };
                e5.positionedLines[x4] = b6;
                const w6 = b6.positionedGlyphs;
                let _6 = 0;
                if (!o7.length()) {
                  d5 += s6, ++x4;
                  continue;
                }
                for (let s7 = 0; s7 < o7.length(); s7++) {
                  const y5 = o7.getSection(s7), m6 = o7.getSectionIndex(s7), g6 = o7.getCharCode(s7);
                  let x5 = 0, b7 = null, A4 = null, S3 = null, k4 = Vl;
                  const I3 = !(u6 === t3.WritingMode.horizontal || !h5 && !Zn(g6) || h5 && (mu[g6] || (v6 = g6, Rn.Arabic(v6) || Rn["Arabic Supplement"](v6) || Rn["Arabic Extended-A"](v6) || Rn["Arabic Presentation Forms-A"](v6) || Rn["Arabic Presentation Forms-B"](v6))));
                  if (y5.imageName) {
                    const t4 = i6[y5.imageName];
                    if (!t4)
                      continue;
                    S3 = y5.imageName, e5.iconsInText = e5.iconsInText || true, A4 = t4.paddedRect;
                    const r7 = t4.displaySize;
                    y5.scale = y5.scale * Vl / p8, b7 = { width: r7[0], height: r7[1], left: lu, top: -su, advance: I3 ? r7[1] : r7[0] }, x5 = l7 + (Vl - r7[1] * y5.scale), k4 = b7.advance;
                    const n5 = I3 ? r7[0] * y5.scale - Vl * a7 : r7[1] * y5.scale - Vl * a7;
                    n5 > 0 && n5 > _6 && (_6 = n5);
                  } else {
                    const t4 = n4[y5.fontStack], e6 = t4 && t4[g6];
                    if (e6 && e6.rect)
                      A4 = e6.rect, b7 = e6.metrics;
                    else {
                      const t5 = r6[y5.fontStack], e7 = t5 && t5[g6];
                      if (!e7)
                        continue;
                      b7 = e7.metrics;
                    }
                    x5 = (a7 - y5.scale) * Vl;
                  }
                  I3 ? (e5.verticalizable = true, w6.push({ glyph: g6, imageName: S3, x: f5, y: d5 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m6, metrics: b7, rect: A4 }), f5 += k4 * y5.scale + c6) : (w6.push({ glyph: g6, imageName: S3, x: f5, y: d5 + x5, vertical: I3, scale: y5.scale, fontStack: y5.fontStack, sectionIndex: m6, metrics: b7, rect: A4 }), f5 += b7.advance * y5.scale + c6);
                }
                0 !== w6.length && (y4 = Math.max(f5 - c6, y4), ku(w6, 0, w6.length - 1, g5, _6)), f5 = 0;
                const A3 = s6 * a7 + _6;
                b6.lineOffset = Math.max(_6, l7), d5 += A3, m5 = Math.max(A3, m5), ++x4;
              }
              var v6;
              const b5 = d5 - pu, { horizontalAlign: w5, verticalAlign: _5 } = Su(o6);
              (function(t4, e6, r7, n5, i7, a7, s7, o7, l7) {
                const u7 = (e6 - r7) * i7;
                let c7 = 0;
                c7 = a7 !== s7 ? -o7 * n5 - pu : (-n5 * l7 + 0.5) * s7;
                for (const e7 of t4)
                  for (const t5 of e7.positionedGlyphs)
                    t5.x += u7, t5.y += c7;
              })(e5.positionedLines, g5, w5, _5, y4, m5, s6, b5, a6.length), e5.top += -_5 * b5, e5.bottom = e5.top + b5, e5.left += -w5 * y4, e5.right = e5.left + y4;
            }(_4, r5, n3, i5, x3, o5, l5, u5, p7, c5, f4, m4), !function(t4) {
              for (const e5 of t4)
                if (0 !== e5.positionedGlyphs.length)
                  return false;
              return true;
            }(w4) && _4;
          }
          const mu = { 9: true, 10: true, 11: true, 12: true, 13: true, 32: true }, gu = { 10: true, 32: true, 38: true, 40: true, 41: true, 43: true, 45: true, 47: true, 173: true, 183: true, 8203: true, 8208: true, 8211: true, 8231: true };
          function xu(t4, e4, r5, n3, i5, a5) {
            if (e4.imageName) {
              const t5 = n3[e4.imageName];
              return t5 ? t5.displaySize[0] * e4.scale * Vl / a5 + i5 : 0;
            }
            {
              const n4 = r5[e4.fontStack], a6 = n4 && n4[t4];
              return a6 ? a6.metrics.advance * e4.scale + i5 : 0;
            }
          }
          function vu(t4, e4, r5, n3) {
            const i5 = Math.pow(t4 - e4, 2);
            return n3 ? t4 < e4 ? i5 / 2 : 2 * i5 : i5 + Math.abs(r5) * r5;
          }
          function bu(t4, e4, r5) {
            let n3 = 0;
            return 10 === t4 && (n3 -= 1e4), r5 && (n3 += 150), 40 !== t4 && 65288 !== t4 || (n3 += 50), 41 !== e4 && 65289 !== e4 || (n3 += 50), n3;
          }
          function wu(t4, e4, r5, n3, i5, a5) {
            let s5 = null, o5 = vu(e4, r5, i5, a5);
            for (const t5 of n3) {
              const n4 = vu(e4 - t5.x, r5, i5, a5) + t5.badness;
              n4 <= o5 && (s5 = t5, o5 = n4);
            }
            return { index: t4, x: e4, priorBreak: s5, badness: o5 };
          }
          function _u(t4) {
            return t4 ? _u(t4.priorBreak).concat(t4.index) : [];
          }
          function Au(t4, e4, r5, n3, i5, a5, s5) {
            if ("point" !== a5)
              return [];
            if (!t4)
              return [];
            const o5 = [], l5 = function(t5, e5, r6, n4, i6, a6) {
              let s6 = 0;
              for (let r7 = 0; r7 < t5.length(); r7++) {
                const o6 = t5.getSection(r7);
                s6 += xu(t5.getCharCode(r7), o6, n4, i6, e5, a6);
              }
              return s6 / Math.max(1, Math.ceil(s6 / r6));
            }(t4, e4, r5, n3, i5, s5), u5 = t4.text.indexOf("\u200B") >= 0;
            let c5 = 0;
            for (let r6 = 0; r6 < t4.length(); r6++) {
              const a6 = t4.getSection(r6), p7 = t4.getCharCode(r6);
              if (mu[p7] || (c5 += xu(p7, a6, n3, i5, e4, s5)), r6 < t4.length() - 1) {
                const e5 = !((h4 = p7) < 11904 || !(Rn["Bopomofo Extended"](h4) || Rn.Bopomofo(h4) || Rn["CJK Compatibility Forms"](h4) || Rn["CJK Compatibility Ideographs"](h4) || Rn["CJK Compatibility"](h4) || Rn["CJK Radicals Supplement"](h4) || Rn["CJK Strokes"](h4) || Rn["CJK Symbols and Punctuation"](h4) || Rn["CJK Unified Ideographs Extension A"](h4) || Rn["CJK Unified Ideographs"](h4) || Rn["Enclosed CJK Letters and Months"](h4) || Rn["Halfwidth and Fullwidth Forms"](h4) || Rn.Hiragana(h4) || Rn["Ideographic Description Characters"](h4) || Rn["Kangxi Radicals"](h4) || Rn["Katakana Phonetic Extensions"](h4) || Rn.Katakana(h4) || Rn["Vertical Forms"](h4) || Rn["Yi Radicals"](h4) || Rn["Yi Syllables"](h4)));
                (gu[p7] || e5 || a6.imageName) && o5.push(wu(r6 + 1, c5, l5, o5, bu(p7, t4.getCharCode(r6 + 1), e5 && u5), false));
              }
            }
            var h4;
            return _u(wu(t4.length(), c5, l5, o5, 0, true));
          }
          function Su(t4) {
            let e4 = 0.5, r5 = 0.5;
            switch (t4) {
              case "right":
              case "top-right":
              case "bottom-right":
                e4 = 1;
                break;
              case "left":
              case "top-left":
              case "bottom-left":
                e4 = 0;
            }
            switch (t4) {
              case "bottom":
              case "bottom-right":
              case "bottom-left":
                r5 = 1;
                break;
              case "top":
              case "top-right":
              case "top-left":
                r5 = 0;
            }
            return { horizontalAlign: e4, verticalAlign: r5 };
          }
          function ku(t4, e4, r5, n3, i5) {
            if (!n3 && !i5)
              return;
            const a5 = t4[r5], s5 = (t4[r5].x + a5.metrics.advance * a5.scale) * n3;
            for (let n4 = e4; n4 <= r5; n4++)
              t4[n4].x -= s5, t4[n4].y += i5;
          }
          function Iu(t4, e4, r5) {
            const { horizontalAlign: n3, verticalAlign: i5 } = Su(r5), a5 = e4[0] - t4.displaySize[0] * n3, s5 = e4[1] - t4.displaySize[1] * i5;
            return { image: t4, top: s5, bottom: s5 + t4.displaySize[1], left: a5, right: a5 + t4.displaySize[0] };
          }
          function zu(t4, e4, r5, n3, i5, a5) {
            const s5 = t4.image;
            let o5;
            if (s5.content) {
              const t5 = s5.content, e5 = s5.pixelRatio || 1;
              o5 = [t5[0] / e5, t5[1] / e5, s5.displaySize[0] - t5[2] / e5, s5.displaySize[1] - t5[3] / e5];
            }
            const l5 = e4.left * a5, u5 = e4.right * a5;
            let c5, h4, p7, f4;
            "width" === r5 || "both" === r5 ? (f4 = i5[0] + l5 - n3[3], h4 = i5[0] + u5 + n3[1]) : (f4 = i5[0] + (l5 + u5 - s5.displaySize[0]) / 2, h4 = f4 + s5.displaySize[0]);
            const d4 = e4.top * a5, y3 = e4.bottom * a5;
            return "height" === r5 || "both" === r5 ? (c5 = i5[1] + d4 - n3[0], p7 = i5[1] + y3 + n3[2]) : (c5 = i5[1] + (d4 + y3 - s5.displaySize[1]) / 2, p7 = c5 + s5.displaySize[1]), { image: s5, top: c5, right: h4, bottom: p7, left: f4, collisionPadding: o5 };
          }
          const Mu = 255, Pu = 128, Cu = Mu * Pu;
          function Bu(t4, e4) {
            const { expression: r5 } = e4;
            if ("constant" === r5.kind)
              return { kind: "constant", layoutSize: r5.evaluate(new li(t4 + 1)) };
            if ("source" === r5.kind)
              return { kind: "source" };
            {
              const { zoomStops: e5, interpolationType: n3 } = r5;
              let i5 = 0;
              for (; i5 < e5.length && e5[i5] <= t4; )
                i5++;
              i5 = Math.max(0, i5 - 1);
              let a5 = i5;
              for (; a5 < e5.length && e5[a5] < t4 + 1; )
                a5++;
              a5 = Math.min(e5.length - 1, a5);
              const s5 = e5[i5], o5 = e5[a5];
              return "composite" === r5.kind ? { kind: "composite", minZoom: s5, maxZoom: o5, interpolationType: n3 } : { kind: "camera", minZoom: s5, maxZoom: o5, minSize: r5.evaluate(new li(s5)), maxSize: r5.evaluate(new li(o5)), interpolationType: n3 };
            }
          }
          function Vu(t4, e4, r5) {
            let n3 = "never";
            const i5 = t4.get(e4);
            return i5 ? n3 = i5 : t4.get(r5) && (n3 = "always"), n3;
          }
          const Eu = Ro.VectorTileFeature.types, Fu = [{ name: "a_fade_opacity", components: 1, type: "Uint8", offset: 0 }];
          function Tu(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7) {
            const f4 = o5 ? Math.min(Cu, Math.round(o5[0])) : 0, d4 = o5 ? Math.min(Cu, Math.round(o5[1])) : 0;
            t4.emplaceBack(e4, r5, Math.round(32 * n3), Math.round(32 * i5), a5, s5, (f4 << 1) + (l5 ? 1 : 0), d4, 16 * u5, 16 * c5, 256 * h4, 256 * p7);
          }
          function $u(t4, e4, r5) {
            t4.emplaceBack(e4.x, e4.y, r5), t4.emplaceBack(e4.x, e4.y, r5), t4.emplaceBack(e4.x, e4.y, r5), t4.emplaceBack(e4.x, e4.y, r5);
          }
          function Lu(t4) {
            for (const e4 of t4.sections)
              if (Xn(e4.text))
                return true;
            return false;
          }
          class Du {
            constructor(t4) {
              this.layoutVertexArray = new xa(), this.indexArray = new Aa(), this.programConfigurations = t4, this.segments = new za(), this.dynamicLayoutVertexArray = new va(), this.opacityVertexArray = new ba(), this.hasVisibleVertices = false, this.placedSymbolArray = new ra();
            }
            isEmpty() {
              return 0 === this.layoutVertexArray.length && 0 === this.indexArray.length && 0 === this.dynamicLayoutVertexArray.length && 0 === this.opacityVertexArray.length;
            }
            upload(t4, e4, r5, n3) {
              this.isEmpty() || (r5 && (this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, kl.members), this.indexBuffer = t4.createIndexBuffer(this.indexArray, e4), this.dynamicLayoutVertexBuffer = t4.createVertexBuffer(this.dynamicLayoutVertexArray, Il.members, true), this.opacityVertexBuffer = t4.createVertexBuffer(this.opacityVertexArray, Fu, true), this.opacityVertexBuffer.itemSize = 1), (r5 || n3) && this.programConfigurations.upload(t4));
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.programConfigurations.destroy(), this.segments.destroy(), this.dynamicLayoutVertexBuffer.destroy(), this.opacityVertexBuffer.destroy());
            }
          }
          $n("SymbolBuffers", Du);
          class Ou {
            constructor(t4, e4, r5) {
              this.layoutVertexArray = new t4(), this.layoutAttributes = e4, this.indexArray = new r5(), this.segments = new za(), this.collisionVertexArray = new _a();
            }
            upload(t4) {
              this.layoutVertexBuffer = t4.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes), this.indexBuffer = t4.createIndexBuffer(this.indexArray), this.collisionVertexBuffer = t4.createVertexBuffer(this.collisionVertexArray, zl.members, true);
            }
            destroy() {
              this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(), this.indexBuffer.destroy(), this.segments.destroy(), this.collisionVertexBuffer.destroy());
            }
          }
          $n("CollisionBuffers", Ou);
          class Uu {
            constructor(e4) {
              this.collisionBoxArray = e4.collisionBoxArray, this.zoom = e4.zoom, this.overscaling = e4.overscaling, this.layers = e4.layers, this.layerIds = this.layers.map((t4) => t4.id), this.index = e4.index, this.pixelRatio = e4.pixelRatio, this.sourceLayerIndex = e4.sourceLayerIndex, this.hasPattern = false, this.hasRTLText = false, this.sortKeyRanges = [], this.collisionCircleArray = [], this.placementInvProjMatrix = Ms([]), this.placementViewportMatrix = Ms([]);
              const r5 = this.layers[0]._unevaluatedLayout._values;
              this.textSizeData = Bu(this.zoom, r5["text-size"]), this.iconSizeData = Bu(this.zoom, r5["icon-size"]);
              const n3 = this.layers[0].layout, i5 = n3.get("symbol-sort-key"), a5 = n3.get("symbol-z-order");
              this.canOverlap = "never" !== Vu(n3, "text-overlap", "text-allow-overlap") || "never" !== Vu(n3, "icon-overlap", "icon-allow-overlap") || n3.get("text-ignore-placement") || n3.get("icon-ignore-placement"), this.sortFeaturesByKey = "viewport-y" !== a5 && !i5.isConstant(), this.sortFeaturesByY = ("viewport-y" === a5 || "auto" === a5 && !this.sortFeaturesByKey) && this.canOverlap, "point" === n3.get("symbol-placement") && (this.writingModes = n3.get("text-writing-mode").map((e5) => t3.WritingMode[e5])), this.stateDependentLayerIds = this.layers.filter((t4) => t4.isStateDependent()).map((t4) => t4.id), this.sourceID = e4.sourceID;
            }
            createArrays() {
              this.text = new Du(new Qa(this.layers, this.zoom, (t4) => /^text/.test(t4))), this.icon = new Du(new Qa(this.layers, this.zoom, (t4) => /^icon/.test(t4))), this.glyphOffsetArray = new aa(), this.lineVertexArray = new sa(), this.symbolInstances = new ia(), this.textAnchorOffsets = new la();
            }
            calculateGlyphDependencies(t4, e4, r5, n3, i5) {
              for (let a5 = 0; a5 < t4.length; a5++)
                if (e4[t4.charCodeAt(a5)] = true, (r5 || n3) && i5) {
                  const r6 = Bl[t4.charAt(a5)];
                  r6 && (e4[r6.charCodeAt(0)] = true);
                }
            }
            populate(e4, r5, n3) {
              const i5 = this.layers[0], a5 = i5.layout, s5 = a5.get("text-font"), o5 = a5.get("text-field"), l5 = a5.get("icon-image"), u5 = ("constant" !== o5.value.kind || o5.value.value instanceof Qt && !o5.value.value.isEmpty() || o5.value.value.toString().length > 0) && ("constant" !== s5.value.kind || s5.value.value.length > 0), c5 = "constant" !== l5.value.kind || !!l5.value.value || Object.keys(l5.parameters).length > 0, h4 = a5.get("symbol-sort-key");
              if (this.features = [], !u5 && !c5)
                return;
              const p7 = r5.iconDependencies, f4 = r5.glyphDependencies, d4 = r5.availableImages, y3 = new li(this.zoom);
              for (const { feature: r6, id: o6, index: l6, sourceLayerIndex: m4 } of e4) {
                const e5 = i5._featureFilter.needGeometry, g4 = ss(r6, e5);
                if (!i5._featureFilter.filter(y3, g4, n3))
                  continue;
                let x3, v5;
                if (e5 || (g4.geometry = as(r6)), u5) {
                  const t4 = i5.getValueAndResolveTokens("text-field", g4, n3, d4), e6 = Qt.factory(t4);
                  Lu(e6) && (this.hasRTLText = true), (!this.hasRTLText || "unavailable" === ai() || this.hasRTLText && oi.isParsed()) && (x3 = Cl(e6, i5, g4));
                }
                if (c5) {
                  const t4 = i5.getValueAndResolveTokens("icon-image", g4, n3, d4);
                  v5 = t4 instanceof ne ? t4 : ne.fromString(t4);
                }
                if (!x3 && !v5)
                  continue;
                const b4 = this.sortFeaturesByKey ? h4.evaluate(g4, {}, n3) : void 0;
                if (this.features.push({ id: o6, text: x3, icon: v5, index: l6, sourceLayerIndex: m4, geometry: g4.geometry, properties: r6.properties, type: Eu[r6.type], sortKey: b4 }), v5 && (p7[v5.name] = true), x3) {
                  const e6 = s5.evaluate(g4, {}, n3).join(","), r7 = "viewport" !== a5.get("text-rotation-alignment") && "point" !== a5.get("symbol-placement");
                  this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(t3.WritingMode.vertical) >= 0;
                  for (const t4 of x3.sections)
                    if (t4.image)
                      p7[t4.image.name] = true;
                    else {
                      const n4 = qn(x3.toString()), i6 = t4.fontStack || e6, a6 = f4[i6] = f4[i6] || {};
                      this.calculateGlyphDependencies(t4.text, a6, r7, this.allowVerticalPlacement, n4);
                    }
                }
              }
              "line" === a5.get("symbol-placement") && (this.features = function(t4) {
                const e5 = {}, r6 = {}, n4 = [];
                let i6 = 0;
                function a6(e6) {
                  n4.push(t4[e6]), i6++;
                }
                function s6(t5, e6, i7) {
                  const a7 = r6[t5];
                  return delete r6[t5], r6[e6] = a7, n4[a7].geometry[0].pop(), n4[a7].geometry[0] = n4[a7].geometry[0].concat(i7[0]), a7;
                }
                function o6(t5, r7, i7) {
                  const a7 = e5[r7];
                  return delete e5[r7], e5[t5] = a7, n4[a7].geometry[0].shift(), n4[a7].geometry[0] = i7[0].concat(n4[a7].geometry[0]), a7;
                }
                function l6(t5, e6, r7) {
                  const n5 = r7 ? e6[0][e6[0].length - 1] : e6[0][0];
                  return `${t5}:${n5.x}:${n5.y}`;
                }
                for (let u6 = 0; u6 < t4.length; u6++) {
                  const c6 = t4[u6], h5 = c6.geometry, p8 = c6.text ? c6.text.toString() : null;
                  if (!p8) {
                    a6(u6);
                    continue;
                  }
                  const f5 = l6(p8, h5), d5 = l6(p8, h5, true);
                  if (f5 in r6 && d5 in e5 && r6[f5] !== e5[d5]) {
                    const t5 = o6(f5, d5, h5), i7 = s6(f5, d5, n4[t5].geometry);
                    delete e5[f5], delete r6[d5], r6[l6(p8, n4[i7].geometry, true)] = i7, n4[t5].geometry = null;
                  } else
                    f5 in r6 ? s6(f5, d5, h5) : d5 in e5 ? o6(f5, d5, h5) : (a6(u6), e5[f5] = i6 - 1, r6[d5] = i6 - 1);
                }
                return n4.filter((t5) => t5.geometry);
              }(this.features)), this.sortFeaturesByKey && this.features.sort((t4, e5) => t4.sortKey - e5.sortKey);
            }
            update(t4, e4, r5) {
              this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t4, e4, this.layers, r5), this.icon.programConfigurations.updatePaintArrays(t4, e4, this.layers, r5));
            }
            isEmpty() {
              return 0 === this.symbolInstances.length && !this.hasRTLText;
            }
            uploadPending() {
              return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload;
            }
            upload(t4) {
              !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t4), this.iconCollisionBox.upload(t4)), this.text.upload(t4, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload), this.icon.upload(t4, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload), this.uploaded = true;
            }
            destroyDebugData() {
              this.textCollisionBox.destroy(), this.iconCollisionBox.destroy();
            }
            destroy() {
              this.text.destroy(), this.icon.destroy(), this.hasDebugData() && this.destroyDebugData();
            }
            addToLineVertexArray(t4, e4) {
              const r5 = this.lineVertexArray.length;
              if (void 0 !== t4.segment) {
                let r6 = t4.dist(e4[t4.segment + 1]), n3 = t4.dist(e4[t4.segment]);
                const i5 = {};
                for (let n4 = t4.segment + 1; n4 < e4.length; n4++)
                  i5[n4] = { x: e4[n4].x, y: e4[n4].y, tileUnitDistanceFromAnchor: r6 }, n4 < e4.length - 1 && (r6 += e4[n4 + 1].dist(e4[n4]));
                for (let r7 = t4.segment || 0; r7 >= 0; r7--)
                  i5[r7] = { x: e4[r7].x, y: e4[r7].y, tileUnitDistanceFromAnchor: n3 }, r7 > 0 && (n3 += e4[r7 - 1].dist(e4[r7]));
                for (let t5 = 0; t5 < e4.length; t5++) {
                  const e5 = i5[t5];
                  this.lineVertexArray.emplaceBack(e5.x, e5.y, e5.tileUnitDistanceFromAnchor);
                }
              }
              return { lineStartIndex: r5, lineLength: this.lineVertexArray.length - r5 };
            }
            addSymbols(e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4, p7) {
              const f4 = e4.indexArray, d4 = e4.layoutVertexArray, y3 = e4.segments.prepareSegment(4 * r5.length, d4, f4, this.canOverlap ? s5.sortKey : void 0), m4 = this.glyphOffsetArray.length, g4 = y3.vertexLength, x3 = this.allowVerticalPlacement && o5 === t3.WritingMode.vertical ? Math.PI / 2 : 0, v5 = s5.text && s5.text.sections;
              for (let t4 = 0; t4 < r5.length; t4++) {
                const { tl: i6, tr: a6, bl: o6, br: u6, tex: c6, pixelOffsetTL: h5, pixelOffsetBR: m5, minFontScaleX: g5, minFontScaleY: b4, glyphOffset: w4, isSDF: _4, sectionIndex: A3 } = r5[t4], S3 = y3.vertexLength, k4 = w4[1];
                Tu(d4, l5.x, l5.y, i6.x, k4 + i6.y, c6.x, c6.y, n3, _4, h5.x, h5.y, g5, b4), Tu(d4, l5.x, l5.y, a6.x, k4 + a6.y, c6.x + c6.w, c6.y, n3, _4, m5.x, h5.y, g5, b4), Tu(d4, l5.x, l5.y, o6.x, k4 + o6.y, c6.x, c6.y + c6.h, n3, _4, h5.x, m5.y, g5, b4), Tu(d4, l5.x, l5.y, u6.x, k4 + u6.y, c6.x + c6.w, c6.y + c6.h, n3, _4, m5.x, m5.y, g5, b4), $u(e4.dynamicLayoutVertexArray, l5, x3), f4.emplaceBack(S3, S3 + 1, S3 + 2), f4.emplaceBack(S3 + 1, S3 + 2, S3 + 3), y3.vertexLength += 4, y3.primitiveLength += 2, this.glyphOffsetArray.emplaceBack(w4[0]), t4 !== r5.length - 1 && A3 === r5[t4 + 1].sectionIndex || e4.programConfigurations.populatePaintArrays(d4.length, s5, s5.index, {}, p7, v5 && v5[A3]);
              }
              e4.placedSymbolArray.emplaceBack(l5.x, l5.y, m4, this.glyphOffsetArray.length - m4, g4, u5, c5, l5.segment, n3 ? n3[0] : 0, n3 ? n3[1] : 0, i5[0], i5[1], o5, 0, false, 0, h4);
            }
            _addCollisionDebugVertex(t4, e4, r5, n3, i5, a5) {
              return e4.emplaceBack(0, 0), t4.emplaceBack(r5.x, r5.y, n3, i5, Math.round(a5.x), Math.round(a5.y));
            }
            addCollisionDebugVertices(t4, e4, r5, n3, a5, s5, o5) {
              const l5 = a5.segments.prepareSegment(4, a5.layoutVertexArray, a5.indexArray), u5 = l5.vertexLength, c5 = a5.layoutVertexArray, h4 = a5.collisionVertexArray, p7 = o5.anchorX, f4 = o5.anchorY;
              this._addCollisionDebugVertex(c5, h4, s5, p7, f4, new i4(t4, e4)), this._addCollisionDebugVertex(c5, h4, s5, p7, f4, new i4(r5, e4)), this._addCollisionDebugVertex(c5, h4, s5, p7, f4, new i4(r5, n3)), this._addCollisionDebugVertex(c5, h4, s5, p7, f4, new i4(t4, n3)), l5.vertexLength += 4;
              const d4 = a5.indexArray;
              d4.emplaceBack(u5, u5 + 1), d4.emplaceBack(u5 + 1, u5 + 2), d4.emplaceBack(u5 + 2, u5 + 3), d4.emplaceBack(u5 + 3, u5), l5.primitiveLength += 4;
            }
            addDebugCollisionBoxes(t4, e4, r5, n3) {
              for (let i5 = t4; i5 < e4; i5++) {
                const t5 = this.collisionBoxArray.get(i5);
                this.addCollisionDebugVertices(t5.x1, t5.y1, t5.x2, t5.y2, n3 ? this.textCollisionBox : this.iconCollisionBox, t5.anchorPoint, r5);
              }
            }
            generateCollisionDebugBuffers() {
              this.hasDebugData() && this.destroyDebugData(), this.textCollisionBox = new Ou(wa, Ml.members, Sa), this.iconCollisionBox = new Ou(wa, Ml.members, Sa);
              for (let t4 = 0; t4 < this.symbolInstances.length; t4++) {
                const e4 = this.symbolInstances.get(t4);
                this.addDebugCollisionBoxes(e4.textBoxStartIndex, e4.textBoxEndIndex, e4, true), this.addDebugCollisionBoxes(e4.verticalTextBoxStartIndex, e4.verticalTextBoxEndIndex, e4, true), this.addDebugCollisionBoxes(e4.iconBoxStartIndex, e4.iconBoxEndIndex, e4, false), this.addDebugCollisionBoxes(e4.verticalIconBoxStartIndex, e4.verticalIconBoxEndIndex, e4, false);
              }
            }
            _deserializeCollisionBoxesForSymbol(t4, e4, r5, n3, i5, a5, s5, o5, l5) {
              const u5 = {};
              for (let n4 = e4; n4 < r5; n4++) {
                const e5 = t4.get(n4);
                u5.textBox = { x1: e5.x1, y1: e5.y1, x2: e5.x2, y2: e5.y2, anchorPointX: e5.anchorPointX, anchorPointY: e5.anchorPointY }, u5.textFeatureIndex = e5.featureIndex;
                break;
              }
              for (let e5 = n3; e5 < i5; e5++) {
                const r6 = t4.get(e5);
                u5.verticalTextBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u5.verticalTextFeatureIndex = r6.featureIndex;
                break;
              }
              for (let e5 = a5; e5 < s5; e5++) {
                const r6 = t4.get(e5);
                u5.iconBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u5.iconFeatureIndex = r6.featureIndex;
                break;
              }
              for (let e5 = o5; e5 < l5; e5++) {
                const r6 = t4.get(e5);
                u5.verticalIconBox = { x1: r6.x1, y1: r6.y1, x2: r6.x2, y2: r6.y2, anchorPointX: r6.anchorPointX, anchorPointY: r6.anchorPointY }, u5.verticalIconFeatureIndex = r6.featureIndex;
                break;
              }
              return u5;
            }
            deserializeCollisionBoxes(t4) {
              this.collisionArrays = [];
              for (let e4 = 0; e4 < this.symbolInstances.length; e4++) {
                const r5 = this.symbolInstances.get(e4);
                this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t4, r5.textBoxStartIndex, r5.textBoxEndIndex, r5.verticalTextBoxStartIndex, r5.verticalTextBoxEndIndex, r5.iconBoxStartIndex, r5.iconBoxEndIndex, r5.verticalIconBoxStartIndex, r5.verticalIconBoxEndIndex));
              }
            }
            hasTextData() {
              return this.text.segments.get().length > 0;
            }
            hasIconData() {
              return this.icon.segments.get().length > 0;
            }
            hasDebugData() {
              return this.textCollisionBox && this.iconCollisionBox;
            }
            hasTextCollisionBoxData() {
              return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0;
            }
            hasIconCollisionBoxData() {
              return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0;
            }
            addIndicesForPlacedSymbol(t4, e4) {
              const r5 = t4.placedSymbolArray.get(e4), n3 = r5.vertexStartIndex + 4 * r5.numGlyphs;
              for (let e5 = r5.vertexStartIndex; e5 < n3; e5 += 4)
                t4.indexArray.emplaceBack(e5, e5 + 1, e5 + 2), t4.indexArray.emplaceBack(e5 + 1, e5 + 2, e5 + 3);
            }
            getSortedSymbolIndexes(t4) {
              if (this.sortedAngle === t4 && void 0 !== this.symbolInstanceIndexes)
                return this.symbolInstanceIndexes;
              const e4 = Math.sin(t4), r5 = Math.cos(t4), n3 = [], i5 = [], a5 = [];
              for (let t5 = 0; t5 < this.symbolInstances.length; ++t5) {
                a5.push(t5);
                const s5 = this.symbolInstances.get(t5);
                n3.push(0 | Math.round(e4 * s5.anchorX + r5 * s5.anchorY)), i5.push(s5.featureIndex);
              }
              return a5.sort((t5, e5) => n3[t5] - n3[e5] || i5[e5] - i5[t5]), a5;
            }
            addToSortKeyRanges(t4, e4) {
              const r5 = this.sortKeyRanges[this.sortKeyRanges.length - 1];
              r5 && r5.sortKey === e4 ? r5.symbolInstanceEnd = t4 + 1 : this.sortKeyRanges.push({ sortKey: e4, symbolInstanceStart: t4, symbolInstanceEnd: t4 + 1 });
            }
            sortFeatures(t4) {
              if (this.sortFeaturesByY && this.sortedAngle !== t4 && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t4), this.sortedAngle = t4, this.text.indexArray.clear(), this.icon.indexArray.clear(), this.featureSortOrder = [];
                for (const t5 of this.symbolInstanceIndexes) {
                  const e4 = this.symbolInstances.get(t5);
                  this.featureSortOrder.push(e4.featureIndex), [e4.rightJustifiedTextSymbolIndex, e4.centerJustifiedTextSymbolIndex, e4.leftJustifiedTextSymbolIndex].forEach((t6, e5, r5) => {
                    t6 >= 0 && r5.indexOf(t6) === e5 && this.addIndicesForPlacedSymbol(this.text, t6);
                  }), e4.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, e4.verticalPlacedTextSymbolIndex), e4.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e4.placedIconSymbolIndex), e4.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, e4.verticalPlacedIconSymbolIndex);
                }
                this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray), this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray);
              }
            }
          }
          let Ru, qu;
          $n("SymbolBucket", Uu, { omit: ["layers", "collisionBoxArray", "features", "compareText"] }), Uu.MAX_GLYPHS = 65535, Uu.addDynamicAttributes = $u;
          var ju = { get paint() {
            return qu = qu || new _i({ "icon-opacity": new xi(X.paint_symbol["icon-opacity"]), "icon-color": new xi(X.paint_symbol["icon-color"]), "icon-halo-color": new xi(X.paint_symbol["icon-halo-color"]), "icon-halo-width": new xi(X.paint_symbol["icon-halo-width"]), "icon-halo-blur": new xi(X.paint_symbol["icon-halo-blur"]), "icon-translate": new gi(X.paint_symbol["icon-translate"]), "icon-translate-anchor": new gi(X.paint_symbol["icon-translate-anchor"]), "text-opacity": new xi(X.paint_symbol["text-opacity"]), "text-color": new xi(X.paint_symbol["text-color"], { runtimeType: yt, getOverride: (t4) => t4.textColor, hasOverride: (t4) => !!t4.textColor }), "text-halo-color": new xi(X.paint_symbol["text-halo-color"]), "text-halo-width": new xi(X.paint_symbol["text-halo-width"]), "text-halo-blur": new xi(X.paint_symbol["text-halo-blur"]), "text-translate": new gi(X.paint_symbol["text-translate"]), "text-translate-anchor": new gi(X.paint_symbol["text-translate-anchor"]) });
          }, get layout() {
            return Ru = Ru || new _i({ "symbol-placement": new gi(X.layout_symbol["symbol-placement"]), "symbol-spacing": new gi(X.layout_symbol["symbol-spacing"]), "symbol-avoid-edges": new gi(X.layout_symbol["symbol-avoid-edges"]), "symbol-sort-key": new xi(X.layout_symbol["symbol-sort-key"]), "symbol-z-order": new gi(X.layout_symbol["symbol-z-order"]), "icon-allow-overlap": new gi(X.layout_symbol["icon-allow-overlap"]), "icon-overlap": new gi(X.layout_symbol["icon-overlap"]), "icon-ignore-placement": new gi(X.layout_symbol["icon-ignore-placement"]), "icon-optional": new gi(X.layout_symbol["icon-optional"]), "icon-rotation-alignment": new gi(X.layout_symbol["icon-rotation-alignment"]), "icon-size": new xi(X.layout_symbol["icon-size"]), "icon-text-fit": new gi(X.layout_symbol["icon-text-fit"]), "icon-text-fit-padding": new gi(X.layout_symbol["icon-text-fit-padding"]), "icon-image": new xi(X.layout_symbol["icon-image"]), "icon-rotate": new xi(X.layout_symbol["icon-rotate"]), "icon-padding": new xi(X.layout_symbol["icon-padding"]), "icon-keep-upright": new gi(X.layout_symbol["icon-keep-upright"]), "icon-offset": new xi(X.layout_symbol["icon-offset"]), "icon-anchor": new xi(X.layout_symbol["icon-anchor"]), "icon-pitch-alignment": new gi(X.layout_symbol["icon-pitch-alignment"]), "text-pitch-alignment": new gi(X.layout_symbol["text-pitch-alignment"]), "text-rotation-alignment": new gi(X.layout_symbol["text-rotation-alignment"]), "text-field": new xi(X.layout_symbol["text-field"]), "text-font": new xi(X.layout_symbol["text-font"]), "text-size": new xi(X.layout_symbol["text-size"]), "text-max-width": new xi(X.layout_symbol["text-max-width"]), "text-line-height": new gi(X.layout_symbol["text-line-height"]), "text-letter-spacing": new xi(X.layout_symbol["text-letter-spacing"]), "text-justify": new xi(X.layout_symbol["text-justify"]), "text-radial-offset": new xi(X.layout_symbol["text-radial-offset"]), "text-variable-anchor": new gi(X.layout_symbol["text-variable-anchor"]), "text-variable-anchor-offset": new xi(X.layout_symbol["text-variable-anchor-offset"]), "text-anchor": new xi(X.layout_symbol["text-anchor"]), "text-max-angle": new gi(X.layout_symbol["text-max-angle"]), "text-writing-mode": new gi(X.layout_symbol["text-writing-mode"]), "text-rotate": new xi(X.layout_symbol["text-rotate"]), "text-padding": new gi(X.layout_symbol["text-padding"]), "text-keep-upright": new gi(X.layout_symbol["text-keep-upright"]), "text-transform": new xi(X.layout_symbol["text-transform"]), "text-offset": new xi(X.layout_symbol["text-offset"]), "text-allow-overlap": new gi(X.layout_symbol["text-allow-overlap"]), "text-overlap": new gi(X.layout_symbol["text-overlap"]), "text-ignore-placement": new gi(X.layout_symbol["text-ignore-placement"]), "text-optional": new gi(X.layout_symbol["text-optional"]) });
          } };
          class Nu {
            constructor(t4) {
              if (void 0 === t4.property.overrides)
                throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
              this.type = t4.property.overrides ? t4.property.overrides.runtimeType : ht, this.defaultValue = t4;
            }
            evaluate(t4) {
              if (t4.formattedSection) {
                const e4 = this.defaultValue.property.overrides;
                if (e4 && e4.hasOverride(t4.formattedSection))
                  return e4.getOverride(t4.formattedSection);
              }
              return t4.feature && t4.featureState ? this.defaultValue.evaluate(t4.feature, t4.featureState) : this.defaultValue.property.specification.default;
            }
            eachChild(t4) {
              this.defaultValue.isConstant() || t4(this.defaultValue.value._styleExpression.expression);
            }
            outputDefined() {
              return false;
            }
            serialize() {
              return null;
            }
          }
          $n("FormatSectionOverride", Nu, { omit: ["defaultValue"] });
          class Zu extends Si {
            constructor(t4) {
              super(t4, ju);
            }
            recalculate(t4, e4) {
              if (super.recalculate(t4, e4), "auto" === this.layout.get("icon-rotation-alignment") && (this.layout._values["icon-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-rotation-alignment") && (this.layout._values["text-rotation-alignment"] = "point" !== this.layout.get("symbol-placement") ? "map" : "viewport"), "auto" === this.layout.get("text-pitch-alignment") && (this.layout._values["text-pitch-alignment"] = "map" === this.layout.get("text-rotation-alignment") ? "map" : "viewport"), "auto" === this.layout.get("icon-pitch-alignment") && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")), "point" === this.layout.get("symbol-placement")) {
                const t5 = this.layout.get("text-writing-mode");
                if (t5) {
                  const e5 = [];
                  for (const r5 of t5)
                    e5.indexOf(r5) < 0 && e5.push(r5);
                  this.layout._values["text-writing-mode"] = e5;
                } else
                  this.layout._values["text-writing-mode"] = ["horizontal"];
              }
              this._setPaintOverrides();
            }
            getValueAndResolveTokens(t4, e4, r5, n3) {
              const i5 = this.layout.get(t4).evaluate(e4, {}, r5, n3), a5 = this._unevaluatedLayout._values[t4];
              return a5.isDataDriven() || Tr(a5.value) || !i5 ? i5 : function(t5, e5) {
                return e5.replace(/{([^{}]+)}/g, (e6, r6) => r6 in t5 ? String(t5[r6]) : "");
              }(e4.properties, i5);
            }
            createBucket(t4) {
              return new Uu(t4);
            }
            queryRadius() {
              return 0;
            }
            queryIntersectsFeature() {
              throw new Error("Should take a different path in FeatureIndex");
            }
            _setPaintOverrides() {
              for (const t4 of ju.paint.overridableProperties) {
                if (!Zu.hasPaintOverride(this.layout, t4))
                  continue;
                const e4 = this.paint.get(t4), r5 = new Nu(e4), n3 = new Fr(r5, e4.property.specification);
                let i5 = null;
                i5 = "constant" === e4.value.kind || "source" === e4.value.kind ? new Lr("source", n3) : new Dr("composite", n3, e4.value.zoomStops), this.paint._values[t4] = new yi(e4.property, i5, e4.parameters);
              }
            }
            _handleOverridablePaintPropertyUpdate(t4, e4, r5) {
              return !(!this.layout || e4.isDataDriven() || r5.isDataDriven()) && Zu.hasPaintOverride(this.layout, t4);
            }
            static hasPaintOverride(t4, e4) {
              const r5 = t4.get("text-field"), n3 = ju.paint.properties[e4];
              let i5 = false;
              const a5 = (t5) => {
                for (const e5 of t5)
                  if (n3.overrides && n3.overrides.hasOverride(e5))
                    return void (i5 = true);
              };
              if ("constant" === r5.value.kind && r5.value.value instanceof Qt)
                a5(r5.value.value.sections);
              else if ("source" === r5.value.kind) {
                const t5 = (e6) => {
                  i5 || (e6 instanceof le && se(e6.value) === vt ? a5(e6.value.sections) : e6 instanceof pr ? a5(e6.sections) : e6.eachChild(t5));
                }, e5 = r5.value;
                e5._styleExpression && t5(e5._styleExpression.expression);
              }
              return i5;
            }
          }
          let Ku;
          var Gu = { get paint() {
            return Ku = Ku || new _i({ "background-color": new gi(X.paint_background["background-color"]), "background-pattern": new bi(X.paint_background["background-pattern"]), "background-opacity": new gi(X.paint_background["background-opacity"]) });
          } };
          class Ju extends Si {
            constructor(t4) {
              super(t4, Gu);
            }
          }
          let Xu;
          var Yu = { get paint() {
            return Xu = Xu || new _i({ "raster-opacity": new gi(X.paint_raster["raster-opacity"]), "raster-hue-rotate": new gi(X.paint_raster["raster-hue-rotate"]), "raster-brightness-min": new gi(X.paint_raster["raster-brightness-min"]), "raster-brightness-max": new gi(X.paint_raster["raster-brightness-max"]), "raster-saturation": new gi(X.paint_raster["raster-saturation"]), "raster-contrast": new gi(X.paint_raster["raster-contrast"]), "raster-resampling": new gi(X.paint_raster["raster-resampling"]), "raster-fade-duration": new gi(X.paint_raster["raster-fade-duration"]) });
          } };
          class Hu extends Si {
            constructor(t4) {
              super(t4, Yu);
            }
          }
          class Wu extends Si {
            constructor(t4) {
              super(t4, {}), this.onAdd = (t5) => {
                this.implementation.onAdd && this.implementation.onAdd(t5, t5.painter.context.gl);
              }, this.onRemove = (t5) => {
                this.implementation.onRemove && this.implementation.onRemove(t5, t5.painter.context.gl);
              }, this.implementation = t4;
            }
            is3D() {
              return "3d" === this.implementation.renderingMode;
            }
            hasOffscreenPass() {
              return void 0 !== this.implementation.prerender;
            }
            recalculate() {
            }
            updateTransitions() {
            }
            hasTransition() {
              return false;
            }
            serialize() {
              throw new Error("Custom layers cannot be serialized");
            }
          }
          class Qu {
            constructor(t4) {
              this._callback = t4, this._triggered = false, "undefined" != typeof MessageChannel && (this._channel = new MessageChannel(), this._channel.port2.onmessage = () => {
                this._triggered = false, this._callback();
              });
            }
            trigger() {
              this._triggered || (this._triggered = true, this._channel ? this._channel.port1.postMessage(true) : setTimeout(() => {
                this._triggered = false, this._callback();
              }, 0));
            }
            remove() {
              delete this._channel, this._callback = () => {
              };
            }
          }
          const tc = 63710088e-1;
          class ec {
            constructor(t4, e4) {
              if (isNaN(t4) || isNaN(e4))
                throw new Error(`Invalid LngLat object: (${t4}, ${e4})`);
              if (this.lng = +t4, this.lat = +e4, this.lat > 90 || this.lat < -90)
                throw new Error("Invalid LngLat latitude value: must be between -90 and 90");
            }
            wrap() {
              return new ec(y2(this.lng, -180, 180), this.lat);
            }
            toArray() {
              return [this.lng, this.lat];
            }
            toString() {
              return `LngLat(${this.lng}, ${this.lat})`;
            }
            distanceTo(t4) {
              const e4 = Math.PI / 180, r5 = this.lat * e4, n3 = t4.lat * e4, i5 = Math.sin(r5) * Math.sin(n3) + Math.cos(r5) * Math.cos(n3) * Math.cos((t4.lng - this.lng) * e4);
              return tc * Math.acos(Math.min(i5, 1));
            }
            static convert(t4) {
              if (t4 instanceof ec)
                return t4;
              if (Array.isArray(t4) && (2 === t4.length || 3 === t4.length))
                return new ec(Number(t4[0]), Number(t4[1]));
              if (!Array.isArray(t4) && "object" == typeof t4 && null !== t4)
                return new ec(Number("lng" in t4 ? t4.lng : t4.lon), Number(t4.lat));
              throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]");
            }
          }
          const rc = 2 * Math.PI * tc;
          function nc(t4) {
            return rc * Math.cos(t4 * Math.PI / 180);
          }
          function ic(t4) {
            return (180 + t4) / 360;
          }
          function ac(t4) {
            return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + t4 * Math.PI / 360))) / 360;
          }
          function sc(t4, e4) {
            return t4 / nc(e4);
          }
          function oc(t4) {
            return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * t4) * Math.PI / 180)) - 90;
          }
          class lc {
            constructor(t4, e4, r5 = 0) {
              this.x = +t4, this.y = +e4, this.z = +r5;
            }
            static fromLngLat(t4, e4 = 0) {
              const r5 = ec.convert(t4);
              return new lc(ic(r5.lng), ac(r5.lat), sc(e4, r5.lat));
            }
            toLngLat() {
              return new ec(360 * this.x - 180, oc(this.y));
            }
            toAltitude() {
              return this.z * nc(oc(this.y));
            }
            meterInMercatorCoordinateUnits() {
              return 1 / rc * (t4 = oc(this.y), 1 / Math.cos(t4 * Math.PI / 180));
              var t4;
            }
          }
          function uc(t4, e4, r5) {
            var n3 = 2 * Math.PI * 6378137 / 256 / Math.pow(2, r5);
            return [t4 * n3 - 2 * Math.PI * 6378137 / 2, e4 * n3 - 2 * Math.PI * 6378137 / 2];
          }
          class cc {
            constructor(t4, e4, r5) {
              if (t4 < 0 || t4 > 25 || r5 < 0 || r5 >= Math.pow(2, t4) || e4 < 0 || e4 >= Math.pow(2, t4))
                throw new Error(`x=${e4}, y=${r5}, z=${t4} outside of bounds. 0<=x<${Math.pow(2, t4)}, 0<=y<${Math.pow(2, t4)} 0<=z<=25 `);
              this.z = t4, this.x = e4, this.y = r5, this.key = fc(0, t4, t4, e4, r5);
            }
            equals(t4) {
              return this.z === t4.z && this.x === t4.x && this.y === t4.y;
            }
            url(t4, e4, r5) {
              const n3 = (a5 = this.y, s5 = this.z, o5 = uc(256 * (i5 = this.x), 256 * (a5 = Math.pow(2, s5) - a5 - 1), s5), l5 = uc(256 * (i5 + 1), 256 * (a5 + 1), s5), o5[0] + "," + o5[1] + "," + l5[0] + "," + l5[1]);
              var i5, a5, s5, o5, l5;
              const u5 = function(t5, e5, r6) {
                let n4, i6 = "";
                for (let a6 = t5; a6 > 0; a6--)
                  n4 = 1 << a6 - 1, i6 += (e5 & n4 ? 1 : 0) + (r6 & n4 ? 2 : 0);
                return i6;
              }(this.z, this.x, this.y);
              return t4[(this.x + this.y) % t4.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String("tms" === r5 ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, e4 > 1 ? "@2x" : "").replace(/{quadkey}/g, u5).replace(/{bbox-epsg-3857}/g, n3);
            }
            isChildOf(t4) {
              const e4 = this.z - t4.z;
              return e4 > 0 && t4.x === this.x >> e4 && t4.y === this.y >> e4;
            }
            getTilePoint(t4) {
              const e4 = Math.pow(2, this.z);
              return new i4((t4.x * e4 - this.x) * rs, (t4.y * e4 - this.y) * rs);
            }
            toString() {
              return `${this.z}/${this.x}/${this.y}`;
            }
          }
          class hc {
            constructor(t4, e4) {
              this.wrap = t4, this.canonical = e4, this.key = fc(t4, e4.z, e4.z, e4.x, e4.y);
            }
          }
          class pc {
            constructor(t4, e4, r5, n3, i5) {
              if (t4 < r5)
                throw new Error(`overscaledZ should be >= z; overscaledZ = ${t4}; z = ${r5}`);
              this.overscaledZ = t4, this.wrap = e4, this.canonical = new cc(r5, +n3, +i5), this.key = fc(e4, t4, r5, n3, i5);
            }
            clone() {
              return new pc(this.overscaledZ, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            equals(t4) {
              return this.overscaledZ === t4.overscaledZ && this.wrap === t4.wrap && this.canonical.equals(t4.canonical);
            }
            scaledTo(t4) {
              if (t4 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t4}; overscaledZ = ${this.overscaledZ}`);
              const e4 = this.canonical.z - t4;
              return t4 > this.canonical.z ? new pc(t4, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y) : new pc(t4, this.wrap, t4, this.canonical.x >> e4, this.canonical.y >> e4);
            }
            calculateScaledKey(t4, e4) {
              if (t4 > this.overscaledZ)
                throw new Error(`targetZ > this.overscaledZ; targetZ = ${t4}; overscaledZ = ${this.overscaledZ}`);
              const r5 = this.canonical.z - t4;
              return t4 > this.canonical.z ? fc(this.wrap * +e4, t4, this.canonical.z, this.canonical.x, this.canonical.y) : fc(this.wrap * +e4, t4, t4, this.canonical.x >> r5, this.canonical.y >> r5);
            }
            isChildOf(t4) {
              if (t4.wrap !== this.wrap)
                return false;
              const e4 = this.canonical.z - t4.canonical.z;
              return 0 === t4.overscaledZ || t4.overscaledZ < this.overscaledZ && t4.canonical.x === this.canonical.x >> e4 && t4.canonical.y === this.canonical.y >> e4;
            }
            children(t4) {
              if (this.overscaledZ >= t4)
                return [new pc(this.overscaledZ + 1, this.wrap, this.canonical.z, this.canonical.x, this.canonical.y)];
              const e4 = this.canonical.z + 1, r5 = 2 * this.canonical.x, n3 = 2 * this.canonical.y;
              return [new pc(e4, this.wrap, e4, r5, n3), new pc(e4, this.wrap, e4, r5 + 1, n3), new pc(e4, this.wrap, e4, r5, n3 + 1), new pc(e4, this.wrap, e4, r5 + 1, n3 + 1)];
            }
            isLessThan(t4) {
              return this.wrap < t4.wrap || !(this.wrap > t4.wrap) && (this.overscaledZ < t4.overscaledZ || !(this.overscaledZ > t4.overscaledZ) && (this.canonical.x < t4.canonical.x || !(this.canonical.x > t4.canonical.x) && this.canonical.y < t4.canonical.y));
            }
            wrapped() {
              return new pc(this.overscaledZ, 0, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            unwrapTo(t4) {
              return new pc(this.overscaledZ, t4, this.canonical.z, this.canonical.x, this.canonical.y);
            }
            overscaleFactor() {
              return Math.pow(2, this.overscaledZ - this.canonical.z);
            }
            toUnwrapped() {
              return new hc(this.wrap, this.canonical);
            }
            toString() {
              return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`;
            }
            getTilePoint(t4) {
              return this.canonical.getTilePoint(new lc(t4.x - this.wrap, t4.y));
            }
          }
          function fc(t4, e4, r5, n3, i5) {
            (t4 *= 2) < 0 && (t4 = -1 * t4 - 1);
            const a5 = 1 << r5;
            return (a5 * a5 * t4 + a5 * i5 + n3).toString(36) + r5.toString(36) + e4.toString(36);
          }
          $n("CanonicalTileID", cc), $n("OverscaledTileID", pc, { omit: ["posMatrix"] });
          class dc {
            constructor(t4, e4, r5, n3 = 1, i5 = 1, a5 = 1, s5 = 0) {
              if (this.uid = t4, e4.height !== e4.width)
                throw new RangeError("DEM tiles must be square");
              if (r5 && !["mapbox", "terrarium", "custom"].includes(r5))
                return void _3(`"${r5}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
              this.stride = e4.height;
              const o5 = this.dim = e4.height - 2;
              switch (this.data = new Uint32Array(e4.data.buffer), r5) {
                case "terrarium":
                  this.redFactor = 256, this.greenFactor = 1, this.blueFactor = 1 / 256, this.baseShift = 32768;
                  break;
                case "custom":
                  this.redFactor = n3, this.greenFactor = i5, this.blueFactor = a5, this.baseShift = s5;
                  break;
                default:
                  this.redFactor = 6553.6, this.greenFactor = 25.6, this.blueFactor = 0.1, this.baseShift = 1e4;
              }
              for (let t5 = 0; t5 < o5; t5++)
                this.data[this._idx(-1, t5)] = this.data[this._idx(0, t5)], this.data[this._idx(o5, t5)] = this.data[this._idx(o5 - 1, t5)], this.data[this._idx(t5, -1)] = this.data[this._idx(t5, 0)], this.data[this._idx(t5, o5)] = this.data[this._idx(t5, o5 - 1)];
              this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)], this.data[this._idx(o5, -1)] = this.data[this._idx(o5 - 1, 0)], this.data[this._idx(-1, o5)] = this.data[this._idx(0, o5 - 1)], this.data[this._idx(o5, o5)] = this.data[this._idx(o5 - 1, o5 - 1)], this.min = Number.MAX_SAFE_INTEGER, this.max = Number.MIN_SAFE_INTEGER;
              for (let t5 = 0; t5 < o5; t5++)
                for (let e5 = 0; e5 < o5; e5++) {
                  const r6 = this.get(t5, e5);
                  r6 > this.max && (this.max = r6), r6 < this.min && (this.min = r6);
                }
            }
            get(t4, e4) {
              const r5 = new Uint8Array(this.data.buffer), n3 = 4 * this._idx(t4, e4);
              return this.unpack(r5[n3], r5[n3 + 1], r5[n3 + 2]);
            }
            getUnpackVector() {
              return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift];
            }
            _idx(t4, e4) {
              if (t4 < -1 || t4 >= this.dim + 1 || e4 < -1 || e4 >= this.dim + 1)
                throw new RangeError("out of range source coordinates for DEM data");
              return (e4 + 1) * this.stride + (t4 + 1);
            }
            unpack(t4, e4, r5) {
              return t4 * this.redFactor + e4 * this.greenFactor + r5 * this.blueFactor - this.baseShift;
            }
            getPixels() {
              return new qs({ width: this.stride, height: this.stride }, new Uint8Array(this.data.buffer));
            }
            backfillBorder(t4, e4, r5) {
              if (this.dim !== t4.dim)
                throw new Error("dem dimension mismatch");
              let n3 = e4 * this.dim, i5 = e4 * this.dim + this.dim, a5 = r5 * this.dim, s5 = r5 * this.dim + this.dim;
              switch (e4) {
                case -1:
                  n3 = i5 - 1;
                  break;
                case 1:
                  i5 = n3 + 1;
              }
              switch (r5) {
                case -1:
                  a5 = s5 - 1;
                  break;
                case 1:
                  s5 = a5 + 1;
              }
              const o5 = -e4 * this.dim, l5 = -r5 * this.dim;
              for (let e5 = a5; e5 < s5; e5++)
                for (let r6 = n3; r6 < i5; r6++)
                  this.data[this._idx(r6, e5)] = t4.data[this._idx(r6 + o5, e5 + l5)];
            }
          }
          $n("DEMData", dc);
          class yc {
            constructor(t4) {
              this._stringToNumber = {}, this._numberToString = [];
              for (let e4 = 0; e4 < t4.length; e4++) {
                const r5 = t4[e4];
                this._stringToNumber[r5] = e4, this._numberToString[e4] = r5;
              }
            }
            encode(t4) {
              return this._stringToNumber[t4];
            }
            decode(t4) {
              if (t4 >= this._numberToString.length)
                throw new Error(`Out of bounds. Index requested n=${t4} can't be >= this._numberToString.length ${this._numberToString.length}`);
              return this._numberToString[t4];
            }
          }
          class mc {
            constructor(t4, e4, r5, n3, i5) {
              this.type = "Feature", this._vectorTileFeature = t4, t4._z = e4, t4._x = r5, t4._y = n3, this.properties = t4.properties, this.id = i5;
            }
            get geometry() {
              return void 0 === this._geometry && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry), this._geometry;
            }
            set geometry(t4) {
              this._geometry = t4;
            }
            toJSON() {
              const t4 = { geometry: this.geometry };
              for (const e4 in this)
                "_geometry" !== e4 && "_vectorTileFeature" !== e4 && (t4[e4] = this[e4]);
              return t4;
            }
          }
          class gc {
            constructor(t4, e4) {
              this.tileID = t4, this.x = t4.canonical.x, this.y = t4.canonical.y, this.z = t4.canonical.z, this.grid = new Fn(rs, 16, 0), this.grid3D = new Fn(rs, 16, 0), this.featureIndexArray = new ca(), this.promoteId = e4;
            }
            insert(t4, e4, r5, n3, i5, a5) {
              const s5 = this.featureIndexArray.length;
              this.featureIndexArray.emplaceBack(r5, n3, i5);
              const o5 = a5 ? this.grid3D : this.grid;
              for (let t5 = 0; t5 < e4.length; t5++) {
                const r6 = e4[t5], n4 = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                for (let t6 = 0; t6 < r6.length; t6++) {
                  const e5 = r6[t6];
                  n4[0] = Math.min(n4[0], e5.x), n4[1] = Math.min(n4[1], e5.y), n4[2] = Math.max(n4[2], e5.x), n4[3] = Math.max(n4[3], e5.y);
                }
                n4[0] < rs && n4[1] < rs && n4[2] >= 0 && n4[3] >= 0 && o5.insert(s5, n4[0], n4[1], n4[2], n4[3]);
              }
            }
            loadVTLayers() {
              return this.vtLayers || (this.vtLayers = new Ro.VectorTile(new eu(this.rawTileData)).layers, this.sourceLayerCoder = new yc(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])), this.vtLayers;
            }
            query(t4, e4, r5, n3) {
              this.loadVTLayers();
              const a5 = t4.params || {}, s5 = rs / t4.tileSize / t4.scale, o5 = Nr(a5.filter), l5 = t4.queryGeometry, u5 = t4.queryPadding * s5, c5 = vc(l5), h4 = this.grid.query(c5.minX - u5, c5.minY - u5, c5.maxX + u5, c5.maxY + u5), p7 = vc(t4.cameraQueryGeometry), f4 = this.grid3D.query(p7.minX - u5, p7.minY - u5, p7.maxX + u5, p7.maxY + u5, (e5, r6, n4, a6) => function(t5, e6, r7, n5, a7) {
                for (const i5 of t5)
                  if (e6 <= i5.x && r7 <= i5.y && n5 >= i5.x && a7 >= i5.y)
                    return true;
                const s6 = [new i4(e6, r7), new i4(e6, a7), new i4(n5, a7), new i4(n5, r7)];
                if (t5.length > 2) {
                  for (const e7 of s6)
                    if (xs(t5, e7))
                      return true;
                }
                for (let e7 = 0; e7 < t5.length - 1; e7++)
                  if (vs(t5[e7], t5[e7 + 1], s6))
                    return true;
                return false;
              }(t4.cameraQueryGeometry, e5 - u5, r6 - u5, n4 + u5, a6 + u5));
              for (const t5 of f4)
                h4.push(t5);
              h4.sort(bc);
              const d4 = {};
              let y3;
              for (let i5 = 0; i5 < h4.length; i5++) {
                const u6 = h4[i5];
                if (u6 === y3)
                  continue;
                y3 = u6;
                const c6 = this.featureIndexArray.get(u6);
                let p8 = null;
                this.loadMatchingFeature(d4, c6.bucketIndex, c6.sourceLayerIndex, c6.featureIndex, o5, a5.layers, a5.availableImages, e4, r5, n3, (e5, r6, n4) => (p8 || (p8 = as(e5)), r6.queryIntersectsFeature(l5, e5, n4, p8, this.z, t4.transform, s5, t4.pixelPosMatrix)));
              }
              return d4;
            }
            loadMatchingFeature(t4, e4, r5, n3, i5, a5, s5, o5, l5, u5, c5) {
              const h4 = this.bucketLayerIDs[e4];
              if (a5 && !function(t5, e5) {
                for (let r6 = 0; r6 < t5.length; r6++)
                  if (e5.indexOf(t5[r6]) >= 0)
                    return true;
                return false;
              }(a5, h4))
                return;
              const p7 = this.sourceLayerCoder.decode(r5), f4 = this.vtLayers[p7].feature(n3);
              if (i5.needGeometry) {
                const t5 = ss(f4, true);
                if (!i5.filter(new li(this.tileID.overscaledZ), t5, this.tileID.canonical))
                  return;
              } else if (!i5.filter(new li(this.tileID.overscaledZ), f4))
                return;
              const d4 = this.getId(f4, p7);
              for (let e5 = 0; e5 < h4.length; e5++) {
                const r6 = h4[e5];
                if (a5 && a5.indexOf(r6) < 0)
                  continue;
                const i6 = o5[r6];
                if (!i6)
                  continue;
                let p8 = {};
                d4 && u5 && (p8 = u5.getState(i6.sourceLayer || "_geojsonTileLayer", d4));
                const y3 = m3({}, l5[r6]);
                y3.paint = xc(y3.paint, i6.paint, f4, p8, s5), y3.layout = xc(y3.layout, i6.layout, f4, p8, s5);
                const g4 = !c5 || c5(f4, i6, p8);
                if (!g4)
                  continue;
                const x3 = new mc(f4, this.z, this.x, this.y, d4);
                x3.layer = y3;
                let v5 = t4[r6];
                void 0 === v5 && (v5 = t4[r6] = []), v5.push({ featureIndex: n3, feature: x3, intersectionZ: g4 });
              }
            }
            lookupSymbolFeatures(t4, e4, r5, n3, i5, a5, s5, o5) {
              const l5 = {};
              this.loadVTLayers();
              const u5 = Nr(i5);
              for (const i6 of t4)
                this.loadMatchingFeature(l5, r5, n3, i6, u5, a5, s5, o5, e4);
              return l5;
            }
            hasLayer(t4) {
              for (const e4 of this.bucketLayerIDs)
                for (const r5 of e4)
                  if (t4 === r5)
                    return true;
              return false;
            }
            getId(t4, e4) {
              let r5 = t4.id;
              return this.promoteId && (r5 = t4.properties["string" == typeof this.promoteId ? this.promoteId : this.promoteId[e4]], "boolean" == typeof r5 && (r5 = Number(r5))), r5;
            }
          }
          function xc(t4, e4, r5, n3, i5) {
            return x2(t4, (t5, a5) => {
              const s5 = e4 instanceof mi ? e4.get(a5) : null;
              return s5 && s5.evaluate ? s5.evaluate(r5, n3, i5) : s5;
            });
          }
          function vc(t4) {
            let e4 = 1 / 0, r5 = 1 / 0, n3 = -1 / 0, i5 = -1 / 0;
            for (const a5 of t4)
              e4 = Math.min(e4, a5.x), r5 = Math.min(r5, a5.y), n3 = Math.max(n3, a5.x), i5 = Math.max(i5, a5.y);
            return { minX: e4, minY: r5, maxX: n3, maxY: i5 };
          }
          function bc(t4, e4) {
            return e4 - t4;
          }
          function wc(t4, e4, r5, n3, a5) {
            const s5 = [];
            for (let o5 = 0; o5 < t4.length; o5++) {
              const l5 = t4[o5];
              let u5;
              for (let t5 = 0; t5 < l5.length - 1; t5++) {
                let o6 = l5[t5], c5 = l5[t5 + 1];
                o6.x < e4 && c5.x < e4 || (o6.x < e4 ? o6 = new i4(e4, o6.y + (e4 - o6.x) / (c5.x - o6.x) * (c5.y - o6.y))._round() : c5.x < e4 && (c5 = new i4(e4, o6.y + (e4 - o6.x) / (c5.x - o6.x) * (c5.y - o6.y))._round()), o6.y < r5 && c5.y < r5 || (o6.y < r5 ? o6 = new i4(o6.x + (r5 - o6.y) / (c5.y - o6.y) * (c5.x - o6.x), r5)._round() : c5.y < r5 && (c5 = new i4(o6.x + (r5 - o6.y) / (c5.y - o6.y) * (c5.x - o6.x), r5)._round()), o6.x >= n3 && c5.x >= n3 || (o6.x >= n3 ? o6 = new i4(n3, o6.y + (n3 - o6.x) / (c5.x - o6.x) * (c5.y - o6.y))._round() : c5.x >= n3 && (c5 = new i4(n3, o6.y + (n3 - o6.x) / (c5.x - o6.x) * (c5.y - o6.y))._round()), o6.y >= a5 && c5.y >= a5 || (o6.y >= a5 ? o6 = new i4(o6.x + (a5 - o6.y) / (c5.y - o6.y) * (c5.x - o6.x), a5)._round() : c5.y >= a5 && (c5 = new i4(o6.x + (a5 - o6.y) / (c5.y - o6.y) * (c5.x - o6.x), a5)._round()), u5 && o6.equals(u5[u5.length - 1]) || (u5 = [o6], s5.push(u5)), u5.push(c5)))));
              }
            }
            return s5;
          }
          $n("FeatureIndex", gc, { omit: ["rawTileData", "sourceLayerCoder"] });
          class _c extends i4 {
            constructor(t4, e4, r5, n3) {
              super(t4, e4), this.angle = r5, void 0 !== n3 && (this.segment = n3);
            }
            clone() {
              return new _c(this.x, this.y, this.angle, this.segment);
            }
          }
          function Ac(t4, e4, r5, n3, i5) {
            if (void 0 === e4.segment || 0 === r5)
              return true;
            let a5 = e4, s5 = e4.segment + 1, o5 = 0;
            for (; o5 > -r5 / 2; ) {
              if (s5--, s5 < 0)
                return false;
              o5 -= t4[s5].dist(a5), a5 = t4[s5];
            }
            o5 += t4[s5].dist(t4[s5 + 1]), s5++;
            const l5 = [];
            let u5 = 0;
            for (; o5 < r5 / 2; ) {
              const e5 = t4[s5], r6 = t4[s5 + 1];
              if (!r6)
                return false;
              let a6 = t4[s5 - 1].angleTo(e5) - e5.angleTo(r6);
              for (a6 = Math.abs((a6 + 3 * Math.PI) % (2 * Math.PI) - Math.PI), l5.push({ distance: o5, angleDelta: a6 }), u5 += a6; o5 - l5[0].distance > n3; )
                u5 -= l5.shift().angleDelta;
              if (u5 > i5)
                return false;
              s5++, o5 += e5.dist(r6);
            }
            return true;
          }
          function Sc(t4) {
            let e4 = 0;
            for (let r5 = 0; r5 < t4.length - 1; r5++)
              e4 += t4[r5].dist(t4[r5 + 1]);
            return e4;
          }
          function kc(t4, e4, r5) {
            return t4 ? 0.6 * e4 * r5 : 0;
          }
          function Ic(t4, e4) {
            return Math.max(t4 ? t4.right - t4.left : 0, e4 ? e4.right - e4.left : 0);
          }
          function zc(t4, e4, r5, n3, i5, a5) {
            const s5 = kc(r5, i5, a5), o5 = Ic(r5, n3) * a5;
            let l5 = 0;
            const u5 = Sc(t4) / 2;
            for (let r6 = 0; r6 < t4.length - 1; r6++) {
              const n4 = t4[r6], i6 = t4[r6 + 1], a6 = n4.dist(i6);
              if (l5 + a6 > u5) {
                const c5 = (u5 - l5) / a6, h4 = Ze.number(n4.x, i6.x, c5), p7 = Ze.number(n4.y, i6.y, c5), f4 = new _c(h4, p7, i6.angleTo(n4), r6);
                return f4._round(), !s5 || Ac(t4, f4, o5, s5, e4) ? f4 : void 0;
              }
              l5 += a6;
            }
          }
          function Mc(t4, e4, r5, n3, i5, a5, s5, o5, l5) {
            const u5 = kc(n3, a5, s5), c5 = Ic(n3, i5), h4 = c5 * s5, p7 = 0 === t4[0].x || t4[0].x === l5 || 0 === t4[0].y || t4[0].y === l5;
            return e4 - h4 < e4 / 4 && (e4 = h4 + e4 / 4), Pc(t4, p7 ? e4 / 2 * o5 % e4 : (c5 / 2 + 2 * a5) * s5 * o5 % e4, e4, u5, r5, h4, p7, false, l5);
          }
          function Pc(t4, e4, r5, n3, i5, a5, s5, o5, l5) {
            const u5 = a5 / 2, c5 = Sc(t4);
            let h4 = 0, p7 = e4 - r5, f4 = [];
            for (let e5 = 0; e5 < t4.length - 1; e5++) {
              const s6 = t4[e5], o6 = t4[e5 + 1], d4 = s6.dist(o6), y3 = o6.angleTo(s6);
              for (; p7 + r5 < h4 + d4; ) {
                p7 += r5;
                const m4 = (p7 - h4) / d4, g4 = Ze.number(s6.x, o6.x, m4), x3 = Ze.number(s6.y, o6.y, m4);
                if (g4 >= 0 && g4 < l5 && x3 >= 0 && x3 < l5 && p7 - u5 >= 0 && p7 + u5 <= c5) {
                  const r6 = new _c(g4, x3, y3, e5);
                  r6._round(), n3 && !Ac(t4, r6, a5, n3, i5) || f4.push(r6);
                }
              }
              h4 += d4;
            }
            return o5 || f4.length || s5 || (f4 = Pc(t4, h4 / 2, r5, n3, i5, a5, s5, true, l5)), f4;
          }
          $n("Anchor", _c);
          const Cc = lu;
          function Bc(t4, e4, r5, n3) {
            const a5 = [], s5 = t4.image, o5 = s5.pixelRatio, l5 = s5.paddedRect.w - 2 * Cc, u5 = s5.paddedRect.h - 2 * Cc, c5 = t4.right - t4.left, h4 = t4.bottom - t4.top, p7 = s5.stretchX || [[0, l5]], f4 = s5.stretchY || [[0, u5]], d4 = (t5, e5) => t5 + e5[1] - e5[0], y3 = p7.reduce(d4, 0), m4 = f4.reduce(d4, 0), g4 = l5 - y3, x3 = u5 - m4;
            let v5 = 0, b4 = y3, w4 = 0, _4 = m4, A3 = 0, S3 = g4, k4 = 0, I3 = x3;
            if (s5.content && n3) {
              const t5 = s5.content;
              v5 = Vc(p7, 0, t5[0]), w4 = Vc(f4, 0, t5[1]), b4 = Vc(p7, t5[0], t5[2]), _4 = Vc(f4, t5[1], t5[3]), A3 = t5[0] - v5, k4 = t5[1] - w4, S3 = t5[2] - t5[0] - b4, I3 = t5[3] - t5[1] - _4;
            }
            const z4 = (n4, a6, l6, u6) => {
              const p8 = Fc(n4.stretch - v5, b4, c5, t4.left), f5 = Tc(n4.fixed - A3, S3, n4.stretch, y3), d5 = Fc(a6.stretch - w4, _4, h4, t4.top), g5 = Tc(a6.fixed - k4, I3, a6.stretch, m4), x4 = Fc(l6.stretch - v5, b4, c5, t4.left), z5 = Tc(l6.fixed - A3, S3, l6.stretch, y3), M3 = Fc(u6.stretch - w4, _4, h4, t4.top), P3 = Tc(u6.fixed - k4, I3, u6.stretch, m4), C2 = new i4(p8, d5), B4 = new i4(x4, d5), V2 = new i4(x4, M3), E3 = new i4(p8, M3), F4 = new i4(f5 / o5, g5 / o5), T3 = new i4(z5 / o5, P3 / o5), $3 = e4 * Math.PI / 180;
              if ($3) {
                const t5 = Math.sin($3), e5 = Math.cos($3), r6 = [e5, -t5, t5, e5];
                C2._matMult(r6), B4._matMult(r6), E3._matMult(r6), V2._matMult(r6);
              }
              const L3 = n4.stretch + n4.fixed, D3 = a6.stretch + a6.fixed;
              return { tl: C2, tr: B4, bl: E3, br: V2, tex: { x: s5.paddedRect.x + Cc + L3, y: s5.paddedRect.y + Cc + D3, w: l6.stretch + l6.fixed - L3, h: u6.stretch + u6.fixed - D3 }, writingMode: void 0, glyphOffset: [0, 0], sectionIndex: 0, pixelOffsetTL: F4, pixelOffsetBR: T3, minFontScaleX: S3 / o5 / c5, minFontScaleY: I3 / o5 / h4, isSDF: r5 };
            };
            if (n3 && (s5.stretchX || s5.stretchY)) {
              const t5 = Ec(p7, g4, y3), e5 = Ec(f4, x3, m4);
              for (let r6 = 0; r6 < t5.length - 1; r6++) {
                const n4 = t5[r6], i5 = t5[r6 + 1];
                for (let t6 = 0; t6 < e5.length - 1; t6++)
                  a5.push(z4(n4, e5[t6], i5, e5[t6 + 1]));
              }
            } else
              a5.push(z4({ fixed: 0, stretch: -1 }, { fixed: 0, stretch: -1 }, { fixed: 0, stretch: l5 + 1 }, { fixed: 0, stretch: u5 + 1 }));
            return a5;
          }
          function Vc(t4, e4, r5) {
            let n3 = 0;
            for (const i5 of t4)
              n3 += Math.max(e4, Math.min(r5, i5[1])) - Math.max(e4, Math.min(r5, i5[0]));
            return n3;
          }
          function Ec(t4, e4, r5) {
            const n3 = [{ fixed: -Cc, stretch: 0 }];
            for (const [e5, r6] of t4) {
              const t5 = n3[n3.length - 1];
              n3.push({ fixed: e5 - t5.stretch, stretch: t5.stretch }), n3.push({ fixed: e5 - t5.stretch, stretch: t5.stretch + (r6 - e5) });
            }
            return n3.push({ fixed: e4 + Cc, stretch: r5 }), n3;
          }
          function Fc(t4, e4, r5, n3) {
            return t4 / e4 * r5 + n3;
          }
          function Tc(t4, e4, r5, n3) {
            return t4 - e4 * r5 / n3;
          }
          class $c {
            constructor(t4, e4, r5, n3, a5, s5, o5, l5, u5, c5) {
              if (this.boxStartIndex = t4.length, u5) {
                let t5 = s5.top, e5 = s5.bottom;
                const r6 = s5.collisionPadding;
                r6 && (t5 -= r6[1], e5 += r6[3]);
                let n4 = e5 - t5;
                n4 > 0 && (n4 = Math.max(10, n4), this.circleDiameter = n4);
              } else {
                let u6 = s5.top * o5 - l5[0], h4 = s5.bottom * o5 + l5[2], p7 = s5.left * o5 - l5[3], f4 = s5.right * o5 + l5[1];
                const d4 = s5.collisionPadding;
                if (d4 && (p7 -= d4[0] * o5, u6 -= d4[1] * o5, f4 += d4[2] * o5, h4 += d4[3] * o5), c5) {
                  const t5 = new i4(p7, u6), e5 = new i4(f4, u6), r6 = new i4(p7, h4), n4 = new i4(f4, h4), a6 = c5 * Math.PI / 180;
                  t5._rotate(a6), e5._rotate(a6), r6._rotate(a6), n4._rotate(a6), p7 = Math.min(t5.x, e5.x, r6.x, n4.x), f4 = Math.max(t5.x, e5.x, r6.x, n4.x), u6 = Math.min(t5.y, e5.y, r6.y, n4.y), h4 = Math.max(t5.y, e5.y, r6.y, n4.y);
                }
                t4.emplaceBack(e4.x, e4.y, p7, u6, f4, h4, r5, n3, a5);
              }
              this.boxEndIndex = t4.length;
            }
          }
          class Lc {
            constructor(t4 = [], e4 = Dc) {
              if (this.data = t4, this.length = this.data.length, this.compare = e4, this.length > 0)
                for (let t5 = (this.length >> 1) - 1; t5 >= 0; t5--)
                  this._down(t5);
            }
            push(t4) {
              this.data.push(t4), this.length++, this._up(this.length - 1);
            }
            pop() {
              if (0 === this.length)
                return;
              const t4 = this.data[0], e4 = this.data.pop();
              return this.length--, this.length > 0 && (this.data[0] = e4, this._down(0)), t4;
            }
            peek() {
              return this.data[0];
            }
            _up(t4) {
              const { data: e4, compare: r5 } = this, n3 = e4[t4];
              for (; t4 > 0; ) {
                const i5 = t4 - 1 >> 1, a5 = e4[i5];
                if (r5(n3, a5) >= 0)
                  break;
                e4[t4] = a5, t4 = i5;
              }
              e4[t4] = n3;
            }
            _down(t4) {
              const { data: e4, compare: r5 } = this, n3 = this.length >> 1, i5 = e4[t4];
              for (; t4 < n3; ) {
                let n4 = 1 + (t4 << 1), a5 = e4[n4];
                const s5 = n4 + 1;
                if (s5 < this.length && r5(e4[s5], a5) < 0 && (n4 = s5, a5 = e4[s5]), r5(a5, i5) >= 0)
                  break;
                e4[t4] = a5, t4 = n4;
              }
              e4[t4] = i5;
            }
          }
          function Dc(t4, e4) {
            return t4 < e4 ? -1 : t4 > e4 ? 1 : 0;
          }
          function Oc(t4, e4 = 1, r5 = false) {
            let n3 = 1 / 0, a5 = 1 / 0, s5 = -1 / 0, o5 = -1 / 0;
            const l5 = t4[0];
            for (let t5 = 0; t5 < l5.length; t5++) {
              const e5 = l5[t5];
              (!t5 || e5.x < n3) && (n3 = e5.x), (!t5 || e5.y < a5) && (a5 = e5.y), (!t5 || e5.x > s5) && (s5 = e5.x), (!t5 || e5.y > o5) && (o5 = e5.y);
            }
            const u5 = Math.min(s5 - n3, o5 - a5);
            let c5 = u5 / 2;
            const h4 = new Lc([], Uc);
            if (0 === u5)
              return new i4(n3, a5);
            for (let e5 = n3; e5 < s5; e5 += u5)
              for (let r6 = a5; r6 < o5; r6 += u5)
                h4.push(new Rc(e5 + c5, r6 + c5, c5, t4));
            let p7 = function(t5) {
              let e5 = 0, r6 = 0, n4 = 0;
              const i5 = t5[0];
              for (let t6 = 0, a6 = i5.length, s6 = a6 - 1; t6 < a6; s6 = t6++) {
                const a7 = i5[t6], o6 = i5[s6], l6 = a7.x * o6.y - o6.x * a7.y;
                r6 += (a7.x + o6.x) * l6, n4 += (a7.y + o6.y) * l6, e5 += 3 * l6;
              }
              return new Rc(r6 / e5, n4 / e5, 0, t5);
            }(t4), f4 = h4.length;
            for (; h4.length; ) {
              const n4 = h4.pop();
              (n4.d > p7.d || !p7.d) && (p7 = n4, r5 && console.log("found best %d after %d probes", Math.round(1e4 * n4.d) / 1e4, f4)), n4.max - p7.d <= e4 || (c5 = n4.h / 2, h4.push(new Rc(n4.p.x - c5, n4.p.y - c5, c5, t4)), h4.push(new Rc(n4.p.x + c5, n4.p.y - c5, c5, t4)), h4.push(new Rc(n4.p.x - c5, n4.p.y + c5, c5, t4)), h4.push(new Rc(n4.p.x + c5, n4.p.y + c5, c5, t4)), f4 += 4);
            }
            return r5 && (console.log(`num probes: ${f4}`), console.log(`best distance: ${p7.d}`)), p7.p;
          }
          function Uc(t4, e4) {
            return e4.max - t4.max;
          }
          function Rc(t4, e4, r5, n3) {
            this.p = new i4(t4, e4), this.h = r5, this.d = function(t5, e5) {
              let r6 = false, n4 = 1 / 0;
              for (let i5 = 0; i5 < e5.length; i5++) {
                const a5 = e5[i5];
                for (let e6 = 0, i6 = a5.length, s5 = i6 - 1; e6 < i6; s5 = e6++) {
                  const i7 = a5[e6], o5 = a5[s5];
                  i7.y > t5.y != o5.y > t5.y && t5.x < (o5.x - i7.x) * (t5.y - i7.y) / (o5.y - i7.y) + i7.x && (r6 = !r6), n4 = Math.min(n4, ms(t5, i7, o5));
                }
              }
              return (r6 ? 1 : -1) * Math.sqrt(n4);
            }(this.p, n3), this.max = this.d + this.h * Math.SQRT2;
          }
          var qc;
          t3.TextAnchorEnum = void 0, (qc = t3.TextAnchorEnum || (t3.TextAnchorEnum = {}))[qc.center = 1] = "center", qc[qc.left = 2] = "left", qc[qc.right = 3] = "right", qc[qc.top = 4] = "top", qc[qc.bottom = 5] = "bottom", qc[qc["top-left"] = 6] = "top-left", qc[qc["top-right"] = 7] = "top-right", qc[qc["bottom-left"] = 8] = "bottom-left", qc[qc["bottom-right"] = 9] = "bottom-right";
          const jc = 7, Nc = Number.POSITIVE_INFINITY;
          function Zc(t4, e4) {
            return e4[1] !== Nc ? function(t5, e5, r5) {
              let n3 = 0, i5 = 0;
              switch (e5 = Math.abs(e5), r5 = Math.abs(r5), t5) {
                case "top-right":
                case "top-left":
                case "top":
                  i5 = r5 - jc;
                  break;
                case "bottom-right":
                case "bottom-left":
                case "bottom":
                  i5 = -r5 + jc;
              }
              switch (t5) {
                case "top-right":
                case "bottom-right":
                case "right":
                  n3 = -e5;
                  break;
                case "top-left":
                case "bottom-left":
                case "left":
                  n3 = e5;
              }
              return [n3, i5];
            }(t4, e4[0], e4[1]) : function(t5, e5) {
              let r5 = 0, n3 = 0;
              e5 < 0 && (e5 = 0);
              const i5 = e5 / Math.SQRT2;
              switch (t5) {
                case "top-right":
                case "top-left":
                  n3 = i5 - jc;
                  break;
                case "bottom-right":
                case "bottom-left":
                  n3 = -i5 + jc;
                  break;
                case "bottom":
                  n3 = -e5 + jc;
                  break;
                case "top":
                  n3 = e5 - jc;
              }
              switch (t5) {
                case "top-right":
                case "bottom-right":
                  r5 = -i5;
                  break;
                case "top-left":
                case "bottom-left":
                  r5 = i5;
                  break;
                case "left":
                  r5 = e5;
                  break;
                case "right":
                  r5 = -e5;
              }
              return [r5, n3];
            }(t4, e4[0]);
          }
          function Kc(t4, e4, r5) {
            var n3;
            const i5 = t4.layout, a5 = null === (n3 = i5.get("text-variable-anchor-offset")) || void 0 === n3 ? void 0 : n3.evaluate(e4, {}, r5);
            if (a5) {
              const t5 = a5.values, e5 = [];
              for (let r6 = 0; r6 < t5.length; r6 += 2) {
                const n4 = e5[r6] = t5[r6], i6 = t5[r6 + 1].map((t6) => t6 * Vl);
                n4.startsWith("top") ? i6[1] -= jc : n4.startsWith("bottom") && (i6[1] += jc), e5[r6 + 1] = i6;
              }
              return new re(e5);
            }
            const s5 = i5.get("text-variable-anchor");
            if (s5) {
              let n4;
              n4 = void 0 !== t4._unevaluatedLayout.getValue("text-radial-offset") ? [i5.get("text-radial-offset").evaluate(e4, {}, r5) * Vl, Nc] : i5.get("text-offset").evaluate(e4, {}, r5).map((t5) => t5 * Vl);
              const a6 = [];
              for (const t5 of s5)
                a6.push(t5, Zc(t5, n4));
              return new re(a6);
            }
            return null;
          }
          function Gc(t4) {
            switch (t4) {
              case "right":
              case "top-right":
              case "bottom-right":
                return "right";
              case "left":
              case "top-left":
              case "bottom-left":
                return "left";
            }
            return "center";
          }
          function Jc(e4, r5, n3, i5, a5, s5, o5, l5, u5, c5, h4) {
            let p7 = s5.textMaxSize.evaluate(r5, {});
            void 0 === p7 && (p7 = o5);
            const f4 = e4.layers[0].layout, d4 = f4.get("icon-offset").evaluate(r5, {}, h4), y3 = Yc(n3.horizontal), m4 = o5 / 24, g4 = e4.tilePixelRatio * m4, x3 = e4.tilePixelRatio * p7 / 24, v5 = e4.tilePixelRatio * l5, b4 = e4.tilePixelRatio * f4.get("symbol-spacing"), w4 = f4.get("text-padding") * e4.tilePixelRatio, A3 = function(t4, e5, r6, n4 = 1) {
              const i6 = t4.get("icon-padding").evaluate(e5, {}, r6), a6 = i6 && i6.values;
              return [a6[0] * n4, a6[1] * n4, a6[2] * n4, a6[3] * n4];
            }(f4, r5, h4, e4.tilePixelRatio), S3 = f4.get("text-max-angle") / 180 * Math.PI, k4 = "viewport" !== f4.get("text-rotation-alignment") && "point" !== f4.get("symbol-placement"), I3 = "map" === f4.get("icon-rotation-alignment") && "point" !== f4.get("symbol-placement"), z4 = f4.get("symbol-placement"), M3 = b4 / 2, P3 = f4.get("icon-text-fit");
            let C2;
            i5 && "none" !== P3 && (e4.allowVerticalPlacement && n3.vertical && (C2 = zu(i5, n3.vertical, P3, f4.get("icon-text-fit-padding"), d4, m4)), y3 && (i5 = zu(i5, y3, P3, f4.get("icon-text-fit-padding"), d4, m4)));
            const B4 = (l6, p8) => {
              p8.x < 0 || p8.x >= rs || p8.y < 0 || p8.y >= rs || function(e5, r6, n4, i6, a6, s6, o6, l7, u6, c6, h5, p9, f5, d5, y4, m5, g5, x4, v6, b5, w5, A4, S4, k5, I4) {
                const z5 = e5.addToLineVertexArray(r6, n4);
                let M4, P4, C3, B5, V2 = 0, E3 = 0, F4 = 0, T3 = 0, $3 = -1, L3 = -1;
                const D3 = {};
                let O3 = $a("");
                if (e5.allowVerticalPlacement && i6.vertical) {
                  const t4 = l7.layout.get("text-rotate").evaluate(w5, {}, k5) + 90;
                  C3 = new $c(u6, r6, c6, h5, p9, i6.vertical, f5, d5, y4, t4), o6 && (B5 = new $c(u6, r6, c6, h5, p9, o6, g5, x4, y4, t4));
                }
                if (a6) {
                  const n5 = l7.layout.get("icon-rotate").evaluate(w5, {}), i7 = "none" !== l7.layout.get("icon-text-fit"), s7 = Bc(a6, n5, S4, i7), f6 = o6 ? Bc(o6, n5, S4, i7) : void 0;
                  P4 = new $c(u6, r6, c6, h5, p9, a6, g5, x4, false, n5), V2 = 4 * s7.length;
                  const d6 = e5.iconSizeData;
                  let y5 = null;
                  "source" === d6.kind ? (y5 = [Pu * l7.layout.get("icon-size").evaluate(w5, {})], y5[0] > Cu && _3(`${e5.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)) : "composite" === d6.kind && (y5 = [Pu * A4.compositeIconSizes[0].evaluate(w5, {}, k5), Pu * A4.compositeIconSizes[1].evaluate(w5, {}, k5)], (y5[0] > Cu || y5[1] > Cu) && _3(`${e5.layerIds[0]}: Value for "icon-size" is >= ${Mu}. Reduce your "icon-size".`)), e5.addSymbols(e5.icon, s7, y5, b5, v6, w5, t3.WritingMode.none, r6, z5.lineStartIndex, z5.lineLength, -1, k5), $3 = e5.icon.placedSymbolArray.length - 1, f6 && (E3 = 4 * f6.length, e5.addSymbols(e5.icon, f6, y5, b5, v6, w5, t3.WritingMode.vertical, r6, z5.lineStartIndex, z5.lineLength, -1, k5), L3 = e5.icon.placedSymbolArray.length - 1);
                }
                const U2 = Object.keys(i6.horizontal);
                for (const n5 of U2) {
                  const a7 = i6.horizontal[n5];
                  if (!M4) {
                    O3 = $a(a7.text);
                    const t4 = l7.layout.get("text-rotate").evaluate(w5, {}, k5);
                    M4 = new $c(u6, r6, c6, h5, p9, a7, f5, d5, y4, t4);
                  }
                  const o7 = 1 === a7.positionedLines.length;
                  if (F4 += Xc(e5, r6, a7, s6, l7, y4, w5, m5, z5, i6.vertical ? t3.WritingMode.horizontal : t3.WritingMode.horizontalOnly, o7 ? U2 : [n5], D3, $3, A4, k5), o7)
                    break;
                }
                i6.vertical && (T3 += Xc(e5, r6, i6.vertical, s6, l7, y4, w5, m5, z5, t3.WritingMode.vertical, ["vertical"], D3, L3, A4, k5));
                const R2 = M4 ? M4.boxStartIndex : e5.collisionBoxArray.length, q4 = M4 ? M4.boxEndIndex : e5.collisionBoxArray.length, j4 = C3 ? C3.boxStartIndex : e5.collisionBoxArray.length, N3 = C3 ? C3.boxEndIndex : e5.collisionBoxArray.length, Z2 = P4 ? P4.boxStartIndex : e5.collisionBoxArray.length, K2 = P4 ? P4.boxEndIndex : e5.collisionBoxArray.length, G3 = B5 ? B5.boxStartIndex : e5.collisionBoxArray.length, J2 = B5 ? B5.boxEndIndex : e5.collisionBoxArray.length;
                let X2 = -1;
                const Y2 = (t4, e6) => t4 && t4.circleDiameter ? Math.max(t4.circleDiameter, e6) : e6;
                X2 = Y2(M4, X2), X2 = Y2(C3, X2), X2 = Y2(P4, X2), X2 = Y2(B5, X2);
                const H3 = X2 > -1 ? 1 : 0;
                H3 && (X2 *= I4 / Vl), e5.glyphOffsetArray.length >= Uu.MAX_GLYPHS && _3("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"), void 0 !== w5.sortKey && e5.addToSortKeyRanges(e5.symbolInstances.length, w5.sortKey);
                const W2 = Kc(l7, w5, k5), [Q2, tt2] = function(e6, r7) {
                  const n5 = e6.length, i7 = null == r7 ? void 0 : r7.values;
                  if ((null == i7 ? void 0 : i7.length) > 0)
                    for (let r8 = 0; r8 < i7.length; r8 += 2) {
                      const n6 = i7[r8 + 1];
                      e6.emplaceBack(t3.TextAnchorEnum[i7[r8]], n6[0], n6[1]);
                    }
                  return [n5, e6.length];
                }(e5.textAnchorOffsets, W2);
                e5.symbolInstances.emplaceBack(r6.x, r6.y, D3.right >= 0 ? D3.right : -1, D3.center >= 0 ? D3.center : -1, D3.left >= 0 ? D3.left : -1, D3.vertical || -1, $3, L3, O3, R2, q4, j4, N3, Z2, K2, G3, J2, c6, F4, T3, V2, E3, H3, 0, f5, X2, Q2, tt2);
              }(e4, p8, l6, n3, i5, a5, C2, e4.layers[0], e4.collisionBoxArray, r5.index, r5.sourceLayerIndex, e4.index, g4, [w4, w4, w4, w4], k4, u5, v5, A3, I3, d4, r5, s5, c5, h4, o5);
            };
            if ("line" === z4)
              for (const t4 of wc(r5.geometry, 0, 0, rs, rs)) {
                const r6 = Mc(t4, b4, S3, n3.vertical || y3, i5, 24, x3, e4.overscaling, rs);
                for (const n4 of r6)
                  y3 && Hc(e4, y3.text, M3, n4) || B4(t4, n4);
              }
            else if ("line-center" === z4) {
              for (const t4 of r5.geometry)
                if (t4.length > 1) {
                  const e5 = zc(t4, S3, n3.vertical || y3, i5, 24, x3);
                  e5 && B4(t4, e5);
                }
            } else if ("Polygon" === r5.type)
              for (const t4 of Po(r5.geometry, 0)) {
                const e5 = Oc(t4, 16);
                B4(t4[0], new _c(e5.x, e5.y, 0));
              }
            else if ("LineString" === r5.type)
              for (const t4 of r5.geometry)
                B4(t4, new _c(t4[0].x, t4[0].y, 0));
            else if ("Point" === r5.type)
              for (const t4 of r5.geometry)
                for (const e5 of t4)
                  B4([e5], new _c(e5.x, e5.y, 0));
          }
          function Xc(t4, e4, r5, n3, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3) {
            const m4 = function(t5, e5, r6, n4, a6, s6, o6, l6) {
              const u6 = n4.layout.get("text-rotate").evaluate(s6, {}) * Math.PI / 180, c6 = [];
              for (const t6 of e5.positionedLines)
                for (const n5 of t6.positionedGlyphs) {
                  if (!n5.rect)
                    continue;
                  const s7 = n5.rect || {};
                  let h5 = su + 1, p8 = true, f5 = 1, d5 = 0;
                  const y4 = (a6 || l6) && n5.vertical, m5 = n5.metrics.advance * n5.scale / 2;
                  if (l6 && e5.verticalizable && (d5 = t6.lineOffset / 2 - (n5.imageName ? -(Vl - n5.metrics.width * n5.scale) / 2 : (n5.scale - 1) * Vl)), n5.imageName) {
                    const t7 = o6[n5.imageName];
                    p8 = t7.sdf, f5 = t7.pixelRatio, h5 = lu / f5;
                  }
                  const g5 = a6 ? [n5.x + m5, n5.y] : [0, 0];
                  let x4 = a6 ? [0, 0] : [n5.x + m5 + r6[0], n5.y + r6[1] - d5], v5 = [0, 0];
                  y4 && (v5 = x4, x4 = [0, 0]);
                  const b4 = n5.metrics.isDoubleResolution ? 2 : 1, w4 = (n5.metrics.left - h5) * n5.scale - m5 + x4[0], _4 = (-n5.metrics.top - h5) * n5.scale + x4[1], A3 = w4 + s7.w / b4 * n5.scale / f5, S3 = _4 + s7.h / b4 * n5.scale / f5, k4 = new i4(w4, _4), I3 = new i4(A3, _4), z4 = new i4(w4, S3), M3 = new i4(A3, S3);
                  if (y4) {
                    const t7 = new i4(-m5, m5 - pu), e6 = -Math.PI / 2, r7 = Vl / 2 - m5, a7 = new i4(5 - pu - r7, -(n5.imageName ? r7 : 0)), s8 = new i4(...v5);
                    k4._rotateAround(e6, t7)._add(a7)._add(s8), I3._rotateAround(e6, t7)._add(a7)._add(s8), z4._rotateAround(e6, t7)._add(a7)._add(s8), M3._rotateAround(e6, t7)._add(a7)._add(s8);
                  }
                  if (u6) {
                    const t7 = Math.sin(u6), e6 = Math.cos(u6), r7 = [e6, -t7, t7, e6];
                    k4._matMult(r7), I3._matMult(r7), z4._matMult(r7), M3._matMult(r7);
                  }
                  const P3 = new i4(0, 0), C2 = new i4(0, 0);
                  c6.push({ tl: k4, tr: I3, bl: z4, br: M3, tex: s7, writingMode: e5.writingMode, glyphOffset: g5, sectionIndex: n5.sectionIndex, isSDF: p8, pixelOffsetTL: P3, pixelOffsetBR: C2, minFontScaleX: 0, minFontScaleY: 0 });
                }
              return c6;
            }(0, r5, l5, a5, s5, o5, n3, t4.allowVerticalPlacement), g4 = t4.textSizeData;
            let x3 = null;
            "source" === g4.kind ? (x3 = [Pu * a5.layout.get("text-size").evaluate(o5, {})], x3[0] > Cu && _3(`${t4.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)) : "composite" === g4.kind && (x3 = [Pu * d4.compositeTextSizes[0].evaluate(o5, {}, y3), Pu * d4.compositeTextSizes[1].evaluate(o5, {}, y3)], (x3[0] > Cu || x3[1] > Cu) && _3(`${t4.layerIds[0]}: Value for "text-size" is >= ${Mu}. Reduce your "text-size".`)), t4.addSymbols(t4.text, m4, x3, l5, s5, o5, c5, e4, u5.lineStartIndex, u5.lineLength, f4, y3);
            for (const e5 of h4)
              p7[e5] = t4.text.placedSymbolArray.length - 1;
            return 4 * m4.length;
          }
          function Yc(t4) {
            for (const e4 in t4)
              return t4[e4];
            return null;
          }
          function Hc(t4, e4, r5, n3) {
            const i5 = t4.compareText;
            if (e4 in i5) {
              const t5 = i5[e4];
              for (let e5 = t5.length - 1; e5 >= 0; e5--)
                if (n3.dist(t5[e5]) < r5)
                  return true;
            } else
              i5[e4] = [];
            return i5[e4].push(n3), false;
          }
          const Wc = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
          class Qc {
            static from(t4) {
              if (!(t4 instanceof ArrayBuffer))
                throw new Error("Data must be an instance of ArrayBuffer.");
              const [e4, r5] = new Uint8Array(t4, 0, 2);
              if (219 !== e4)
                throw new Error("Data does not appear to be in a KDBush format.");
              const n3 = r5 >> 4;
              if (1 !== n3)
                throw new Error(`Got v${n3} data when expected v1.`);
              const i5 = Wc[15 & r5];
              if (!i5)
                throw new Error("Unrecognized array type.");
              const [a5] = new Uint16Array(t4, 2, 1), [s5] = new Uint32Array(t4, 4, 1);
              return new Qc(s5, a5, i5, t4);
            }
            constructor(t4, e4 = 64, r5 = Float64Array, n3) {
              if (isNaN(t4) || t4 < 0)
                throw new Error(`Unpexpected numItems value: ${t4}.`);
              this.numItems = +t4, this.nodeSize = Math.min(Math.max(+e4, 2), 65535), this.ArrayType = r5, this.IndexArrayType = t4 < 65536 ? Uint16Array : Uint32Array;
              const i5 = Wc.indexOf(this.ArrayType), a5 = 2 * t4 * this.ArrayType.BYTES_PER_ELEMENT, s5 = t4 * this.IndexArrayType.BYTES_PER_ELEMENT, o5 = (8 - s5 % 8) % 8;
              if (i5 < 0)
                throw new Error(`Unexpected typed array class: ${r5}.`);
              n3 && n3 instanceof ArrayBuffer ? (this.data = n3, this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + s5 + o5, 2 * t4), this._pos = 2 * t4, this._finished = true) : (this.data = new ArrayBuffer(8 + a5 + s5 + o5), this.ids = new this.IndexArrayType(this.data, 8, t4), this.coords = new this.ArrayType(this.data, 8 + s5 + o5, 2 * t4), this._pos = 0, this._finished = false, new Uint8Array(this.data, 0, 2).set([219, 16 + i5]), new Uint16Array(this.data, 2, 1)[0] = e4, new Uint32Array(this.data, 4, 1)[0] = t4);
            }
            add(t4, e4) {
              const r5 = this._pos >> 1;
              return this.ids[r5] = r5, this.coords[this._pos++] = t4, this.coords[this._pos++] = e4, r5;
            }
            finish() {
              const t4 = this._pos >> 1;
              if (t4 !== this.numItems)
                throw new Error(`Added ${t4} items when expected ${this.numItems}.`);
              return th(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = true, this;
            }
            range(t4, e4, r5, n3) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: i5, coords: a5, nodeSize: s5 } = this, o5 = [0, i5.length - 1, 0], l5 = [];
              for (; o5.length; ) {
                const u5 = o5.pop() || 0, c5 = o5.pop() || 0, h4 = o5.pop() || 0;
                if (c5 - h4 <= s5) {
                  for (let s6 = h4; s6 <= c5; s6++) {
                    const o6 = a5[2 * s6], u6 = a5[2 * s6 + 1];
                    o6 >= t4 && o6 <= r5 && u6 >= e4 && u6 <= n3 && l5.push(i5[s6]);
                  }
                  continue;
                }
                const p7 = h4 + c5 >> 1, f4 = a5[2 * p7], d4 = a5[2 * p7 + 1];
                f4 >= t4 && f4 <= r5 && d4 >= e4 && d4 <= n3 && l5.push(i5[p7]), (0 === u5 ? t4 <= f4 : e4 <= d4) && (o5.push(h4), o5.push(p7 - 1), o5.push(1 - u5)), (0 === u5 ? r5 >= f4 : n3 >= d4) && (o5.push(p7 + 1), o5.push(c5), o5.push(1 - u5));
              }
              return l5;
            }
            within(t4, e4, r5) {
              if (!this._finished)
                throw new Error("Data not yet indexed - call index.finish().");
              const { ids: n3, coords: i5, nodeSize: a5 } = this, s5 = [0, n3.length - 1, 0], o5 = [], l5 = r5 * r5;
              for (; s5.length; ) {
                const u5 = s5.pop() || 0, c5 = s5.pop() || 0, h4 = s5.pop() || 0;
                if (c5 - h4 <= a5) {
                  for (let r6 = h4; r6 <= c5; r6++)
                    ih(i5[2 * r6], i5[2 * r6 + 1], t4, e4) <= l5 && o5.push(n3[r6]);
                  continue;
                }
                const p7 = h4 + c5 >> 1, f4 = i5[2 * p7], d4 = i5[2 * p7 + 1];
                ih(f4, d4, t4, e4) <= l5 && o5.push(n3[p7]), (0 === u5 ? t4 - r5 <= f4 : e4 - r5 <= d4) && (s5.push(h4), s5.push(p7 - 1), s5.push(1 - u5)), (0 === u5 ? t4 + r5 >= f4 : e4 + r5 >= d4) && (s5.push(p7 + 1), s5.push(c5), s5.push(1 - u5));
              }
              return o5;
            }
          }
          function th(t4, e4, r5, n3, i5, a5) {
            if (i5 - n3 <= r5)
              return;
            const s5 = n3 + i5 >> 1;
            eh(t4, e4, s5, n3, i5, a5), th(t4, e4, r5, n3, s5 - 1, 1 - a5), th(t4, e4, r5, s5 + 1, i5, 1 - a5);
          }
          function eh(t4, e4, r5, n3, i5, a5) {
            for (; i5 > n3; ) {
              if (i5 - n3 > 600) {
                const s6 = i5 - n3 + 1, o6 = r5 - n3 + 1, l6 = Math.log(s6), u5 = 0.5 * Math.exp(2 * l6 / 3), c5 = 0.5 * Math.sqrt(l6 * u5 * (s6 - u5) / s6) * (o6 - s6 / 2 < 0 ? -1 : 1);
                eh(t4, e4, r5, Math.max(n3, Math.floor(r5 - o6 * u5 / s6 + c5)), Math.min(i5, Math.floor(r5 + (s6 - o6) * u5 / s6 + c5)), a5);
              }
              const s5 = e4[2 * r5 + a5];
              let o5 = n3, l5 = i5;
              for (rh(t4, e4, n3, r5), e4[2 * i5 + a5] > s5 && rh(t4, e4, n3, i5); o5 < l5; ) {
                for (rh(t4, e4, o5, l5), o5++, l5--; e4[2 * o5 + a5] < s5; )
                  o5++;
                for (; e4[2 * l5 + a5] > s5; )
                  l5--;
              }
              e4[2 * n3 + a5] === s5 ? rh(t4, e4, n3, l5) : (l5++, rh(t4, e4, l5, i5)), l5 <= r5 && (n3 = l5 + 1), r5 <= l5 && (i5 = l5 - 1);
            }
          }
          function rh(t4, e4, r5, n3) {
            nh(t4, r5, n3), nh(e4, 2 * r5, 2 * n3), nh(e4, 2 * r5 + 1, 2 * n3 + 1);
          }
          function nh(t4, e4, r5) {
            const n3 = t4[e4];
            t4[e4] = t4[r5], t4[r5] = n3;
          }
          function ih(t4, e4, r5, n3) {
            const i5 = t4 - r5, a5 = e4 - n3;
            return i5 * i5 + a5 * a5;
          }
          var ah;
          t3.PerformanceMarkers = void 0, (ah = t3.PerformanceMarkers || (t3.PerformanceMarkers = {})).create = "create", ah.load = "load", ah.fullLoad = "fullLoad";
          let sh = null, oh = [];
          const lh = 1e3 / 60, uh = "loadTime", ch = "fullLoadTime", hh = { mark(t4) {
            performance.mark(t4);
          }, frame(t4) {
            const e4 = t4;
            null != sh && oh.push(e4 - sh), sh = e4;
          }, clearMetrics() {
            sh = null, oh = [], performance.clearMeasures(uh), performance.clearMeasures(ch);
            for (const e4 in t3.PerformanceMarkers)
              performance.clearMarks(t3.PerformanceMarkers[e4]);
          }, getPerformanceMetrics() {
            performance.measure(uh, t3.PerformanceMarkers.create, t3.PerformanceMarkers.load), performance.measure(ch, t3.PerformanceMarkers.create, t3.PerformanceMarkers.fullLoad);
            const e4 = performance.getEntriesByName(uh)[0].duration, r5 = performance.getEntriesByName(ch)[0].duration, n3 = oh.length, i5 = 1 / (oh.reduce((t4, e5) => t4 + e5, 0) / n3 / 1e3), a5 = oh.filter((t4) => t4 > lh).reduce((t4, e5) => t4 + (e5 - lh) / lh, 0);
            return { loadTime: e4, fullLoadTime: r5, fps: i5, percentDroppedFrames: a5 / (n3 + a5) * 100, totalFrames: n3 };
          } };
          t3.AJAXError = L2, t3.ARRAY_TYPE = zs, t3.Actor = class {
            constructor(t4, e4, r5) {
              this.receive = (t5) => {
                const e5 = t5.data, r6 = e5.id;
                if (r6 && (!e5.targetMapId || this.mapId === e5.targetMapId))
                  if ("<cancel>" === e5.type) {
                    delete this.tasks[r6];
                    const t6 = this.cancelCallbacks[r6];
                    delete this.cancelCallbacks[r6], t6 && t6();
                  } else
                    k3() || e5.mustQueue ? (this.tasks[r6] = e5, this.taskQueue.push(r6), this.invoker.trigger()) : this.processTask(r6, e5);
              }, this.process = () => {
                if (!this.taskQueue.length)
                  return;
                const t5 = this.taskQueue.shift(), e5 = this.tasks[t5];
                delete this.tasks[t5], this.taskQueue.length && this.invoker.trigger(), e5 && this.processTask(t5, e5);
              }, this.target = t4, this.parent = e4, this.mapId = r5, this.callbacks = {}, this.tasks = {}, this.taskQueue = [], this.cancelCallbacks = {}, this.invoker = new Qu(this.process), this.target.addEventListener("message", this.receive, false), this.globalScope = k3() ? t4 : window;
            }
            send(t4, e4, r5, n3, i5 = false) {
              const a5 = Math.round(1e18 * Math.random()).toString(36).substring(0, 10);
              r5 && (this.callbacks[a5] = r5);
              const s5 = z3(this.globalScope) ? void 0 : [];
              return this.target.postMessage({ id: a5, type: t4, hasCallback: !!r5, targetMapId: n3, mustQueue: i5, sourceMapId: this.mapId, data: Dn(e4, s5) }, s5), { cancel: () => {
                r5 && delete this.callbacks[a5], this.target.postMessage({ id: a5, type: "<cancel>", targetMapId: n3, sourceMapId: this.mapId });
              } };
            }
            processTask(t4, e4) {
              if ("<response>" === e4.type) {
                const r5 = this.callbacks[t4];
                delete this.callbacks[t4], r5 && (e4.error ? r5(On(e4.error)) : r5(null, On(e4.data)));
              } else {
                let r5 = false;
                const n3 = z3(this.globalScope) ? void 0 : [], i5 = e4.hasCallback ? (e5, i6) => {
                  r5 = true, delete this.cancelCallbacks[t4], this.target.postMessage({ id: t4, type: "<response>", sourceMapId: this.mapId, error: e5 ? Dn(e5) : null, data: Dn(i6, n3) }, n3);
                } : (t5) => {
                  r5 = true;
                };
                let a5 = null;
                const s5 = On(e4.data);
                if (this.parent[e4.type])
                  a5 = this.parent[e4.type](e4.sourceMapId, s5, i5);
                else if (this.parent.getWorkerSource) {
                  const t5 = e4.type.split(".");
                  a5 = this.parent.getWorkerSource(e4.sourceMapId, t5[0], s5.source)[t5[1]](s5, i5);
                } else
                  i5(new Error(`Could not find function ${e4.type}`));
                !r5 && a5 && a5.cancel && (this.cancelCallbacks[t4] = a5.cancel);
              }
            }
            remove() {
              this.invoker.remove(), this.target.removeEventListener("message", this.receive, false);
            }
          }, t3.AlphaImage = Rs, t3.CanonicalTileID = cc, t3.CollisionBoxArray = ta, t3.CollisionCircleLayoutArray = class extends qi {
          }, t3.Color = Yt, t3.DEMData = dc, t3.DataConstantProperty = gi, t3.DictionaryCoder = yc, t3.EXTENT = rs, t3.ErrorEvent = G2, t3.EvaluationParameters = li, t3.Event = K, t3.Evented = J, t3.FeatureIndex = gc, t3.FillBucket = Eo, t3.FillExtrusionBucket = rl, t3.GeoJSONFeature = mc, t3.ImageAtlas = cu, t3.ImagePosition = uu, t3.KDBush = Qc, t3.LineBucket = gl, t3.LineStripIndexArray = class extends Hi {
          }, t3.LngLat = ec, t3.MercatorCoordinate = lc, t3.ONE_EM = Vl, t3.OverscaledTileID = pc, t3.PerformanceUtils = hh, t3.Point = i4, t3.Pos3dArray = class extends Bi {
          }, t3.PosArray = ha, t3.Properties = _i, t3.Protobuf = eu, t3.QuadTriangleArray = class extends Ni {
          }, t3.RGBAImage = qs, t3.RasterBoundsArray = class extends Vi {
          }, t3.RequestPerformance = class {
            constructor(t4) {
              this._marks = { start: [t4.url, "start"].join("#"), end: [t4.url, "end"].join("#"), measure: t4.url.toString() }, performance.mark(this._marks.start);
            }
            finish() {
              performance.mark(this._marks.end);
              let t4 = performance.getEntriesByName(this._marks.measure);
              return 0 === t4.length && (performance.measure(this._marks.measure, this._marks.start, this._marks.end), t4 = performance.getEntriesByName(this._marks.measure), performance.clearMarks(this._marks.start), performance.clearMarks(this._marks.end), performance.clearMeasures(this._marks.measure)), t4;
            }
          }, t3.SegmentVector = za, t3.SymbolBucket = Uu, t3.Transitionable = hi, t3.TriangleIndexArray = Aa, t3.Uniform1f = qa, t3.Uniform1i = class extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = 0;
            }
            set(t4) {
              this.current !== t4 && (this.current = t4, this.gl.uniform1i(this.location, t4));
            }
          }, t3.Uniform2f = class extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = [0, 0];
            }
            set(t4) {
              t4[0] === this.current[0] && t4[1] === this.current[1] || (this.current = t4, this.gl.uniform2f(this.location, t4[0], t4[1]));
            }
          }, t3.Uniform3f = class extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = [0, 0, 0];
            }
            set(t4) {
              t4[0] === this.current[0] && t4[1] === this.current[1] && t4[2] === this.current[2] || (this.current = t4, this.gl.uniform3f(this.location, t4[0], t4[1], t4[2]));
            }
          }, t3.Uniform4f = ja, t3.UniformColor = Na, t3.UniformMatrix4f = class extends Ra {
            constructor(t4, e4) {
              super(t4, e4), this.current = Za;
            }
            set(t4) {
              if (t4[12] !== this.current[12] || t4[0] !== this.current[0])
                return this.current = t4, void this.gl.uniformMatrix4fv(this.location, false, t4);
              for (let e4 = 1; e4 < 16; e4++)
                if (t4[e4] !== this.current[e4]) {
                  this.current = t4, this.gl.uniformMatrix4fv(this.location, false, t4);
                  break;
                }
            }
          }, t3.UnwrappedTileID = hc, t3.ValidationError = ot, t3.ZoomHistory = Un, t3.addDynamicAttributes = $u, t3.arrayBufferToImage = function(t4, e4) {
            const r5 = new Image();
            r5.onload = () => {
              e4(null, r5), URL.revokeObjectURL(r5.src), r5.onload = null, window.requestAnimationFrame(() => {
                r5.src = P2;
              });
            }, r5.onerror = () => e4(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
            const n3 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            r5.src = t4.byteLength ? URL.createObjectURL(n3) : P2;
          }, t3.arrayBufferToImageBitmap = function(t4, e4) {
            const r5 = new Blob([new Uint8Array(t4)], { type: "image/png" });
            createImageBitmap(r5).then((t5) => {
              e4(null, t5);
            }).catch((t5) => {
              e4(new Error(`Could not load image because of ${t5.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`));
            });
          }, t3.asyncAll = function(t4, e4, r5) {
            if (!t4.length)
              return r5(null, []);
            let n3 = t4.length;
            const i5 = new Array(t4.length);
            let a5 = null;
            t4.forEach((t5, s5) => {
              e4(t5, (t6, e5) => {
                t6 && (a5 = t6), i5[s5] = e5, 0 == --n3 && r5(a5, i5);
              });
            });
          }, t3.bezier = p6, t3.browser = T2, t3.clamp = d3, t3.clipLine = wc, t3.clone = function(t4) {
            var e4 = new zs(16);
            return e4[0] = t4[0], e4[1] = t4[1], e4[2] = t4[2], e4[3] = t4[3], e4[4] = t4[4], e4[5] = t4[5], e4[6] = t4[6], e4[7] = t4[7], e4[8] = t4[8], e4[9] = t4[9], e4[10] = t4[10], e4[11] = t4[11], e4[12] = t4[12], e4[13] = t4[13], e4[14] = t4[14], e4[15] = t4[15], e4;
          }, t3.clone$1 = b3, t3.collisionCircleLayout = Pl, t3.config = $2, t3.copy = function(t4, e4) {
            return t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[4] = e4[4], t4[5] = e4[5], t4[6] = e4[6], t4[7] = e4[7], t4[8] = e4[8], t4[9] = e4[9], t4[10] = e4[10], t4[11] = e4[11], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15], t4;
          }, t3.create = function() {
            var t4 = new zs(16);
            return zs != Float32Array && (t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0), t4[0] = 1, t4[5] = 1, t4[10] = 1, t4[15] = 1, t4;
          }, t3.createExpression = $r, t3.createFilter = Nr, t3.createLayout = Mi, t3.createStyleLayer = function(t4) {
            if ("custom" === t4.type)
              return new Wu(t4);
            switch (t4.type) {
              case "background":
                return new Ju(t4);
              case "circle":
                return new Es(t4);
              case "fill":
                return new Lo(t4);
              case "fill-extrusion":
                return new ol(t4);
              case "heatmap":
                return new Ns(t4);
              case "hillshade":
                return new Gs(t4);
              case "line":
                return new Al(t4);
              case "raster":
                return new Hu(t4);
              case "symbol":
                return new Zu(t4);
            }
          }, t3.deepEqual = function t4(e4, r5) {
            if (Array.isArray(e4)) {
              if (!Array.isArray(r5) || e4.length !== r5.length)
                return false;
              for (let n3 = 0; n3 < e4.length; n3++)
                if (!t4(e4[n3], r5[n3]))
                  return false;
              return true;
            }
            if ("object" == typeof e4 && null !== e4 && null !== r5) {
              if ("object" != typeof r5)
                return false;
              if (Object.keys(e4).length !== Object.keys(r5).length)
                return false;
              for (const n3 in e4)
                if (!t4(e4[n3], r5[n3]))
                  return false;
              return true;
            }
            return e4 === r5;
          }, t3.defaultEasing = f3, t3.derefLayers = function(t4) {
            t4 = t4.slice();
            const e4 = /* @__PURE__ */ Object.create(null);
            for (let r5 = 0; r5 < t4.length; r5++)
              e4[t4[r5].id] = t4[r5];
            for (let r5 = 0; r5 < t4.length; r5++)
              "ref" in t4[r5] && (t4[r5] = H2(t4[r5], e4[t4[r5].ref]));
            return t4;
          }, t3.diffStyles = function(t4, e4) {
            if (!t4)
              return [{ command: Q.setStyle, args: [e4] }];
            let r5 = [];
            try {
              if (!W(t4.version, e4.version))
                return [{ command: Q.setStyle, args: [e4] }];
              W(t4.center, e4.center) || r5.push({ command: Q.setCenter, args: [e4.center] }), W(t4.zoom, e4.zoom) || r5.push({ command: Q.setZoom, args: [e4.zoom] }), W(t4.bearing, e4.bearing) || r5.push({ command: Q.setBearing, args: [e4.bearing] }), W(t4.pitch, e4.pitch) || r5.push({ command: Q.setPitch, args: [e4.pitch] }), W(t4.sprite, e4.sprite) || r5.push({ command: Q.setSprite, args: [e4.sprite] }), W(t4.glyphs, e4.glyphs) || r5.push({ command: Q.setGlyphs, args: [e4.glyphs] }), W(t4.transition, e4.transition) || r5.push({ command: Q.setTransition, args: [e4.transition] }), W(t4.light, e4.light) || r5.push({ command: Q.setLight, args: [e4.light] });
              const n3 = {}, i5 = [];
              !function(t5, e5, r6, n4) {
                let i6;
                for (i6 in e5 = e5 || {}, t5 = t5 || {})
                  Object.prototype.hasOwnProperty.call(t5, i6) && (Object.prototype.hasOwnProperty.call(e5, i6) || et(i6, r6, n4));
                for (i6 in e5)
                  Object.prototype.hasOwnProperty.call(e5, i6) && (Object.prototype.hasOwnProperty.call(t5, i6) ? W(t5[i6], e5[i6]) || ("geojson" === t5[i6].type && "geojson" === e5[i6].type && nt(t5, e5, i6) ? r6.push({ command: Q.setGeoJSONSourceData, args: [i6, e5[i6].data] }) : rt(i6, e5, r6, n4)) : tt(i6, e5, r6));
              }(t4.sources, e4.sources, i5, n3);
              const a5 = [];
              t4.layers && t4.layers.forEach((t5) => {
                n3[t5.source] ? r5.push({ command: Q.removeLayer, args: [t5.id] }) : a5.push(t5);
              }), r5 = r5.concat(i5), function(t5, e5, r6) {
                e5 = e5 || [];
                const n4 = (t5 = t5 || []).map(at), i6 = e5.map(at), a6 = t5.reduce(st, {}), s5 = e5.reduce(st, {}), o5 = n4.slice(), l5 = /* @__PURE__ */ Object.create(null);
                let u5, c5, h4, p7, f4, d4, y3;
                for (u5 = 0, c5 = 0; u5 < n4.length; u5++)
                  h4 = n4[u5], Object.prototype.hasOwnProperty.call(s5, h4) ? c5++ : (r6.push({ command: Q.removeLayer, args: [h4] }), o5.splice(o5.indexOf(h4, c5), 1));
                for (u5 = 0, c5 = 0; u5 < i6.length; u5++)
                  h4 = i6[i6.length - 1 - u5], o5[o5.length - 1 - u5] !== h4 && (Object.prototype.hasOwnProperty.call(a6, h4) ? (r6.push({ command: Q.removeLayer, args: [h4] }), o5.splice(o5.lastIndexOf(h4, o5.length - c5), 1)) : c5++, d4 = o5[o5.length - u5], r6.push({ command: Q.addLayer, args: [s5[h4], d4] }), o5.splice(o5.length - u5, 0, h4), l5[h4] = true);
                for (u5 = 0; u5 < i6.length; u5++)
                  if (h4 = i6[u5], p7 = a6[h4], f4 = s5[h4], !l5[h4] && !W(p7, f4))
                    if (W(p7.source, f4.source) && W(p7["source-layer"], f4["source-layer"]) && W(p7.type, f4.type)) {
                      for (y3 in it(p7.layout, f4.layout, r6, h4, null, Q.setLayoutProperty), it(p7.paint, f4.paint, r6, h4, null, Q.setPaintProperty), W(p7.filter, f4.filter) || r6.push({ command: Q.setFilter, args: [h4, f4.filter] }), W(p7.minzoom, f4.minzoom) && W(p7.maxzoom, f4.maxzoom) || r6.push({ command: Q.setLayerZoomRange, args: [h4, f4.minzoom, f4.maxzoom] }), p7)
                        Object.prototype.hasOwnProperty.call(p7, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p7[y3], f4[y3], r6, h4, y3.slice(6), Q.setPaintProperty) : W(p7[y3], f4[y3]) || r6.push({ command: Q.setLayerProperty, args: [h4, y3, f4[y3]] }));
                      for (y3 in f4)
                        Object.prototype.hasOwnProperty.call(f4, y3) && !Object.prototype.hasOwnProperty.call(p7, y3) && "layout" !== y3 && "paint" !== y3 && "filter" !== y3 && "metadata" !== y3 && "minzoom" !== y3 && "maxzoom" !== y3 && (0 === y3.indexOf("paint.") ? it(p7[y3], f4[y3], r6, h4, y3.slice(6), Q.setPaintProperty) : W(p7[y3], f4[y3]) || r6.push({ command: Q.setLayerProperty, args: [h4, y3, f4[y3]] }));
                    } else
                      r6.push({ command: Q.removeLayer, args: [h4] }), d4 = o5[o5.lastIndexOf(h4) + 1], r6.push({ command: Q.addLayer, args: [f4, d4] });
              }(a5, e4.layers, r5);
            } catch (t5) {
              console.warn("Unable to compute style diff:", t5), r5 = [{ command: Q.setStyle, args: [e4] }];
            }
            return r5;
          }, t3.dot = function(t4, e4) {
            return t4[0] * e4[0] + t4[1] * e4[1] + t4[2] * e4[2] + t4[3] * e4[3];
          }, t3.earthRadius = tc, t3.emitValidationErrors = En, t3.emptyStyle = function() {
            const t4 = {}, e4 = X.$version;
            for (const r5 in X.$root) {
              const n3 = X.$root[r5];
              if (n3.required) {
                let i5 = null;
                i5 = "version" === r5 ? e4 : "array" === n3.type ? [] : {}, null != i5 && (t4[r5] = i5);
              }
            }
            return t4;
          }, t3.equals = function(t4, e4) {
            var r5 = t4[0], n3 = t4[1], i5 = t4[2], a5 = t4[3], s5 = t4[4], o5 = t4[5], l5 = t4[6], u5 = t4[7], c5 = t4[8], h4 = t4[9], p7 = t4[10], f4 = t4[11], d4 = t4[12], y3 = t4[13], m4 = t4[14], g4 = t4[15], x3 = e4[0], v5 = e4[1], b4 = e4[2], w4 = e4[3], _4 = e4[4], A3 = e4[5], S3 = e4[6], k4 = e4[7], I3 = e4[8], z4 = e4[9], M3 = e4[10], P3 = e4[11], C2 = e4[12], B4 = e4[13], V2 = e4[14], E3 = e4[15];
            return Math.abs(r5 - x3) <= Is * Math.max(1, Math.abs(r5), Math.abs(x3)) && Math.abs(n3 - v5) <= Is * Math.max(1, Math.abs(n3), Math.abs(v5)) && Math.abs(i5 - b4) <= Is * Math.max(1, Math.abs(i5), Math.abs(b4)) && Math.abs(a5 - w4) <= Is * Math.max(1, Math.abs(a5), Math.abs(w4)) && Math.abs(s5 - _4) <= Is * Math.max(1, Math.abs(s5), Math.abs(_4)) && Math.abs(o5 - A3) <= Is * Math.max(1, Math.abs(o5), Math.abs(A3)) && Math.abs(l5 - S3) <= Is * Math.max(1, Math.abs(l5), Math.abs(S3)) && Math.abs(u5 - k4) <= Is * Math.max(1, Math.abs(u5), Math.abs(k4)) && Math.abs(c5 - I3) <= Is * Math.max(1, Math.abs(c5), Math.abs(I3)) && Math.abs(h4 - z4) <= Is * Math.max(1, Math.abs(h4), Math.abs(z4)) && Math.abs(p7 - M3) <= Is * Math.max(1, Math.abs(p7), Math.abs(M3)) && Math.abs(f4 - P3) <= Is * Math.max(1, Math.abs(f4), Math.abs(P3)) && Math.abs(d4 - C2) <= Is * Math.max(1, Math.abs(d4), Math.abs(C2)) && Math.abs(y3 - B4) <= Is * Math.max(1, Math.abs(y3), Math.abs(B4)) && Math.abs(m4 - V2) <= Is * Math.max(1, Math.abs(m4), Math.abs(V2)) && Math.abs(g4 - E3) <= Is * Math.max(1, Math.abs(g4), Math.abs(E3));
          }, t3.evaluateSizeForFeature = function(t4, { uSize: e4, uSizeT: r5 }, { lowerSize: n3, upperSize: i5 }) {
            return "source" === t4.kind ? n3 / Pu : "composite" === t4.kind ? Ze.number(n3 / Pu, i5 / Pu, r5) : e4;
          }, t3.evaluateSizeForZoom = function(t4, e4) {
            let r5 = 0, n3 = 0;
            if ("constant" === t4.kind)
              n3 = t4.layoutSize;
            else if ("source" !== t4.kind) {
              const { interpolationType: i5, minZoom: a5, maxZoom: s5 } = t4, o5 = i5 ? d3(Ke.interpolationFactor(i5, e4, a5, s5), 0, 1) : 0;
              "camera" === t4.kind ? n3 = Ze.number(t4.minSize, t4.maxSize, o5) : r5 = o5;
            }
            return { uSizeT: r5, uSize: n3 };
          }, t3.evented = ii, t3.extend = m3, t3.filterObject = v3, t3.findLineIntersection = function(t4, e4, r5, n3) {
            const a5 = e4.y - t4.y, s5 = e4.x - t4.x, o5 = n3.y - r5.y, l5 = n3.x - r5.x, u5 = o5 * s5 - l5 * a5;
            if (0 === u5)
              return null;
            const c5 = (l5 * (t4.y - r5.y) - o5 * (t4.x - r5.x)) / u5;
            return new i4(t4.x + c5 * s5, t4.y + c5 * a5);
          }, t3.fromScaling = function(t4, e4) {
            return t4[0] = e4[0], t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = e4[1], t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = e4[2], t4[11] = 0, t4[12] = 0, t4[13] = 0, t4[14] = 0, t4[15] = 1, t4;
          }, t3.getAnchorAlignment = Su, t3.getAnchorJustification = Gc, t3.getArrayBuffer = q3, t3.getDefaultExportFromCjs = e3, t3.getImageData = async function(t4, e4, r5, n3, i5) {
            if (h3())
              try {
                return await C(t4, e4, r5, n3, i5);
              } catch (t5) {
              }
            return function(t5, e5, r6, n4, i6) {
              const a5 = t5.width, s5 = t5.height;
              B3 && V || (B3 = new OffscreenCanvas(a5, s5), V = B3.getContext("2d", { willReadFrequently: true })), B3.width = a5, B3.height = s5, V.drawImage(t5, 0, 0, a5, s5);
              const o5 = V.getImageData(e5, r6, n4, i6);
              return V.clearRect(0, 0, a5, s5), o5.data;
            }(t4, e4, r5, n3, i5);
          }, t3.getJSON = function(t4, e4) {
            return R(m3(t4, { type: "json" }), e4);
          }, t3.getOverlapMode = Vu, t3.getProtocolAction = O2, t3.getRTLTextPluginStatus = ai, t3.getReferrer = D2, t3.getVideo = function(t4, e4) {
            const r5 = window.document.createElement("video");
            r5.muted = true, r5.onloadstart = function() {
              e4(null, r5);
            };
            for (let e5 = 0; e5 < t4.length; e5++) {
              const n3 = window.document.createElement("source");
              j3(t4[e5]) || (r5.crossOrigin = "Anonymous"), n3.src = t4[e5], r5.appendChild(n3);
            }
            return { cancel: () => {
            } };
          }, t3.groupByLayout = function(t4, e4) {
            const r5 = {};
            for (let n4 = 0; n4 < t4.length; n4++) {
              const i5 = e4 && e4[t4[n4].id] || Qr(t4[n4]);
              e4 && (e4[t4[n4].id] = i5);
              let a5 = r5[i5];
              a5 || (a5 = r5[i5] = []), a5.push(t4[n4]);
            }
            const n3 = [];
            for (const t5 in r5)
              n3.push(r5[t5]);
            return n3;
          }, t3.identity = Ms, t3.interpolate = Ze, t3.invert = function(t4, e4) {
            var r5 = e4[0], n3 = e4[1], i5 = e4[2], a5 = e4[3], s5 = e4[4], o5 = e4[5], l5 = e4[6], u5 = e4[7], c5 = e4[8], h4 = e4[9], p7 = e4[10], f4 = e4[11], d4 = e4[12], y3 = e4[13], m4 = e4[14], g4 = e4[15], x3 = r5 * o5 - n3 * s5, v5 = r5 * l5 - i5 * s5, b4 = r5 * u5 - a5 * s5, w4 = n3 * l5 - i5 * o5, _4 = n3 * u5 - a5 * o5, A3 = i5 * u5 - a5 * l5, S3 = c5 * y3 - h4 * d4, k4 = c5 * m4 - p7 * d4, I3 = c5 * g4 - f4 * d4, z4 = h4 * m4 - p7 * y3, M3 = h4 * g4 - f4 * y3, P3 = p7 * g4 - f4 * m4, C2 = x3 * P3 - v5 * M3 + b4 * z4 + w4 * I3 - _4 * k4 + A3 * S3;
            return C2 ? (t4[0] = (o5 * P3 - l5 * M3 + u5 * z4) * (C2 = 1 / C2), t4[1] = (i5 * M3 - n3 * P3 - a5 * z4) * C2, t4[2] = (y3 * A3 - m4 * _4 + g4 * w4) * C2, t4[3] = (p7 * _4 - h4 * A3 - f4 * w4) * C2, t4[4] = (l5 * I3 - s5 * P3 - u5 * k4) * C2, t4[5] = (r5 * P3 - i5 * I3 + a5 * k4) * C2, t4[6] = (m4 * b4 - d4 * A3 - g4 * v5) * C2, t4[7] = (c5 * A3 - p7 * b4 + f4 * v5) * C2, t4[8] = (s5 * M3 - o5 * I3 + u5 * S3) * C2, t4[9] = (n3 * I3 - r5 * M3 - a5 * S3) * C2, t4[10] = (d4 * _4 - y3 * b4 + g4 * x3) * C2, t4[11] = (h4 * b4 - c5 * _4 - f4 * x3) * C2, t4[12] = (o5 * k4 - s5 * z4 - l5 * S3) * C2, t4[13] = (r5 * z4 - n3 * k4 + i5 * S3) * C2, t4[14] = (y3 * v5 - d4 * w4 - m4 * x3) * C2, t4[15] = (c5 * w4 - h4 * v5 + p7 * x3) * C2, t4) : null;
          }, t3.isImageBitmap = M2, t3.isOffscreenCanvasDistorted = h3, t3.isSafari = z3, t3.isWorker = k3, t3.keysDifference = function(t4, e4) {
            const r5 = [];
            for (const n3 in t4)
              n3 in e4 || r5.push(n3);
            return r5;
          }, t3.lazyLoadRTLTextPlugin = function() {
            oi.isLoading() || oi.isLoaded() || "deferred" !== ai() || si();
          }, t3.makeRequest = R, t3.mapObject = x2, t3.mercatorXfromLng = ic, t3.mercatorYfromLat = ac, t3.mercatorZfromAltitude = sc, t3.mul = Bs, t3.mul$1 = function(t4, e4, r5) {
            return t4[0] = e4[0] * r5[0], t4[1] = e4[1] * r5[1], t4[2] = e4[2] * r5[2], t4[3] = e4[3] * r5[3], t4;
          }, t3.multiply = Ps, t3.nextPowerOfTwo = function(t4) {
            return t4 <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(t4) / Math.LN2));
          }, t3.offscreenCanvasSupported = c4, t3.operations = Q, t3.ortho = function(t4, e4, r5, n3, i5, a5, s5) {
            var o5 = 1 / (e4 - r5), l5 = 1 / (n3 - i5), u5 = 1 / (a5 - s5);
            return t4[0] = -2 * o5, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = -2 * l5, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[10] = 2 * u5, t4[11] = 0, t4[12] = (e4 + r5) * o5, t4[13] = (i5 + n3) * l5, t4[14] = (s5 + a5) * u5, t4[15] = 1, t4;
          }, t3.parseCacheControl = function(t4) {
            const e4 = {};
            if (t4.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (t5, r5, n3, i5) => {
              const a5 = n3 || i5;
              return e4[r5] = !a5 || a5.toLowerCase(), "";
            }), e4["max-age"]) {
              const t5 = parseInt(e4["max-age"], 10);
              isNaN(t5) ? delete e4["max-age"] : e4["max-age"] = t5;
            }
            return e4;
          }, t3.parseGlyphPbf = function(t4) {
            return new eu(t4).readFields(nu, []);
          }, t3.pbf = El, t3.performSymbolLayout = function(e4) {
            e4.bucket.createArrays(), e4.bucket.tilePixelRatio = rs / (512 * e4.bucket.overscaling), e4.bucket.compareText = {}, e4.bucket.iconsNeedLinear = false;
            const r5 = e4.bucket.layers[0], n3 = r5.layout, i5 = r5._unevaluatedLayout._values, a5 = { layoutIconSize: i5["icon-size"].possiblyEvaluate(new li(e4.bucket.zoom + 1), e4.canonical), layoutTextSize: i5["text-size"].possiblyEvaluate(new li(e4.bucket.zoom + 1), e4.canonical), textMaxSize: i5["text-size"].possiblyEvaluate(new li(18)) };
            if ("composite" === e4.bucket.textSizeData.kind) {
              const { minZoom: t4, maxZoom: r6 } = e4.bucket.textSizeData;
              a5.compositeTextSizes = [i5["text-size"].possiblyEvaluate(new li(t4), e4.canonical), i5["text-size"].possiblyEvaluate(new li(r6), e4.canonical)];
            }
            if ("composite" === e4.bucket.iconSizeData.kind) {
              const { minZoom: t4, maxZoom: r6 } = e4.bucket.iconSizeData;
              a5.compositeIconSizes = [i5["icon-size"].possiblyEvaluate(new li(t4), e4.canonical), i5["icon-size"].possiblyEvaluate(new li(r6), e4.canonical)];
            }
            const s5 = n3.get("text-line-height") * Vl, o5 = "viewport" !== n3.get("text-rotation-alignment") && "point" !== n3.get("symbol-placement"), l5 = n3.get("text-keep-upright"), u5 = n3.get("text-size");
            for (const i6 of e4.bucket.features) {
              const c5 = n3.get("text-font").evaluate(i6, {}, e4.canonical).join(","), h4 = u5.evaluate(i6, {}, e4.canonical), p7 = a5.layoutTextSize.evaluate(i6, {}, e4.canonical), f4 = a5.layoutIconSize.evaluate(i6, {}, e4.canonical), d4 = { horizontal: {}, vertical: void 0 }, y3 = i6.text;
              let m4, g4 = [0, 0];
              if (y3) {
                const a6 = y3.toString(), u6 = n3.get("text-letter-spacing").evaluate(i6, {}, e4.canonical) * Vl, f5 = jn(a6) ? u6 : 0, m5 = n3.get("text-anchor").evaluate(i6, {}, e4.canonical), x4 = Kc(r5, i6, e4.canonical);
                if (!x4) {
                  const t4 = n3.get("text-radial-offset").evaluate(i6, {}, e4.canonical);
                  g4 = t4 ? Zc(m5, [t4 * Vl, Nc]) : n3.get("text-offset").evaluate(i6, {}, e4.canonical).map((t5) => t5 * Vl);
                }
                let v6 = o5 ? "center" : n3.get("text-justify").evaluate(i6, {}, e4.canonical);
                const b4 = n3.get("symbol-placement"), w4 = "point" === b4 ? n3.get("text-max-width").evaluate(i6, {}, e4.canonical) * Vl : 0, _4 = () => {
                  e4.bucket.allowVerticalPlacement && qn(a6) && (d4.vertical = yu(y3, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c5, w4, s5, m5, "left", f5, g4, t3.WritingMode.vertical, true, b4, p7, h4));
                };
                if (!o5 && x4) {
                  const r6 = /* @__PURE__ */ new Set();
                  if ("auto" === v6)
                    for (let t4 = 0; t4 < x4.values.length; t4 += 2)
                      r6.add(Gc(x4.values[t4]));
                  else
                    r6.add(v6);
                  let n4 = false;
                  for (const i7 of r6)
                    if (!d4.horizontal[i7])
                      if (n4)
                        d4.horizontal[i7] = d4.horizontal[0];
                      else {
                        const r7 = yu(y3, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c5, w4, s5, "center", i7, f5, g4, t3.WritingMode.horizontal, false, b4, p7, h4);
                        r7 && (d4.horizontal[i7] = r7, n4 = 1 === r7.positionedLines.length);
                      }
                  _4();
                } else {
                  "auto" === v6 && (v6 = Gc(m5));
                  const r6 = yu(y3, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c5, w4, s5, m5, v6, f5, g4, t3.WritingMode.horizontal, false, b4, p7, h4);
                  r6 && (d4.horizontal[v6] = r6), _4(), qn(a6) && o5 && l5 && (d4.vertical = yu(y3, e4.glyphMap, e4.glyphPositions, e4.imagePositions, c5, w4, s5, m5, v6, f5, g4, t3.WritingMode.vertical, false, b4, p7, h4));
                }
              }
              let x3 = false;
              if (i6.icon && i6.icon.name) {
                const t4 = e4.imageMap[i6.icon.name];
                t4 && (m4 = Iu(e4.imagePositions[i6.icon.name], n3.get("icon-offset").evaluate(i6, {}, e4.canonical), n3.get("icon-anchor").evaluate(i6, {}, e4.canonical)), x3 = !!t4.sdf, void 0 === e4.bucket.sdfIcons ? e4.bucket.sdfIcons = x3 : e4.bucket.sdfIcons !== x3 && _3("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"), (t4.pixelRatio !== e4.bucket.pixelRatio || 0 !== n3.get("icon-rotate").constantOr(1)) && (e4.bucket.iconsNeedLinear = true));
              }
              const v5 = Yc(d4.horizontal) || d4.vertical;
              e4.bucket.iconsInText = !!v5 && v5.iconsInText, (v5 || m4) && Jc(e4.bucket, i6, d4, m4, e4.imageMap, a5, p7, f4, g4, x3, e4.canonical);
            }
            e4.showCollisionBoxes && e4.bucket.generateCollisionDebugBuffers();
          }, t3.perspective = function(t4, e4, r5, n3, i5) {
            var a5, s5 = 1 / Math.tan(e4 / 2);
            return t4[0] = s5 / r5, t4[1] = 0, t4[2] = 0, t4[3] = 0, t4[4] = 0, t4[5] = s5, t4[6] = 0, t4[7] = 0, t4[8] = 0, t4[9] = 0, t4[11] = -1, t4[12] = 0, t4[13] = 0, t4[15] = 0, null != i5 && i5 !== 1 / 0 ? (t4[10] = (i5 + n3) * (a5 = 1 / (n3 - i5)), t4[14] = 2 * i5 * n3 * a5) : (t4[10] = -1, t4[14] = -2 * n3), t4;
          }, t3.pick = function(t4, e4) {
            const r5 = {};
            for (let n3 = 0; n3 < e4.length; n3++) {
              const i5 = e4[n3];
              i5 in t4 && (r5[i5] = t4[i5]);
            }
            return r5;
          }, t3.plugin = oi, t3.pointGeometry = r4, t3.polygonIntersectsPolygon = us, t3.potpack = ou, t3.readImageUsingVideoFrame = C, t3.register = $n, t3.registerForPluginStateChange = function(t4) {
            return t4({ pluginStatus: ti, pluginURL: ei }), ii.on("pluginStateChange", t4), t4;
          }, t3.renderColorRamp = js, t3.rotateX = function(t4, e4, r5) {
            var n3 = Math.sin(r5), i5 = Math.cos(r5), a5 = e4[4], s5 = e4[5], o5 = e4[6], l5 = e4[7], u5 = e4[8], c5 = e4[9], h4 = e4[10], p7 = e4[11];
            return e4 !== t4 && (t4[0] = e4[0], t4[1] = e4[1], t4[2] = e4[2], t4[3] = e4[3], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4[4] = a5 * i5 + u5 * n3, t4[5] = s5 * i5 + c5 * n3, t4[6] = o5 * i5 + h4 * n3, t4[7] = l5 * i5 + p7 * n3, t4[8] = u5 * i5 - a5 * n3, t4[9] = c5 * i5 - s5 * n3, t4[10] = h4 * i5 - o5 * n3, t4[11] = p7 * i5 - l5 * n3, t4;
          }, t3.rotateZ = function(t4, e4, r5) {
            var n3 = Math.sin(r5), i5 = Math.cos(r5), a5 = e4[0], s5 = e4[1], o5 = e4[2], l5 = e4[3], u5 = e4[4], c5 = e4[5], h4 = e4[6], p7 = e4[7];
            return e4 !== t4 && (t4[8] = e4[8], t4[9] = e4[9], t4[10] = e4[10], t4[11] = e4[11], t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15]), t4[0] = a5 * i5 + u5 * n3, t4[1] = s5 * i5 + c5 * n3, t4[2] = o5 * i5 + h4 * n3, t4[3] = l5 * i5 + p7 * n3, t4[4] = u5 * i5 - a5 * n3, t4[5] = c5 * i5 - s5 * n3, t4[6] = h4 * i5 - o5 * n3, t4[7] = p7 * i5 - l5 * n3, t4;
          }, t3.sameOrigin = j3, t3.scale = function(t4, e4, r5) {
            var n3 = r5[0], i5 = r5[1], a5 = r5[2];
            return t4[0] = e4[0] * n3, t4[1] = e4[1] * n3, t4[2] = e4[2] * n3, t4[3] = e4[3] * n3, t4[4] = e4[4] * i5, t4[5] = e4[5] * i5, t4[6] = e4[6] * i5, t4[7] = e4[7] * i5, t4[8] = e4[8] * a5, t4[9] = e4[9] * a5, t4[10] = e4[10] * a5, t4[11] = e4[11] * a5, t4[12] = e4[12], t4[13] = e4[13], t4[14] = e4[14], t4[15] = e4[15], t4;
          }, t3.setRTLTextPlugin = function(t4, e4, r5 = false) {
            if (ti === Yn || ti === Hn || ti === Wn)
              throw new Error("setRTLTextPlugin cannot be called multiple times.");
            ei = T2.resolveURL(t4), ti = Yn, Qn = e4, ni(), r5 || si();
          }, t3.sphericalToCartesian = function([t4, e4, r5]) {
            return e4 += 90, e4 *= Math.PI / 180, r5 *= Math.PI / 180, { x: t4 * Math.cos(e4) * Math.sin(r5), y: t4 * Math.sin(e4) * Math.sin(r5), z: t4 * Math.cos(r5) };
          }, t3.toEvaluationFeature = ss, t3.transformMat4 = Vs, t3.translate = function(t4, e4, r5) {
            var n3, i5, a5, s5, o5, l5, u5, c5, h4, p7, f4, d4, y3 = r5[0], m4 = r5[1], g4 = r5[2];
            return e4 === t4 ? (t4[12] = e4[0] * y3 + e4[4] * m4 + e4[8] * g4 + e4[12], t4[13] = e4[1] * y3 + e4[5] * m4 + e4[9] * g4 + e4[13], t4[14] = e4[2] * y3 + e4[6] * m4 + e4[10] * g4 + e4[14], t4[15] = e4[3] * y3 + e4[7] * m4 + e4[11] * g4 + e4[15]) : (i5 = e4[1], a5 = e4[2], s5 = e4[3], o5 = e4[4], l5 = e4[5], u5 = e4[6], c5 = e4[7], h4 = e4[8], p7 = e4[9], f4 = e4[10], d4 = e4[11], t4[0] = n3 = e4[0], t4[1] = i5, t4[2] = a5, t4[3] = s5, t4[4] = o5, t4[5] = l5, t4[6] = u5, t4[7] = c5, t4[8] = h4, t4[9] = p7, t4[10] = f4, t4[11] = d4, t4[12] = n3 * y3 + o5 * m4 + h4 * g4 + e4[12], t4[13] = i5 * y3 + l5 * m4 + p7 * g4 + e4[13], t4[14] = a5 * y3 + u5 * m4 + f4 * g4 + e4[14], t4[15] = s5 * y3 + c5 * m4 + d4 * g4 + e4[15]), t4;
          }, t3.triggerPluginCompletionEvent = ri, t3.unicodeBlockLookup = Rn, t3.uniqueId = function() {
            return g3++;
          }, t3.v8Spec = X, t3.validateCustomStyleLayer = function(t4) {
            const e4 = [], r5 = t4.id;
            return void 0 === r5 && e4.push({ message: `layers.${r5}: missing required property "id"` }), void 0 === t4.render && e4.push({ message: `layers.${r5}: missing required method "render"` }), t4.renderingMode && "2d" !== t4.renderingMode && "3d" !== t4.renderingMode && e4.push({ message: `layers.${r5}: property "renderingMode" must be either "2d" or "3d"` }), e4;
          }, t3.validateLight = Cn, t3.validateStyle = Pn, t3.vectorTile = Ro, t3.warnOnce = _3, t3.wrap = y2;
        });
        define2(["./shared"], function(e3) {
          "use strict";
          class t3 {
            constructor(e4) {
              this.keyCache = {}, e4 && this.replace(e4);
            }
            replace(e4) {
              this._layerConfigs = {}, this._layers = {}, this.update(e4, []);
            }
            update(t4, i5) {
              for (const i6 of t4) {
                this._layerConfigs[i6.id] = i6;
                const t5 = this._layers[i6.id] = e3.createStyleLayer(i6);
                t5._featureFilter = e3.createFilter(t5.filter), this.keyCache[i6.id] && delete this.keyCache[i6.id];
              }
              for (const e4 of i5)
                delete this.keyCache[e4], delete this._layerConfigs[e4], delete this._layers[e4];
              this.familiesBySource = {};
              const r5 = e3.groupByLayout(Object.values(this._layerConfigs), this.keyCache);
              for (const e4 of r5) {
                const t5 = e4.map((e5) => this._layers[e5.id]), i6 = t5[0];
                if ("none" === i6.visibility)
                  continue;
                const r6 = i6.source || "";
                let o5 = this.familiesBySource[r6];
                o5 || (o5 = this.familiesBySource[r6] = {});
                const s5 = i6.sourceLayer || "_geojsonTileLayer";
                let n3 = o5[s5];
                n3 || (n3 = o5[s5] = []), n3.push(t5);
              }
            }
          }
          class i4 {
            constructor(t4) {
              const i5 = {}, r5 = [];
              for (const e4 in t4) {
                const o6 = t4[e4], s6 = i5[e4] = {};
                for (const e5 in o6) {
                  const t5 = o6[+e5];
                  if (!t5 || 0 === t5.bitmap.width || 0 === t5.bitmap.height)
                    continue;
                  const i6 = { x: 0, y: 0, w: t5.bitmap.width + 2, h: t5.bitmap.height + 2 };
                  r5.push(i6), s6[e5] = { rect: i6, metrics: t5.metrics };
                }
              }
              const { w: o5, h: s5 } = e3.potpack(r5), n3 = new e3.AlphaImage({ width: o5 || 1, height: s5 || 1 });
              for (const r6 in t4) {
                const o6 = t4[r6];
                for (const t5 in o6) {
                  const s6 = o6[+t5];
                  if (!s6 || 0 === s6.bitmap.width || 0 === s6.bitmap.height)
                    continue;
                  const a5 = i5[r6][t5].rect;
                  e3.AlphaImage.copy(s6.bitmap, n3, { x: 0, y: 0 }, { x: a5.x + 1, y: a5.y + 1 }, s6.bitmap);
                }
              }
              this.image = n3, this.positions = i5;
            }
          }
          e3.register("GlyphAtlas", i4);
          class r4 {
            constructor(t4) {
              this.tileID = new e3.OverscaledTileID(t4.tileID.overscaledZ, t4.tileID.wrap, t4.tileID.canonical.z, t4.tileID.canonical.x, t4.tileID.canonical.y), this.uid = t4.uid, this.zoom = t4.zoom, this.pixelRatio = t4.pixelRatio, this.tileSize = t4.tileSize, this.source = t4.source, this.overscaling = this.tileID.overscaleFactor(), this.showCollisionBoxes = t4.showCollisionBoxes, this.collectResourceTiming = !!t4.collectResourceTiming, this.returnDependencies = !!t4.returnDependencies, this.promoteId = t4.promoteId, this.inFlightDependencies = [], this.dependencySentinel = -1;
            }
            parse(t4, r5, s5, n3, a5) {
              this.status = "parsing", this.data = t4, this.collisionBoxArray = new e3.CollisionBoxArray();
              const l5 = new e3.DictionaryCoder(Object.keys(t4.layers).sort()), c5 = new e3.FeatureIndex(this.tileID, this.promoteId);
              c5.bucketLayerIDs = [];
              const u5 = {}, h4 = { featureIndex: c5, iconDependencies: {}, patternDependencies: {}, glyphDependencies: {}, availableImages: s5 }, p7 = r5.familiesBySource[this.source];
              for (const i5 in p7) {
                const r6 = t4.layers[i5];
                if (!r6)
                  continue;
                1 === r6.version && e3.warnOnce(`Vector tile source "${this.source}" layer "${i5}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                const n4 = l5.encode(i5), a6 = [];
                for (let e4 = 0; e4 < r6.length; e4++) {
                  const t5 = r6.feature(e4), o5 = c5.getId(t5, i5);
                  a6.push({ feature: t5, id: o5, index: e4, sourceLayerIndex: n4 });
                }
                for (const t5 of p7[i5]) {
                  const i6 = t5[0];
                  i6.source !== this.source && e3.warnOnce(`layer.source = ${i6.source} does not equal this.source = ${this.source}`), i6.minzoom && this.zoom < Math.floor(i6.minzoom) || i6.maxzoom && this.zoom >= i6.maxzoom || "none" !== i6.visibility && (o4(t5, this.zoom, s5), (u5[i6.id] = i6.createBucket({ index: c5.bucketLayerIDs.length, layers: t5, zoom: this.zoom, pixelRatio: this.pixelRatio, overscaling: this.overscaling, collisionBoxArray: this.collisionBoxArray, sourceLayerIndex: n4, sourceID: this.source })).populate(a6, h4, this.tileID.canonical), c5.bucketLayerIDs.push(t5.map((e4) => e4.id)));
                }
              }
              let d4, f4, g4, m4;
              const y3 = e3.mapObject(h4.glyphDependencies, (e4) => Object.keys(e4).map(Number));
              this.inFlightDependencies.forEach((e4) => null == e4 ? void 0 : e4.cancel()), this.inFlightDependencies = [];
              const v5 = ++this.dependencySentinel;
              Object.keys(y3).length ? this.inFlightDependencies.push(n3.send("getGlyphs", { uid: this.uid, stacks: y3, source: this.source, tileID: this.tileID, type: "glyphs" }, (e4, t5) => {
                v5 === this.dependencySentinel && (d4 || (d4 = e4, f4 = t5, S3.call(this)));
              })) : f4 = {};
              const x3 = Object.keys(h4.iconDependencies);
              x3.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: x3, source: this.source, tileID: this.tileID, type: "icons" }, (e4, t5) => {
                v5 === this.dependencySentinel && (d4 || (d4 = e4, g4 = t5, S3.call(this)));
              })) : g4 = {};
              const w4 = Object.keys(h4.patternDependencies);
              function S3() {
                if (d4)
                  return a5(d4);
                if (f4 && g4 && m4) {
                  const t5 = new i4(f4), r6 = new e3.ImageAtlas(g4, m4);
                  for (const i5 in u5) {
                    const n4 = u5[i5];
                    n4 instanceof e3.SymbolBucket ? (o4(n4.layers, this.zoom, s5), e3.performSymbolLayout({ bucket: n4, glyphMap: f4, glyphPositions: t5.positions, imageMap: g4, imagePositions: r6.iconPositions, showCollisionBoxes: this.showCollisionBoxes, canonical: this.tileID.canonical })) : n4.hasPattern && (n4 instanceof e3.LineBucket || n4 instanceof e3.FillBucket || n4 instanceof e3.FillExtrusionBucket) && (o4(n4.layers, this.zoom, s5), n4.addFeatures(h4, this.tileID.canonical, r6.patternPositions));
                  }
                  this.status = "done", a5(null, { buckets: Object.values(u5).filter((e4) => !e4.isEmpty()), featureIndex: c5, collisionBoxArray: this.collisionBoxArray, glyphAtlasImage: t5.image, imageAtlas: r6, glyphMap: this.returnDependencies ? f4 : null, iconMap: this.returnDependencies ? g4 : null, glyphPositions: this.returnDependencies ? t5.positions : null });
                }
              }
              w4.length ? this.inFlightDependencies.push(n3.send("getImages", { icons: w4, source: this.source, tileID: this.tileID, type: "patterns" }, (e4, t5) => {
                v5 === this.dependencySentinel && (d4 || (d4 = e4, m4 = t5, S3.call(this)));
              })) : m4 = {}, S3.call(this);
            }
          }
          function o4(t4, i5, r5) {
            const o5 = new e3.EvaluationParameters(i5);
            for (const e4 of t4)
              e4.recalculate(o5, r5);
          }
          function s4(t4, i5) {
            const r5 = e3.getArrayBuffer(t4.request, (r6, o5, s5, n3) => {
              if (r6)
                i5(r6);
              else if (o5)
                try {
                  const t5 = new e3.vectorTile.VectorTile(new e3.Protobuf(o5));
                  i5(null, { vectorTile: t5, rawData: o5, cacheControl: s5, expires: n3 });
                } catch (e4) {
                  const r7 = new Uint8Array(o5);
                  let s6 = `Unable to parse the tile at ${t4.request.url}, `;
                  s6 += 31 === r7[0] && 139 === r7[1] ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${e4.messge}`, i5(new Error(s6));
                }
            });
            return () => {
              r5.cancel(), i5();
            };
          }
          class n2 {
            constructor(e4, t4, i5, r5) {
              this.actor = e4, this.layerIndex = t4, this.availableImages = i5, this.loadVectorData = r5 || s4, this.fetching = {}, this.loading = {}, this.loaded = {};
            }
            loadTile(t4, i5) {
              const o5 = t4.uid;
              this.loading || (this.loading = {});
              const s5 = !!(t4 && t4.request && t4.request.collectResourceTiming) && new e3.RequestPerformance(t4.request), n3 = this.loading[o5] = new r4(t4);
              n3.abort = this.loadVectorData(t4, (t5, r5) => {
                if (delete this.loading[o5], t5 || !r5)
                  return n3.status = "done", this.loaded[o5] = n3, i5(t5);
                const a5 = r5.rawData, l5 = {};
                r5.expires && (l5.expires = r5.expires), r5.cacheControl && (l5.cacheControl = r5.cacheControl);
                const c5 = {};
                if (s5) {
                  const e4 = s5.finish();
                  e4 && (c5.resourceTiming = JSON.parse(JSON.stringify(e4)));
                }
                n3.vectorTile = r5.vectorTile, n3.parse(r5.vectorTile, this.layerIndex, this.availableImages, this.actor, (t6, r6) => {
                  if (delete this.fetching[o5], t6 || !r6)
                    return i5(t6);
                  i5(null, e3.extend({ rawTileData: a5.slice(0) }, r6, l5, c5));
                }), this.loaded = this.loaded || {}, this.loaded[o5] = n3, this.fetching[o5] = { rawTileData: a5, cacheControl: l5, resourceTiming: c5 };
              });
            }
            reloadTile(t4, i5) {
              const r5 = this.loaded, o5 = t4.uid;
              if (r5 && r5[o5]) {
                const s5 = r5[o5];
                s5.showCollisionBoxes = t4.showCollisionBoxes, "parsing" === s5.status ? s5.parse(s5.vectorTile, this.layerIndex, this.availableImages, this.actor, (t5, r6) => {
                  if (t5 || !r6)
                    return i5(t5, r6);
                  let s6;
                  if (this.fetching[o5]) {
                    const { rawTileData: t6, cacheControl: i6, resourceTiming: n3 } = this.fetching[o5];
                    delete this.fetching[o5], s6 = e3.extend({ rawTileData: t6.slice(0) }, r6, i6, n3);
                  } else
                    s6 = r6;
                  i5(null, s6);
                }) : "done" === s5.status && (s5.vectorTile ? s5.parse(s5.vectorTile, this.layerIndex, this.availableImages, this.actor, i5) : i5());
              }
            }
            abortTile(e4, t4) {
              const i5 = this.loading, r5 = e4.uid;
              i5 && i5[r5] && i5[r5].abort && (i5[r5].abort(), delete i5[r5]), t4();
            }
            removeTile(e4, t4) {
              const i5 = this.loaded, r5 = e4.uid;
              i5 && i5[r5] && delete i5[r5], t4();
            }
          }
          class a4 {
            constructor() {
              this.loaded = {};
            }
            async loadTile(t4, i5) {
              const { uid: r5, encoding: o5, rawImageData: s5, redFactor: n3, greenFactor: a5, blueFactor: l5, baseShift: c5 } = t4, u5 = s5.width + 2, h4 = s5.height + 2, p7 = e3.isImageBitmap(s5) ? new e3.RGBAImage({ width: u5, height: h4 }, await e3.getImageData(s5, -1, -1, u5, h4)) : s5, d4 = new e3.DEMData(r5, p7, o5, n3, a5, l5, c5);
              this.loaded = this.loaded || {}, this.loaded[r5] = d4, i5(null, d4);
            }
            removeTile(e4) {
              const t4 = this.loaded, i5 = e4.uid;
              t4 && t4[i5] && delete t4[i5];
            }
          }
          function l4(e4, t4) {
            if (0 !== e4.length) {
              c4(e4[0], t4);
              for (var i5 = 1; i5 < e4.length; i5++)
                c4(e4[i5], !t4);
            }
          }
          function c4(e4, t4) {
            for (var i5 = 0, r5 = 0, o5 = 0, s5 = e4.length, n3 = s5 - 1; o5 < s5; n3 = o5++) {
              var a5 = (e4[o5][0] - e4[n3][0]) * (e4[n3][1] + e4[o5][1]), l5 = i5 + a5;
              r5 += Math.abs(i5) >= Math.abs(a5) ? i5 - l5 + a5 : a5 - l5 + i5, i5 = l5;
            }
            i5 + r5 >= 0 != !!t4 && e4.reverse();
          }
          var u4 = e3.getDefaultExportFromCjs(function e4(t4, i5) {
            var r5, o5 = t4 && t4.type;
            if ("FeatureCollection" === o5)
              for (r5 = 0; r5 < t4.features.length; r5++)
                e4(t4.features[r5], i5);
            else if ("GeometryCollection" === o5)
              for (r5 = 0; r5 < t4.geometries.length; r5++)
                e4(t4.geometries[r5], i5);
            else if ("Feature" === o5)
              e4(t4.geometry, i5);
            else if ("Polygon" === o5)
              l4(t4.coordinates, i5);
            else if ("MultiPolygon" === o5)
              for (r5 = 0; r5 < t4.coordinates.length; r5++)
                l4(t4.coordinates[r5], i5);
            return t4;
          });
          const h3 = e3.vectorTile.VectorTileFeature.prototype.toGeoJSON;
          var p6 = { exports: {} }, d3 = e3.pointGeometry, f3 = e3.vectorTile.VectorTileFeature, g3 = m3;
          function m3(e4, t4) {
            this.options = t4 || {}, this.features = e4, this.length = e4.length;
          }
          function y2(e4, t4) {
            this.id = "number" == typeof e4.id ? e4.id : void 0, this.type = e4.type, this.rawGeometry = 1 === e4.type ? [e4.geometry] : e4.geometry, this.properties = e4.tags, this.extent = t4 || 4096;
          }
          m3.prototype.feature = function(e4) {
            return new y2(this.features[e4], this.options.extent);
          }, y2.prototype.loadGeometry = function() {
            var e4 = this.rawGeometry;
            this.geometry = [];
            for (var t4 = 0; t4 < e4.length; t4++) {
              for (var i5 = e4[t4], r5 = [], o5 = 0; o5 < i5.length; o5++)
                r5.push(new d3(i5[o5][0], i5[o5][1]));
              this.geometry.push(r5);
            }
            return this.geometry;
          }, y2.prototype.bbox = function() {
            this.geometry || this.loadGeometry();
            for (var e4 = this.geometry, t4 = 1 / 0, i5 = -1 / 0, r5 = 1 / 0, o5 = -1 / 0, s5 = 0; s5 < e4.length; s5++)
              for (var n3 = e4[s5], a5 = 0; a5 < n3.length; a5++) {
                var l5 = n3[a5];
                t4 = Math.min(t4, l5.x), i5 = Math.max(i5, l5.x), r5 = Math.min(r5, l5.y), o5 = Math.max(o5, l5.y);
              }
            return [t4, r5, i5, o5];
          }, y2.prototype.toGeoJSON = f3.prototype.toGeoJSON;
          var v3 = e3.pbf, x2 = g3;
          function w3(e4) {
            var t4 = new v3();
            return function(e5, t5) {
              for (var i5 in e5.layers)
                t5.writeMessage(3, S2, e5.layers[i5]);
            }(e4, t4), t4.finish();
          }
          function S2(e4, t4) {
            var i5;
            t4.writeVarintField(15, e4.version || 1), t4.writeStringField(1, e4.name || ""), t4.writeVarintField(5, e4.extent || 4096);
            var r5 = { keys: [], values: [], keycache: {}, valuecache: {} };
            for (i5 = 0; i5 < e4.length; i5++)
              r5.feature = e4.feature(i5), t4.writeMessage(2, b3, r5);
            var o5 = r5.keys;
            for (i5 = 0; i5 < o5.length; i5++)
              t4.writeStringField(3, o5[i5]);
            var s5 = r5.values;
            for (i5 = 0; i5 < s5.length; i5++)
              t4.writeMessage(4, k3, s5[i5]);
          }
          function b3(e4, t4) {
            var i5 = e4.feature;
            void 0 !== i5.id && t4.writeVarintField(1, i5.id), t4.writeMessage(2, M2, e4), t4.writeVarintField(3, i5.type), t4.writeMessage(4, T2, i5);
          }
          function M2(e4, t4) {
            var i5 = e4.feature, r5 = e4.keys, o5 = e4.values, s5 = e4.keycache, n3 = e4.valuecache;
            for (var a5 in i5.properties) {
              var l5 = i5.properties[a5], c5 = s5[a5];
              if (null !== l5) {
                void 0 === c5 && (r5.push(a5), s5[a5] = c5 = r5.length - 1), t4.writeVarint(c5);
                var u5 = typeof l5;
                "string" !== u5 && "boolean" !== u5 && "number" !== u5 && (l5 = JSON.stringify(l5));
                var h4 = u5 + ":" + l5, p7 = n3[h4];
                void 0 === p7 && (o5.push(l5), n3[h4] = p7 = o5.length - 1), t4.writeVarint(p7);
              }
            }
          }
          function I2(e4, t4) {
            return (t4 << 3) + (7 & e4);
          }
          function P2(e4) {
            return e4 << 1 ^ e4 >> 31;
          }
          function T2(e4, t4) {
            for (var i5 = e4.loadGeometry(), r5 = e4.type, o5 = 0, s5 = 0, n3 = i5.length, a5 = 0; a5 < n3; a5++) {
              var l5 = i5[a5], c5 = 1;
              1 === r5 && (c5 = l5.length), t4.writeVarint(I2(1, c5));
              for (var u5 = 3 === r5 ? l5.length - 1 : l5.length, h4 = 0; h4 < u5; h4++) {
                1 === h4 && 1 !== r5 && t4.writeVarint(I2(2, u5 - 1));
                var p7 = l5[h4].x - o5, d4 = l5[h4].y - s5;
                t4.writeVarint(P2(p7)), t4.writeVarint(P2(d4)), o5 += p7, s5 += d4;
              }
              3 === r5 && t4.writeVarint(I2(7, 1));
            }
          }
          function k3(e4, t4) {
            var i5 = typeof e4;
            "string" === i5 ? t4.writeStringField(1, e4) : "boolean" === i5 ? t4.writeBooleanField(7, e4) : "number" === i5 && (e4 % 1 != 0 ? t4.writeDoubleField(3, e4) : e4 < 0 ? t4.writeSVarintField(6, e4) : t4.writeVarintField(5, e4));
          }
          p6.exports = w3, p6.exports.fromVectorTileJs = w3, p6.exports.fromGeojsonVt = function(e4, t4) {
            t4 = t4 || {};
            var i5 = {};
            for (var r5 in e4)
              i5[r5] = new x2(e4[r5].features, t4), i5[r5].name = r5, i5[r5].version = t4.version, i5[r5].extent = t4.extent;
            return w3({ layers: i5 });
          }, p6.exports.GeoJSONWrapper = x2;
          var _3 = e3.getDefaultExportFromCjs(p6.exports);
          const D2 = { minZoom: 0, maxZoom: 16, minPoints: 2, radius: 40, extent: 512, nodeSize: 64, log: false, generateId: false, reduce: null, map: (e4) => e4 }, O2 = Math.fround || (C = new Float32Array(1), (e4) => (C[0] = +e4, C[0]));
          var C;
          const L2 = 3, F3 = 5, E2 = 6;
          class z3 {
            constructor(e4) {
              this.options = Object.assign(Object.create(D2), e4), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
            }
            load(e4) {
              const { log: t4, minZoom: i5, maxZoom: r5 } = this.options;
              t4 && console.time("total time");
              const o5 = `prepare ${e4.length} points`;
              t4 && console.time(o5), this.points = e4;
              const s5 = [];
              for (let t5 = 0; t5 < e4.length; t5++) {
                const i6 = e4[t5];
                if (!i6.geometry)
                  continue;
                const [r6, o6] = i6.geometry.coordinates, n4 = O2(B3(r6)), a5 = O2(A2(o6));
                s5.push(n4, a5, 1 / 0, t5, -1, 1), this.options.reduce && s5.push(0);
              }
              let n3 = this.trees[r5 + 1] = this._createTree(s5);
              t4 && console.timeEnd(o5);
              for (let e5 = r5; e5 >= i5; e5--) {
                const i6 = +Date.now();
                n3 = this.trees[e5] = this._createTree(this._cluster(n3, e5)), t4 && console.log("z%d: %d clusters in %dms", e5, n3.numItems, +Date.now() - i6);
              }
              return t4 && console.timeEnd("total time"), this;
            }
            getClusters(e4, t4) {
              let i5 = ((e4[0] + 180) % 360 + 360) % 360 - 180;
              const r5 = Math.max(-90, Math.min(90, e4[1]));
              let o5 = 180 === e4[2] ? 180 : ((e4[2] + 180) % 360 + 360) % 360 - 180;
              const s5 = Math.max(-90, Math.min(90, e4[3]));
              if (e4[2] - e4[0] >= 360)
                i5 = -180, o5 = 180;
              else if (i5 > o5) {
                const e5 = this.getClusters([i5, r5, 180, s5], t4), n4 = this.getClusters([-180, r5, o5, s5], t4);
                return e5.concat(n4);
              }
              const n3 = this.trees[this._limitZoom(t4)], a5 = n3.range(B3(i5), A2(s5), B3(o5), A2(r5)), l5 = n3.data, c5 = [];
              for (const e5 of a5) {
                const t5 = this.stride * e5;
                c5.push(l5[t5 + F3] > 1 ? j3(l5, t5, this.clusterProps) : this.points[l5[t5 + L2]]);
              }
              return c5;
            }
            getChildren(e4) {
              const t4 = this._getOriginId(e4), i5 = this._getOriginZoom(e4), r5 = "No cluster with the specified id.", o5 = this.trees[i5];
              if (!o5)
                throw new Error(r5);
              const s5 = o5.data;
              if (t4 * this.stride >= s5.length)
                throw new Error(r5);
              const n3 = this.options.radius / (this.options.extent * Math.pow(2, i5 - 1)), a5 = o5.within(s5[t4 * this.stride], s5[t4 * this.stride + 1], n3), l5 = [];
              for (const t5 of a5) {
                const i6 = t5 * this.stride;
                s5[i6 + 4] === e4 && l5.push(s5[i6 + F3] > 1 ? j3(s5, i6, this.clusterProps) : this.points[s5[i6 + L2]]);
              }
              if (0 === l5.length)
                throw new Error(r5);
              return l5;
            }
            getLeaves(e4, t4, i5) {
              const r5 = [];
              return this._appendLeaves(r5, e4, t4 = t4 || 10, i5 = i5 || 0, 0), r5;
            }
            getTile(e4, t4, i5) {
              const r5 = this.trees[this._limitZoom(e4)], o5 = Math.pow(2, e4), { extent: s5, radius: n3 } = this.options, a5 = n3 / s5, l5 = (i5 - a5) / o5, c5 = (i5 + 1 + a5) / o5, u5 = { features: [] };
              return this._addTileFeatures(r5.range((t4 - a5) / o5, l5, (t4 + 1 + a5) / o5, c5), r5.data, t4, i5, o5, u5), 0 === t4 && this._addTileFeatures(r5.range(1 - a5 / o5, l5, 1, c5), r5.data, o5, i5, o5, u5), t4 === o5 - 1 && this._addTileFeatures(r5.range(0, l5, a5 / o5, c5), r5.data, -1, i5, o5, u5), u5.features.length ? u5 : null;
            }
            getClusterExpansionZoom(e4) {
              let t4 = this._getOriginZoom(e4) - 1;
              for (; t4 <= this.options.maxZoom; ) {
                const i5 = this.getChildren(e4);
                if (t4++, 1 !== i5.length)
                  break;
                e4 = i5[0].properties.cluster_id;
              }
              return t4;
            }
            _appendLeaves(e4, t4, i5, r5, o5) {
              const s5 = this.getChildren(t4);
              for (const t5 of s5) {
                const s6 = t5.properties;
                if (s6 && s6.cluster ? o5 + s6.point_count <= r5 ? o5 += s6.point_count : o5 = this._appendLeaves(e4, s6.cluster_id, i5, r5, o5) : o5 < r5 ? o5++ : e4.push(t5), e4.length === i5)
                  break;
              }
              return o5;
            }
            _createTree(t4) {
              const i5 = new e3.KDBush(t4.length / this.stride | 0, this.options.nodeSize, Float32Array);
              for (let e4 = 0; e4 < t4.length; e4 += this.stride)
                i5.add(t4[e4], t4[e4 + 1]);
              return i5.finish(), i5.data = t4, i5;
            }
            _addTileFeatures(e4, t4, i5, r5, o5, s5) {
              for (const n3 of e4) {
                const e5 = n3 * this.stride, a5 = t4[e5 + F3] > 1;
                let l5, c5, u5;
                if (a5)
                  l5 = N2(t4, e5, this.clusterProps), c5 = t4[e5], u5 = t4[e5 + 1];
                else {
                  const i6 = this.points[t4[e5 + L2]];
                  l5 = i6.properties;
                  const [r6, o6] = i6.geometry.coordinates;
                  c5 = B3(r6), u5 = A2(o6);
                }
                const h4 = { type: 1, geometry: [[Math.round(this.options.extent * (c5 * o5 - i5)), Math.round(this.options.extent * (u5 * o5 - r5))]], tags: l5 };
                let p7;
                p7 = a5 || this.options.generateId ? t4[e5 + L2] : this.points[t4[e5 + L2]].id, void 0 !== p7 && (h4.id = p7), s5.features.push(h4);
              }
            }
            _limitZoom(e4) {
              return Math.max(this.options.minZoom, Math.min(Math.floor(+e4), this.options.maxZoom + 1));
            }
            _cluster(e4, t4) {
              const { radius: i5, extent: r5, reduce: o5, minPoints: s5 } = this.options, n3 = i5 / (r5 * Math.pow(2, t4)), a5 = e4.data, l5 = [], c5 = this.stride;
              for (let i6 = 0; i6 < a5.length; i6 += c5) {
                if (a5[i6 + 2] <= t4)
                  continue;
                a5[i6 + 2] = t4;
                const r6 = a5[i6], u5 = a5[i6 + 1], h4 = e4.within(a5[i6], a5[i6 + 1], n3), p7 = a5[i6 + F3];
                let d4 = p7;
                for (const e5 of h4) {
                  const i7 = e5 * c5;
                  a5[i7 + 2] > t4 && (d4 += a5[i7 + F3]);
                }
                if (d4 > p7 && d4 >= s5) {
                  let e5, s6 = r6 * p7, n4 = u5 * p7, f4 = -1;
                  const g4 = ((i6 / c5 | 0) << 5) + (t4 + 1) + this.points.length;
                  for (const r7 of h4) {
                    const l6 = r7 * c5;
                    if (a5[l6 + 2] <= t4)
                      continue;
                    a5[l6 + 2] = t4;
                    const u6 = a5[l6 + F3];
                    s6 += a5[l6] * u6, n4 += a5[l6 + 1] * u6, a5[l6 + 4] = g4, o5 && (e5 || (e5 = this._map(a5, i6, true), f4 = this.clusterProps.length, this.clusterProps.push(e5)), o5(e5, this._map(a5, l6)));
                  }
                  a5[i6 + 4] = g4, l5.push(s6 / d4, n4 / d4, 1 / 0, g4, -1, d4), o5 && l5.push(f4);
                } else {
                  for (let e5 = 0; e5 < c5; e5++)
                    l5.push(a5[i6 + e5]);
                  if (d4 > 1)
                    for (const e5 of h4) {
                      const i7 = e5 * c5;
                      if (!(a5[i7 + 2] <= t4)) {
                        a5[i7 + 2] = t4;
                        for (let e6 = 0; e6 < c5; e6++)
                          l5.push(a5[i7 + e6]);
                      }
                    }
                }
              }
              return l5;
            }
            _getOriginId(e4) {
              return e4 - this.points.length >> 5;
            }
            _getOriginZoom(e4) {
              return (e4 - this.points.length) % 32;
            }
            _map(e4, t4, i5) {
              if (e4[t4 + F3] > 1) {
                const r6 = this.clusterProps[e4[t4 + E2]];
                return i5 ? Object.assign({}, r6) : r6;
              }
              const r5 = this.points[e4[t4 + L2]].properties, o5 = this.options.map(r5);
              return i5 && o5 === r5 ? Object.assign({}, o5) : o5;
            }
          }
          function j3(e4, t4, i5) {
            return { type: "Feature", id: e4[t4 + L2], properties: N2(e4, t4, i5), geometry: { type: "Point", coordinates: [(r5 = e4[t4], 360 * (r5 - 0.5)), Z(e4[t4 + 1])] } };
            var r5;
          }
          function N2(e4, t4, i5) {
            const r5 = e4[t4 + F3], o5 = r5 >= 1e4 ? `${Math.round(r5 / 1e3)}k` : r5 >= 1e3 ? Math.round(r5 / 100) / 10 + "k" : r5, s5 = e4[t4 + E2], n3 = -1 === s5 ? {} : Object.assign({}, i5[s5]);
            return Object.assign(n3, { cluster: true, cluster_id: e4[t4 + L2], point_count: r5, point_count_abbreviated: o5 });
          }
          function B3(e4) {
            return e4 / 360 + 0.5;
          }
          function A2(e4) {
            const t4 = Math.sin(e4 * Math.PI / 180), i5 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
            return i5 < 0 ? 0 : i5 > 1 ? 1 : i5;
          }
          function Z(e4) {
            const t4 = (180 - 360 * e4) * Math.PI / 180;
            return 360 * Math.atan(Math.exp(t4)) / Math.PI - 90;
          }
          function G2(e4, t4, i5, r5) {
            for (var o5, s5 = r5, n3 = i5 - t4 >> 1, a5 = i5 - t4, l5 = e4[t4], c5 = e4[t4 + 1], u5 = e4[i5], h4 = e4[i5 + 1], p7 = t4 + 3; p7 < i5; p7 += 3) {
              var d4 = J(e4[p7], e4[p7 + 1], l5, c5, u5, h4);
              if (d4 > s5)
                o5 = p7, s5 = d4;
              else if (d4 === s5) {
                var f4 = Math.abs(p7 - n3);
                f4 < a5 && (o5 = p7, a5 = f4);
              }
            }
            s5 > r5 && (o5 - t4 > 3 && G2(e4, t4, o5, r5), e4[o5 + 2] = s5, i5 - o5 > 3 && G2(e4, o5, i5, r5));
          }
          function J(e4, t4, i5, r5, o5, s5) {
            var n3 = o5 - i5, a5 = s5 - r5;
            if (0 !== n3 || 0 !== a5) {
              var l5 = ((e4 - i5) * n3 + (t4 - r5) * a5) / (n3 * n3 + a5 * a5);
              l5 > 1 ? (i5 = o5, r5 = s5) : l5 > 0 && (i5 += n3 * l5, r5 += a5 * l5);
            }
            return (n3 = e4 - i5) * n3 + (a5 = t4 - r5) * a5;
          }
          function Y(e4, t4, i5, r5) {
            var o5 = { id: void 0 === e4 ? null : e4, type: t4, geometry: i5, tags: r5, minX: 1 / 0, minY: 1 / 0, maxX: -1 / 0, maxY: -1 / 0 };
            return function(e5) {
              var t5 = e5.geometry, i6 = e5.type;
              if ("Point" === i6 || "MultiPoint" === i6 || "LineString" === i6)
                V(e5, t5);
              else if ("Polygon" === i6 || "MultiLineString" === i6)
                for (var r6 = 0; r6 < t5.length; r6++)
                  V(e5, t5[r6]);
              else if ("MultiPolygon" === i6)
                for (r6 = 0; r6 < t5.length; r6++)
                  for (var o6 = 0; o6 < t5[r6].length; o6++)
                    V(e5, t5[r6][o6]);
            }(o5), o5;
          }
          function V(e4, t4) {
            for (var i5 = 0; i5 < t4.length; i5 += 3)
              e4.minX = Math.min(e4.minX, t4[i5]), e4.minY = Math.min(e4.minY, t4[i5 + 1]), e4.maxX = Math.max(e4.maxX, t4[i5]), e4.maxY = Math.max(e4.maxY, t4[i5 + 1]);
          }
          function X(e4, t4, i5, r5) {
            if (t4.geometry) {
              var o5 = t4.geometry.coordinates, s5 = t4.geometry.type, n3 = Math.pow(i5.tolerance / ((1 << i5.maxZoom) * i5.extent), 2), a5 = [], l5 = t4.id;
              if (i5.promoteId ? l5 = t4.properties[i5.promoteId] : i5.generateId && (l5 = r5 || 0), "Point" === s5)
                R(o5, a5);
              else if ("MultiPoint" === s5)
                for (var c5 = 0; c5 < o5.length; c5++)
                  R(o5[c5], a5);
              else if ("LineString" === s5)
                W(o5, a5, n3, false);
              else if ("MultiLineString" === s5) {
                if (i5.lineMetrics) {
                  for (c5 = 0; c5 < o5.length; c5++)
                    W(o5[c5], a5 = [], n3, false), e4.push(Y(l5, "LineString", a5, t4.properties));
                  return;
                }
                q3(o5, a5, n3, false);
              } else if ("Polygon" === s5)
                q3(o5, a5, n3, true);
              else {
                if ("MultiPolygon" !== s5) {
                  if ("GeometryCollection" === s5) {
                    for (c5 = 0; c5 < t4.geometry.geometries.length; c5++)
                      X(e4, { id: l5, geometry: t4.geometry.geometries[c5], properties: t4.properties }, i5, r5);
                    return;
                  }
                  throw new Error("Input data is not a valid GeoJSON object.");
                }
                for (c5 = 0; c5 < o5.length; c5++) {
                  var u5 = [];
                  q3(o5[c5], u5, n3, true), a5.push(u5);
                }
              }
              e4.push(Y(l5, s5, a5, t4.properties));
            }
          }
          function R(e4, t4) {
            t4.push($2(e4[0])), t4.push(U(e4[1])), t4.push(0);
          }
          function W(e4, t4, i5, r5) {
            for (var o5, s5, n3 = 0, a5 = 0; a5 < e4.length; a5++) {
              var l5 = $2(e4[a5][0]), c5 = U(e4[a5][1]);
              t4.push(l5), t4.push(c5), t4.push(0), a5 > 0 && (n3 += r5 ? (o5 * c5 - l5 * s5) / 2 : Math.sqrt(Math.pow(l5 - o5, 2) + Math.pow(c5 - s5, 2))), o5 = l5, s5 = c5;
            }
            var u5 = t4.length - 3;
            t4[2] = 1, G2(t4, 0, u5, i5), t4[u5 + 2] = 1, t4.size = Math.abs(n3), t4.start = 0, t4.end = t4.size;
          }
          function q3(e4, t4, i5, r5) {
            for (var o5 = 0; o5 < e4.length; o5++) {
              var s5 = [];
              W(e4[o5], s5, i5, r5), t4.push(s5);
            }
          }
          function $2(e4) {
            return e4 / 360 + 0.5;
          }
          function U(e4) {
            var t4 = Math.sin(e4 * Math.PI / 180), i5 = 0.5 - 0.25 * Math.log((1 + t4) / (1 - t4)) / Math.PI;
            return i5 < 0 ? 0 : i5 > 1 ? 1 : i5;
          }
          function K(e4, t4, i5, r5, o5, s5, n3, a5) {
            if (r5 /= t4, s5 >= (i5 /= t4) && n3 < r5)
              return e4;
            if (n3 < i5 || s5 >= r5)
              return null;
            for (var l5 = [], c5 = 0; c5 < e4.length; c5++) {
              var u5 = e4[c5], h4 = u5.geometry, p7 = u5.type, d4 = 0 === o5 ? u5.minX : u5.minY, f4 = 0 === o5 ? u5.maxX : u5.maxY;
              if (d4 >= i5 && f4 < r5)
                l5.push(u5);
              else if (!(f4 < i5 || d4 >= r5)) {
                var g4 = [];
                if ("Point" === p7 || "MultiPoint" === p7)
                  H2(h4, g4, i5, r5, o5);
                else if ("LineString" === p7)
                  Q(h4, g4, i5, r5, o5, false, a5.lineMetrics);
                else if ("MultiLineString" === p7)
                  te(h4, g4, i5, r5, o5, false);
                else if ("Polygon" === p7)
                  te(h4, g4, i5, r5, o5, true);
                else if ("MultiPolygon" === p7)
                  for (var m4 = 0; m4 < h4.length; m4++) {
                    var y3 = [];
                    te(h4[m4], y3, i5, r5, o5, true), y3.length && g4.push(y3);
                  }
                if (g4.length) {
                  if (a5.lineMetrics && "LineString" === p7) {
                    for (m4 = 0; m4 < g4.length; m4++)
                      l5.push(Y(u5.id, p7, g4[m4], u5.tags));
                    continue;
                  }
                  "LineString" !== p7 && "MultiLineString" !== p7 || (1 === g4.length ? (p7 = "LineString", g4 = g4[0]) : p7 = "MultiLineString"), "Point" !== p7 && "MultiPoint" !== p7 || (p7 = 3 === g4.length ? "Point" : "MultiPoint"), l5.push(Y(u5.id, p7, g4, u5.tags));
                }
              }
            }
            return l5.length ? l5 : null;
          }
          function H2(e4, t4, i5, r5, o5) {
            for (var s5 = 0; s5 < e4.length; s5 += 3) {
              var n3 = e4[s5 + o5];
              n3 >= i5 && n3 <= r5 && (t4.push(e4[s5]), t4.push(e4[s5 + 1]), t4.push(e4[s5 + 2]));
            }
          }
          function Q(e4, t4, i5, r5, o5, s5, n3) {
            for (var a5, l5, c5 = ee(e4), u5 = 0 === o5 ? re : oe, h4 = e4.start, p7 = 0; p7 < e4.length - 3; p7 += 3) {
              var d4 = e4[p7], f4 = e4[p7 + 1], g4 = e4[p7 + 2], m4 = e4[p7 + 3], y3 = e4[p7 + 4], v5 = 0 === o5 ? d4 : f4, x3 = 0 === o5 ? m4 : y3, w4 = false;
              n3 && (a5 = Math.sqrt(Math.pow(d4 - m4, 2) + Math.pow(f4 - y3, 2))), v5 < i5 ? x3 > i5 && (l5 = u5(c5, d4, f4, m4, y3, i5), n3 && (c5.start = h4 + a5 * l5)) : v5 > r5 ? x3 < r5 && (l5 = u5(c5, d4, f4, m4, y3, r5), n3 && (c5.start = h4 + a5 * l5)) : ie(c5, d4, f4, g4), x3 < i5 && v5 >= i5 && (l5 = u5(c5, d4, f4, m4, y3, i5), w4 = true), x3 > r5 && v5 <= r5 && (l5 = u5(c5, d4, f4, m4, y3, r5), w4 = true), !s5 && w4 && (n3 && (c5.end = h4 + a5 * l5), t4.push(c5), c5 = ee(e4)), n3 && (h4 += a5);
            }
            var S3 = e4.length - 3;
            d4 = e4[S3], f4 = e4[S3 + 1], g4 = e4[S3 + 2], (v5 = 0 === o5 ? d4 : f4) >= i5 && v5 <= r5 && ie(c5, d4, f4, g4), S3 = c5.length - 3, s5 && S3 >= 3 && (c5[S3] !== c5[0] || c5[S3 + 1] !== c5[1]) && ie(c5, c5[0], c5[1], c5[2]), c5.length && t4.push(c5);
          }
          function ee(e4) {
            var t4 = [];
            return t4.size = e4.size, t4.start = e4.start, t4.end = e4.end, t4;
          }
          function te(e4, t4, i5, r5, o5, s5) {
            for (var n3 = 0; n3 < e4.length; n3++)
              Q(e4[n3], t4, i5, r5, o5, s5, false);
          }
          function ie(e4, t4, i5, r5) {
            e4.push(t4), e4.push(i5), e4.push(r5);
          }
          function re(e4, t4, i5, r5, o5, s5) {
            var n3 = (s5 - t4) / (r5 - t4);
            return e4.push(s5), e4.push(i5 + (o5 - i5) * n3), e4.push(1), n3;
          }
          function oe(e4, t4, i5, r5, o5, s5) {
            var n3 = (s5 - i5) / (o5 - i5);
            return e4.push(t4 + (r5 - t4) * n3), e4.push(s5), e4.push(1), n3;
          }
          function se(e4, t4) {
            for (var i5 = [], r5 = 0; r5 < e4.length; r5++) {
              var o5, s5 = e4[r5], n3 = s5.type;
              if ("Point" === n3 || "MultiPoint" === n3 || "LineString" === n3)
                o5 = ne(s5.geometry, t4);
              else if ("MultiLineString" === n3 || "Polygon" === n3) {
                o5 = [];
                for (var a5 = 0; a5 < s5.geometry.length; a5++)
                  o5.push(ne(s5.geometry[a5], t4));
              } else if ("MultiPolygon" === n3)
                for (o5 = [], a5 = 0; a5 < s5.geometry.length; a5++) {
                  for (var l5 = [], c5 = 0; c5 < s5.geometry[a5].length; c5++)
                    l5.push(ne(s5.geometry[a5][c5], t4));
                  o5.push(l5);
                }
              i5.push(Y(s5.id, n3, o5, s5.tags));
            }
            return i5;
          }
          function ne(e4, t4) {
            var i5 = [];
            i5.size = e4.size, void 0 !== e4.start && (i5.start = e4.start, i5.end = e4.end);
            for (var r5 = 0; r5 < e4.length; r5 += 3)
              i5.push(e4[r5] + t4, e4[r5 + 1], e4[r5 + 2]);
            return i5;
          }
          function ae(e4, t4) {
            if (e4.transformed)
              return e4;
            var i5, r5, o5, s5 = 1 << e4.z, n3 = e4.x, a5 = e4.y;
            for (i5 = 0; i5 < e4.features.length; i5++) {
              var l5 = e4.features[i5], c5 = l5.geometry, u5 = l5.type;
              if (l5.geometry = [], 1 === u5)
                for (r5 = 0; r5 < c5.length; r5 += 2)
                  l5.geometry.push(le(c5[r5], c5[r5 + 1], t4, s5, n3, a5));
              else
                for (r5 = 0; r5 < c5.length; r5++) {
                  var h4 = [];
                  for (o5 = 0; o5 < c5[r5].length; o5 += 2)
                    h4.push(le(c5[r5][o5], c5[r5][o5 + 1], t4, s5, n3, a5));
                  l5.geometry.push(h4);
                }
            }
            return e4.transformed = true, e4;
          }
          function le(e4, t4, i5, r5, o5, s5) {
            return [Math.round(i5 * (e4 * r5 - o5)), Math.round(i5 * (t4 * r5 - s5))];
          }
          function ce(e4, t4, i5, r5, o5) {
            for (var s5 = t4 === o5.maxZoom ? 0 : o5.tolerance / ((1 << t4) * o5.extent), n3 = { features: [], numPoints: 0, numSimplified: 0, numFeatures: 0, source: null, x: i5, y: r5, z: t4, transformed: false, minX: 2, minY: 1, maxX: -1, maxY: 0 }, a5 = 0; a5 < e4.length; a5++) {
              n3.numFeatures++, ue(n3, e4[a5], s5, o5);
              var l5 = e4[a5].minX, c5 = e4[a5].minY, u5 = e4[a5].maxX, h4 = e4[a5].maxY;
              l5 < n3.minX && (n3.minX = l5), c5 < n3.minY && (n3.minY = c5), u5 > n3.maxX && (n3.maxX = u5), h4 > n3.maxY && (n3.maxY = h4);
            }
            return n3;
          }
          function ue(e4, t4, i5, r5) {
            var o5 = t4.geometry, s5 = t4.type, n3 = [];
            if ("Point" === s5 || "MultiPoint" === s5)
              for (var a5 = 0; a5 < o5.length; a5 += 3)
                n3.push(o5[a5]), n3.push(o5[a5 + 1]), e4.numPoints++, e4.numSimplified++;
            else if ("LineString" === s5)
              he(n3, o5, e4, i5, false, false);
            else if ("MultiLineString" === s5 || "Polygon" === s5)
              for (a5 = 0; a5 < o5.length; a5++)
                he(n3, o5[a5], e4, i5, "Polygon" === s5, 0 === a5);
            else if ("MultiPolygon" === s5)
              for (var l5 = 0; l5 < o5.length; l5++) {
                var c5 = o5[l5];
                for (a5 = 0; a5 < c5.length; a5++)
                  he(n3, c5[a5], e4, i5, true, 0 === a5);
              }
            if (n3.length) {
              var u5 = t4.tags || null;
              if ("LineString" === s5 && r5.lineMetrics) {
                for (var h4 in u5 = {}, t4.tags)
                  u5[h4] = t4.tags[h4];
                u5.mapbox_clip_start = o5.start / o5.size, u5.mapbox_clip_end = o5.end / o5.size;
              }
              var p7 = { geometry: n3, type: "Polygon" === s5 || "MultiPolygon" === s5 ? 3 : "LineString" === s5 || "MultiLineString" === s5 ? 2 : 1, tags: u5 };
              null !== t4.id && (p7.id = t4.id), e4.features.push(p7);
            }
          }
          function he(e4, t4, i5, r5, o5, s5) {
            var n3 = r5 * r5;
            if (r5 > 0 && t4.size < (o5 ? n3 : r5))
              i5.numPoints += t4.length / 3;
            else {
              for (var a5 = [], l5 = 0; l5 < t4.length; l5 += 3)
                (0 === r5 || t4[l5 + 2] > n3) && (i5.numSimplified++, a5.push(t4[l5]), a5.push(t4[l5 + 1])), i5.numPoints++;
              o5 && function(e5, t5) {
                for (var i6 = 0, r6 = 0, o6 = e5.length, s6 = o6 - 2; r6 < o6; s6 = r6, r6 += 2)
                  i6 += (e5[r6] - e5[s6]) * (e5[r6 + 1] + e5[s6 + 1]);
                if (i6 > 0 === t5)
                  for (r6 = 0, o6 = e5.length; r6 < o6 / 2; r6 += 2) {
                    var n4 = e5[r6], a6 = e5[r6 + 1];
                    e5[r6] = e5[o6 - 2 - r6], e5[r6 + 1] = e5[o6 - 1 - r6], e5[o6 - 2 - r6] = n4, e5[o6 - 1 - r6] = a6;
                  }
              }(a5, s5), e4.push(a5);
            }
          }
          function pe(e4, t4) {
            var i5 = (t4 = this.options = function(e5, t5) {
              for (var i6 in t5)
                e5[i6] = t5[i6];
              return e5;
            }(Object.create(this.options), t4)).debug;
            if (i5 && console.time("preprocess data"), t4.maxZoom < 0 || t4.maxZoom > 24)
              throw new Error("maxZoom should be in the 0-24 range");
            if (t4.promoteId && t4.generateId)
              throw new Error("promoteId and generateId cannot be used together.");
            var r5 = function(e5, t5) {
              var i6 = [];
              if ("FeatureCollection" === e5.type)
                for (var r6 = 0; r6 < e5.features.length; r6++)
                  X(i6, e5.features[r6], t5, r6);
              else
                X(i6, "Feature" === e5.type ? e5 : { geometry: e5 }, t5);
              return i6;
            }(e4, t4);
            this.tiles = {}, this.tileCoords = [], i5 && (console.timeEnd("preprocess data"), console.log("index: maxZoom: %d, maxPoints: %d", t4.indexMaxZoom, t4.indexMaxPoints), console.time("generate tiles"), this.stats = {}, this.total = 0), r5 = function(e5, t5) {
              var i6 = t5.buffer / t5.extent, r6 = e5, o5 = K(e5, 1, -1 - i6, i6, 0, -1, 2, t5), s5 = K(e5, 1, 1 - i6, 2 + i6, 0, -1, 2, t5);
              return (o5 || s5) && (r6 = K(e5, 1, -i6, 1 + i6, 0, -1, 2, t5) || [], o5 && (r6 = se(o5, 1).concat(r6)), s5 && (r6 = r6.concat(se(s5, -1)))), r6;
            }(r5, t4), r5.length && this.splitTile(r5, 0, 0, 0), i5 && (r5.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints), console.timeEnd("generate tiles"), console.log("tiles generated:", this.total, JSON.stringify(this.stats)));
          }
          function de(e4, t4, i5) {
            return 32 * ((1 << e4) * i5 + t4) + e4;
          }
          function fe(e4, t4) {
            return t4 ? e4.properties[t4] : e4.id;
          }
          function ge(e4, t4) {
            if (null == e4)
              return true;
            if ("Feature" === e4.type)
              return null != fe(e4, t4);
            if ("FeatureCollection" === e4.type) {
              const i5 = /* @__PURE__ */ new Set();
              for (const r5 of e4.features) {
                const e5 = fe(r5, t4);
                if (null == e5)
                  return false;
                if (i5.has(e5))
                  return false;
                i5.add(e5);
              }
              return true;
            }
            return false;
          }
          function me(e4, t4) {
            const i5 = /* @__PURE__ */ new Map();
            if (null == e4)
              ;
            else if ("Feature" === e4.type)
              i5.set(fe(e4, t4), e4);
            else
              for (const r5 of e4.features)
                i5.set(fe(r5, t4), r5);
            return i5;
          }
          function ye(t4, i5) {
            const r5 = t4.tileID.canonical;
            if (!this._geoJSONIndex)
              return i5(null, null);
            const o5 = this._geoJSONIndex.getTile(r5.z, r5.x, r5.y);
            if (!o5)
              return i5(null, null);
            const s5 = new class {
              constructor(t5) {
                this.layers = { _geojsonTileLayer: this }, this.name = "_geojsonTileLayer", this.extent = e3.EXTENT, this.length = t5.length, this._features = t5;
              }
              feature(t5) {
                return new class {
                  constructor(t6) {
                    this._feature = t6, this.extent = e3.EXTENT, this.type = t6.type, this.properties = t6.tags, "id" in t6 && !isNaN(t6.id) && (this.id = parseInt(t6.id, 10));
                  }
                  loadGeometry() {
                    if (1 === this._feature.type) {
                      const t6 = [];
                      for (const i6 of this._feature.geometry)
                        t6.push([new e3.Point(i6[0], i6[1])]);
                      return t6;
                    }
                    {
                      const t6 = [];
                      for (const i6 of this._feature.geometry) {
                        const r6 = [];
                        for (const t7 of i6)
                          r6.push(new e3.Point(t7[0], t7[1]));
                        t6.push(r6);
                      }
                      return t6;
                    }
                  }
                  toGeoJSON(e4, t6, i6) {
                    return h3.call(this, e4, t6, i6);
                  }
                }(this._features[t5]);
              }
            }(o5.features);
            let n3 = _3(s5);
            0 === n3.byteOffset && n3.byteLength === n3.buffer.byteLength || (n3 = new Uint8Array(n3)), i5(null, { vectorTile: s5, rawData: n3.buffer });
          }
          pe.prototype.options = { maxZoom: 14, indexMaxZoom: 5, indexMaxPoints: 1e5, tolerance: 3, extent: 4096, buffer: 64, lineMetrics: false, promoteId: null, generateId: false, debug: 0 }, pe.prototype.splitTile = function(e4, t4, i5, r5, o5, s5, n3) {
            for (var a5 = [e4, t4, i5, r5], l5 = this.options, c5 = l5.debug; a5.length; ) {
              r5 = a5.pop(), i5 = a5.pop(), t4 = a5.pop(), e4 = a5.pop();
              var u5 = 1 << t4, h4 = de(t4, i5, r5), p7 = this.tiles[h4];
              if (!p7 && (c5 > 1 && console.time("creation"), p7 = this.tiles[h4] = ce(e4, t4, i5, r5, l5), this.tileCoords.push({ z: t4, x: i5, y: r5 }), c5)) {
                c5 > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", t4, i5, r5, p7.numFeatures, p7.numPoints, p7.numSimplified), console.timeEnd("creation"));
                var d4 = "z" + t4;
                this.stats[d4] = (this.stats[d4] || 0) + 1, this.total++;
              }
              if (p7.source = e4, o5) {
                if (t4 === l5.maxZoom || t4 === o5)
                  continue;
                var f4 = 1 << o5 - t4;
                if (i5 !== Math.floor(s5 / f4) || r5 !== Math.floor(n3 / f4))
                  continue;
              } else if (t4 === l5.indexMaxZoom || p7.numPoints <= l5.indexMaxPoints)
                continue;
              if (p7.source = null, 0 !== e4.length) {
                c5 > 1 && console.time("clipping");
                var g4, m4, y3, v5, x3, w4, S3 = 0.5 * l5.buffer / l5.extent, b4 = 0.5 - S3, M3 = 0.5 + S3, I3 = 1 + S3;
                g4 = m4 = y3 = v5 = null, x3 = K(e4, u5, i5 - S3, i5 + M3, 0, p7.minX, p7.maxX, l5), w4 = K(e4, u5, i5 + b4, i5 + I3, 0, p7.minX, p7.maxX, l5), e4 = null, x3 && (g4 = K(x3, u5, r5 - S3, r5 + M3, 1, p7.minY, p7.maxY, l5), m4 = K(x3, u5, r5 + b4, r5 + I3, 1, p7.minY, p7.maxY, l5), x3 = null), w4 && (y3 = K(w4, u5, r5 - S3, r5 + M3, 1, p7.minY, p7.maxY, l5), v5 = K(w4, u5, r5 + b4, r5 + I3, 1, p7.minY, p7.maxY, l5), w4 = null), c5 > 1 && console.timeEnd("clipping"), a5.push(g4 || [], t4 + 1, 2 * i5, 2 * r5), a5.push(m4 || [], t4 + 1, 2 * i5, 2 * r5 + 1), a5.push(y3 || [], t4 + 1, 2 * i5 + 1, 2 * r5), a5.push(v5 || [], t4 + 1, 2 * i5 + 1, 2 * r5 + 1);
              }
            }
          }, pe.prototype.getTile = function(e4, t4, i5) {
            var r5 = this.options, o5 = r5.extent, s5 = r5.debug;
            if (e4 < 0 || e4 > 24)
              return null;
            var n3 = 1 << e4, a5 = de(e4, t4 = (t4 % n3 + n3) % n3, i5);
            if (this.tiles[a5])
              return ae(this.tiles[a5], o5);
            s5 > 1 && console.log("drilling down to z%d-%d-%d", e4, t4, i5);
            for (var l5, c5 = e4, u5 = t4, h4 = i5; !l5 && c5 > 0; )
              c5--, u5 = Math.floor(u5 / 2), h4 = Math.floor(h4 / 2), l5 = this.tiles[de(c5, u5, h4)];
            return l5 && l5.source ? (s5 > 1 && console.log("found parent tile z%d-%d-%d", c5, u5, h4), s5 > 1 && console.time("drilling down"), this.splitTile(l5.source, c5, u5, h4, e4, t4, i5), s5 > 1 && console.timeEnd("drilling down"), this.tiles[a5] ? ae(this.tiles[a5], o5) : null) : null;
          };
          class ve extends n2 {
            constructor(t4, i5, r5, o5) {
              super(t4, i5, r5, ye), this._dataUpdateable = /* @__PURE__ */ new Map(), this.loadGeoJSON = (t5, i6) => {
                const { promoteId: r6 } = t5;
                if (t5.request)
                  return e3.getJSON(t5.request, (e4, t6, o6, s5) => {
                    this._dataUpdateable = ge(t6, r6) ? me(t6, r6) : void 0, i6(e4, t6, o6, s5);
                  });
                if ("string" == typeof t5.data)
                  try {
                    const e4 = JSON.parse(t5.data);
                    this._dataUpdateable = ge(e4, r6) ? me(e4, r6) : void 0, i6(null, e4);
                  } catch (e4) {
                    i6(new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`));
                  }
                else
                  t5.dataDiff ? this._dataUpdateable ? (function(e4, t6, i7) {
                    var r7, o6, s5, n3;
                    if (t6.removeAll && e4.clear(), t6.remove)
                      for (const i8 of t6.remove)
                        e4.delete(i8);
                    if (t6.add)
                      for (const r8 of t6.add) {
                        const t7 = fe(r8, i7);
                        null != t7 && e4.set(t7, r8);
                      }
                    if (t6.update)
                      for (const i8 of t6.update) {
                        let t7 = e4.get(i8.id);
                        if (null == t7)
                          continue;
                        const a5 = !i8.removeAllProperties && ((null === (r7 = i8.removeProperties) || void 0 === r7 ? void 0 : r7.length) > 0 || (null === (o6 = i8.addOrUpdateProperties) || void 0 === o6 ? void 0 : o6.length) > 0);
                        if ((i8.newGeometry || i8.removeAllProperties || a5) && (t7 = { ...t7 }, e4.set(i8.id, t7), a5 && (t7.properties = { ...t7.properties })), i8.newGeometry && (t7.geometry = i8.newGeometry), i8.removeAllProperties)
                          t7.properties = {};
                        else if ((null === (s5 = i8.removeProperties) || void 0 === s5 ? void 0 : s5.length) > 0)
                          for (const e5 of i8.removeProperties)
                            Object.prototype.hasOwnProperty.call(t7.properties, e5) && delete t7.properties[e5];
                        if ((null === (n3 = i8.addOrUpdateProperties) || void 0 === n3 ? void 0 : n3.length) > 0)
                          for (const { key: e5, value: r8 } of i8.addOrUpdateProperties)
                            t7.properties[e5] = r8;
                      }
                  }(this._dataUpdateable, t5.dataDiff, r6), i6(null, { type: "FeatureCollection", features: Array.from(this._dataUpdateable.values()) })) : i6(new Error(`Cannot update existing geojson data in ${t5.source}`)) : i6(new Error(`Input data given to '${t5.source}' is not a valid GeoJSON object.`));
                return { cancel: () => {
                } };
              }, o5 && (this.loadGeoJSON = o5);
            }
            loadData(t4, i5) {
              var r5;
              null === (r5 = this._pendingRequest) || void 0 === r5 || r5.cancel(), this._pendingCallback && this._pendingCallback(null, { abandoned: true });
              const o5 = !!(t4 && t4.request && t4.request.collectResourceTiming) && new e3.RequestPerformance(t4.request);
              this._pendingCallback = i5, this._pendingRequest = this.loadGeoJSON(t4, (r6, s5) => {
                if (delete this._pendingCallback, delete this._pendingRequest, r6 || !s5)
                  return i5(r6);
                if ("object" != typeof s5)
                  return i5(new Error(`Input data given to '${t4.source}' is not a valid GeoJSON object.`));
                {
                  u4(s5, true);
                  try {
                    if (t4.filter) {
                      const i6 = e3.createExpression(t4.filter, { type: "boolean", "property-type": "data-driven", overridable: false, transition: false });
                      if ("error" === i6.result)
                        throw new Error(i6.value.map((e4) => `${e4.key}: ${e4.message}`).join(", "));
                      const r7 = s5.features.filter((e4) => i6.value.evaluate({ zoom: 0 }, e4));
                      s5 = { type: "FeatureCollection", features: r7 };
                    }
                    this._geoJSONIndex = t4.cluster ? new z3(function({ superclusterOptions: t5, clusterProperties: i6 }) {
                      if (!i6 || !t5)
                        return t5;
                      const r7 = {}, o6 = {}, s6 = { accumulated: null, zoom: 0 }, n4 = { properties: null }, a5 = Object.keys(i6);
                      for (const t6 of a5) {
                        const [s7, n5] = i6[t6], a6 = e3.createExpression(n5), l5 = e3.createExpression("string" == typeof s7 ? [s7, ["accumulated"], ["get", t6]] : s7);
                        r7[t6] = a6.value, o6[t6] = l5.value;
                      }
                      return t5.map = (e4) => {
                        n4.properties = e4;
                        const t6 = {};
                        for (const e5 of a5)
                          t6[e5] = r7[e5].evaluate(s6, n4);
                        return t6;
                      }, t5.reduce = (e4, t6) => {
                        n4.properties = t6;
                        for (const t7 of a5)
                          s6.accumulated = e4[t7], e4[t7] = o6[t7].evaluate(s6, n4);
                      }, t5;
                    }(t4)).load(s5.features) : function(e4, t5) {
                      return new pe(e4, t5);
                    }(s5, t4.geojsonVtOptions);
                  } catch (r7) {
                    return i5(r7);
                  }
                  this.loaded = {};
                  const n3 = {};
                  if (o5) {
                    const e4 = o5.finish();
                    e4 && (n3.resourceTiming = {}, n3.resourceTiming[t4.source] = JSON.parse(JSON.stringify(e4)));
                  }
                  i5(null, n3);
                }
              });
            }
            reloadTile(e4, t4) {
              const i5 = this.loaded;
              return i5 && i5[e4.uid] ? super.reloadTile(e4, t4) : this.loadTile(e4, t4);
            }
            removeSource(e4, t4) {
              this._pendingCallback && this._pendingCallback(null, { abandoned: true }), t4();
            }
            getClusterExpansionZoom(e4, t4) {
              try {
                t4(null, this._geoJSONIndex.getClusterExpansionZoom(e4.clusterId));
              } catch (e5) {
                t4(e5);
              }
            }
            getClusterChildren(e4, t4) {
              try {
                t4(null, this._geoJSONIndex.getChildren(e4.clusterId));
              } catch (e5) {
                t4(e5);
              }
            }
            getClusterLeaves(e4, t4) {
              try {
                t4(null, this._geoJSONIndex.getLeaves(e4.clusterId, e4.limit, e4.offset));
              } catch (e5) {
                t4(e5);
              }
            }
          }
          class xe {
            constructor(t4) {
              this.self = t4, this.actor = new e3.Actor(t4, this), this.layerIndexes = {}, this.availableImages = {}, this.workerSourceTypes = { vector: n2, geojson: ve }, this.workerSources = {}, this.demWorkerSources = {}, this.self.registerWorkerSource = (e4, t5) => {
                if (this.workerSourceTypes[e4])
                  throw new Error(`Worker source with name "${e4}" already registered.`);
                this.workerSourceTypes[e4] = t5;
              }, this.self.registerRTLTextPlugin = (t5) => {
                if (e3.plugin.isParsed())
                  throw new Error("RTL text plugin already registered.");
                e3.plugin.applyArabicShaping = t5.applyArabicShaping, e3.plugin.processBidirectionalText = t5.processBidirectionalText, e3.plugin.processStyledBidirectionalText = t5.processStyledBidirectionalText;
              };
            }
            setReferrer(e4, t4) {
              this.referrer = t4;
            }
            setImages(e4, t4, i5) {
              this.availableImages[e4] = t4;
              for (const i6 in this.workerSources[e4]) {
                const r5 = this.workerSources[e4][i6];
                for (const e5 in r5)
                  r5[e5].availableImages = t4;
              }
              i5();
            }
            setLayers(e4, t4, i5) {
              this.getLayerIndex(e4).replace(t4), i5();
            }
            updateLayers(e4, t4, i5) {
              this.getLayerIndex(e4).update(t4.layers, t4.removedIds), i5();
            }
            loadTile(e4, t4, i5) {
              this.getWorkerSource(e4, t4.type, t4.source).loadTile(t4, i5);
            }
            loadDEMTile(e4, t4, i5) {
              this.getDEMWorkerSource(e4, t4.source).loadTile(t4, i5);
            }
            reloadTile(e4, t4, i5) {
              this.getWorkerSource(e4, t4.type, t4.source).reloadTile(t4, i5);
            }
            abortTile(e4, t4, i5) {
              this.getWorkerSource(e4, t4.type, t4.source).abortTile(t4, i5);
            }
            removeTile(e4, t4, i5) {
              this.getWorkerSource(e4, t4.type, t4.source).removeTile(t4, i5);
            }
            removeDEMTile(e4, t4) {
              this.getDEMWorkerSource(e4, t4.source).removeTile(t4);
            }
            removeSource(e4, t4, i5) {
              if (!this.workerSources[e4] || !this.workerSources[e4][t4.type] || !this.workerSources[e4][t4.type][t4.source])
                return;
              const r5 = this.workerSources[e4][t4.type][t4.source];
              delete this.workerSources[e4][t4.type][t4.source], void 0 !== r5.removeSource ? r5.removeSource(t4, i5) : i5();
            }
            loadWorkerSource(e4, t4, i5) {
              try {
                this.self.importScripts(t4.url), i5();
              } catch (e5) {
                i5(e5.toString());
              }
            }
            syncRTLPluginState(t4, i5, r5) {
              try {
                e3.plugin.setState(i5);
                const t5 = e3.plugin.getPluginURL();
                if (e3.plugin.isLoaded() && !e3.plugin.isParsed() && null != t5) {
                  this.self.importScripts(t5);
                  const i6 = e3.plugin.isParsed();
                  r5(i6 ? void 0 : new Error(`RTL Text Plugin failed to import scripts from ${t5}`), i6);
                }
              } catch (e4) {
                r5(e4.toString());
              }
            }
            getAvailableImages(e4) {
              let t4 = this.availableImages[e4];
              return t4 || (t4 = []), t4;
            }
            getLayerIndex(e4) {
              let i5 = this.layerIndexes[e4];
              return i5 || (i5 = this.layerIndexes[e4] = new t3()), i5;
            }
            getWorkerSource(e4, t4, i5) {
              if (this.workerSources[e4] || (this.workerSources[e4] = {}), this.workerSources[e4][t4] || (this.workerSources[e4][t4] = {}), !this.workerSources[e4][t4][i5]) {
                const r5 = { send: (t5, i6, r6) => {
                  this.actor.send(t5, i6, r6, e4);
                } };
                this.workerSources[e4][t4][i5] = new this.workerSourceTypes[t4](r5, this.getLayerIndex(e4), this.getAvailableImages(e4));
              }
              return this.workerSources[e4][t4][i5];
            }
            getDEMWorkerSource(e4, t4) {
              return this.demWorkerSources[e4] || (this.demWorkerSources[e4] = {}), this.demWorkerSources[e4][t4] || (this.demWorkerSources[e4][t4] = new a4()), this.demWorkerSources[e4][t4];
            }
          }
          return e3.isWorker() && (self.worker = new xe(self)), xe;
        });
        define2(["./shared"], function(t3) {
          "use strict";
          var e3 = "3.5.0";
          class i4 {
            static testProp(t4) {
              if (!i4.docStyle)
                return t4[0];
              for (let e4 = 0; e4 < t4.length; e4++)
                if (t4[e4] in i4.docStyle)
                  return t4[e4];
              return t4[0];
            }
            static create(t4, e4, i5) {
              const s5 = window.document.createElement(t4);
              return void 0 !== e4 && (s5.className = e4), i5 && i5.appendChild(s5), s5;
            }
            static createNS(t4, e4) {
              return window.document.createElementNS(t4, e4);
            }
            static disableDrag() {
              i4.docStyle && i4.selectProp && (i4.userSelect = i4.docStyle[i4.selectProp], i4.docStyle[i4.selectProp] = "none");
            }
            static enableDrag() {
              i4.docStyle && i4.selectProp && (i4.docStyle[i4.selectProp] = i4.userSelect);
            }
            static setTransform(t4, e4) {
              t4.style[i4.transformProp] = e4;
            }
            static addEventListener(t4, e4, i5, s5 = {}) {
              t4.addEventListener(e4, i5, "passive" in s5 ? s5 : s5.capture);
            }
            static removeEventListener(t4, e4, i5, s5 = {}) {
              t4.removeEventListener(e4, i5, "passive" in s5 ? s5 : s5.capture);
            }
            static suppressClickInternal(t4) {
              t4.preventDefault(), t4.stopPropagation(), window.removeEventListener("click", i4.suppressClickInternal, true);
            }
            static suppressClick() {
              window.addEventListener("click", i4.suppressClickInternal, true), window.setTimeout(() => {
                window.removeEventListener("click", i4.suppressClickInternal, true);
              }, 0);
            }
            static mousePos(e4, i5) {
              const s5 = e4.getBoundingClientRect();
              return new t3.Point(i5.clientX - s5.left - e4.clientLeft, i5.clientY - s5.top - e4.clientTop);
            }
            static touchPos(e4, i5) {
              const s5 = e4.getBoundingClientRect(), a5 = [];
              for (let o5 = 0; o5 < i5.length; o5++)
                a5.push(new t3.Point(i5[o5].clientX - s5.left - e4.clientLeft, i5[o5].clientY - s5.top - e4.clientTop));
              return a5;
            }
            static mouseButton(t4) {
              return t4.button;
            }
            static remove(t4) {
              t4.parentNode && t4.parentNode.removeChild(t4);
            }
          }
          i4.docStyle = "undefined" != typeof window && window.document && window.document.documentElement.style, i4.selectProp = i4.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]), i4.transformProp = i4.testProp(["transform", "WebkitTransform"]);
          const s4 = { supported: false, testSupport: function(t4) {
            !r4 && o4 && (n2 ? l4(t4) : a4 = t4);
          } };
          let a4, o4, r4 = false, n2 = false;
          function l4(t4) {
            const e4 = t4.createTexture();
            t4.bindTexture(t4.TEXTURE_2D, e4);
            try {
              if (t4.texImage2D(t4.TEXTURE_2D, 0, t4.RGBA, t4.RGBA, t4.UNSIGNED_BYTE, o4), t4.isContextLost())
                return;
              s4.supported = true;
            } catch (t5) {
            }
            t4.deleteTexture(e4), r4 = true;
          }
          var c4, h3;
          "undefined" != typeof document && (o4 = document.createElement("img"), o4.onload = function() {
            a4 && l4(a4), a4 = null, n2 = true;
          }, o4.onerror = function() {
            r4 = true, a4 = null;
          }, o4.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="), function(e4) {
            let i5, a5, o5, r5;
            e4.resetRequestQueue = () => {
              i5 = [], a5 = 0, o5 = 0, r5 = {};
            }, e4.addThrottleControl = (t4) => {
              const e5 = o5++;
              return r5[e5] = t4, e5;
            }, e4.removeThrottleControl = (t4) => {
              delete r5[t4], c5();
            }, e4.getImage = (t4, e5, o6 = true) => {
              s4.supported && (t4.headers || (t4.headers = {}), t4.headers.accept = "image/webp,*/*");
              const r6 = { requestParameters: t4, supportImageRefresh: o6, callback: e5, cancelled: false, completed: false, cancel: () => {
                r6.completed || r6.cancelled || (r6.cancelled = true, r6.innerRequest && (r6.innerRequest.cancel(), a5--), c5());
              } };
              return i5.push(r6), c5(), r6;
            };
            const n3 = (e5) => {
              const { requestParameters: i6, supportImageRefresh: s5, callback: a6 } = e5;
              return t3.extend(i6, { type: "image" }), (false !== s5 || t3.isWorker() || t3.getProtocolAction(i6.url) || i6.headers && !Object.keys(i6.headers).reduce((t4, e6) => t4 && "accept" === e6, true) ? t3.makeRequest : h4)(i6, (t4, i7, s6, o6) => {
                l5(e5, a6, t4, i7, s6, o6);
              });
            }, l5 = (e5, i6, s5, o6, r6, n4) => {
              s5 ? i6(s5) : o6 instanceof HTMLImageElement || t3.isImageBitmap(o6) ? i6(null, o6) : o6 && ((e6, i7) => {
                "function" == typeof createImageBitmap ? t3.arrayBufferToImageBitmap(e6, i7) : t3.arrayBufferToImage(e6, i7);
              })(o6, (t4, e6) => {
                null != t4 ? i6(t4) : null != e6 && i6(null, e6, { cacheControl: r6, expires: n4 });
              }), e5.cancelled || (e5.completed = true, a5--, c5());
            }, c5 = () => {
              const e5 = (() => {
                const t4 = Object.keys(r5);
                let e6 = false;
                if (t4.length > 0) {
                  for (const i6 of t4)
                    if (e6 = r5[i6](), e6)
                      break;
                }
                return e6;
              })() ? t3.config.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : t3.config.MAX_PARALLEL_IMAGE_REQUESTS;
              for (let t4 = a5; t4 < e5 && i5.length > 0; t4++) {
                const e6 = i5.shift();
                if (e6.cancelled) {
                  t4--;
                  continue;
                }
                const s5 = n3(e6);
                a5++, e6.innerRequest = s5;
              }
            }, h4 = (e5, i6) => {
              const s5 = new Image(), a6 = e5.url;
              let o6 = false;
              const r6 = e5.credentials;
              return r6 && "include" === r6 ? s5.crossOrigin = "use-credentials" : (r6 && "same-origin" === r6 || !t3.sameOrigin(a6)) && (s5.crossOrigin = "anonymous"), s5.fetchPriority = "high", s5.onload = () => {
                i6(null, s5), s5.onerror = s5.onload = null;
              }, s5.onerror = () => {
                o6 || i6(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.")), s5.onerror = s5.onload = null;
              }, s5.src = a6, { cancel: () => {
                o6 = true, s5.src = "";
              } };
            };
          }(c4 || (c4 = {})), c4.resetRequestQueue(), function(t4) {
            t4.Glyphs = "Glyphs", t4.Image = "Image", t4.Source = "Source", t4.SpriteImage = "SpriteImage", t4.SpriteJSON = "SpriteJSON", t4.Style = "Style", t4.Tile = "Tile", t4.Unknown = "Unknown";
          }(h3 || (h3 = {}));
          class u4 {
            constructor(t4) {
              this._transformRequestFn = t4;
            }
            transformRequest(t4, e4) {
              return this._transformRequestFn && this._transformRequestFn(t4, e4) || { url: t4 };
            }
            normalizeSpriteURL(t4, e4, i5) {
              const s5 = function(t5) {
                const e5 = t5.match(d3);
                if (!e5)
                  throw new Error(`Unable to parse URL "${t5}"`);
                return { protocol: e5[1], authority: e5[2], path: e5[3] || "/", params: e5[4] ? e5[4].split("&") : [] };
              }(t4);
              return s5.path += `${e4}${i5}`, function(t5) {
                const e5 = t5.params.length ? `?${t5.params.join("&")}` : "";
                return `${t5.protocol}://${t5.authority}${t5.path}${e5}`;
              }(s5);
            }
            setTransformRequest(t4) {
              this._transformRequestFn = t4;
            }
          }
          const d3 = /^(\w+):\/\/([^/?]*)(\/[^?]+)?\??(.+)?/;
          function _3(e4) {
            var i5 = new t3.ARRAY_TYPE(3);
            return i5[0] = e4[0], i5[1] = e4[1], i5[2] = e4[2], i5;
          }
          var m3, p6 = function(t4, e4, i5) {
            return t4[0] = e4[0] - i5[0], t4[1] = e4[1] - i5[1], t4[2] = e4[2] - i5[2], t4;
          };
          m3 = new t3.ARRAY_TYPE(3), t3.ARRAY_TYPE != Float32Array && (m3[0] = 0, m3[1] = 0, m3[2] = 0);
          var f3 = function(t4) {
            var e4 = t4[0], i5 = t4[1];
            return e4 * e4 + i5 * i5;
          };
          function g3(t4) {
            const e4 = [];
            if ("string" == typeof t4)
              e4.push({ id: "default", url: t4 });
            else if (t4 && t4.length > 0) {
              const i5 = [];
              for (const { id: s5, url: a5 } of t4) {
                const t5 = `${s5}${a5}`;
                -1 === i5.indexOf(t5) && (i5.push(t5), e4.push({ id: s5, url: a5 }));
              }
            }
            return e4;
          }
          function v3(e4, i5, s5, a5, o5) {
            if (a5)
              return void e4(a5);
            if (o5 !== Object.values(i5).length || o5 !== Object.values(s5).length)
              return;
            const r5 = {};
            for (const e5 in i5) {
              r5[e5] = {};
              const a6 = t3.browser.getImageCanvasContext(s5[e5]), o6 = i5[e5];
              for (const t4 in o6) {
                const { width: i6, height: s6, x: n3, y: l5, sdf: c5, pixelRatio: h4, stretchX: u5, stretchY: d4, content: _4 } = o6[t4];
                r5[e5][t4] = { data: null, pixelRatio: h4, sdf: c5, stretchX: u5, stretchY: d4, content: _4, spriteData: { width: i6, height: s6, x: n3, y: l5, context: a6 } };
              }
            }
            e4(null, r5);
          }
          !function() {
            var e4 = new t3.ARRAY_TYPE(2);
            t3.ARRAY_TYPE != Float32Array && (e4[0] = 0, e4[1] = 0);
          }();
          class x2 {
            constructor(t4, e4, i5, s5) {
              this.context = t4, this.format = i5, this.texture = t4.gl.createTexture(), this.update(e4, s5);
            }
            update(e4, i5, s5) {
              const { width: a5, height: o5 } = e4, r5 = !(this.size && this.size[0] === a5 && this.size[1] === o5 || s5), { context: n3 } = this, { gl: l5 } = n3;
              if (this.useMipmap = Boolean(i5 && i5.useMipmap), l5.bindTexture(l5.TEXTURE_2D, this.texture), n3.pixelStoreUnpackFlipY.set(false), n3.pixelStoreUnpack.set(1), n3.pixelStoreUnpackPremultiplyAlpha.set(this.format === l5.RGBA && (!i5 || false !== i5.premultiply)), r5)
                this.size = [a5, o5], e4 instanceof HTMLImageElement || e4 instanceof HTMLCanvasElement || e4 instanceof HTMLVideoElement || e4 instanceof ImageData || t3.isImageBitmap(e4) ? l5.texImage2D(l5.TEXTURE_2D, 0, this.format, this.format, l5.UNSIGNED_BYTE, e4) : l5.texImage2D(l5.TEXTURE_2D, 0, this.format, a5, o5, 0, this.format, l5.UNSIGNED_BYTE, e4.data);
              else {
                const { x: i6, y: r6 } = s5 || { x: 0, y: 0 };
                e4 instanceof HTMLImageElement || e4 instanceof HTMLCanvasElement || e4 instanceof HTMLVideoElement || e4 instanceof ImageData || t3.isImageBitmap(e4) ? l5.texSubImage2D(l5.TEXTURE_2D, 0, i6, r6, l5.RGBA, l5.UNSIGNED_BYTE, e4) : l5.texSubImage2D(l5.TEXTURE_2D, 0, i6, r6, a5, o5, l5.RGBA, l5.UNSIGNED_BYTE, e4.data);
              }
              this.useMipmap && this.isSizePowerOfTwo() && l5.generateMipmap(l5.TEXTURE_2D);
            }
            bind(t4, e4, i5) {
              const { context: s5 } = this, { gl: a5 } = s5;
              a5.bindTexture(a5.TEXTURE_2D, this.texture), i5 !== a5.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (i5 = a5.LINEAR), t4 !== this.filter && (a5.texParameteri(a5.TEXTURE_2D, a5.TEXTURE_MAG_FILTER, t4), a5.texParameteri(a5.TEXTURE_2D, a5.TEXTURE_MIN_FILTER, i5 || t4), this.filter = t4), e4 !== this.wrap && (a5.texParameteri(a5.TEXTURE_2D, a5.TEXTURE_WRAP_S, e4), a5.texParameteri(a5.TEXTURE_2D, a5.TEXTURE_WRAP_T, e4), this.wrap = e4);
            }
            isSizePowerOfTwo() {
              return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0;
            }
            destroy() {
              const { gl: t4 } = this.context;
              t4.deleteTexture(this.texture), this.texture = null;
            }
          }
          function y2(t4) {
            const { userImage: e4 } = t4;
            return !!(e4 && e4.render && e4.render()) && (t4.data.replace(new Uint8Array(e4.data.buffer)), true);
          }
          class b3 extends t3.Evented {
            constructor() {
              super(), this.images = {}, this.updatedImages = {}, this.callbackDispatchedThisFrame = {}, this.loaded = false, this.requestors = [], this.patterns = {}, this.atlasImage = new t3.RGBAImage({ width: 1, height: 1 }), this.dirty = true;
            }
            isLoaded() {
              return this.loaded;
            }
            setLoaded(t4) {
              if (this.loaded !== t4 && (this.loaded = t4, t4)) {
                for (const { ids: t5, callback: e4 } of this.requestors)
                  this._notify(t5, e4);
                this.requestors = [];
              }
            }
            getImage(e4) {
              const i5 = this.images[e4];
              if (i5 && !i5.data && i5.spriteData) {
                const e5 = i5.spriteData;
                i5.data = new t3.RGBAImage({ width: e5.width, height: e5.height }, e5.context.getImageData(e5.x, e5.y, e5.width, e5.height).data), i5.spriteData = null;
              }
              return i5;
            }
            addImage(t4, e4) {
              if (this.images[t4])
                throw new Error(`Image id ${t4} already exist, use updateImage instead`);
              this._validate(t4, e4) && (this.images[t4] = e4);
            }
            _validate(e4, i5) {
              let s5 = true;
              const a5 = i5.data || i5.spriteData;
              return this._validateStretch(i5.stretchX, a5 && a5.width) || (this.fire(new t3.ErrorEvent(new Error(`Image "${e4}" has invalid "stretchX" value`))), s5 = false), this._validateStretch(i5.stretchY, a5 && a5.height) || (this.fire(new t3.ErrorEvent(new Error(`Image "${e4}" has invalid "stretchY" value`))), s5 = false), this._validateContent(i5.content, i5) || (this.fire(new t3.ErrorEvent(new Error(`Image "${e4}" has invalid "content" value`))), s5 = false), s5;
            }
            _validateStretch(t4, e4) {
              if (!t4)
                return true;
              let i5 = 0;
              for (const s5 of t4) {
                if (s5[0] < i5 || s5[1] < s5[0] || e4 < s5[1])
                  return false;
                i5 = s5[1];
              }
              return true;
            }
            _validateContent(t4, e4) {
              if (!t4)
                return true;
              if (4 !== t4.length)
                return false;
              const i5 = e4.spriteData, s5 = i5 && i5.width || e4.data.width, a5 = i5 && i5.height || e4.data.height;
              return !(t4[0] < 0 || s5 < t4[0] || t4[1] < 0 || a5 < t4[1] || t4[2] < 0 || s5 < t4[2] || t4[3] < 0 || a5 < t4[3] || t4[2] < t4[0] || t4[3] < t4[1]);
            }
            updateImage(t4, e4, i5 = true) {
              const s5 = this.getImage(t4);
              if (i5 && (s5.data.width !== e4.data.width || s5.data.height !== e4.data.height))
                throw new Error(`size mismatch between old image (${s5.data.width}x${s5.data.height}) and new image (${e4.data.width}x${e4.data.height}).`);
              e4.version = s5.version + 1, this.images[t4] = e4, this.updatedImages[t4] = true;
            }
            removeImage(t4) {
              const e4 = this.images[t4];
              delete this.images[t4], delete this.patterns[t4], e4.userImage && e4.userImage.onRemove && e4.userImage.onRemove();
            }
            listImages() {
              return Object.keys(this.images);
            }
            getImages(t4, e4) {
              let i5 = true;
              if (!this.isLoaded())
                for (const e5 of t4)
                  this.images[e5] || (i5 = false);
              this.isLoaded() || i5 ? this._notify(t4, e4) : this.requestors.push({ ids: t4, callback: e4 });
            }
            _notify(e4, i5) {
              const s5 = {};
              for (const i6 of e4) {
                let e5 = this.getImage(i6);
                e5 || (this.fire(new t3.Event("styleimagemissing", { id: i6 })), e5 = this.getImage(i6)), e5 ? s5[i6] = { data: e5.data.clone(), pixelRatio: e5.pixelRatio, sdf: e5.sdf, version: e5.version, stretchX: e5.stretchX, stretchY: e5.stretchY, content: e5.content, hasRenderCallback: Boolean(e5.userImage && e5.userImage.render) } : t3.warnOnce(`Image "${i6}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`);
              }
              i5(null, s5);
            }
            getPixelSize() {
              const { width: t4, height: e4 } = this.atlasImage;
              return { width: t4, height: e4 };
            }
            getPattern(e4) {
              const i5 = this.patterns[e4], s5 = this.getImage(e4);
              if (!s5)
                return null;
              if (i5 && i5.position.version === s5.version)
                return i5.position;
              if (i5)
                i5.position.version = s5.version;
              else {
                const i6 = { w: s5.data.width + 2, h: s5.data.height + 2, x: 0, y: 0 }, a5 = new t3.ImagePosition(i6, s5);
                this.patterns[e4] = { bin: i6, position: a5 };
              }
              return this._updatePatternAtlas(), this.patterns[e4].position;
            }
            bind(t4) {
              const e4 = t4.gl;
              this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage), this.dirty = false) : this.atlasTexture = new x2(t4, this.atlasImage, e4.RGBA), this.atlasTexture.bind(e4.LINEAR, e4.CLAMP_TO_EDGE);
            }
            _updatePatternAtlas() {
              const e4 = [];
              for (const t4 in this.patterns)
                e4.push(this.patterns[t4].bin);
              const { w: i5, h: s5 } = t3.potpack(e4), a5 = this.atlasImage;
              a5.resize({ width: i5 || 1, height: s5 || 1 });
              for (const e5 in this.patterns) {
                const { bin: i6 } = this.patterns[e5], s6 = i6.x + 1, o5 = i6.y + 1, r5 = this.getImage(e5).data, n3 = r5.width, l5 = r5.height;
                t3.RGBAImage.copy(r5, a5, { x: 0, y: 0 }, { x: s6, y: o5 }, { width: n3, height: l5 }), t3.RGBAImage.copy(r5, a5, { x: 0, y: l5 - 1 }, { x: s6, y: o5 - 1 }, { width: n3, height: 1 }), t3.RGBAImage.copy(r5, a5, { x: 0, y: 0 }, { x: s6, y: o5 + l5 }, { width: n3, height: 1 }), t3.RGBAImage.copy(r5, a5, { x: n3 - 1, y: 0 }, { x: s6 - 1, y: o5 }, { width: 1, height: l5 }), t3.RGBAImage.copy(r5, a5, { x: 0, y: 0 }, { x: s6 + n3, y: o5 }, { width: 1, height: l5 });
              }
              this.dirty = true;
            }
            beginFrame() {
              this.callbackDispatchedThisFrame = {};
            }
            dispatchRenderCallbacks(e4) {
              for (const i5 of e4) {
                if (this.callbackDispatchedThisFrame[i5])
                  continue;
                this.callbackDispatchedThisFrame[i5] = true;
                const e5 = this.getImage(i5);
                e5 || t3.warnOnce(`Image with ID: "${i5}" was not found`), y2(e5) && this.updateImage(i5, e5);
              }
            }
          }
          const w3 = 1e20;
          function T2(t4, e4, i5, s5, a5, o5, r5, n3, l5) {
            for (let c5 = e4; c5 < e4 + s5; c5++)
              E2(t4, i5 * o5 + c5, o5, a5, r5, n3, l5);
            for (let c5 = i5; c5 < i5 + a5; c5++)
              E2(t4, c5 * o5 + e4, 1, s5, r5, n3, l5);
          }
          function E2(t4, e4, i5, s5, a5, o5, r5) {
            o5[0] = 0, r5[0] = -w3, r5[1] = w3, a5[0] = t4[e4];
            for (let n3 = 1, l5 = 0, c5 = 0; n3 < s5; n3++) {
              a5[n3] = t4[e4 + n3 * i5];
              const s6 = n3 * n3;
              do {
                const t5 = o5[l5];
                c5 = (a5[n3] - a5[t5] + s6 - t5 * t5) / (n3 - t5) / 2;
              } while (c5 <= r5[l5] && --l5 > -1);
              l5++, o5[l5] = n3, r5[l5] = c5, r5[l5 + 1] = w3;
            }
            for (let n3 = 0, l5 = 0; n3 < s5; n3++) {
              for (; r5[l5 + 1] < n3; )
                l5++;
              const s6 = o5[l5], c5 = n3 - s6;
              t4[e4 + n3 * i5] = a5[s6] + c5 * c5;
            }
          }
          class I2 {
            constructor(t4, e4) {
              this.requestManager = t4, this.localIdeographFontFamily = e4, this.entries = {};
            }
            setURL(t4) {
              this.url = t4;
            }
            getGlyphs(e4, i5) {
              const s5 = [];
              for (const t4 in e4)
                for (const i6 of e4[t4])
                  s5.push({ stack: t4, id: i6 });
              t3.asyncAll(s5, ({ stack: t4, id: e5 }, i6) => {
                let s6 = this.entries[t4];
                s6 || (s6 = this.entries[t4] = { glyphs: {}, requests: {}, ranges: {} });
                let a5 = s6.glyphs[e5];
                if (void 0 !== a5)
                  return void i6(null, { stack: t4, id: e5, glyph: a5 });
                if (a5 = this._tinySDF(s6, t4, e5), a5)
                  return s6.glyphs[e5] = a5, void i6(null, { stack: t4, id: e5, glyph: a5 });
                const o5 = Math.floor(e5 / 256);
                if (256 * o5 > 65535)
                  return void i6(new Error("glyphs > 65535 not supported"));
                if (s6.ranges[o5])
                  return void i6(null, { stack: t4, id: e5, glyph: a5 });
                if (!this.url)
                  return void i6(new Error("glyphsUrl is not set"));
                let r5 = s6.requests[o5];
                r5 || (r5 = s6.requests[o5] = [], I2.loadGlyphRange(t4, o5, this.url, this.requestManager, (t5, e6) => {
                  if (e6) {
                    for (const t6 in e6)
                      this._doesCharSupportLocalGlyph(+t6) || (s6.glyphs[+t6] = e6[+t6]);
                    s6.ranges[o5] = true;
                  }
                  for (const i7 of r5)
                    i7(t5, e6);
                  delete s6.requests[o5];
                })), r5.push((s7, a6) => {
                  s7 ? i6(s7) : a6 && i6(null, { stack: t4, id: e5, glyph: a6[e5] || null });
                });
              }, (t4, e5) => {
                if (t4)
                  i5(t4);
                else if (e5) {
                  const t5 = {};
                  for (const { stack: i6, id: s6, glyph: a5 } of e5)
                    (t5[i6] || (t5[i6] = {}))[s6] = a5 && { id: a5.id, bitmap: a5.bitmap.clone(), metrics: a5.metrics };
                  i5(null, t5);
                }
              });
            }
            _doesCharSupportLocalGlyph(e4) {
              return !!this.localIdeographFontFamily && (t3.unicodeBlockLookup["CJK Unified Ideographs"](e4) || t3.unicodeBlockLookup["Hangul Syllables"](e4) || t3.unicodeBlockLookup.Hiragana(e4) || t3.unicodeBlockLookup.Katakana(e4));
            }
            _tinySDF(e4, i5, s5) {
              const a5 = this.localIdeographFontFamily;
              if (!a5)
                return;
              if (!this._doesCharSupportLocalGlyph(s5))
                return;
              let o5 = e4.tinySDF;
              if (!o5) {
                let t4 = "400";
                /bold/i.test(i5) ? t4 = "900" : /medium/i.test(i5) ? t4 = "500" : /light/i.test(i5) && (t4 = "200"), o5 = e4.tinySDF = new I2.TinySDF({ fontSize: 48, buffer: 6, radius: 16, cutoff: 0.25, fontFamily: a5, fontWeight: t4 });
              }
              const r5 = o5.draw(String.fromCharCode(s5));
              return { id: s5, bitmap: new t3.AlphaImage({ width: r5.width || 60, height: r5.height || 60 }, r5.data), metrics: { width: r5.glyphWidth / 2 || 24, height: r5.glyphHeight / 2 || 24, left: r5.glyphLeft / 2 + 0.5 || 0, top: r5.glyphTop / 2 - 27.5 || -8, advance: r5.glyphAdvance / 2 || 24, isDoubleResolution: true } };
            }
          }
          I2.loadGlyphRange = function(e4, i5, s5, a5, o5) {
            const r5 = 256 * i5, n3 = r5 + 255, l5 = a5.transformRequest(s5.replace("{fontstack}", e4).replace("{range}", `${r5}-${n3}`), h3.Glyphs);
            t3.getArrayBuffer(l5, (e5, i6) => {
              if (e5)
                o5(e5);
              else if (i6) {
                const e6 = {};
                for (const s6 of t3.parseGlyphPbf(i6))
                  e6[s6.id] = s6;
                o5(null, e6);
              }
            });
          }, I2.TinySDF = class {
            constructor({ fontSize: t4 = 24, buffer: e4 = 3, radius: i5 = 8, cutoff: s5 = 0.25, fontFamily: a5 = "sans-serif", fontWeight: o5 = "normal", fontStyle: r5 = "normal" } = {}) {
              this.buffer = e4, this.cutoff = s5, this.radius = i5;
              const n3 = this.size = t4 + 4 * e4, l5 = this._createCanvas(n3), c5 = this.ctx = l5.getContext("2d", { willReadFrequently: true });
              c5.font = `${r5} ${o5} ${t4}px ${a5}`, c5.textBaseline = "alphabetic", c5.textAlign = "left", c5.fillStyle = "black", this.gridOuter = new Float64Array(n3 * n3), this.gridInner = new Float64Array(n3 * n3), this.f = new Float64Array(n3), this.z = new Float64Array(n3 + 1), this.v = new Uint16Array(n3);
            }
            _createCanvas(t4) {
              const e4 = document.createElement("canvas");
              return e4.width = e4.height = t4, e4;
            }
            draw(t4) {
              const { width: e4, actualBoundingBoxAscent: i5, actualBoundingBoxDescent: s5, actualBoundingBoxLeft: a5, actualBoundingBoxRight: o5 } = this.ctx.measureText(t4), r5 = Math.ceil(i5), n3 = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(o5 - a5))), l5 = Math.min(this.size - this.buffer, r5 + Math.ceil(s5)), c5 = n3 + 2 * this.buffer, h4 = l5 + 2 * this.buffer, u5 = Math.max(c5 * h4, 0), d4 = new Uint8ClampedArray(u5), _4 = { data: d4, width: c5, height: h4, glyphWidth: n3, glyphHeight: l5, glyphTop: r5, glyphLeft: 0, glyphAdvance: e4 };
              if (0 === n3 || 0 === l5)
                return _4;
              const { ctx: m4, buffer: p7, gridInner: f4, gridOuter: g4 } = this;
              m4.clearRect(p7, p7, n3, l5), m4.fillText(t4, p7, p7 + r5);
              const v5 = m4.getImageData(p7, p7, n3, l5);
              g4.fill(w3, 0, u5), f4.fill(0, 0, u5);
              for (let t5 = 0; t5 < l5; t5++)
                for (let e5 = 0; e5 < n3; e5++) {
                  const i6 = v5.data[4 * (t5 * n3 + e5) + 3] / 255;
                  if (0 === i6)
                    continue;
                  const s6 = (t5 + p7) * c5 + e5 + p7;
                  if (1 === i6)
                    g4[s6] = 0, f4[s6] = w3;
                  else {
                    const t6 = 0.5 - i6;
                    g4[s6] = t6 > 0 ? t6 * t6 : 0, f4[s6] = t6 < 0 ? t6 * t6 : 0;
                  }
                }
              T2(g4, 0, 0, c5, h4, c5, this.f, this.v, this.z), T2(f4, p7, p7, n3, l5, c5, this.f, this.v, this.z);
              for (let t5 = 0; t5 < u5; t5++) {
                const e5 = Math.sqrt(g4[t5]) - Math.sqrt(f4[t5]);
                d4[t5] = Math.round(255 - 255 * (e5 / this.radius + this.cutoff));
              }
              return _4;
            }
          };
          class S2 {
            constructor() {
              this.specification = t3.v8Spec.light.position;
            }
            possiblyEvaluate(e4, i5) {
              return t3.sphericalToCartesian(e4.expression.evaluate(i5));
            }
            interpolate(e4, i5, s5) {
              return { x: t3.interpolate.number(e4.x, i5.x, s5), y: t3.interpolate.number(e4.y, i5.y, s5), z: t3.interpolate.number(e4.z, i5.z, s5) };
            }
          }
          let C;
          class P2 extends t3.Evented {
            constructor(e4) {
              super(), C = C || new t3.Properties({ anchor: new t3.DataConstantProperty(t3.v8Spec.light.anchor), position: new S2(), color: new t3.DataConstantProperty(t3.v8Spec.light.color), intensity: new t3.DataConstantProperty(t3.v8Spec.light.intensity) }), this._transitionable = new t3.Transitionable(C), this.setLight(e4), this._transitioning = this._transitionable.untransitioned();
            }
            getLight() {
              return this._transitionable.serialize();
            }
            setLight(e4, i5 = {}) {
              if (!this._validate(t3.validateLight, e4, i5))
                for (const t4 in e4) {
                  const i6 = e4[t4];
                  t4.endsWith("-transition") ? this._transitionable.setTransition(t4.slice(0, -11), i6) : this._transitionable.setValue(t4, i6);
                }
            }
            updateTransitions(t4) {
              this._transitioning = this._transitionable.transitioned(t4, this._transitioning);
            }
            hasTransition() {
              return this._transitioning.hasTransition();
            }
            recalculate(t4) {
              this.properties = this._transitioning.possiblyEvaluate(t4);
            }
            _validate(e4, i5, s5) {
              return (!s5 || false !== s5.validate) && t3.emitValidationErrors(this, e4.call(t3.validateStyle, t3.extend({ value: i5, style: { glyphs: true, sprite: true }, styleSpec: t3.v8Spec })));
            }
          }
          class D2 {
            constructor(t4, e4) {
              this.width = t4, this.height = e4, this.nextRow = 0, this.data = new Uint8Array(this.width * this.height), this.dashEntry = {};
            }
            getDash(t4, e4) {
              const i5 = t4.join(",") + String(e4);
              return this.dashEntry[i5] || (this.dashEntry[i5] = this.addDash(t4, e4)), this.dashEntry[i5];
            }
            getDashRanges(t4, e4, i5) {
              const s5 = [];
              let a5 = t4.length % 2 == 1 ? -t4[t4.length - 1] * i5 : 0, o5 = t4[0] * i5, r5 = true;
              s5.push({ left: a5, right: o5, isDash: r5, zeroLength: 0 === t4[0] });
              let n3 = t4[0];
              for (let e5 = 1; e5 < t4.length; e5++) {
                r5 = !r5;
                const l5 = t4[e5];
                a5 = n3 * i5, n3 += l5, o5 = n3 * i5, s5.push({ left: a5, right: o5, isDash: r5, zeroLength: 0 === l5 });
              }
              return s5;
            }
            addRoundDash(t4, e4, i5) {
              const s5 = e4 / 2;
              for (let e5 = -i5; e5 <= i5; e5++) {
                const a5 = this.width * (this.nextRow + i5 + e5);
                let o5 = 0, r5 = t4[o5];
                for (let n3 = 0; n3 < this.width; n3++) {
                  n3 / r5.right > 1 && (r5 = t4[++o5]);
                  const l5 = Math.abs(n3 - r5.left), c5 = Math.abs(n3 - r5.right), h4 = Math.min(l5, c5);
                  let u5;
                  const d4 = e5 / i5 * (s5 + 1);
                  if (r5.isDash) {
                    const t5 = s5 - Math.abs(d4);
                    u5 = Math.sqrt(h4 * h4 + t5 * t5);
                  } else
                    u5 = s5 - Math.sqrt(h4 * h4 + d4 * d4);
                  this.data[a5 + n3] = Math.max(0, Math.min(255, u5 + 128));
                }
              }
            }
            addRegularDash(t4) {
              for (let e5 = t4.length - 1; e5 >= 0; --e5) {
                const i6 = t4[e5], s6 = t4[e5 + 1];
                i6.zeroLength ? t4.splice(e5, 1) : s6 && s6.isDash === i6.isDash && (s6.left = i6.left, t4.splice(e5, 1));
              }
              const e4 = t4[0], i5 = t4[t4.length - 1];
              e4.isDash === i5.isDash && (e4.left = i5.left - this.width, i5.right = e4.right + this.width);
              const s5 = this.width * this.nextRow;
              let a5 = 0, o5 = t4[a5];
              for (let e5 = 0; e5 < this.width; e5++) {
                e5 / o5.right > 1 && (o5 = t4[++a5]);
                const i6 = Math.abs(e5 - o5.left), r5 = Math.abs(e5 - o5.right), n3 = Math.min(i6, r5);
                this.data[s5 + e5] = Math.max(0, Math.min(255, (o5.isDash ? n3 : -n3) + 128));
              }
            }
            addDash(e4, i5) {
              const s5 = i5 ? 7 : 0, a5 = 2 * s5 + 1;
              if (this.nextRow + a5 > this.height)
                return t3.warnOnce("LineAtlas out of space"), null;
              let o5 = 0;
              for (let t4 = 0; t4 < e4.length; t4++)
                o5 += e4[t4];
              if (0 !== o5) {
                const t4 = this.width / o5, a6 = this.getDashRanges(e4, this.width, t4);
                i5 ? this.addRoundDash(a6, t4, s5) : this.addRegularDash(a6);
              }
              const r5 = { y: (this.nextRow + s5 + 0.5) / this.height, height: 2 * s5 / this.height, width: o5 };
              return this.nextRow += a5, this.dirty = true, r5;
            }
            bind(t4) {
              const e4 = t4.gl;
              this.texture ? (e4.bindTexture(e4.TEXTURE_2D, this.texture), this.dirty && (this.dirty = false, e4.texSubImage2D(e4.TEXTURE_2D, 0, 0, 0, this.width, this.height, e4.ALPHA, e4.UNSIGNED_BYTE, this.data))) : (this.texture = e4.createTexture(), e4.bindTexture(e4.TEXTURE_2D, this.texture), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_S, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_WRAP_T, e4.REPEAT), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MIN_FILTER, e4.LINEAR), e4.texParameteri(e4.TEXTURE_2D, e4.TEXTURE_MAG_FILTER, e4.LINEAR), e4.texImage2D(e4.TEXTURE_2D, 0, e4.ALPHA, this.width, this.height, 0, e4.ALPHA, e4.UNSIGNED_BYTE, this.data));
            }
          }
          class M2 {
            constructor(t4, e4, i5) {
              this.workerPool = t4, this.actors = [], this.currentActor = 0, this.id = i5;
              const s5 = this.workerPool.acquire(i5);
              for (let t5 = 0; t5 < s5.length; t5++) {
                const a5 = new M2.Actor(s5[t5], e4, i5);
                a5.name = `Worker ${t5}`, this.actors.push(a5);
              }
              if (!this.actors.length)
                throw new Error("No actors found");
            }
            broadcast(e4, i5, s5) {
              t3.asyncAll(this.actors, (t4, s6) => {
                t4.send(e4, i5, s6);
              }, s5 = s5 || function() {
              });
            }
            getActor() {
              return this.currentActor = (this.currentActor + 1) % this.actors.length, this.actors[this.currentActor];
            }
            remove(t4 = true) {
              this.actors.forEach((t5) => {
                t5.remove();
              }), this.actors = [], t4 && this.workerPool.release(this.id);
            }
          }
          function z3(e4, i5, s5) {
            const a5 = function(i6, a6) {
              if (i6)
                return s5(i6);
              if (a6) {
                const i7 = t3.pick(t3.extend(a6, e4), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                a6.vector_layers && (i7.vectorLayers = a6.vector_layers, i7.vectorLayerIds = i7.vectorLayers.map((t4) => t4.id)), s5(null, i7);
              }
            };
            return e4.url ? t3.getJSON(i5.transformRequest(e4.url, h3.Source), a5) : t3.browser.frame(() => a5(null, e4));
          }
          M2.Actor = t3.Actor;
          class A2 {
            constructor(t4, e4) {
              t4 && (e4 ? this.setSouthWest(t4).setNorthEast(e4) : Array.isArray(t4) && (4 === t4.length ? this.setSouthWest([t4[0], t4[1]]).setNorthEast([t4[2], t4[3]]) : this.setSouthWest(t4[0]).setNorthEast(t4[1])));
            }
            setNorthEast(e4) {
              return this._ne = e4 instanceof t3.LngLat ? new t3.LngLat(e4.lng, e4.lat) : t3.LngLat.convert(e4), this;
            }
            setSouthWest(e4) {
              return this._sw = e4 instanceof t3.LngLat ? new t3.LngLat(e4.lng, e4.lat) : t3.LngLat.convert(e4), this;
            }
            extend(e4) {
              const i5 = this._sw, s5 = this._ne;
              let a5, o5;
              if (e4 instanceof t3.LngLat)
                a5 = e4, o5 = e4;
              else {
                if (!(e4 instanceof A2))
                  return Array.isArray(e4) ? 4 === e4.length || e4.every(Array.isArray) ? this.extend(A2.convert(e4)) : this.extend(t3.LngLat.convert(e4)) : e4 && ("lng" in e4 || "lon" in e4) && "lat" in e4 ? this.extend(t3.LngLat.convert(e4)) : this;
                if (a5 = e4._sw, o5 = e4._ne, !a5 || !o5)
                  return this;
              }
              return i5 || s5 ? (i5.lng = Math.min(a5.lng, i5.lng), i5.lat = Math.min(a5.lat, i5.lat), s5.lng = Math.max(o5.lng, s5.lng), s5.lat = Math.max(o5.lat, s5.lat)) : (this._sw = new t3.LngLat(a5.lng, a5.lat), this._ne = new t3.LngLat(o5.lng, o5.lat)), this;
            }
            getCenter() {
              return new t3.LngLat((this._sw.lng + this._ne.lng) / 2, (this._sw.lat + this._ne.lat) / 2);
            }
            getSouthWest() {
              return this._sw;
            }
            getNorthEast() {
              return this._ne;
            }
            getNorthWest() {
              return new t3.LngLat(this.getWest(), this.getNorth());
            }
            getSouthEast() {
              return new t3.LngLat(this.getEast(), this.getSouth());
            }
            getWest() {
              return this._sw.lng;
            }
            getSouth() {
              return this._sw.lat;
            }
            getEast() {
              return this._ne.lng;
            }
            getNorth() {
              return this._ne.lat;
            }
            toArray() {
              return [this._sw.toArray(), this._ne.toArray()];
            }
            toString() {
              return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`;
            }
            isEmpty() {
              return !(this._sw && this._ne);
            }
            contains(e4) {
              const { lng: i5, lat: s5 } = t3.LngLat.convert(e4);
              let a5 = this._sw.lng <= i5 && i5 <= this._ne.lng;
              return this._sw.lng > this._ne.lng && (a5 = this._sw.lng >= i5 && i5 >= this._ne.lng), this._sw.lat <= s5 && s5 <= this._ne.lat && a5;
            }
            static convert(t4) {
              return t4 instanceof A2 ? t4 : t4 ? new A2(t4) : t4;
            }
            static fromLngLat(e4, i5 = 0) {
              const s5 = 360 * i5 / 40075017, a5 = s5 / Math.cos(Math.PI / 180 * e4.lat);
              return new A2(new t3.LngLat(e4.lng - a5, e4.lat - s5), new t3.LngLat(e4.lng + a5, e4.lat + s5));
            }
          }
          class L2 {
            constructor(t4, e4, i5) {
              this.bounds = A2.convert(this.validateBounds(t4)), this.minzoom = e4 || 0, this.maxzoom = i5 || 24;
            }
            validateBounds(t4) {
              return Array.isArray(t4) && 4 === t4.length ? [Math.max(-180, t4[0]), Math.max(-90, t4[1]), Math.min(180, t4[2]), Math.min(90, t4[3])] : [-180, -90, 180, 90];
            }
            contains(e4) {
              const i5 = Math.pow(2, e4.z), s5 = Math.floor(t3.mercatorXfromLng(this.bounds.getWest()) * i5), a5 = Math.floor(t3.mercatorYfromLat(this.bounds.getNorth()) * i5), o5 = Math.ceil(t3.mercatorXfromLng(this.bounds.getEast()) * i5), r5 = Math.ceil(t3.mercatorYfromLat(this.bounds.getSouth()) * i5);
              return e4.x >= s5 && e4.x < o5 && e4.y >= a5 && e4.y < r5;
            }
          }
          class R extends t3.Evented {
            constructor(e4, i5, s5, a5) {
              if (super(), this.load = () => {
                this._loaded = false, this.fire(new t3.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = z3(this._options, this.map._requestManager, (e5, i6) => {
                  this._tileJSONRequest = null, this._loaded = true, this.map.style.sourceCaches[this.id].clearTiles(), e5 ? this.fire(new t3.ErrorEvent(e5)) : i6 && (t3.extend(this, i6), i6.bounds && (this.tileBounds = new L2(i6.bounds, this.minzoom, this.maxzoom)), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "content" })));
                });
              }, this.serialize = () => t3.extend({}, this._options), this.id = e4, this.dispatcher = s5, this.type = "vector", this.minzoom = 0, this.maxzoom = 22, this.scheme = "xyz", this.tileSize = 512, this.reparseOverscaled = true, this.isTileClipped = true, this._loaded = false, t3.extend(this, t3.pick(i5, ["url", "scheme", "tileSize", "promoteId"])), this._options = t3.extend({ type: "vector" }, i5), this._collectResourceTiming = i5.collectResourceTiming, 512 !== this.tileSize)
                throw new Error("vector tile sources must have a tileSize of 512");
              this.setEventedParent(a5);
            }
            loaded() {
              return this._loaded;
            }
            hasTile(t4) {
              return !this.tileBounds || this.tileBounds.contains(t4.canonical);
            }
            onAdd(t4) {
              this.map = t4, this.load();
            }
            setSourceProperty(t4) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t4(), this.load();
            }
            setTiles(t4) {
              return this.setSourceProperty(() => {
                this._options.tiles = t4;
              }), this;
            }
            setUrl(t4) {
              return this.setSourceProperty(() => {
                this.url = t4, this._options.url = t4;
              }), this;
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            loadTile(t4, e4) {
              const i5 = t4.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), s5 = { request: this.map._requestManager.transformRequest(i5, h3.Tile), uid: t4.uid, tileID: t4.tileID, zoom: t4.tileID.overscaledZ, tileSize: this.tileSize * t4.tileID.overscaleFactor(), type: this.type, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              function a5(i6, s6) {
                return delete t4.request, t4.aborted ? e4(null) : i6 && 404 !== i6.status ? e4(i6) : (s6 && s6.resourceTiming && (t4.resourceTiming = s6.resourceTiming), this.map._refreshExpiredTiles && s6 && t4.setExpiryData(s6), t4.loadVectorData(s6, this.map.painter), e4(null), void (t4.reloadCallback && (this.loadTile(t4, t4.reloadCallback), t4.reloadCallback = null)));
              }
              s5.request.collectResourceTiming = this._collectResourceTiming, t4.actor && "expired" !== t4.state ? "loading" === t4.state ? t4.reloadCallback = e4 : t4.request = t4.actor.send("reloadTile", s5, a5.bind(this)) : (t4.actor = this.dispatcher.getActor(), t4.request = t4.actor.send("loadTile", s5, a5.bind(this)));
            }
            abortTile(t4) {
              t4.request && (t4.request.cancel(), delete t4.request), t4.actor && t4.actor.send("abortTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
            }
            unloadTile(t4) {
              t4.unloadVectorData(), t4.actor && t4.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id }, void 0);
            }
            hasTransition() {
              return false;
            }
          }
          class k3 extends t3.Evented {
            constructor(e4, i5, s5, a5) {
              super(), this.id = e4, this.dispatcher = s5, this.setEventedParent(a5), this.type = "raster", this.minzoom = 0, this.maxzoom = 22, this.roundZoom = true, this.scheme = "xyz", this.tileSize = 512, this._loaded = false, this._options = t3.extend({ type: "raster" }, i5), t3.extend(this, t3.pick(i5, ["url", "scheme", "tileSize"]));
            }
            load() {
              this._loaded = false, this.fire(new t3.Event("dataloading", { dataType: "source" })), this._tileJSONRequest = z3(this._options, this.map._requestManager, (e4, i5) => {
                this._tileJSONRequest = null, this._loaded = true, e4 ? this.fire(new t3.ErrorEvent(e4)) : i5 && (t3.extend(this, i5), i5.bounds && (this.tileBounds = new L2(i5.bounds, this.minzoom, this.maxzoom)), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "metadata" })), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "content" })));
              });
            }
            loaded() {
              return this._loaded;
            }
            onAdd(t4) {
              this.map = t4, this.load();
            }
            onRemove() {
              this._tileJSONRequest && (this._tileJSONRequest.cancel(), this._tileJSONRequest = null);
            }
            setSourceProperty(t4) {
              this._tileJSONRequest && this._tileJSONRequest.cancel(), t4(), this.load();
            }
            setTiles(t4) {
              return this.setSourceProperty(() => {
                this._options.tiles = t4;
              }), this;
            }
            serialize() {
              return t3.extend({}, this._options);
            }
            hasTile(t4) {
              return !this.tileBounds || this.tileBounds.contains(t4.canonical);
            }
            loadTile(t4, e4) {
              const i5 = t4.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
              t4.request = c4.getImage(this.map._requestManager.transformRequest(i5, h3.Tile), (i6, s5, a5) => {
                if (delete t4.request, t4.aborted)
                  t4.state = "unloaded", e4(null);
                else if (i6)
                  t4.state = "errored", e4(i6);
                else if (s5) {
                  this.map._refreshExpiredTiles && a5 && t4.setExpiryData(a5);
                  const i7 = this.map.painter.context, o5 = i7.gl;
                  t4.texture = this.map.painter.getTileTexture(s5.width), t4.texture ? t4.texture.update(s5, { useMipmap: true }) : (t4.texture = new x2(i7, s5, o5.RGBA, { useMipmap: true }), t4.texture.bind(o5.LINEAR, o5.CLAMP_TO_EDGE, o5.LINEAR_MIPMAP_NEAREST), i7.extTextureFilterAnisotropic && o5.texParameterf(o5.TEXTURE_2D, i7.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, i7.extTextureFilterAnisotropicMax)), t4.state = "loaded", e4(null);
                }
              }, this.map._refreshExpiredTiles);
            }
            abortTile(t4, e4) {
              t4.request && (t4.request.cancel(), delete t4.request), e4();
            }
            unloadTile(t4, e4) {
              t4.texture && this.map.painter.saveTileTexture(t4.texture), e4();
            }
            hasTransition() {
              return false;
            }
          }
          class F3 extends k3 {
            constructor(e4, i5, s5, a5) {
              super(e4, i5, s5, a5), this.type = "raster-dem", this.maxzoom = 22, this._options = t3.extend({ type: "raster-dem" }, i5), this.encoding = i5.encoding || "mapbox", this.redFactor = i5.redFactor, this.greenFactor = i5.greenFactor, this.blueFactor = i5.blueFactor, this.baseShift = i5.baseShift;
            }
            loadTile(e4, i5) {
              const s5 = e4.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme), a5 = this.map._requestManager.transformRequest(s5, h3.Tile);
              function o5(t4, s6) {
                t4 && (e4.state = "errored", i5(t4)), s6 && (e4.dem = s6, e4.needsHillshadePrepare = true, e4.needsTerrainPrepare = true, e4.state = "loaded", i5(null));
              }
              e4.neighboringTiles = this._getNeighboringTiles(e4.tileID), e4.request = c4.getImage(a5, async (s6, a6, r5) => {
                if (delete e4.request, e4.aborted)
                  e4.state = "unloaded", i5(null);
                else if (s6)
                  e4.state = "errored", i5(s6);
                else if (a6) {
                  this.map._refreshExpiredTiles && e4.setExpiryData(r5);
                  const i6 = t3.isImageBitmap(a6) && t3.offscreenCanvasSupported() ? a6 : await async function(e5) {
                    if ("undefined" != typeof VideoFrame && t3.isOffscreenCanvasDistorted()) {
                      const i7 = e5.width + 2, s8 = e5.height + 2;
                      try {
                        return new t3.RGBAImage({ width: i7, height: s8 }, await t3.readImageUsingVideoFrame(e5, -1, -1, i7, s8));
                      } catch (t4) {
                      }
                    }
                    return t3.browser.getImageData(e5, 1);
                  }(a6), s7 = { uid: e4.uid, coord: e4.tileID, source: this.id, rawImageData: i6, encoding: this.encoding, redFactor: this.redFactor, greenFactor: this.greenFactor, blueFactor: this.blueFactor, baseShift: this.baseShift };
                  e4.actor && "expired" !== e4.state || (e4.actor = this.dispatcher.getActor(), e4.actor.send("loadDEMTile", s7, o5));
                }
              }, this.map._refreshExpiredTiles);
            }
            _getNeighboringTiles(e4) {
              const i5 = e4.canonical, s5 = Math.pow(2, i5.z), a5 = (i5.x - 1 + s5) % s5, o5 = 0 === i5.x ? e4.wrap - 1 : e4.wrap, r5 = (i5.x + 1 + s5) % s5, n3 = i5.x + 1 === s5 ? e4.wrap + 1 : e4.wrap, l5 = {};
              return l5[new t3.OverscaledTileID(e4.overscaledZ, o5, i5.z, a5, i5.y).key] = { backfilled: false }, l5[new t3.OverscaledTileID(e4.overscaledZ, n3, i5.z, r5, i5.y).key] = { backfilled: false }, i5.y > 0 && (l5[new t3.OverscaledTileID(e4.overscaledZ, o5, i5.z, a5, i5.y - 1).key] = { backfilled: false }, l5[new t3.OverscaledTileID(e4.overscaledZ, e4.wrap, i5.z, i5.x, i5.y - 1).key] = { backfilled: false }, l5[new t3.OverscaledTileID(e4.overscaledZ, n3, i5.z, r5, i5.y - 1).key] = { backfilled: false }), i5.y + 1 < s5 && (l5[new t3.OverscaledTileID(e4.overscaledZ, o5, i5.z, a5, i5.y + 1).key] = { backfilled: false }, l5[new t3.OverscaledTileID(e4.overscaledZ, e4.wrap, i5.z, i5.x, i5.y + 1).key] = { backfilled: false }, l5[new t3.OverscaledTileID(e4.overscaledZ, n3, i5.z, r5, i5.y + 1).key] = { backfilled: false }), l5;
            }
            unloadTile(t4) {
              t4.demTexture && this.map.painter.saveTileTexture(t4.demTexture), t4.fbo && (t4.fbo.destroy(), delete t4.fbo), t4.dem && delete t4.dem, delete t4.neighboringTiles, t4.state = "unloaded", t4.actor && t4.actor.send("removeDEMTile", { uid: t4.uid, source: this.id });
            }
          }
          class B3 extends t3.Evented {
            constructor(e4, i5, s5, a5) {
              super(), this.load = () => {
                this._updateWorkerData();
              }, this.serialize = () => t3.extend({}, this._options, { type: this.type, data: this._data }), this.id = e4, this.type = "geojson", this.minzoom = 0, this.maxzoom = 18, this.tileSize = 512, this.isTileClipped = true, this.reparseOverscaled = true, this._removed = false, this._pendingLoads = 0, this.actor = s5.getActor(), this.setEventedParent(a5), this._data = i5.data, this._options = t3.extend({}, i5), this._collectResourceTiming = i5.collectResourceTiming, void 0 !== i5.maxzoom && (this.maxzoom = i5.maxzoom), i5.type && (this.type = i5.type), i5.attribution && (this.attribution = i5.attribution), this.promoteId = i5.promoteId;
              const o5 = t3.EXTENT / this.tileSize;
              this.workerOptions = t3.extend({ source: this.id, cluster: i5.cluster || false, geojsonVtOptions: { buffer: (void 0 !== i5.buffer ? i5.buffer : 128) * o5, tolerance: (void 0 !== i5.tolerance ? i5.tolerance : 0.375) * o5, extent: t3.EXTENT, maxZoom: this.maxzoom, lineMetrics: i5.lineMetrics || false, generateId: i5.generateId || false }, superclusterOptions: { maxZoom: void 0 !== i5.clusterMaxZoom ? i5.clusterMaxZoom : this.maxzoom - 1, minPoints: Math.max(2, i5.clusterMinPoints || 2), extent: t3.EXTENT, radius: (i5.clusterRadius || 50) * o5, log: false, generateId: i5.generateId || false }, clusterProperties: i5.clusterProperties, filter: i5.filter }, i5.workerOptions), "string" == typeof this.promoteId && (this.workerOptions.promoteId = this.promoteId);
            }
            onAdd(t4) {
              this.map = t4, this.load();
            }
            setData(t4) {
              return this._data = t4, this._updateWorkerData(), this;
            }
            updateData(t4) {
              return this._updateWorkerData(t4), this;
            }
            setClusterOptions(t4) {
              return this.workerOptions.cluster = t4.cluster, t4 && (void 0 !== t4.clusterRadius && (this.workerOptions.superclusterOptions.radius = t4.clusterRadius), void 0 !== t4.clusterMaxZoom && (this.workerOptions.superclusterOptions.maxZoom = t4.clusterMaxZoom)), this._updateWorkerData(), this;
            }
            getClusterExpansionZoom(t4, e4) {
              return this.actor.send("geojson.getClusterExpansionZoom", { clusterId: t4, source: this.id }, e4), this;
            }
            getClusterChildren(t4, e4) {
              return this.actor.send("geojson.getClusterChildren", { clusterId: t4, source: this.id }, e4), this;
            }
            getClusterLeaves(t4, e4, i5, s5) {
              return this.actor.send("geojson.getClusterLeaves", { source: this.id, clusterId: t4, limit: e4, offset: i5 }, s5), this;
            }
            _updateWorkerData(e4) {
              const i5 = t3.extend({}, this.workerOptions);
              e4 ? i5.dataDiff = e4 : "string" == typeof this._data ? (i5.request = this.map._requestManager.transformRequest(t3.browser.resolveURL(this._data), h3.Source), i5.request.collectResourceTiming = this._collectResourceTiming) : i5.data = JSON.stringify(this._data), this._pendingLoads++, this.fire(new t3.Event("dataloading", { dataType: "source" })), this.actor.send(`${this.type}.loadData`, i5, (e5, i6) => {
                if (this._pendingLoads--, this._removed || i6 && i6.abandoned)
                  return void this.fire(new t3.Event("dataabort", { dataType: "source" }));
                let s5 = null;
                if (i6 && i6.resourceTiming && i6.resourceTiming[this.id] && (s5 = i6.resourceTiming[this.id].slice(0)), e5)
                  return void this.fire(new t3.ErrorEvent(e5));
                const a5 = { dataType: "source" };
                this._collectResourceTiming && s5 && s5.length > 0 && t3.extend(a5, { resourceTiming: s5 }), this.fire(new t3.Event("data", { ...a5, sourceDataType: "metadata" })), this.fire(new t3.Event("data", { ...a5, sourceDataType: "content" }));
              });
            }
            loaded() {
              return 0 === this._pendingLoads;
            }
            loadTile(t4, e4) {
              const i5 = t4.actor ? "reloadTile" : "loadTile";
              t4.actor = this.actor;
              const s5 = { type: this.type, uid: t4.uid, tileID: t4.tileID, zoom: t4.tileID.overscaledZ, maxZoom: this.maxzoom, tileSize: this.tileSize, source: this.id, pixelRatio: this.map.getPixelRatio(), showCollisionBoxes: this.map.showCollisionBoxes, promoteId: this.promoteId };
              t4.request = this.actor.send(i5, s5, (s6, a5) => (delete t4.request, t4.unloadVectorData(), t4.aborted ? e4(null) : s6 ? e4(s6) : (t4.loadVectorData(a5, this.map.painter, "reloadTile" === i5), e4(null))));
            }
            abortTile(t4) {
              t4.request && (t4.request.cancel(), delete t4.request), t4.aborted = true;
            }
            unloadTile(t4) {
              t4.unloadVectorData(), this.actor.send("removeTile", { uid: t4.uid, type: this.type, source: this.id });
            }
            onRemove() {
              this._removed = true, this.actor.send("removeSource", { type: this.type, source: this.id });
            }
            hasTransition() {
              return false;
            }
          }
          var U = t3.createLayout([{ name: "a_pos", type: "Int16", components: 2 }, { name: "a_texture_pos", type: "Int16", components: 2 }]);
          class O2 extends t3.Evented {
            constructor(e4, i5, s5, a5) {
              super(), this.load = (e5, i6) => {
                this._loaded = false, this.fire(new t3.Event("dataloading", { dataType: "source" })), this.url = this.options.url, this._request = c4.getImage(this.map._requestManager.transformRequest(this.url, h3.Image), (s6, a6) => {
                  this._request = null, this._loaded = true, s6 ? this.fire(new t3.ErrorEvent(s6)) : a6 && (this.image = a6, e5 && (this.coordinates = e5), i6 && i6(), this._finishLoading());
                });
              }, this.prepare = () => {
                if (0 === Object.keys(this.tiles).length || !this.image)
                  return;
                const e5 = this.map.painter.context, i6 = e5.gl;
                this.boundsBuffer || (this.boundsBuffer = e5.createVertexBuffer(this._boundsArray, U.members)), this.boundsSegments || (this.boundsSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture || (this.texture = new x2(e5, this.image, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
                let s6 = false;
                for (const t4 in this.tiles) {
                  const e6 = this.tiles[t4];
                  "loaded" !== e6.state && (e6.state = "loaded", e6.texture = this.texture, s6 = true);
                }
                s6 && this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "image", url: this.options.url, coordinates: this.coordinates }), this.id = e4, this.dispatcher = s5, this.coordinates = i5.coordinates, this.type = "image", this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.tiles = {}, this._loaded = false, this.setEventedParent(a5), this.options = i5;
            }
            loaded() {
              return this._loaded;
            }
            updateImage(t4) {
              return t4.url ? (this._request && (this._request.cancel(), this._request = null), this.options.url = t4.url, this.load(t4.coordinates, () => {
                this.texture = null;
              }), this) : this;
            }
            _finishLoading() {
              this.map && (this.setCoordinates(this.coordinates), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "metadata" })));
            }
            onAdd(t4) {
              this.map = t4, this.load();
            }
            onRemove() {
              this._request && (this._request.cancel(), this._request = null);
            }
            setCoordinates(e4) {
              this.coordinates = e4;
              const i5 = e4.map(t3.MercatorCoordinate.fromLngLat);
              this.tileID = function(e5) {
                let i6 = 1 / 0, s6 = 1 / 0, a5 = -1 / 0, o5 = -1 / 0;
                for (const t4 of e5)
                  i6 = Math.min(i6, t4.x), s6 = Math.min(s6, t4.y), a5 = Math.max(a5, t4.x), o5 = Math.max(o5, t4.y);
                const r5 = Math.max(a5 - i6, o5 - s6), n3 = Math.max(0, Math.floor(-Math.log(r5) / Math.LN2)), l5 = Math.pow(2, n3);
                return new t3.CanonicalTileID(n3, Math.floor((i6 + a5) / 2 * l5), Math.floor((s6 + o5) / 2 * l5));
              }(i5), this.minzoom = this.maxzoom = this.tileID.z;
              const s5 = i5.map((t4) => this.tileID.getTilePoint(t4)._round());
              return this._boundsArray = new t3.RasterBoundsArray(), this._boundsArray.emplaceBack(s5[0].x, s5[0].y, 0, 0), this._boundsArray.emplaceBack(s5[1].x, s5[1].y, t3.EXTENT, 0), this._boundsArray.emplaceBack(s5[3].x, s5[3].y, 0, t3.EXTENT), this._boundsArray.emplaceBack(s5[2].x, s5[2].y, t3.EXTENT, t3.EXTENT), this.boundsBuffer && (this.boundsBuffer.destroy(), delete this.boundsBuffer), this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "content" })), this;
            }
            loadTile(t4, e4) {
              this.tileID && this.tileID.equals(t4.tileID.canonical) ? (this.tiles[String(t4.tileID.wrap)] = t4, t4.buckets = {}, e4(null)) : (t4.state = "errored", e4(null));
            }
            hasTransition() {
              return false;
            }
          }
          class N2 extends O2 {
            constructor(e4, i5, s5, a5) {
              super(e4, i5, s5, a5), this.load = () => {
                this._loaded = false;
                const e5 = this.options;
                this.urls = [];
                for (const t4 of e5.urls)
                  this.urls.push(this.map._requestManager.transformRequest(t4, h3.Source).url);
                t3.getVideo(this.urls, (e6, i6) => {
                  this._loaded = true, e6 ? this.fire(new t3.ErrorEvent(e6)) : i6 && (this.video = i6, this.video.loop = true, this.video.addEventListener("playing", () => {
                    this.map.triggerRepaint();
                  }), this.map && this.video.play(), this._finishLoading());
                });
              }, this.prepare = () => {
                if (0 === Object.keys(this.tiles).length || this.video.readyState < 2)
                  return;
                const e5 = this.map.painter.context, i6 = e5.gl;
                this.boundsBuffer || (this.boundsBuffer = e5.createVertexBuffer(this._boundsArray, U.members)), this.boundsSegments || (this.boundsSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? this.video.paused || (this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE), i6.texSubImage2D(i6.TEXTURE_2D, 0, 0, 0, i6.RGBA, i6.UNSIGNED_BYTE, this.video)) : (this.texture = new x2(e5, this.video, i6.RGBA), this.texture.bind(i6.LINEAR, i6.CLAMP_TO_EDGE));
                let s6 = false;
                for (const t4 in this.tiles) {
                  const e6 = this.tiles[t4];
                  "loaded" !== e6.state && (e6.state = "loaded", e6.texture = this.texture, s6 = true);
                }
                s6 && this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "video", urls: this.urls, coordinates: this.coordinates }), this.roundZoom = true, this.type = "video", this.options = i5;
            }
            pause() {
              this.video && this.video.pause();
            }
            play() {
              this.video && this.video.play();
            }
            seek(e4) {
              if (this.video) {
                const i5 = this.video.seekable;
                e4 < i5.start(0) || e4 > i5.end(0) ? this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${this.id}`, null, `Playback for this video can be set only between the ${i5.start(0)} and ${i5.end(0)}-second mark.`))) : this.video.currentTime = e4;
              }
            }
            getVideo() {
              return this.video;
            }
            onAdd(t4) {
              this.map || (this.map = t4, this.load(), this.video && (this.video.play(), this.setCoordinates(this.coordinates)));
            }
            hasTransition() {
              return this.video && !this.video.paused;
            }
          }
          class Z extends O2 {
            constructor(e4, i5, s5, a5) {
              super(e4, i5, s5, a5), this.load = () => {
                this._loaded = true, this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)), this.width = this.canvas.width, this.height = this.canvas.height, this._hasInvalidDimensions() ? this.fire(new t3.ErrorEvent(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                  this._playing = true, this.map.triggerRepaint();
                }, this.pause = function() {
                  this._playing && (this.prepare(), this._playing = false);
                }, this._finishLoading());
              }, this.prepare = () => {
                let e5 = false;
                if (this.canvas.width !== this.width && (this.width = this.canvas.width, e5 = true), this.canvas.height !== this.height && (this.height = this.canvas.height, e5 = true), this._hasInvalidDimensions())
                  return;
                if (0 === Object.keys(this.tiles).length)
                  return;
                const i6 = this.map.painter.context, s6 = i6.gl;
                this.boundsBuffer || (this.boundsBuffer = i6.createVertexBuffer(this._boundsArray, U.members)), this.boundsSegments || (this.boundsSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2)), this.texture ? (e5 || this._playing) && this.texture.update(this.canvas, { premultiply: true }) : this.texture = new x2(i6, this.canvas, s6.RGBA, { premultiply: true });
                let a6 = false;
                for (const t4 in this.tiles) {
                  const e6 = this.tiles[t4];
                  "loaded" !== e6.state && (e6.state = "loaded", e6.texture = this.texture, a6 = true);
                }
                a6 && this.fire(new t3.Event("data", { dataType: "source", sourceDataType: "idle", sourceId: this.id }));
              }, this.serialize = () => ({ type: "canvas", coordinates: this.coordinates }), i5.coordinates ? Array.isArray(i5.coordinates) && 4 === i5.coordinates.length && !i5.coordinates.some((t4) => !Array.isArray(t4) || 2 !== t4.length || t4.some((t5) => "number" != typeof t5)) || this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${e4}`, null, '"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${e4}`, null, 'missing required property "coordinates"'))), i5.animate && "boolean" != typeof i5.animate && this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${e4}`, null, 'optional "animate" property must be a boolean value'))), i5.canvas ? "string" == typeof i5.canvas || i5.canvas instanceof HTMLCanvasElement || this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${e4}`, null, '"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new t3.ErrorEvent(new t3.ValidationError(`sources.${e4}`, null, 'missing required property "canvas"'))), this.options = i5, this.animate = void 0 === i5.animate || i5.animate;
            }
            getCanvas() {
              return this.canvas;
            }
            onAdd(t4) {
              this.map = t4, this.load(), this.canvas && this.animate && this.play();
            }
            onRemove() {
              this.pause();
            }
            hasTransition() {
              return this._playing;
            }
            _hasInvalidDimensions() {
              for (const t4 of [this.canvas.width, this.canvas.height])
                if (isNaN(t4) || t4 <= 0)
                  return true;
              return false;
            }
          }
          const G2 = {}, V = (t4) => {
            switch (t4) {
              case "geojson":
                return B3;
              case "image":
                return O2;
              case "raster":
                return k3;
              case "raster-dem":
                return F3;
              case "vector":
                return R;
              case "video":
                return N2;
              case "canvas":
                return Z;
            }
            return G2[t4];
          };
          function q3(e4, i5) {
            const s5 = t3.create();
            return t3.translate(s5, s5, [1, 1, 0]), t3.scale(s5, s5, [0.5 * e4.width, 0.5 * e4.height, 1]), t3.multiply(s5, s5, e4.calculatePosMatrix(i5.toUnwrapped()));
          }
          function j3(t4, e4, i5, s5, a5, o5) {
            const r5 = function(t5, e5, i6) {
              if (t5)
                for (const s6 of t5) {
                  const t6 = e5[s6];
                  if (t6 && t6.source === i6 && "fill-extrusion" === t6.type)
                    return true;
                }
              else
                for (const t6 in e5) {
                  const s6 = e5[t6];
                  if (s6.source === i6 && "fill-extrusion" === s6.type)
                    return true;
                }
              return false;
            }(a5 && a5.layers, e4, t4.id), n3 = o5.maxPitchScaleFactor(), l5 = t4.tilesIn(s5, n3, r5);
            l5.sort($2);
            const c5 = [];
            for (const s6 of l5)
              c5.push({ wrappedTileID: s6.tileID.wrapped().key, queryResults: s6.tile.queryRenderedFeatures(e4, i5, t4._state, s6.queryGeometry, s6.cameraQueryGeometry, s6.scale, a5, o5, n3, q3(t4.transform, s6.tileID)) });
            const h4 = function(t5) {
              const e5 = {}, i6 = {};
              for (const s6 of t5) {
                const t6 = s6.queryResults, a6 = s6.wrappedTileID, o6 = i6[a6] = i6[a6] || {};
                for (const i7 in t6) {
                  const s7 = t6[i7], a7 = o6[i7] = o6[i7] || {}, r6 = e5[i7] = e5[i7] || [];
                  for (const t7 of s7)
                    a7[t7.featureIndex] || (a7[t7.featureIndex] = true, r6.push(t7));
                }
              }
              return e5;
            }(c5);
            for (const e5 in h4)
              h4[e5].forEach((e6) => {
                const i6 = e6.feature, s6 = t4.getFeatureState(i6.layer["source-layer"], i6.id);
                i6.source = i6.layer.source, i6.layer["source-layer"] && (i6.sourceLayer = i6.layer["source-layer"]), i6.state = s6;
              });
            return h4;
          }
          function $2(t4, e4) {
            const i5 = t4.tileID, s5 = e4.tileID;
            return i5.overscaledZ - s5.overscaledZ || i5.canonical.y - s5.canonical.y || i5.wrap - s5.wrap || i5.canonical.x - s5.canonical.x;
          }
          class X {
            constructor(e4, i5) {
              this.timeAdded = 0, this.fadeEndTime = 0, this.tileID = e4, this.uid = t3.uniqueId(), this.uses = 0, this.tileSize = i5, this.buckets = {}, this.expirationTime = null, this.queryPadding = 0, this.hasSymbolBuckets = false, this.hasRTLText = false, this.dependencies = {}, this.rtt = [], this.rttCoords = {}, this.expiredRequestCount = 0, this.state = "loading";
            }
            registerFadeDuration(t4) {
              const e4 = t4 + this.timeAdded;
              e4 < this.fadeEndTime || (this.fadeEndTime = e4);
            }
            wasRequested() {
              return "errored" === this.state || "loaded" === this.state || "reloading" === this.state;
            }
            clearTextures(t4) {
              this.demTexture && t4.saveTileTexture(this.demTexture), this.demTexture = null;
            }
            loadVectorData(e4, i5, s5) {
              if (this.hasData() && this.unloadVectorData(), this.state = "loaded", e4) {
                e4.featureIndex && (this.latestFeatureIndex = e4.featureIndex, e4.rawTileData ? (this.latestRawTileData = e4.rawTileData, this.latestFeatureIndex.rawTileData = e4.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)), this.collisionBoxArray = e4.collisionBoxArray, this.buckets = function(t4, e5) {
                  const i6 = {};
                  if (!e5)
                    return i6;
                  for (const s6 of t4) {
                    const t5 = s6.layerIds.map((t6) => e5.getLayer(t6)).filter(Boolean);
                    if (0 !== t5.length) {
                      s6.layers = t5, s6.stateDependentLayerIds && (s6.stateDependentLayers = s6.stateDependentLayerIds.map((e6) => t5.filter((t6) => t6.id === e6)[0]));
                      for (const e6 of t5)
                        i6[e6.id] = s6;
                    }
                  }
                  return i6;
                }(e4.buckets, i5.style), this.hasSymbolBuckets = false;
                for (const e5 in this.buckets) {
                  const i6 = this.buckets[e5];
                  if (i6 instanceof t3.SymbolBucket) {
                    if (this.hasSymbolBuckets = true, !s5)
                      break;
                    i6.justReloaded = true;
                  }
                }
                if (this.hasRTLText = false, this.hasSymbolBuckets)
                  for (const e5 in this.buckets) {
                    const i6 = this.buckets[e5];
                    if (i6 instanceof t3.SymbolBucket && i6.hasRTLText) {
                      this.hasRTLText = true, t3.lazyLoadRTLTextPlugin();
                      break;
                    }
                  }
                this.queryPadding = 0;
                for (const t4 in this.buckets) {
                  const e5 = this.buckets[t4];
                  this.queryPadding = Math.max(this.queryPadding, i5.style.getLayer(t4).queryRadius(e5));
                }
                e4.imageAtlas && (this.imageAtlas = e4.imageAtlas), e4.glyphAtlasImage && (this.glyphAtlasImage = e4.glyphAtlasImage);
              } else
                this.collisionBoxArray = new t3.CollisionBoxArray();
            }
            unloadVectorData() {
              for (const t4 in this.buckets)
                this.buckets[t4].destroy();
              this.buckets = {}, this.imageAtlasTexture && this.imageAtlasTexture.destroy(), this.imageAtlas && (this.imageAtlas = null), this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(), this.latestFeatureIndex = null, this.state = "unloaded";
            }
            getBucket(t4) {
              return this.buckets[t4.id];
            }
            upload(t4) {
              for (const e5 in this.buckets) {
                const i5 = this.buckets[e5];
                i5.uploadPending() && i5.upload(t4);
              }
              const e4 = t4.gl;
              this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new x2(t4, this.imageAtlas.image, e4.RGBA), this.imageAtlas.uploaded = true), this.glyphAtlasImage && (this.glyphAtlasTexture = new x2(t4, this.glyphAtlasImage, e4.ALPHA), this.glyphAtlasImage = null);
            }
            prepare(t4) {
              this.imageAtlas && this.imageAtlas.patchUpdatedImages(t4, this.imageAtlasTexture);
            }
            queryRenderedFeatures(t4, e4, i5, s5, a5, o5, r5, n3, l5, c5) {
              return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({ queryGeometry: s5, cameraQueryGeometry: a5, scale: o5, tileSize: this.tileSize, pixelPosMatrix: c5, transform: n3, params: r5, queryPadding: this.queryPadding * l5 }, t4, e4, i5) : {};
            }
            querySourceFeatures(e4, i5) {
              const s5 = this.latestFeatureIndex;
              if (!s5 || !s5.rawTileData)
                return;
              const a5 = s5.loadVTLayers(), o5 = i5 && i5.sourceLayer ? i5.sourceLayer : "", r5 = a5._geojsonTileLayer || a5[o5];
              if (!r5)
                return;
              const n3 = t3.createFilter(i5 && i5.filter), { z: l5, x: c5, y: h4 } = this.tileID.canonical, u5 = { z: l5, x: c5, y: h4 };
              for (let i6 = 0; i6 < r5.length; i6++) {
                const a6 = r5.feature(i6);
                if (n3.needGeometry) {
                  const e5 = t3.toEvaluationFeature(a6, true);
                  if (!n3.filter(new t3.EvaluationParameters(this.tileID.overscaledZ), e5, this.tileID.canonical))
                    continue;
                } else if (!n3.filter(new t3.EvaluationParameters(this.tileID.overscaledZ), a6))
                  continue;
                const d4 = s5.getId(a6, o5), _4 = new t3.GeoJSONFeature(a6, l5, c5, h4, d4);
                _4.tile = u5, e4.push(_4);
              }
            }
            hasData() {
              return "loaded" === this.state || "reloading" === this.state || "expired" === this.state;
            }
            patternsLoaded() {
              return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length;
            }
            setExpiryData(e4) {
              const i5 = this.expirationTime;
              if (e4.cacheControl) {
                const i6 = t3.parseCacheControl(e4.cacheControl);
                i6["max-age"] && (this.expirationTime = Date.now() + 1e3 * i6["max-age"]);
              } else
                e4.expires && (this.expirationTime = new Date(e4.expires).getTime());
              if (this.expirationTime) {
                const t4 = Date.now();
                let e5 = false;
                if (this.expirationTime > t4)
                  e5 = false;
                else if (i5)
                  if (this.expirationTime < i5)
                    e5 = true;
                  else {
                    const s5 = this.expirationTime - i5;
                    s5 ? this.expirationTime = t4 + Math.max(s5, 3e4) : e5 = true;
                  }
                else
                  e5 = true;
                e5 ? (this.expiredRequestCount++, this.state = "expired") : this.expiredRequestCount = 0;
              }
            }
            getExpiryTimeout() {
              if (this.expirationTime)
                return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - (/* @__PURE__ */ new Date()).getTime(), Math.pow(2, 31) - 1);
            }
            setFeatureState(t4, e4) {
              if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || 0 === Object.keys(t4).length)
                return;
              const i5 = this.latestFeatureIndex.loadVTLayers();
              for (const s5 in this.buckets) {
                if (!e4.style.hasLayer(s5))
                  continue;
                const a5 = this.buckets[s5], o5 = a5.layers[0].sourceLayer || "_geojsonTileLayer", r5 = i5[o5], n3 = t4[o5];
                if (!r5 || !n3 || 0 === Object.keys(n3).length)
                  continue;
                a5.update(n3, r5, this.imageAtlas && this.imageAtlas.patternPositions || {});
                const l5 = e4 && e4.style && e4.style.getLayer(s5);
                l5 && (this.queryPadding = Math.max(this.queryPadding, l5.queryRadius(a5)));
              }
            }
            holdingForFade() {
              return void 0 !== this.symbolFadeHoldUntil;
            }
            symbolFadeFinished() {
              return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < t3.browser.now();
            }
            clearFadeHold() {
              this.symbolFadeHoldUntil = void 0;
            }
            setHoldDuration(e4) {
              this.symbolFadeHoldUntil = t3.browser.now() + e4;
            }
            setDependencies(t4, e4) {
              const i5 = {};
              for (const t5 of e4)
                i5[t5] = true;
              this.dependencies[t4] = i5;
            }
            hasDependency(t4, e4) {
              for (const i5 of t4) {
                const t5 = this.dependencies[i5];
                if (t5) {
                  for (const i6 of e4)
                    if (t5[i6])
                      return true;
                }
              }
              return false;
            }
          }
          class W {
            constructor(t4, e4) {
              this.max = t4, this.onRemove = e4, this.reset();
            }
            reset() {
              for (const t4 in this.data)
                for (const e4 of this.data[t4])
                  e4.timeout && clearTimeout(e4.timeout), this.onRemove(e4.value);
              return this.data = {}, this.order = [], this;
            }
            add(t4, e4, i5) {
              const s5 = t4.wrapped().key;
              void 0 === this.data[s5] && (this.data[s5] = []);
              const a5 = { value: e4, timeout: void 0 };
              if (void 0 !== i5 && (a5.timeout = setTimeout(() => {
                this.remove(t4, a5);
              }, i5)), this.data[s5].push(a5), this.order.push(s5), this.order.length > this.max) {
                const t5 = this._getAndRemoveByKey(this.order[0]);
                t5 && this.onRemove(t5);
              }
              return this;
            }
            has(t4) {
              return t4.wrapped().key in this.data;
            }
            getAndRemove(t4) {
              return this.has(t4) ? this._getAndRemoveByKey(t4.wrapped().key) : null;
            }
            _getAndRemoveByKey(t4) {
              const e4 = this.data[t4].shift();
              return e4.timeout && clearTimeout(e4.timeout), 0 === this.data[t4].length && delete this.data[t4], this.order.splice(this.order.indexOf(t4), 1), e4.value;
            }
            getByKey(t4) {
              const e4 = this.data[t4];
              return e4 ? e4[0].value : null;
            }
            get(t4) {
              return this.has(t4) ? this.data[t4.wrapped().key][0].value : null;
            }
            remove(t4, e4) {
              if (!this.has(t4))
                return this;
              const i5 = t4.wrapped().key, s5 = void 0 === e4 ? 0 : this.data[i5].indexOf(e4), a5 = this.data[i5][s5];
              return this.data[i5].splice(s5, 1), a5.timeout && clearTimeout(a5.timeout), 0 === this.data[i5].length && delete this.data[i5], this.onRemove(a5.value), this.order.splice(this.order.indexOf(i5), 1), this;
            }
            setMaxSize(t4) {
              for (this.max = t4; this.order.length > this.max; ) {
                const t5 = this._getAndRemoveByKey(this.order[0]);
                t5 && this.onRemove(t5);
              }
              return this;
            }
            filter(t4) {
              const e4 = [];
              for (const i5 in this.data)
                for (const s5 of this.data[i5])
                  t4(s5.value) || e4.push(s5);
              for (const t5 of e4)
                this.remove(t5.value.tileID, t5);
            }
          }
          class H2 {
            constructor() {
              this.state = {}, this.stateChanges = {}, this.deletedStates = {};
            }
            updateState(e4, i5, s5) {
              const a5 = String(i5);
              if (this.stateChanges[e4] = this.stateChanges[e4] || {}, this.stateChanges[e4][a5] = this.stateChanges[e4][a5] || {}, t3.extend(this.stateChanges[e4][a5], s5), null === this.deletedStates[e4]) {
                this.deletedStates[e4] = {};
                for (const t4 in this.state[e4])
                  t4 !== a5 && (this.deletedStates[e4][t4] = null);
              } else if (this.deletedStates[e4] && null === this.deletedStates[e4][a5]) {
                this.deletedStates[e4][a5] = {};
                for (const t4 in this.state[e4][a5])
                  s5[t4] || (this.deletedStates[e4][a5][t4] = null);
              } else
                for (const t4 in s5)
                  this.deletedStates[e4] && this.deletedStates[e4][a5] && null === this.deletedStates[e4][a5][t4] && delete this.deletedStates[e4][a5][t4];
            }
            removeFeatureState(t4, e4, i5) {
              if (null === this.deletedStates[t4])
                return;
              const s5 = String(e4);
              if (this.deletedStates[t4] = this.deletedStates[t4] || {}, i5 && void 0 !== e4)
                null !== this.deletedStates[t4][s5] && (this.deletedStates[t4][s5] = this.deletedStates[t4][s5] || {}, this.deletedStates[t4][s5][i5] = null);
              else if (void 0 !== e4)
                if (this.stateChanges[t4] && this.stateChanges[t4][s5])
                  for (i5 in this.deletedStates[t4][s5] = {}, this.stateChanges[t4][s5])
                    this.deletedStates[t4][s5][i5] = null;
                else
                  this.deletedStates[t4][s5] = null;
              else
                this.deletedStates[t4] = null;
            }
            getState(e4, i5) {
              const s5 = String(i5), a5 = t3.extend({}, (this.state[e4] || {})[s5], (this.stateChanges[e4] || {})[s5]);
              if (null === this.deletedStates[e4])
                return {};
              if (this.deletedStates[e4]) {
                const t4 = this.deletedStates[e4][i5];
                if (null === t4)
                  return {};
                for (const e5 in t4)
                  delete a5[e5];
              }
              return a5;
            }
            initializeTileState(t4, e4) {
              t4.setFeatureState(this.state, e4);
            }
            coalesceChanges(e4, i5) {
              const s5 = {};
              for (const e5 in this.stateChanges) {
                this.state[e5] = this.state[e5] || {};
                const i6 = {};
                for (const s6 in this.stateChanges[e5])
                  this.state[e5][s6] || (this.state[e5][s6] = {}), t3.extend(this.state[e5][s6], this.stateChanges[e5][s6]), i6[s6] = this.state[e5][s6];
                s5[e5] = i6;
              }
              for (const e5 in this.deletedStates) {
                this.state[e5] = this.state[e5] || {};
                const i6 = {};
                if (null === this.deletedStates[e5])
                  for (const t4 in this.state[e5])
                    i6[t4] = {}, this.state[e5][t4] = {};
                else
                  for (const t4 in this.deletedStates[e5]) {
                    if (null === this.deletedStates[e5][t4])
                      this.state[e5][t4] = {};
                    else
                      for (const i7 of Object.keys(this.deletedStates[e5][t4]))
                        delete this.state[e5][t4][i7];
                    i6[t4] = this.state[e5][t4];
                  }
                s5[e5] = s5[e5] || {}, t3.extend(s5[e5], i6);
              }
              if (this.stateChanges = {}, this.deletedStates = {}, 0 !== Object.keys(s5).length)
                for (const t4 in e4)
                  e4[t4].setFeatureState(s5, i5);
            }
          }
          class K extends t3.Evented {
            constructor(t4, e4, i5) {
              super(), this.id = t4, this.dispatcher = i5, this.on("data", (t5) => {
                "source" === t5.dataType && "metadata" === t5.sourceDataType && (this._sourceLoaded = true), this._sourceLoaded && !this._paused && "source" === t5.dataType && "content" === t5.sourceDataType && (this.reload(), this.transform && this.update(this.transform, this.terrain), this._didEmitContent = true);
              }), this.on("dataloading", () => {
                this._sourceErrored = false;
              }), this.on("error", () => {
                this._sourceErrored = this._source.loaded();
              }), this._source = ((t5, e5, i6, s5) => {
                const a5 = new (V(e5.type))(t5, e5, i6, s5);
                if (a5.id !== t5)
                  throw new Error(`Expected Source id to be ${t5} instead of ${a5.id}`);
                return a5;
              })(t4, e4, i5, this), this._tiles = {}, this._cache = new W(0, this._unloadTile.bind(this)), this._timers = {}, this._cacheTimers = {}, this._maxTileCacheSize = null, this._maxTileCacheZoomLevels = null, this._loadedParentTiles = {}, this._coveredTiles = {}, this._state = new H2(), this._didEmitContent = false, this._updated = false;
            }
            onAdd(t4) {
              this.map = t4, this._maxTileCacheSize = t4 ? t4._maxTileCacheSize : null, this._maxTileCacheZoomLevels = t4 ? t4._maxTileCacheZoomLevels : null, this._source && this._source.onAdd && this._source.onAdd(t4);
            }
            onRemove(t4) {
              this.clearTiles(), this._source && this._source.onRemove && this._source.onRemove(t4);
            }
            loaded() {
              if (this._sourceErrored)
                return true;
              if (!this._sourceLoaded)
                return false;
              if (!this._source.loaded())
                return false;
              if (!(void 0 === this.used && void 0 === this.usedForTerrain || this.used || this.usedForTerrain))
                return true;
              if (!this._updated)
                return false;
              for (const t4 in this._tiles) {
                const e4 = this._tiles[t4];
                if ("loaded" !== e4.state && "errored" !== e4.state)
                  return false;
              }
              return true;
            }
            getSource() {
              return this._source;
            }
            pause() {
              this._paused = true;
            }
            resume() {
              if (!this._paused)
                return;
              const t4 = this._shouldReloadOnResume;
              this._paused = false, this._shouldReloadOnResume = false, t4 && this.reload(), this.transform && this.update(this.transform, this.terrain);
            }
            _loadTile(t4, e4) {
              return this._source.loadTile(t4, e4);
            }
            _unloadTile(t4) {
              if (this._source.unloadTile)
                return this._source.unloadTile(t4, () => {
                });
            }
            _abortTile(e4) {
              this._source.abortTile && this._source.abortTile(e4, () => {
              }), this._source.fire(new t3.Event("dataabort", { tile: e4, coord: e4.tileID, dataType: "source" }));
            }
            serialize() {
              return this._source.serialize();
            }
            prepare(t4) {
              this._source.prepare && this._source.prepare(), this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
              for (const e4 in this._tiles) {
                const i5 = this._tiles[e4];
                i5.upload(t4), i5.prepare(this.map.style.imageManager);
              }
            }
            getIds() {
              return Object.values(this._tiles).map((t4) => t4.tileID).sort(Y).map((t4) => t4.key);
            }
            getRenderableIds(e4) {
              const i5 = [];
              for (const t4 in this._tiles)
                this._isIdRenderable(t4, e4) && i5.push(this._tiles[t4]);
              return e4 ? i5.sort((e5, i6) => {
                const s5 = e5.tileID, a5 = i6.tileID, o5 = new t3.Point(s5.canonical.x, s5.canonical.y)._rotate(this.transform.angle), r5 = new t3.Point(a5.canonical.x, a5.canonical.y)._rotate(this.transform.angle);
                return s5.overscaledZ - a5.overscaledZ || r5.y - o5.y || r5.x - o5.x;
              }).map((t4) => t4.tileID.key) : i5.map((t4) => t4.tileID).sort(Y).map((t4) => t4.key);
            }
            hasRenderableParent(t4) {
              const e4 = this.findLoadedParent(t4, 0);
              return !!e4 && this._isIdRenderable(e4.tileID.key);
            }
            _isIdRenderable(t4, e4) {
              return this._tiles[t4] && this._tiles[t4].hasData() && !this._coveredTiles[t4] && (e4 || !this._tiles[t4].holdingForFade());
            }
            reload() {
              if (this._paused)
                this._shouldReloadOnResume = true;
              else {
                this._cache.reset();
                for (const t4 in this._tiles)
                  "errored" !== this._tiles[t4].state && this._reloadTile(t4, "reloading");
              }
            }
            _reloadTile(t4, e4) {
              const i5 = this._tiles[t4];
              i5 && ("loading" !== i5.state && (i5.state = e4), this._loadTile(i5, this._tileLoaded.bind(this, i5, t4, e4)));
            }
            _tileLoaded(e4, i5, s5, a5) {
              if (a5)
                return e4.state = "errored", void (404 !== a5.status ? this._source.fire(new t3.ErrorEvent(a5, { tile: e4 })) : this.update(this.transform, this.terrain));
              e4.timeAdded = t3.browser.now(), "expired" === s5 && (e4.refreshedUponExpiration = true), this._setTileReloadTimer(i5, e4), "raster-dem" === this.getSource().type && e4.dem && this._backfillDEM(e4), this._state.initializeTileState(e4, this.map ? this.map.painter : null), e4.aborted || this._source.fire(new t3.Event("data", { dataType: "source", tile: e4, coord: e4.tileID }));
            }
            _backfillDEM(t4) {
              const e4 = this.getRenderableIds();
              for (let s5 = 0; s5 < e4.length; s5++) {
                const a5 = e4[s5];
                if (t4.neighboringTiles && t4.neighboringTiles[a5]) {
                  const e5 = this.getTileByID(a5);
                  i5(t4, e5), i5(e5, t4);
                }
              }
              function i5(t5, e5) {
                t5.needsHillshadePrepare = true, t5.needsTerrainPrepare = true;
                let i6 = e5.tileID.canonical.x - t5.tileID.canonical.x;
                const s5 = e5.tileID.canonical.y - t5.tileID.canonical.y, a5 = Math.pow(2, t5.tileID.canonical.z), o5 = e5.tileID.key;
                0 === i6 && 0 === s5 || Math.abs(s5) > 1 || (Math.abs(i6) > 1 && (1 === Math.abs(i6 + a5) ? i6 += a5 : 1 === Math.abs(i6 - a5) && (i6 -= a5)), e5.dem && t5.dem && (t5.dem.backfillBorder(e5.dem, i6, s5), t5.neighboringTiles && t5.neighboringTiles[o5] && (t5.neighboringTiles[o5].backfilled = true)));
              }
            }
            getTile(t4) {
              return this.getTileByID(t4.key);
            }
            getTileByID(t4) {
              return this._tiles[t4];
            }
            _retainLoadedChildren(t4, e4, i5, s5) {
              for (const a5 in this._tiles) {
                let o5 = this._tiles[a5];
                if (s5[a5] || !o5.hasData() || o5.tileID.overscaledZ <= e4 || o5.tileID.overscaledZ > i5)
                  continue;
                let r5 = o5.tileID;
                for (; o5 && o5.tileID.overscaledZ > e4 + 1; ) {
                  const t5 = o5.tileID.scaledTo(o5.tileID.overscaledZ - 1);
                  o5 = this._tiles[t5.key], o5 && o5.hasData() && (r5 = t5);
                }
                let n3 = r5;
                for (; n3.overscaledZ > e4; )
                  if (n3 = n3.scaledTo(n3.overscaledZ - 1), t4[n3.key]) {
                    s5[r5.key] = r5;
                    break;
                  }
              }
            }
            findLoadedParent(t4, e4) {
              if (t4.key in this._loadedParentTiles) {
                const i5 = this._loadedParentTiles[t4.key];
                return i5 && i5.tileID.overscaledZ >= e4 ? i5 : null;
              }
              for (let i5 = t4.overscaledZ - 1; i5 >= e4; i5--) {
                const e5 = t4.scaledTo(i5), s5 = this._getLoadedTile(e5);
                if (s5)
                  return s5;
              }
            }
            _getLoadedTile(t4) {
              const e4 = this._tiles[t4.key];
              return e4 && e4.hasData() ? e4 : this._cache.getByKey(t4.wrapped().key);
            }
            updateCacheSize(e4) {
              const i5 = Math.ceil(e4.width / this._source.tileSize) + 1, s5 = Math.ceil(e4.height / this._source.tileSize) + 1, a5 = Math.floor(i5 * s5 * (null === this._maxTileCacheZoomLevels ? t3.config.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels)), o5 = "number" == typeof this._maxTileCacheSize ? Math.min(this._maxTileCacheSize, a5) : a5;
              this._cache.setMaxSize(o5);
            }
            handleWrapJump(t4) {
              const e4 = Math.round((t4 - (void 0 === this._prevLng ? t4 : this._prevLng)) / 360);
              if (this._prevLng = t4, e4) {
                const t5 = {};
                for (const i5 in this._tiles) {
                  const s5 = this._tiles[i5];
                  s5.tileID = s5.tileID.unwrapTo(s5.tileID.wrap + e4), t5[s5.tileID.key] = s5;
                }
                this._tiles = t5;
                for (const t6 in this._timers)
                  clearTimeout(this._timers[t6]), delete this._timers[t6];
                for (const t6 in this._tiles)
                  this._setTileReloadTimer(t6, this._tiles[t6]);
              }
            }
            update(e4, i5) {
              if (this.transform = e4, this.terrain = i5, !this._sourceLoaded || this._paused)
                return;
              let s5;
              this.updateCacheSize(e4), this.handleWrapJump(this.transform.center.lng), this._coveredTiles = {}, this.used || this.usedForTerrain ? this._source.tileID ? s5 = e4.getVisibleUnwrappedCoordinates(this._source.tileID).map((e5) => new t3.OverscaledTileID(e5.canonical.z, e5.wrap, e5.canonical.z, e5.canonical.x, e5.canonical.y)) : (s5 = e4.coveringTiles({ tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize, minzoom: this._source.minzoom, maxzoom: this._source.maxzoom, roundZoom: !this.usedForTerrain && this._source.roundZoom, reparseOverscaled: this._source.reparseOverscaled, terrain: i5 }), this._source.hasTile && (s5 = s5.filter((t4) => this._source.hasTile(t4)))) : s5 = [];
              const a5 = e4.coveringZoomLevel(this._source), o5 = Math.max(a5 - K.maxOverzooming, this._source.minzoom), r5 = Math.max(a5 + K.maxUnderzooming, this._source.minzoom);
              if (this.usedForTerrain) {
                const t4 = {};
                for (const e5 of s5)
                  if (e5.canonical.z > this._source.minzoom) {
                    const i6 = e5.scaledTo(e5.canonical.z - 1);
                    t4[i6.key] = i6;
                    const s6 = e5.scaledTo(Math.max(this._source.minzoom, Math.min(e5.canonical.z, 5)));
                    t4[s6.key] = s6;
                  }
                s5 = s5.concat(Object.values(t4));
              }
              const n3 = 0 === s5.length && !this._updated && this._didEmitContent;
              this._updated = true, n3 && this.fire(new t3.Event("data", { sourceDataType: "idle", dataType: "source", sourceId: this.id }));
              const l5 = this._updateRetainedTiles(s5, a5);
              if (J(this._source.type)) {
                const e5 = {}, n4 = {}, c6 = Object.keys(l5), h4 = t3.browser.now();
                for (const t4 of c6) {
                  const i6 = l5[t4], s6 = this._tiles[t4];
                  if (!s6 || 0 !== s6.fadeEndTime && s6.fadeEndTime <= h4)
                    continue;
                  const a6 = this.findLoadedParent(i6, o5);
                  a6 && (this._addTile(a6.tileID), e5[a6.tileID.key] = a6.tileID), n4[t4] = i6;
                }
                this._retainLoadedChildren(n4, a5, r5, l5);
                for (const t4 in e5)
                  l5[t4] || (this._coveredTiles[t4] = true, l5[t4] = e5[t4]);
                if (i5) {
                  const t4 = {}, e6 = {};
                  for (const i6 of s5)
                    this._tiles[i6.key].hasData() ? t4[i6.key] = i6 : e6[i6.key] = i6;
                  for (const i6 in e6) {
                    const s6 = e6[i6].children(this._source.maxzoom);
                    this._tiles[s6[0].key] && this._tiles[s6[1].key] && this._tiles[s6[2].key] && this._tiles[s6[3].key] && (t4[s6[0].key] = l5[s6[0].key] = s6[0], t4[s6[1].key] = l5[s6[1].key] = s6[1], t4[s6[2].key] = l5[s6[2].key] = s6[2], t4[s6[3].key] = l5[s6[3].key] = s6[3], delete e6[i6]);
                  }
                  for (const i6 in e6) {
                    const s6 = this.findLoadedParent(e6[i6], this._source.minzoom);
                    if (s6) {
                      t4[s6.tileID.key] = l5[s6.tileID.key] = s6.tileID;
                      for (const e7 in t4)
                        t4[e7].isChildOf(s6.tileID) && delete t4[e7];
                    }
                  }
                  for (const e7 in this._tiles)
                    t4[e7] || (this._coveredTiles[e7] = true);
                }
              }
              for (const t4 in l5)
                this._tiles[t4].clearFadeHold();
              const c5 = t3.keysDifference(this._tiles, l5);
              for (const t4 of c5) {
                const e5 = this._tiles[t4];
                e5.hasSymbolBuckets && !e5.holdingForFade() ? e5.setHoldDuration(this.map._fadeDuration) : e5.hasSymbolBuckets && !e5.symbolFadeFinished() || this._removeTile(t4);
              }
              this._updateLoadedParentTileCache();
            }
            releaseSymbolFadeTiles() {
              for (const t4 in this._tiles)
                this._tiles[t4].holdingForFade() && this._removeTile(t4);
            }
            _updateRetainedTiles(t4, e4) {
              const i5 = {}, s5 = {}, a5 = Math.max(e4 - K.maxOverzooming, this._source.minzoom), o5 = Math.max(e4 + K.maxUnderzooming, this._source.minzoom), r5 = {};
              for (const s6 of t4) {
                const t5 = this._addTile(s6);
                i5[s6.key] = s6, t5.hasData() || e4 < this._source.maxzoom && (r5[s6.key] = s6);
              }
              this._retainLoadedChildren(r5, e4, o5, i5);
              for (const o6 of t4) {
                let t5 = this._tiles[o6.key];
                if (t5.hasData())
                  continue;
                if (e4 + 1 > this._source.maxzoom) {
                  const t6 = o6.children(this._source.maxzoom)[0], e5 = this.getTile(t6);
                  if (e5 && e5.hasData()) {
                    i5[t6.key] = t6;
                    continue;
                  }
                } else {
                  const t6 = o6.children(this._source.maxzoom);
                  if (i5[t6[0].key] && i5[t6[1].key] && i5[t6[2].key] && i5[t6[3].key])
                    continue;
                }
                let r6 = t5.wasRequested();
                for (let e5 = o6.overscaledZ - 1; e5 >= a5; --e5) {
                  const a6 = o6.scaledTo(e5);
                  if (s5[a6.key])
                    break;
                  if (s5[a6.key] = true, t5 = this.getTile(a6), !t5 && r6 && (t5 = this._addTile(a6)), t5) {
                    const e6 = t5.hasData();
                    if ((r6 || e6) && (i5[a6.key] = a6), r6 = t5.wasRequested(), e6)
                      break;
                  }
                }
              }
              return i5;
            }
            _updateLoadedParentTileCache() {
              this._loadedParentTiles = {};
              for (const t4 in this._tiles) {
                const e4 = [];
                let i5, s5 = this._tiles[t4].tileID;
                for (; s5.overscaledZ > 0; ) {
                  if (s5.key in this._loadedParentTiles) {
                    i5 = this._loadedParentTiles[s5.key];
                    break;
                  }
                  e4.push(s5.key);
                  const t5 = s5.scaledTo(s5.overscaledZ - 1);
                  if (i5 = this._getLoadedTile(t5), i5)
                    break;
                  s5 = t5;
                }
                for (const t5 of e4)
                  this._loadedParentTiles[t5] = i5;
              }
            }
            _addTile(e4) {
              let i5 = this._tiles[e4.key];
              if (i5)
                return i5;
              i5 = this._cache.getAndRemove(e4), i5 && (this._setTileReloadTimer(e4.key, i5), i5.tileID = e4, this._state.initializeTileState(i5, this.map ? this.map.painter : null), this._cacheTimers[e4.key] && (clearTimeout(this._cacheTimers[e4.key]), delete this._cacheTimers[e4.key], this._setTileReloadTimer(e4.key, i5)));
              const s5 = i5;
              return i5 || (i5 = new X(e4, this._source.tileSize * e4.overscaleFactor()), this._loadTile(i5, this._tileLoaded.bind(this, i5, e4.key, i5.state))), i5.uses++, this._tiles[e4.key] = i5, s5 || this._source.fire(new t3.Event("dataloading", { tile: i5, coord: i5.tileID, dataType: "source" })), i5;
            }
            _setTileReloadTimer(t4, e4) {
              t4 in this._timers && (clearTimeout(this._timers[t4]), delete this._timers[t4]);
              const i5 = e4.getExpiryTimeout();
              i5 && (this._timers[t4] = setTimeout(() => {
                this._reloadTile(t4, "expired"), delete this._timers[t4];
              }, i5));
            }
            _removeTile(t4) {
              const e4 = this._tiles[t4];
              e4 && (e4.uses--, delete this._tiles[t4], this._timers[t4] && (clearTimeout(this._timers[t4]), delete this._timers[t4]), e4.uses > 0 || (e4.hasData() && "reloading" !== e4.state ? this._cache.add(e4.tileID, e4, e4.getExpiryTimeout()) : (e4.aborted = true, this._abortTile(e4), this._unloadTile(e4))));
            }
            clearTiles() {
              this._shouldReloadOnResume = false, this._paused = false;
              for (const t4 in this._tiles)
                this._removeTile(t4);
              this._cache.reset();
            }
            tilesIn(e4, i5, s5) {
              const a5 = [], o5 = this.transform;
              if (!o5)
                return a5;
              const r5 = s5 ? o5.getCameraQueryGeometry(e4) : e4, n3 = e4.map((t4) => o5.pointCoordinate(t4, this.terrain)), l5 = r5.map((t4) => o5.pointCoordinate(t4, this.terrain)), c5 = this.getIds();
              let h4 = 1 / 0, u5 = 1 / 0, d4 = -1 / 0, _4 = -1 / 0;
              for (const t4 of l5)
                h4 = Math.min(h4, t4.x), u5 = Math.min(u5, t4.y), d4 = Math.max(d4, t4.x), _4 = Math.max(_4, t4.y);
              for (let e5 = 0; e5 < c5.length; e5++) {
                const s6 = this._tiles[c5[e5]];
                if (s6.holdingForFade())
                  continue;
                const r6 = s6.tileID, m4 = Math.pow(2, o5.zoom - s6.tileID.overscaledZ), p7 = i5 * s6.queryPadding * t3.EXTENT / s6.tileSize / m4, f4 = [r6.getTilePoint(new t3.MercatorCoordinate(h4, u5)), r6.getTilePoint(new t3.MercatorCoordinate(d4, _4))];
                if (f4[0].x - p7 < t3.EXTENT && f4[0].y - p7 < t3.EXTENT && f4[1].x + p7 >= 0 && f4[1].y + p7 >= 0) {
                  const t4 = n3.map((t5) => r6.getTilePoint(t5)), e6 = l5.map((t5) => r6.getTilePoint(t5));
                  a5.push({ tile: s6, tileID: r6, queryGeometry: t4, cameraQueryGeometry: e6, scale: m4 });
                }
              }
              return a5;
            }
            getVisibleCoordinates(t4) {
              const e4 = this.getRenderableIds(t4).map((t5) => this._tiles[t5].tileID);
              for (const t5 of e4)
                t5.posMatrix = this.transform.calculatePosMatrix(t5.toUnwrapped());
              return e4;
            }
            hasTransition() {
              if (this._source.hasTransition())
                return true;
              if (J(this._source.type)) {
                const e4 = t3.browser.now();
                for (const t4 in this._tiles)
                  if (this._tiles[t4].fadeEndTime >= e4)
                    return true;
              }
              return false;
            }
            setFeatureState(t4, e4, i5) {
              this._state.updateState(t4 = t4 || "_geojsonTileLayer", e4, i5);
            }
            removeFeatureState(t4, e4, i5) {
              this._state.removeFeatureState(t4 = t4 || "_geojsonTileLayer", e4, i5);
            }
            getFeatureState(t4, e4) {
              return this._state.getState(t4 = t4 || "_geojsonTileLayer", e4);
            }
            setDependencies(t4, e4, i5) {
              const s5 = this._tiles[t4];
              s5 && s5.setDependencies(e4, i5);
            }
            reloadTilesForDependencies(t4, e4) {
              for (const i5 in this._tiles)
                this._tiles[i5].hasDependency(t4, e4) && this._reloadTile(i5, "reloading");
              this._cache.filter((i5) => !i5.hasDependency(t4, e4));
            }
          }
          function Y(t4, e4) {
            const i5 = Math.abs(2 * t4.wrap) - +(t4.wrap < 0), s5 = Math.abs(2 * e4.wrap) - +(e4.wrap < 0);
            return t4.overscaledZ - e4.overscaledZ || s5 - i5 || e4.canonical.y - t4.canonical.y || e4.canonical.x - t4.canonical.x;
          }
          function J(t4) {
            return "raster" === t4 || "image" === t4 || "video" === t4;
          }
          K.maxOverzooming = 10, K.maxUnderzooming = 3;
          const Q = "mapboxgl_preloaded_worker_pool";
          class tt {
            constructor() {
              this.active = {};
            }
            acquire(e4) {
              if (!this.workers)
                for (this.workers = []; this.workers.length < tt.workerCount; )
                  this.workers.push(new Worker(t3.config.WORKER_URL));
              return this.active[e4] = true, this.workers.slice();
            }
            release(t4) {
              delete this.active[t4], 0 === this.numActive() && (this.workers.forEach((t5) => {
                t5.terminate();
              }), this.workers = null);
            }
            isPreloaded() {
              return !!this.active[Q];
            }
            numActive() {
              return Object.keys(this.active).length;
            }
          }
          const et = Math.floor(t3.browser.hardwareConcurrency / 2);
          let it;
          function st() {
            return it || (it = new tt()), it;
          }
          tt.workerCount = t3.isSafari(globalThis) ? Math.max(Math.min(et, 3), 1) : 1;
          class at {
            constructor(t4, e4) {
              this.reset(t4, e4);
            }
            reset(t4, e4) {
              this.points = t4 || [], this._distances = [0];
              for (let t5 = 1; t5 < this.points.length; t5++)
                this._distances[t5] = this._distances[t5 - 1] + this.points[t5].dist(this.points[t5 - 1]);
              this.length = this._distances[this._distances.length - 1], this.padding = Math.min(e4 || 0, 0.5 * this.length), this.paddedLength = this.length - 2 * this.padding;
            }
            lerp(e4) {
              if (1 === this.points.length)
                return this.points[0];
              e4 = t3.clamp(e4, 0, 1);
              let i5 = 1, s5 = this._distances[i5];
              const a5 = e4 * this.paddedLength + this.padding;
              for (; s5 < a5 && i5 < this._distances.length; )
                s5 = this._distances[++i5];
              const o5 = i5 - 1, r5 = this._distances[o5], n3 = s5 - r5, l5 = n3 > 0 ? (a5 - r5) / n3 : 0;
              return this.points[o5].mult(1 - l5).add(this.points[i5].mult(l5));
            }
          }
          function ot(t4, e4) {
            let i5 = true;
            return "always" === t4 || "never" !== t4 && "never" !== e4 || (i5 = false), i5;
          }
          class rt {
            constructor(t4, e4, i5) {
              const s5 = this.boxCells = [], a5 = this.circleCells = [];
              this.xCellCount = Math.ceil(t4 / i5), this.yCellCount = Math.ceil(e4 / i5);
              for (let t5 = 0; t5 < this.xCellCount * this.yCellCount; t5++)
                s5.push([]), a5.push([]);
              this.circleKeys = [], this.boxKeys = [], this.bboxes = [], this.circles = [], this.width = t4, this.height = e4, this.xScale = this.xCellCount / t4, this.yScale = this.yCellCount / e4, this.boxUid = 0, this.circleUid = 0;
            }
            keysLength() {
              return this.boxKeys.length + this.circleKeys.length;
            }
            insert(t4, e4, i5, s5, a5) {
              this._forEachCell(e4, i5, s5, a5, this._insertBoxCell, this.boxUid++), this.boxKeys.push(t4), this.bboxes.push(e4), this.bboxes.push(i5), this.bboxes.push(s5), this.bboxes.push(a5);
            }
            insertCircle(t4, e4, i5, s5) {
              this._forEachCell(e4 - s5, i5 - s5, e4 + s5, i5 + s5, this._insertCircleCell, this.circleUid++), this.circleKeys.push(t4), this.circles.push(e4), this.circles.push(i5), this.circles.push(s5);
            }
            _insertBoxCell(t4, e4, i5, s5, a5, o5) {
              this.boxCells[a5].push(o5);
            }
            _insertCircleCell(t4, e4, i5, s5, a5, o5) {
              this.circleCells[a5].push(o5);
            }
            _query(t4, e4, i5, s5, a5, o5, r5) {
              if (i5 < 0 || t4 > this.width || s5 < 0 || e4 > this.height)
                return [];
              const n3 = [];
              if (t4 <= 0 && e4 <= 0 && this.width <= i5 && this.height <= s5) {
                if (a5)
                  return [{ key: null, x1: t4, y1: e4, x2: i5, y2: s5 }];
                for (let t5 = 0; t5 < this.boxKeys.length; t5++)
                  n3.push({ key: this.boxKeys[t5], x1: this.bboxes[4 * t5], y1: this.bboxes[4 * t5 + 1], x2: this.bboxes[4 * t5 + 2], y2: this.bboxes[4 * t5 + 3] });
                for (let t5 = 0; t5 < this.circleKeys.length; t5++) {
                  const e5 = this.circles[3 * t5], i6 = this.circles[3 * t5 + 1], s6 = this.circles[3 * t5 + 2];
                  n3.push({ key: this.circleKeys[t5], x1: e5 - s6, y1: i6 - s6, x2: e5 + s6, y2: i6 + s6 });
                }
              } else
                this._forEachCell(t4, e4, i5, s5, this._queryCell, n3, { hitTest: a5, overlapMode: o5, seenUids: { box: {}, circle: {} } }, r5);
              return n3;
            }
            query(t4, e4, i5, s5) {
              return this._query(t4, e4, i5, s5, false, null);
            }
            hitTest(t4, e4, i5, s5, a5, o5) {
              return this._query(t4, e4, i5, s5, true, a5, o5).length > 0;
            }
            hitTestCircle(t4, e4, i5, s5, a5) {
              const o5 = t4 - i5, r5 = t4 + i5, n3 = e4 - i5, l5 = e4 + i5;
              if (r5 < 0 || o5 > this.width || l5 < 0 || n3 > this.height)
                return false;
              const c5 = [];
              return this._forEachCell(o5, n3, r5, l5, this._queryCellCircle, c5, { hitTest: true, overlapMode: s5, circle: { x: t4, y: e4, radius: i5 }, seenUids: { box: {}, circle: {} } }, a5), c5.length > 0;
            }
            _queryCell(t4, e4, i5, s5, a5, o5, r5, n3) {
              const { seenUids: l5, hitTest: c5, overlapMode: h4 } = r5, u5 = this.boxCells[a5];
              if (null !== u5) {
                const a6 = this.bboxes;
                for (const r6 of u5)
                  if (!l5.box[r6]) {
                    l5.box[r6] = true;
                    const u6 = 4 * r6, d5 = this.boxKeys[r6];
                    if (t4 <= a6[u6 + 2] && e4 <= a6[u6 + 3] && i5 >= a6[u6 + 0] && s5 >= a6[u6 + 1] && (!n3 || n3(d5)) && (!c5 || !ot(h4, d5.overlapMode)) && (o5.push({ key: d5, x1: a6[u6], y1: a6[u6 + 1], x2: a6[u6 + 2], y2: a6[u6 + 3] }), c5))
                      return true;
                  }
              }
              const d4 = this.circleCells[a5];
              if (null !== d4) {
                const a6 = this.circles;
                for (const r6 of d4)
                  if (!l5.circle[r6]) {
                    l5.circle[r6] = true;
                    const u6 = 3 * r6, d5 = this.circleKeys[r6];
                    if (this._circleAndRectCollide(a6[u6], a6[u6 + 1], a6[u6 + 2], t4, e4, i5, s5) && (!n3 || n3(d5)) && (!c5 || !ot(h4, d5.overlapMode))) {
                      const t5 = a6[u6], e5 = a6[u6 + 1], i6 = a6[u6 + 2];
                      if (o5.push({ key: d5, x1: t5 - i6, y1: e5 - i6, x2: t5 + i6, y2: e5 + i6 }), c5)
                        return true;
                    }
                  }
              }
              return false;
            }
            _queryCellCircle(t4, e4, i5, s5, a5, o5, r5, n3) {
              const { circle: l5, seenUids: c5, overlapMode: h4 } = r5, u5 = this.boxCells[a5];
              if (null !== u5) {
                const t5 = this.bboxes;
                for (const e5 of u5)
                  if (!c5.box[e5]) {
                    c5.box[e5] = true;
                    const i6 = 4 * e5, s6 = this.boxKeys[e5];
                    if (this._circleAndRectCollide(l5.x, l5.y, l5.radius, t5[i6 + 0], t5[i6 + 1], t5[i6 + 2], t5[i6 + 3]) && (!n3 || n3(s6)) && !ot(h4, s6.overlapMode))
                      return o5.push(true), true;
                  }
              }
              const d4 = this.circleCells[a5];
              if (null !== d4) {
                const t5 = this.circles;
                for (const e5 of d4)
                  if (!c5.circle[e5]) {
                    c5.circle[e5] = true;
                    const i6 = 3 * e5, s6 = this.circleKeys[e5];
                    if (this._circlesCollide(t5[i6], t5[i6 + 1], t5[i6 + 2], l5.x, l5.y, l5.radius) && (!n3 || n3(s6)) && !ot(h4, s6.overlapMode))
                      return o5.push(true), true;
                  }
              }
            }
            _forEachCell(t4, e4, i5, s5, a5, o5, r5, n3) {
              const l5 = this._convertToXCellCoord(t4), c5 = this._convertToYCellCoord(e4), h4 = this._convertToXCellCoord(i5), u5 = this._convertToYCellCoord(s5);
              for (let d4 = l5; d4 <= h4; d4++)
                for (let l6 = c5; l6 <= u5; l6++)
                  if (a5.call(this, t4, e4, i5, s5, this.xCellCount * l6 + d4, o5, r5, n3))
                    return;
            }
            _convertToXCellCoord(t4) {
              return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(t4 * this.xScale)));
            }
            _convertToYCellCoord(t4) {
              return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(t4 * this.yScale)));
            }
            _circlesCollide(t4, e4, i5, s5, a5, o5) {
              const r5 = s5 - t4, n3 = a5 - e4, l5 = i5 + o5;
              return l5 * l5 > r5 * r5 + n3 * n3;
            }
            _circleAndRectCollide(t4, e4, i5, s5, a5, o5, r5) {
              const n3 = (o5 - s5) / 2, l5 = Math.abs(t4 - (s5 + n3));
              if (l5 > n3 + i5)
                return false;
              const c5 = (r5 - a5) / 2, h4 = Math.abs(e4 - (a5 + c5));
              if (h4 > c5 + i5)
                return false;
              if (l5 <= n3 || h4 <= c5)
                return true;
              const u5 = l5 - n3, d4 = h4 - c5;
              return u5 * u5 + d4 * d4 <= i5 * i5;
            }
          }
          function nt(e4, i5, s5, a5, o5) {
            const r5 = t3.create();
            return i5 ? (t3.scale(r5, r5, [1 / o5, 1 / o5, 1]), s5 || t3.rotateZ(r5, r5, a5.angle)) : t3.multiply(r5, a5.labelPlaneMatrix, e4), r5;
          }
          function lt(e4, i5, s5, a5, o5) {
            if (i5) {
              const i6 = t3.clone(e4);
              return t3.scale(i6, i6, [o5, o5, 1]), s5 || t3.rotateZ(i6, i6, -a5.angle), i6;
            }
            return a5.glCoordMatrix;
          }
          function ct(e4, i5, s5) {
            let a5;
            s5 ? (a5 = [e4.x, e4.y, s5(e4.x, e4.y), 1], t3.transformMat4(a5, a5, i5)) : (a5 = [e4.x, e4.y, 0, 1], Tt(a5, a5, i5));
            const o5 = a5[3];
            return { point: new t3.Point(a5[0] / o5, a5[1] / o5), signedDistanceFromCamera: o5 };
          }
          function ht(t4, e4) {
            return 0.5 + t4 / e4 * 0.5;
          }
          function ut(t4, e4) {
            const i5 = t4[0] / t4[3], s5 = t4[1] / t4[3];
            return i5 >= -e4[0] && i5 <= e4[0] && s5 >= -e4[1] && s5 <= e4[1];
          }
          function dt(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4) {
            const u5 = a5 ? e4.textSizeData : e4.iconSizeData, d4 = t3.evaluateSizeForZoom(u5, s5.transform.zoom), _4 = [256 / s5.width * 2 + 1, 256 / s5.height * 2 + 1], m4 = a5 ? e4.text.dynamicLayoutVertexArray : e4.icon.dynamicLayoutVertexArray;
            m4.clear();
            const p7 = e4.lineVertexArray, f4 = a5 ? e4.text.placedSymbolArray : e4.icon.placedSymbolArray, g4 = s5.transform.width / s5.transform.height;
            let v5 = false;
            for (let a6 = 0; a6 < f4.length; a6++) {
              const x3 = f4.get(a6);
              if (x3.hidden || x3.writingMode === t3.WritingMode.vertical && !v5) {
                wt(x3.numGlyphs, m4);
                continue;
              }
              let y3;
              if (v5 = false, h4 ? (y3 = [x3.anchorX, x3.anchorY, h4(x3.anchorX, x3.anchorY), 1], t3.transformMat4(y3, y3, i5)) : (y3 = [x3.anchorX, x3.anchorY, 0, 1], Tt(y3, y3, i5)), !ut(y3, _4)) {
                wt(x3.numGlyphs, m4);
                continue;
              }
              const b4 = ht(s5.transform.cameraToCenterDistance, y3[3]), w4 = t3.evaluateSizeForFeature(u5, d4, x3), T3 = n3 ? w4 / b4 : w4 * b4, E3 = new t3.Point(x3.anchorX, x3.anchorY), I3 = ct(E3, o5, h4).point, S3 = { projections: {}, offsets: {} }, C2 = pt(x3, T3, false, l5, i5, o5, r5, e4.glyphOffsetArray, p7, m4, I3, E3, S3, g4, c5, h4);
              v5 = C2.useVertical, (C2.notEnoughRoom || v5 || C2.needsFlipping && pt(x3, T3, true, l5, i5, o5, r5, e4.glyphOffsetArray, p7, m4, I3, E3, S3, g4, c5, h4).notEnoughRoom) && wt(x3.numGlyphs, m4);
            }
            a5 ? e4.text.dynamicLayoutVertexBuffer.updateData(m4) : e4.icon.dynamicLayoutVertexBuffer.updateData(m4);
          }
          function _t(t4, e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4) {
            const _4 = n3.glyphStartIndex + n3.numGlyphs, m4 = n3.lineStartIndex, p7 = n3.lineStartIndex + n3.lineLength, f4 = e4.getoffsetX(n3.glyphStartIndex), g4 = e4.getoffsetX(_4 - 1), v5 = yt(t4 * f4, i5, s5, a5, o5, r5, n3.segment, m4, p7, l5, c5, h4, u5, d4);
            if (!v5)
              return null;
            const x3 = yt(t4 * g4, i5, s5, a5, o5, r5, n3.segment, m4, p7, l5, c5, h4, u5, d4);
            return x3 ? { first: v5, last: x3 } : null;
          }
          function mt(e4, i5, s5, a5) {
            return e4 === t3.WritingMode.horizontal && Math.abs(s5.y - i5.y) > Math.abs(s5.x - i5.x) * a5 ? { useVertical: true } : (e4 === t3.WritingMode.vertical ? i5.y < s5.y : i5.x > s5.x) ? { needsFlipping: true } : null;
          }
          function pt(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4, _4, m4, p7, f4) {
            const g4 = i5 / 24, v5 = e4.lineOffsetX * g4, x3 = e4.lineOffsetY * g4;
            let y3;
            if (e4.numGlyphs > 1) {
              const t4 = e4.glyphStartIndex + e4.numGlyphs, i6 = e4.lineStartIndex, o6 = e4.lineStartIndex + e4.lineLength, h5 = _t(g4, l5, v5, x3, s5, u5, d4, e4, c5, r5, _4, p7, f4);
              if (!h5)
                return { notEnoughRoom: true };
              const b4 = ct(h5.first.point, n3, f4).point, w4 = ct(h5.last.point, n3, f4).point;
              if (a5 && !s5) {
                const t5 = mt(e4.writingMode, b4, w4, m4);
                if (t5)
                  return t5;
              }
              y3 = [h5.first];
              for (let a6 = e4.glyphStartIndex + 1; a6 < t4 - 1; a6++)
                y3.push(yt(g4 * l5.getoffsetX(a6), v5, x3, s5, u5, d4, e4.segment, i6, o6, c5, r5, _4, p7, f4));
              y3.push(h5.last);
            } else {
              if (a5 && !s5) {
                const i7 = ct(d4, o5, f4).point, s6 = e4.lineStartIndex + e4.segment + 1, a6 = new t3.Point(c5.getx(s6), c5.gety(s6)), r6 = ct(a6, o5, f4), n4 = r6.signedDistanceFromCamera > 0 ? r6.point : ft(d4, a6, i7, 1, o5, f4), l6 = mt(e4.writingMode, i7, n4, m4);
                if (l6)
                  return l6;
              }
              const i6 = yt(g4 * l5.getoffsetX(e4.glyphStartIndex), v5, x3, s5, u5, d4, e4.segment, e4.lineStartIndex, e4.lineStartIndex + e4.lineLength, c5, r5, _4, p7, f4);
              if (!i6)
                return { notEnoughRoom: true };
              y3 = [i6];
            }
            for (const e5 of y3)
              t3.addDynamicAttributes(h4, e5.point, e5.angle);
            return {};
          }
          function ft(t4, e4, i5, s5, a5, o5) {
            const r5 = ct(t4.add(t4.sub(e4)._unit()), a5, o5).point, n3 = i5.sub(r5);
            return i5.add(n3._mult(s5 / n3.mag()));
          }
          function gt(e4, i5) {
            const { projectionCache: s5, lineVertexArray: a5, labelPlaneMatrix: o5, tileAnchorPoint: r5, distanceFromAnchor: n3, getElevation: l5, previousVertex: c5, direction: h4, absOffsetX: u5 } = i5;
            if (s5.projections[e4])
              return s5.projections[e4];
            const d4 = new t3.Point(a5.getx(e4), a5.gety(e4)), _4 = ct(d4, o5, l5);
            if (_4.signedDistanceFromCamera > 0)
              return s5.projections[e4] = _4.point, _4.point;
            const m4 = e4 - h4;
            return ft(0 === n3 ? r5 : new t3.Point(a5.getx(m4), a5.gety(m4)), d4, c5, u5 - n3 + 1, o5, l5);
          }
          function vt(t4, e4, i5) {
            return t4._unit()._perp()._mult(e4 * i5);
          }
          function xt(e4, i5, s5, a5, o5, r5, n3, l5) {
            const { projectionCache: c5, direction: h4 } = l5;
            if (c5.offsets[e4])
              return c5.offsets[e4];
            const u5 = s5.add(i5);
            if (e4 + h4 < a5 || e4 + h4 >= o5)
              return c5.offsets[e4] = u5, u5;
            const d4 = gt(e4 + h4, l5), _4 = vt(d4.sub(s5), n3, h4), m4 = s5.add(_4), p7 = d4.add(_4);
            return c5.offsets[e4] = t3.findLineIntersection(r5, u5, m4, p7) || u5, c5.offsets[e4];
          }
          function yt(t4, e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4, _4) {
            const m4 = s5 ? t4 - e4 : t4 + e4;
            let p7 = m4 > 0 ? 1 : -1, f4 = 0;
            s5 && (p7 *= -1, f4 = Math.PI), p7 < 0 && (f4 += Math.PI);
            let g4, v5, x3 = p7 > 0 ? n3 + r5 : n3 + r5 + 1, y3 = a5, b4 = a5, w4 = 0, T3 = 0;
            const E3 = Math.abs(m4), I3 = [];
            let S3;
            for (; w4 + T3 <= E3; ) {
              if (x3 += p7, x3 < n3 || x3 >= l5)
                return null;
              w4 += T3, b4 = y3, v5 = g4;
              const t5 = { projectionCache: u5, lineVertexArray: c5, labelPlaneMatrix: h4, tileAnchorPoint: o5, distanceFromAnchor: w4, getElevation: _4, previousVertex: b4, direction: p7, absOffsetX: E3 };
              if (y3 = gt(x3, t5), 0 === i5)
                I3.push(b4), S3 = y3.sub(b4);
              else {
                let e5;
                const s6 = y3.sub(b4);
                e5 = 0 === s6.mag() ? vt(gt(x3 + p7, t5).sub(y3), i5, p7) : vt(s6, i5, p7), v5 || (v5 = b4.add(e5)), g4 = xt(x3, e5, y3, n3, l5, v5, i5, t5), I3.push(v5), S3 = g4.sub(v5);
              }
              T3 = S3.mag();
            }
            const C2 = S3._mult((E3 - w4) / T3)._add(v5 || b4), P3 = f4 + Math.atan2(y3.y - b4.y, y3.x - b4.x);
            return I3.push(C2), { point: C2, angle: d4 ? P3 : 0, path: I3 };
          }
          const bt = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
          function wt(t4, e4) {
            for (let i5 = 0; i5 < t4; i5++) {
              const t5 = e4.length;
              e4.resize(t5 + 4), e4.float32.set(bt, 3 * t5);
            }
          }
          function Tt(t4, e4, i5) {
            const s5 = e4[0], a5 = e4[1];
            return t4[0] = i5[0] * s5 + i5[4] * a5 + i5[12], t4[1] = i5[1] * s5 + i5[5] * a5 + i5[13], t4[3] = i5[3] * s5 + i5[7] * a5 + i5[15], t4;
          }
          const Et = 100;
          class It {
            constructor(t4, e4 = new rt(t4.width + 200, t4.height + 200, 25), i5 = new rt(t4.width + 200, t4.height + 200, 25)) {
              this.transform = t4, this.grid = e4, this.ignoredGrid = i5, this.pitchfactor = Math.cos(t4._pitch) * t4.cameraToCenterDistance, this.screenRightBoundary = t4.width + Et, this.screenBottomBoundary = t4.height + Et, this.gridRightBoundary = t4.width + 200, this.gridBottomBoundary = t4.height + 200, this.perspectiveRatioCutoff = 0.6;
            }
            placeCollisionBox(t4, e4, i5, s5, a5, o5) {
              const r5 = this.projectAndGetPerspectiveRatio(s5, t4.anchorPointX, t4.anchorPointY, o5), n3 = i5 * r5.perspectiveRatio, l5 = t4.x1 * n3 + r5.point.x, c5 = t4.y1 * n3 + r5.point.y, h4 = t4.x2 * n3 + r5.point.x, u5 = t4.y2 * n3 + r5.point.y;
              return !this.isInsideGrid(l5, c5, h4, u5) || "always" !== e4 && this.grid.hitTest(l5, c5, h4, u5, e4, a5) || r5.perspectiveRatio < this.perspectiveRatioCutoff ? { box: [], offscreen: false } : { box: [l5, c5, h4, u5], offscreen: this.isOffscreen(l5, c5, h4, u5) };
            }
            placeCollisionCircles(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4, _4, m4) {
              const p7 = [], f4 = new t3.Point(i5.anchorX, i5.anchorY), g4 = ct(f4, r5, m4), v5 = ht(this.transform.cameraToCenterDistance, g4.signedDistanceFromCamera), x3 = (h4 ? o5 / v5 : o5 * v5) / t3.ONE_EM, y3 = ct(f4, n3, m4).point, b4 = _t(x3, a5, i5.lineOffsetX * x3, i5.lineOffsetY * x3, false, y3, f4, i5, s5, n3, { projections: {}, offsets: {} }, false, m4);
              let w4 = false, T3 = false, E3 = true;
              if (b4) {
                const i6 = 0.5 * d4 * v5 + _4, s6 = new t3.Point(-100, -100), a6 = new t3.Point(this.screenRightBoundary, this.screenBottomBoundary), o6 = new at(), r6 = b4.first, n4 = b4.last;
                let h5 = [];
                for (let t4 = r6.path.length - 1; t4 >= 1; t4--)
                  h5.push(r6.path[t4]);
                for (let t4 = 1; t4 < n4.path.length; t4++)
                  h5.push(n4.path[t4]);
                const f5 = 2.5 * i6;
                if (l5) {
                  const t4 = h5.map((t5) => ct(t5, l5, m4));
                  h5 = t4.some((t5) => t5.signedDistanceFromCamera <= 0) ? [] : t4.map((t5) => t5.point);
                }
                let g5 = [];
                if (h5.length > 0) {
                  const e5 = h5[0].clone(), i7 = h5[0].clone();
                  for (let t4 = 1; t4 < h5.length; t4++)
                    e5.x = Math.min(e5.x, h5[t4].x), e5.y = Math.min(e5.y, h5[t4].y), i7.x = Math.max(i7.x, h5[t4].x), i7.y = Math.max(i7.y, h5[t4].y);
                  g5 = e5.x >= s6.x && i7.x <= a6.x && e5.y >= s6.y && i7.y <= a6.y ? [h5] : i7.x < s6.x || e5.x > a6.x || i7.y < s6.y || e5.y > a6.y ? [] : t3.clipLine([h5], s6.x, s6.y, a6.x, a6.y);
                }
                for (const t4 of g5) {
                  o6.reset(t4, 0.25 * i6);
                  let s7 = 0;
                  s7 = o6.length <= 0.5 * i6 ? 1 : Math.ceil(o6.paddedLength / f5) + 1;
                  for (let t5 = 0; t5 < s7; t5++) {
                    const a7 = t5 / Math.max(s7 - 1, 1), r7 = o6.lerp(a7), n5 = r7.x + Et, l6 = r7.y + Et;
                    p7.push(n5, l6, i6, 0);
                    const h6 = n5 - i6, d5 = l6 - i6, _5 = n5 + i6, m5 = l6 + i6;
                    if (E3 = E3 && this.isOffscreen(h6, d5, _5, m5), T3 = T3 || this.isInsideGrid(h6, d5, _5, m5), "always" !== e4 && this.grid.hitTestCircle(n5, l6, i6, e4, u5) && (w4 = true, !c5))
                      return { circles: [], offscreen: false, collisionDetected: w4 };
                  }
                }
              }
              return { circles: !c5 && w4 || !T3 || v5 < this.perspectiveRatioCutoff ? [] : p7, offscreen: E3, collisionDetected: w4 };
            }
            queryRenderedSymbols(e4) {
              if (0 === e4.length || 0 === this.grid.keysLength() && 0 === this.ignoredGrid.keysLength())
                return {};
              const i5 = [];
              let s5 = 1 / 0, a5 = 1 / 0, o5 = -1 / 0, r5 = -1 / 0;
              for (const n4 of e4) {
                const e5 = new t3.Point(n4.x + Et, n4.y + Et);
                s5 = Math.min(s5, e5.x), a5 = Math.min(a5, e5.y), o5 = Math.max(o5, e5.x), r5 = Math.max(r5, e5.y), i5.push(e5);
              }
              const n3 = this.grid.query(s5, a5, o5, r5).concat(this.ignoredGrid.query(s5, a5, o5, r5)), l5 = {}, c5 = {};
              for (const e5 of n3) {
                const s6 = e5.key;
                if (void 0 === l5[s6.bucketInstanceId] && (l5[s6.bucketInstanceId] = {}), l5[s6.bucketInstanceId][s6.featureIndex])
                  continue;
                const a6 = [new t3.Point(e5.x1, e5.y1), new t3.Point(e5.x2, e5.y1), new t3.Point(e5.x2, e5.y2), new t3.Point(e5.x1, e5.y2)];
                t3.polygonIntersectsPolygon(i5, a6) && (l5[s6.bucketInstanceId][s6.featureIndex] = true, void 0 === c5[s6.bucketInstanceId] && (c5[s6.bucketInstanceId] = []), c5[s6.bucketInstanceId].push(s6.featureIndex));
              }
              return c5;
            }
            insertCollisionBox(t4, e4, i5, s5, a5, o5) {
              (i5 ? this.ignoredGrid : this.grid).insert({ bucketInstanceId: s5, featureIndex: a5, collisionGroupID: o5, overlapMode: e4 }, t4[0], t4[1], t4[2], t4[3]);
            }
            insertCollisionCircles(t4, e4, i5, s5, a5, o5) {
              const r5 = i5 ? this.ignoredGrid : this.grid, n3 = { bucketInstanceId: s5, featureIndex: a5, collisionGroupID: o5, overlapMode: e4 };
              for (let e5 = 0; e5 < t4.length; e5 += 4)
                r5.insertCircle(n3, t4[e5], t4[e5 + 1], t4[e5 + 2]);
            }
            projectAndGetPerspectiveRatio(e4, i5, s5, a5) {
              let o5;
              return a5 ? (o5 = [i5, s5, a5(i5, s5), 1], t3.transformMat4(o5, o5, e4)) : (o5 = [i5, s5, 0, 1], Tt(o5, o5, e4)), { point: new t3.Point((o5[0] / o5[3] + 1) / 2 * this.transform.width + Et, (-o5[1] / o5[3] + 1) / 2 * this.transform.height + Et), perspectiveRatio: 0.5 + this.transform.cameraToCenterDistance / o5[3] * 0.5 };
            }
            isOffscreen(t4, e4, i5, s5) {
              return i5 < Et || t4 >= this.screenRightBoundary || s5 < Et || e4 > this.screenBottomBoundary;
            }
            isInsideGrid(t4, e4, i5, s5) {
              return i5 >= 0 && t4 < this.gridRightBoundary && s5 >= 0 && e4 < this.gridBottomBoundary;
            }
            getViewportMatrix() {
              const e4 = t3.identity([]);
              return t3.translate(e4, e4, [-100, -100, 0]), e4;
            }
          }
          function St(e4, i5, s5) {
            return i5 * (t3.EXTENT / (e4.tileSize * Math.pow(2, s5 - e4.tileID.overscaledZ)));
          }
          class Ct {
            constructor(t4, e4, i5, s5) {
              this.opacity = t4 ? Math.max(0, Math.min(1, t4.opacity + (t4.placed ? e4 : -e4))) : s5 && i5 ? 1 : 0, this.placed = i5;
            }
            isHidden() {
              return 0 === this.opacity && !this.placed;
            }
          }
          class Pt {
            constructor(t4, e4, i5, s5, a5) {
              this.text = new Ct(t4 ? t4.text : null, e4, i5, a5), this.icon = new Ct(t4 ? t4.icon : null, e4, s5, a5);
            }
            isHidden() {
              return this.text.isHidden() && this.icon.isHidden();
            }
          }
          class Dt {
            constructor(t4, e4, i5) {
              this.text = t4, this.icon = e4, this.skipFade = i5;
            }
          }
          class Mt {
            constructor() {
              this.invProjMatrix = t3.create(), this.viewportMatrix = t3.create(), this.circles = [];
            }
          }
          class zt {
            constructor(t4, e4, i5, s5, a5) {
              this.bucketInstanceId = t4, this.featureIndex = e4, this.sourceLayerIndex = i5, this.bucketIndex = s5, this.tileID = a5;
            }
          }
          class At {
            constructor(t4) {
              this.crossSourceCollisions = t4, this.maxGroupID = 0, this.collisionGroups = {};
            }
            get(t4) {
              if (this.crossSourceCollisions)
                return { ID: 0, predicate: null };
              if (!this.collisionGroups[t4]) {
                const e4 = ++this.maxGroupID;
                this.collisionGroups[t4] = { ID: e4, predicate: (t5) => t5.collisionGroupID === e4 };
              }
              return this.collisionGroups[t4];
            }
          }
          function Lt(e4, i5, s5, a5, o5) {
            const { horizontalAlign: r5, verticalAlign: n3 } = t3.getAnchorAlignment(e4);
            return new t3.Point(-(r5 - 0.5) * i5 + a5[0] * o5, -(n3 - 0.5) * s5 + a5[1] * o5);
          }
          function Rt(e4, i5, s5, a5, o5, r5) {
            const { x1: n3, x2: l5, y1: c5, y2: h4, anchorPointX: u5, anchorPointY: d4 } = e4, _4 = new t3.Point(i5, s5);
            return a5 && _4._rotate(o5 ? r5 : -r5), { x1: n3 + _4.x, y1: c5 + _4.y, x2: l5 + _4.x, y2: h4 + _4.y, anchorPointX: u5, anchorPointY: d4 };
          }
          class kt {
            constructor(t4, e4, i5, s5, a5) {
              this.transform = t4.clone(), this.terrain = e4, this.collisionIndex = new It(this.transform), this.placements = {}, this.opacities = {}, this.variableOffsets = {}, this.stale = false, this.commitTime = 0, this.fadeDuration = i5, this.retainedQueryData = {}, this.collisionGroups = new At(s5), this.collisionCircleArrays = {}, this.prevPlacement = a5, a5 && (a5.prevPlacement = void 0), this.placedOrientations = {};
            }
            getBucketParts(e4, i5, s5, a5) {
              const o5 = s5.getBucket(i5), r5 = s5.latestFeatureIndex;
              if (!o5 || !r5 || i5.id !== o5.layerIds[0])
                return;
              const n3 = s5.collisionBoxArray, l5 = o5.layers[0].layout, c5 = Math.pow(2, this.transform.zoom - s5.tileID.overscaledZ), h4 = s5.tileSize / t3.EXTENT, u5 = this.transform.calculatePosMatrix(s5.tileID.toUnwrapped()), d4 = "map" === l5.get("text-pitch-alignment"), _4 = "map" === l5.get("text-rotation-alignment"), m4 = St(s5, 1, this.transform.zoom), p7 = nt(u5, d4, _4, this.transform, m4);
              let f4 = null;
              if (d4) {
                const e5 = lt(u5, d4, _4, this.transform, m4);
                f4 = t3.multiply([], this.transform.labelPlaneMatrix, e5);
              }
              this.retainedQueryData[o5.bucketInstanceId] = new zt(o5.bucketInstanceId, r5, o5.sourceLayerIndex, o5.index, s5.tileID);
              const g4 = { bucket: o5, layout: l5, posMatrix: u5, textLabelPlaneMatrix: p7, labelToScreenMatrix: f4, scale: c5, textPixelRatio: h4, holdingForFade: s5.holdingForFade(), collisionBoxArray: n3, partiallyEvaluatedTextSize: t3.evaluateSizeForZoom(o5.textSizeData, this.transform.zoom), collisionGroup: this.collisionGroups.get(o5.sourceID) };
              if (a5)
                for (const t4 of o5.sortKeyRanges) {
                  const { sortKey: i6, symbolInstanceStart: s6, symbolInstanceEnd: a6 } = t4;
                  e4.push({ sortKey: i6, symbolInstanceStart: s6, symbolInstanceEnd: a6, parameters: g4 });
                }
              else
                e4.push({ symbolInstanceStart: 0, symbolInstanceEnd: o5.symbolInstances.length, parameters: g4 });
            }
            attemptAnchorPlacement(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4, _4, m4, p7, f4) {
              const g4 = t3.TextAnchorEnum[e4.textAnchor], v5 = [e4.textOffset0, e4.textOffset1], x3 = Lt(g4, s5, a5, v5, o5), y3 = this.collisionIndex.placeCollisionBox(Rt(i5, x3.x, x3.y, r5, n3, this.transform.angle), u5, l5, c5, h4.predicate, f4);
              if ((!p7 || 0 !== this.collisionIndex.placeCollisionBox(Rt(p7, x3.x, x3.y, r5, n3, this.transform.angle), u5, l5, c5, h4.predicate, f4).box.length) && y3.box.length > 0) {
                let t4;
                if (this.prevPlacement && this.prevPlacement.variableOffsets[d4.crossTileID] && this.prevPlacement.placements[d4.crossTileID] && this.prevPlacement.placements[d4.crossTileID].text && (t4 = this.prevPlacement.variableOffsets[d4.crossTileID].anchor), 0 === d4.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                return this.variableOffsets[d4.crossTileID] = { textOffset: v5, width: s5, height: a5, anchor: g4, textBoxScale: o5, prevAnchor: t4 }, this.markUsedJustification(_4, g4, d4, m4), _4.allowVerticalPlacement && (this.markUsedOrientation(_4, m4, d4), this.placedOrientations[d4.crossTileID] = m4), { shift: x3, placedGlyphBoxes: y3 };
              }
            }
            placeLayerBucketPart(e4, i5, s5) {
              const { bucket: a5, layout: o5, posMatrix: r5, textLabelPlaneMatrix: n3, labelToScreenMatrix: l5, textPixelRatio: c5, holdingForFade: h4, collisionBoxArray: u5, partiallyEvaluatedTextSize: d4, collisionGroup: _4 } = e4.parameters, m4 = o5.get("text-optional"), p7 = o5.get("icon-optional"), f4 = t3.getOverlapMode(o5, "text-overlap", "text-allow-overlap"), g4 = "always" === f4, v5 = t3.getOverlapMode(o5, "icon-overlap", "icon-allow-overlap"), x3 = "always" === v5, y3 = "map" === o5.get("text-rotation-alignment"), b4 = "map" === o5.get("text-pitch-alignment"), w4 = "none" !== o5.get("icon-text-fit"), T3 = "viewport-y" === o5.get("symbol-z-order"), E3 = g4 && (x3 || !a5.hasIconData() || p7), I3 = x3 && (g4 || !a5.hasTextData() || m4);
              !a5.collisionArrays && u5 && a5.deserializeCollisionBoxes(u5);
              const S3 = this.retainedQueryData[a5.bucketInstanceId].tileID, C2 = this.terrain ? (t4, e5) => this.terrain.getElevation(S3, t4, e5) : null, P3 = (e5, u6) => {
                var x4, T4;
                if (i5[e5.crossTileID])
                  return;
                if (h4)
                  return void (this.placements[e5.crossTileID] = new Dt(false, false, false));
                let S4 = false, P4 = false, D3 = true, M3 = null, z4 = { box: null, offscreen: null }, A3 = { box: null, offscreen: null }, L3 = null, R2 = null, k4 = null, F4 = 0, B4 = 0, U2 = 0;
                u6.textFeatureIndex ? F4 = u6.textFeatureIndex : e5.useRuntimeCollisionCircles && (F4 = e5.featureIndex), u6.verticalTextFeatureIndex && (B4 = u6.verticalTextFeatureIndex);
                const O3 = u6.textBox;
                if (O3) {
                  const i6 = (i7) => {
                    let s7 = t3.WritingMode.horizontal;
                    if (a5.allowVerticalPlacement && !i7 && this.prevPlacement) {
                      const t4 = this.prevPlacement.placedOrientations[e5.crossTileID];
                      t4 && (this.placedOrientations[e5.crossTileID] = t4, s7 = t4, this.markUsedOrientation(a5, s7, e5));
                    }
                    return s7;
                  }, s6 = (i7, s7) => {
                    if (a5.allowVerticalPlacement && e5.numVerticalGlyphVertices > 0 && u6.verticalTextBox) {
                      for (const e6 of a5.writingModes)
                        if (e6 === t3.WritingMode.vertical ? (z4 = s7(), A3 = z4) : z4 = i7(), z4 && z4.box && z4.box.length)
                          break;
                    } else
                      z4 = i7();
                  }, o6 = e5.textAnchorOffsetStartIndex, n4 = e5.textAnchorOffsetEndIndex;
                  if (n4 === o6) {
                    const o7 = (t4, i7) => {
                      const s7 = this.collisionIndex.placeCollisionBox(t4, f4, c5, r5, _4.predicate, C2);
                      return s7 && s7.box && s7.box.length && (this.markUsedOrientation(a5, i7, e5), this.placedOrientations[e5.crossTileID] = i7), s7;
                    };
                    s6(() => o7(O3, t3.WritingMode.horizontal), () => {
                      const i7 = u6.verticalTextBox;
                      return a5.allowVerticalPlacement && e5.numVerticalGlyphVertices > 0 && i7 ? o7(i7, t3.WritingMode.vertical) : { box: null, offscreen: null };
                    }), i6(z4 && z4.box && z4.box.length);
                  } else {
                    let l6 = t3.TextAnchorEnum[null === (T4 = null === (x4 = this.prevPlacement) || void 0 === x4 ? void 0 : x4.variableOffsets[e5.crossTileID]) || void 0 === T4 ? void 0 : T4.anchor];
                    const h5 = (t4, i7, s7) => {
                      const h6 = t4.x2 - t4.x1, u7 = t4.y2 - t4.y1, d6 = e5.textBoxScale, m5 = w4 && "never" === v5 ? i7 : null;
                      let p8 = { box: [], offscreen: false }, g5 = "never" === f4 ? 1 : 2, x5 = "never";
                      l6 && g5++;
                      for (let i8 = 0; i8 < g5; i8++) {
                        for (let i9 = o6; i9 < n4; i9++) {
                          const o7 = a5.textAnchorOffsets.get(i9);
                          if (l6 && o7.textAnchor !== l6)
                            continue;
                          const n5 = this.attemptAnchorPlacement(o7, t4, h6, u7, d6, y3, b4, c5, r5, _4, x5, e5, a5, s7, m5, C2);
                          if (n5 && (p8 = n5.placedGlyphBoxes, p8 && p8.box && p8.box.length))
                            return S4 = true, M3 = n5.shift, p8;
                        }
                        l6 ? l6 = null : x5 = f4;
                      }
                      return p8;
                    };
                    s6(() => h5(O3, u6.iconBox, t3.WritingMode.horizontal), () => {
                      const i7 = u6.verticalTextBox;
                      return a5.allowVerticalPlacement && !(z4 && z4.box && z4.box.length) && e5.numVerticalGlyphVertices > 0 && i7 ? h5(i7, u6.verticalIconBox, t3.WritingMode.vertical) : { box: null, offscreen: null };
                    }), z4 && (S4 = z4.box, D3 = z4.offscreen);
                    const d5 = i6(z4 && z4.box);
                    if (!S4 && this.prevPlacement) {
                      const t4 = this.prevPlacement.variableOffsets[e5.crossTileID];
                      t4 && (this.variableOffsets[e5.crossTileID] = t4, this.markUsedJustification(a5, t4.anchor, e5, d5));
                    }
                  }
                }
                if (L3 = z4, S4 = L3 && L3.box && L3.box.length > 0, D3 = L3 && L3.offscreen, e5.useRuntimeCollisionCircles) {
                  const i6 = a5.text.placedSymbolArray.get(e5.centerJustifiedTextSymbolIndex), c6 = t3.evaluateSizeForFeature(a5.textSizeData, d4, i6), h5 = o5.get("text-padding");
                  R2 = this.collisionIndex.placeCollisionCircles(f4, i6, a5.lineVertexArray, a5.glyphOffsetArray, c6, r5, n3, l5, s5, b4, _4.predicate, e5.collisionCircleDiameter, h5, C2), R2.circles.length && R2.collisionDetected && !s5 && t3.warnOnce("Collisions detected, but collision boxes are not shown"), S4 = g4 || R2.circles.length > 0 && !R2.collisionDetected, D3 = D3 && R2.offscreen;
                }
                if (u6.iconFeatureIndex && (U2 = u6.iconFeatureIndex), u6.iconBox) {
                  const t4 = (t5) => {
                    const e6 = w4 && M3 ? Rt(t5, M3.x, M3.y, y3, b4, this.transform.angle) : t5;
                    return this.collisionIndex.placeCollisionBox(e6, v5, c5, r5, _4.predicate, C2);
                  };
                  A3 && A3.box && A3.box.length && u6.verticalIconBox ? (k4 = t4(u6.verticalIconBox), P4 = k4.box.length > 0) : (k4 = t4(u6.iconBox), P4 = k4.box.length > 0), D3 = D3 && k4.offscreen;
                }
                const N3 = m4 || 0 === e5.numHorizontalGlyphVertices && 0 === e5.numVerticalGlyphVertices, Z2 = p7 || 0 === e5.numIconVertices;
                if (N3 || Z2 ? Z2 ? N3 || (P4 = P4 && S4) : S4 = P4 && S4 : P4 = S4 = P4 && S4, S4 && L3 && L3.box && this.collisionIndex.insertCollisionBox(L3.box, f4, o5.get("text-ignore-placement"), a5.bucketInstanceId, A3 && A3.box && B4 ? B4 : F4, _4.ID), P4 && k4 && this.collisionIndex.insertCollisionBox(k4.box, v5, o5.get("icon-ignore-placement"), a5.bucketInstanceId, U2, _4.ID), R2 && (S4 && this.collisionIndex.insertCollisionCircles(R2.circles, f4, o5.get("text-ignore-placement"), a5.bucketInstanceId, F4, _4.ID), s5)) {
                  const t4 = a5.bucketInstanceId;
                  let e6 = this.collisionCircleArrays[t4];
                  void 0 === e6 && (e6 = this.collisionCircleArrays[t4] = new Mt());
                  for (let t5 = 0; t5 < R2.circles.length; t5 += 4)
                    e6.circles.push(R2.circles[t5 + 0]), e6.circles.push(R2.circles[t5 + 1]), e6.circles.push(R2.circles[t5 + 2]), e6.circles.push(R2.collisionDetected ? 1 : 0);
                }
                if (0 === e5.crossTileID)
                  throw new Error("symbolInstance.crossTileID can't be 0");
                if (0 === a5.bucketInstanceId)
                  throw new Error("bucket.bucketInstanceId can't be 0");
                this.placements[e5.crossTileID] = new Dt(S4 || E3, P4 || I3, D3 || a5.justReloaded), i5[e5.crossTileID] = true;
              };
              if (T3) {
                if (0 !== e4.symbolInstanceStart)
                  throw new Error("bucket.bucketInstanceId should be 0");
                const t4 = a5.getSortedSymbolIndexes(this.transform.angle);
                for (let e5 = t4.length - 1; e5 >= 0; --e5) {
                  const i6 = t4[e5];
                  P3(a5.symbolInstances.get(i6), a5.collisionArrays[i6]);
                }
              } else
                for (let t4 = e4.symbolInstanceStart; t4 < e4.symbolInstanceEnd; t4++)
                  P3(a5.symbolInstances.get(t4), a5.collisionArrays[t4]);
              if (s5 && a5.bucketInstanceId in this.collisionCircleArrays) {
                const e5 = this.collisionCircleArrays[a5.bucketInstanceId];
                t3.invert(e5.invProjMatrix, r5), e5.viewportMatrix = this.collisionIndex.getViewportMatrix();
              }
              a5.justReloaded = false;
            }
            markUsedJustification(e4, i5, s5, a5) {
              let o5;
              o5 = a5 === t3.WritingMode.vertical ? s5.verticalPlacedTextSymbolIndex : { left: s5.leftJustifiedTextSymbolIndex, center: s5.centerJustifiedTextSymbolIndex, right: s5.rightJustifiedTextSymbolIndex }[t3.getAnchorJustification(i5)];
              const r5 = [s5.leftJustifiedTextSymbolIndex, s5.centerJustifiedTextSymbolIndex, s5.rightJustifiedTextSymbolIndex, s5.verticalPlacedTextSymbolIndex];
              for (const t4 of r5)
                t4 >= 0 && (e4.text.placedSymbolArray.get(t4).crossTileID = o5 >= 0 && t4 !== o5 ? 0 : s5.crossTileID);
            }
            markUsedOrientation(e4, i5, s5) {
              const a5 = i5 === t3.WritingMode.horizontal || i5 === t3.WritingMode.horizontalOnly ? i5 : 0, o5 = i5 === t3.WritingMode.vertical ? i5 : 0, r5 = [s5.leftJustifiedTextSymbolIndex, s5.centerJustifiedTextSymbolIndex, s5.rightJustifiedTextSymbolIndex];
              for (const t4 of r5)
                e4.text.placedSymbolArray.get(t4).placedOrientation = a5;
              s5.verticalPlacedTextSymbolIndex && (e4.text.placedSymbolArray.get(s5.verticalPlacedTextSymbolIndex).placedOrientation = o5);
            }
            commit(t4) {
              this.commitTime = t4, this.zoomAtLastRecencyCheck = this.transform.zoom;
              const e4 = this.prevPlacement;
              let i5 = false;
              this.prevZoomAdjustment = e4 ? e4.zoomAdjustment(this.transform.zoom) : 0;
              const s5 = e4 ? e4.symbolFadeChange(t4) : 1, a5 = e4 ? e4.opacities : {}, o5 = e4 ? e4.variableOffsets : {}, r5 = e4 ? e4.placedOrientations : {};
              for (const t5 in this.placements) {
                const e5 = this.placements[t5], o6 = a5[t5];
                o6 ? (this.opacities[t5] = new Pt(o6, s5, e5.text, e5.icon), i5 = i5 || e5.text !== o6.text.placed || e5.icon !== o6.icon.placed) : (this.opacities[t5] = new Pt(null, s5, e5.text, e5.icon, e5.skipFade), i5 = i5 || e5.text || e5.icon);
              }
              for (const t5 in a5) {
                const e5 = a5[t5];
                if (!this.opacities[t5]) {
                  const a6 = new Pt(e5, s5, false, false);
                  a6.isHidden() || (this.opacities[t5] = a6, i5 = i5 || e5.text.placed || e5.icon.placed);
                }
              }
              for (const t5 in o5)
                this.variableOffsets[t5] || !this.opacities[t5] || this.opacities[t5].isHidden() || (this.variableOffsets[t5] = o5[t5]);
              for (const t5 in r5)
                this.placedOrientations[t5] || !this.opacities[t5] || this.opacities[t5].isHidden() || (this.placedOrientations[t5] = r5[t5]);
              if (e4 && void 0 === e4.lastPlacementChangeTime)
                throw new Error("Last placement time for previous placement is not defined");
              i5 ? this.lastPlacementChangeTime = t4 : "number" != typeof this.lastPlacementChangeTime && (this.lastPlacementChangeTime = e4 ? e4.lastPlacementChangeTime : t4);
            }
            updateLayerOpacities(t4, e4) {
              const i5 = {};
              for (const s5 of e4) {
                const e5 = s5.getBucket(t4);
                e5 && s5.latestFeatureIndex && t4.id === e5.layerIds[0] && this.updateBucketOpacities(e5, i5, s5.collisionBoxArray);
              }
            }
            updateBucketOpacities(e4, i5, s5) {
              e4.hasTextData() && (e4.text.opacityVertexArray.clear(), e4.text.hasVisibleVertices = false), e4.hasIconData() && (e4.icon.opacityVertexArray.clear(), e4.icon.hasVisibleVertices = false), e4.hasIconCollisionBoxData() && e4.iconCollisionBox.collisionVertexArray.clear(), e4.hasTextCollisionBoxData() && e4.textCollisionBox.collisionVertexArray.clear();
              const a5 = e4.layers[0], o5 = a5.layout, r5 = new Pt(null, 0, false, false, true), n3 = o5.get("text-allow-overlap"), l5 = o5.get("icon-allow-overlap"), c5 = a5._unevaluatedLayout.hasValue("text-variable-anchor") || a5._unevaluatedLayout.hasValue("text-variable-anchor-offset"), h4 = "map" === o5.get("text-rotation-alignment"), u5 = "map" === o5.get("text-pitch-alignment"), d4 = "none" !== o5.get("icon-text-fit"), _4 = new Pt(null, 0, n3 && (l5 || !e4.hasIconData() || o5.get("icon-optional")), l5 && (n3 || !e4.hasTextData() || o5.get("text-optional")), true);
              !e4.collisionArrays && s5 && (e4.hasIconCollisionBoxData() || e4.hasTextCollisionBoxData()) && e4.deserializeCollisionBoxes(s5);
              const m4 = (t4, e5, i6) => {
                for (let s6 = 0; s6 < e5 / 4; s6++)
                  t4.opacityVertexArray.emplaceBack(i6);
                t4.hasVisibleVertices = t4.hasVisibleVertices || i6 !== jt;
              };
              for (let s6 = 0; s6 < e4.symbolInstances.length; s6++) {
                const a6 = e4.symbolInstances.get(s6), { numHorizontalGlyphVertices: o6, numVerticalGlyphVertices: n4, crossTileID: l6 } = a6;
                let p7 = this.opacities[l6];
                i5[l6] ? p7 = r5 : p7 || (p7 = _4, this.opacities[l6] = p7), i5[l6] = true;
                const f4 = a6.numIconVertices > 0, g4 = this.placedOrientations[a6.crossTileID], v5 = g4 === t3.WritingMode.vertical, x3 = g4 === t3.WritingMode.horizontal || g4 === t3.WritingMode.horizontalOnly;
                if (o6 > 0 || n4 > 0) {
                  const t4 = qt(p7.text);
                  m4(e4.text, o6, v5 ? jt : t4), m4(e4.text, n4, x3 ? jt : t4);
                  const i6 = p7.text.isHidden();
                  [a6.rightJustifiedTextSymbolIndex, a6.centerJustifiedTextSymbolIndex, a6.leftJustifiedTextSymbolIndex].forEach((t5) => {
                    t5 >= 0 && (e4.text.placedSymbolArray.get(t5).hidden = i6 || v5 ? 1 : 0);
                  }), a6.verticalPlacedTextSymbolIndex >= 0 && (e4.text.placedSymbolArray.get(a6.verticalPlacedTextSymbolIndex).hidden = i6 || x3 ? 1 : 0);
                  const s7 = this.variableOffsets[a6.crossTileID];
                  s7 && this.markUsedJustification(e4, s7.anchor, a6, g4);
                  const r6 = this.placedOrientations[a6.crossTileID];
                  r6 && (this.markUsedJustification(e4, "left", a6, r6), this.markUsedOrientation(e4, r6, a6));
                }
                if (f4) {
                  const t4 = qt(p7.icon), i6 = !(d4 && a6.verticalPlacedIconSymbolIndex && v5);
                  a6.placedIconSymbolIndex >= 0 && (m4(e4.icon, a6.numIconVertices, i6 ? t4 : jt), e4.icon.placedSymbolArray.get(a6.placedIconSymbolIndex).hidden = p7.icon.isHidden()), a6.verticalPlacedIconSymbolIndex >= 0 && (m4(e4.icon, a6.numVerticalIconVertices, i6 ? jt : t4), e4.icon.placedSymbolArray.get(a6.verticalPlacedIconSymbolIndex).hidden = p7.icon.isHidden());
                }
                if (e4.hasIconCollisionBoxData() || e4.hasTextCollisionBoxData()) {
                  const i6 = e4.collisionArrays[s6];
                  if (i6) {
                    let s7 = new t3.Point(0, 0);
                    if (i6.textBox || i6.verticalTextBox) {
                      let t4 = true;
                      if (c5) {
                        const e5 = this.variableOffsets[l6];
                        e5 ? (s7 = Lt(e5.anchor, e5.width, e5.height, e5.textOffset, e5.textBoxScale), h4 && s7._rotate(u5 ? this.transform.angle : -this.transform.angle)) : t4 = false;
                      }
                      i6.textBox && Ft(e4.textCollisionBox.collisionVertexArray, p7.text.placed, !t4 || v5, s7.x, s7.y), i6.verticalTextBox && Ft(e4.textCollisionBox.collisionVertexArray, p7.text.placed, !t4 || x3, s7.x, s7.y);
                    }
                    const a7 = Boolean(!x3 && i6.verticalIconBox);
                    i6.iconBox && Ft(e4.iconCollisionBox.collisionVertexArray, p7.icon.placed, a7, d4 ? s7.x : 0, d4 ? s7.y : 0), i6.verticalIconBox && Ft(e4.iconCollisionBox.collisionVertexArray, p7.icon.placed, !a7, d4 ? s7.x : 0, d4 ? s7.y : 0);
                  }
                }
              }
              if (e4.sortFeatures(this.transform.angle), this.retainedQueryData[e4.bucketInstanceId] && (this.retainedQueryData[e4.bucketInstanceId].featureSortOrder = e4.featureSortOrder), e4.hasTextData() && e4.text.opacityVertexBuffer && e4.text.opacityVertexBuffer.updateData(e4.text.opacityVertexArray), e4.hasIconData() && e4.icon.opacityVertexBuffer && e4.icon.opacityVertexBuffer.updateData(e4.icon.opacityVertexArray), e4.hasIconCollisionBoxData() && e4.iconCollisionBox.collisionVertexBuffer && e4.iconCollisionBox.collisionVertexBuffer.updateData(e4.iconCollisionBox.collisionVertexArray), e4.hasTextCollisionBoxData() && e4.textCollisionBox.collisionVertexBuffer && e4.textCollisionBox.collisionVertexBuffer.updateData(e4.textCollisionBox.collisionVertexArray), e4.text.opacityVertexArray.length !== e4.text.layoutVertexArray.length / 4)
                throw new Error(`bucket.text.opacityVertexArray.length (= ${e4.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e4.text.layoutVertexArray.length}) / 4`);
              if (e4.icon.opacityVertexArray.length !== e4.icon.layoutVertexArray.length / 4)
                throw new Error(`bucket.icon.opacityVertexArray.length (= ${e4.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e4.icon.layoutVertexArray.length}) / 4`);
              if (e4.bucketInstanceId in this.collisionCircleArrays) {
                const t4 = this.collisionCircleArrays[e4.bucketInstanceId];
                e4.placementInvProjMatrix = t4.invProjMatrix, e4.placementViewportMatrix = t4.viewportMatrix, e4.collisionCircleArray = t4.circles, delete this.collisionCircleArrays[e4.bucketInstanceId];
              }
            }
            symbolFadeChange(t4) {
              return 0 === this.fadeDuration ? 1 : (t4 - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment;
            }
            zoomAdjustment(t4) {
              return Math.max(0, (this.transform.zoom - t4) / 1.5);
            }
            hasTransitions(t4) {
              return this.stale || t4 - this.lastPlacementChangeTime < this.fadeDuration;
            }
            stillRecent(t4, e4) {
              const i5 = this.zoomAtLastRecencyCheck === e4 ? 1 - this.zoomAdjustment(e4) : 1;
              return this.zoomAtLastRecencyCheck = e4, this.commitTime + this.fadeDuration * i5 > t4;
            }
            setStale() {
              this.stale = true;
            }
          }
          function Ft(t4, e4, i5, s5, a5) {
            t4.emplaceBack(e4 ? 1 : 0, i5 ? 1 : 0, s5 || 0, a5 || 0), t4.emplaceBack(e4 ? 1 : 0, i5 ? 1 : 0, s5 || 0, a5 || 0), t4.emplaceBack(e4 ? 1 : 0, i5 ? 1 : 0, s5 || 0, a5 || 0), t4.emplaceBack(e4 ? 1 : 0, i5 ? 1 : 0, s5 || 0, a5 || 0);
          }
          const Bt = Math.pow(2, 25), Ut = Math.pow(2, 24), Ot = Math.pow(2, 17), Nt = Math.pow(2, 16), Zt = Math.pow(2, 9), Gt = Math.pow(2, 8), Vt = Math.pow(2, 1);
          function qt(t4) {
            if (0 === t4.opacity && !t4.placed)
              return 0;
            if (1 === t4.opacity && t4.placed)
              return 4294967295;
            const e4 = t4.placed ? 1 : 0, i5 = Math.floor(127 * t4.opacity);
            return i5 * Bt + e4 * Ut + i5 * Ot + e4 * Nt + i5 * Zt + e4 * Gt + i5 * Vt + e4;
          }
          const jt = 0;
          class $t {
            constructor(t4) {
              this._sortAcrossTiles = "viewport-y" !== t4.layout.get("symbol-z-order") && !t4.layout.get("symbol-sort-key").isConstant(), this._currentTileIndex = 0, this._currentPartIndex = 0, this._seenCrossTileIDs = {}, this._bucketParts = [];
            }
            continuePlacement(t4, e4, i5, s5, a5) {
              const o5 = this._bucketParts;
              for (; this._currentTileIndex < t4.length; )
                if (e4.getBucketParts(o5, s5, t4[this._currentTileIndex], this._sortAcrossTiles), this._currentTileIndex++, a5())
                  return true;
              for (this._sortAcrossTiles && (this._sortAcrossTiles = false, o5.sort((t5, e5) => t5.sortKey - e5.sortKey)); this._currentPartIndex < o5.length; )
                if (e4.placeLayerBucketPart(o5[this._currentPartIndex], this._seenCrossTileIDs, i5), this._currentPartIndex++, a5())
                  return true;
              return false;
            }
          }
          class Xt {
            constructor(t4, e4, i5, s5, a5, o5, r5, n3) {
              this.placement = new kt(t4, e4, o5, r5, n3), this._currentPlacementIndex = i5.length - 1, this._forceFullPlacement = s5, this._showCollisionBoxes = a5, this._done = false;
            }
            isDone() {
              return this._done;
            }
            continuePlacement(e4, i5, s5) {
              const a5 = t3.browser.now(), o5 = () => !this._forceFullPlacement && t3.browser.now() - a5 > 2;
              for (; this._currentPlacementIndex >= 0; ) {
                const t4 = i5[e4[this._currentPlacementIndex]], a6 = this.placement.collisionIndex.transform.zoom;
                if ("symbol" === t4.type && (!t4.minzoom || t4.minzoom <= a6) && (!t4.maxzoom || t4.maxzoom > a6)) {
                  if (this._inProgressLayer || (this._inProgressLayer = new $t(t4)), this._inProgressLayer.continuePlacement(s5[t4.source], this.placement, this._showCollisionBoxes, t4, o5))
                    return;
                  delete this._inProgressLayer;
                }
                this._currentPlacementIndex--;
              }
              this._done = true;
            }
            commit(t4) {
              return this.placement.commit(t4), this.placement;
            }
          }
          const Wt = 512 / t3.EXTENT / 2;
          class Ht {
            constructor(e4, i5, s5) {
              this.tileID = e4, this.bucketInstanceId = s5, this._symbolsByKey = {};
              const a5 = /* @__PURE__ */ new Map();
              for (let t4 = 0; t4 < i5.length; t4++) {
                const e5 = i5.get(t4), s6 = e5.key, o5 = a5.get(s6);
                o5 ? o5.push(e5) : a5.set(s6, [e5]);
              }
              for (const [e5, i6] of a5) {
                const s6 = { positions: i6.map((t4) => ({ x: Math.floor(t4.anchorX * Wt), y: Math.floor(t4.anchorY * Wt) })), crossTileIDs: i6.map((t4) => t4.crossTileID) };
                if (s6.positions.length > 128) {
                  const e6 = new t3.KDBush(s6.positions.length, 16, Uint16Array);
                  for (const { x: t4, y: i7 } of s6.positions)
                    e6.add(t4, i7);
                  e6.finish(), delete s6.positions, s6.index = e6;
                }
                this._symbolsByKey[e5] = s6;
              }
            }
            getScaledCoordinates(e4, i5) {
              const { x: s5, y: a5, z: o5 } = this.tileID.canonical, { x: r5, y: n3, z: l5 } = i5.canonical, c5 = Wt / Math.pow(2, l5 - o5), h4 = (n3 * t3.EXTENT + e4.anchorY) * c5, u5 = a5 * t3.EXTENT * Wt;
              return { x: Math.floor((r5 * t3.EXTENT + e4.anchorX) * c5 - s5 * t3.EXTENT * Wt), y: Math.floor(h4 - u5) };
            }
            findMatches(t4, e4, i5) {
              const s5 = this.tileID.canonical.z < e4.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - e4.canonical.z);
              for (let a5 = 0; a5 < t4.length; a5++) {
                const o5 = t4.get(a5);
                if (o5.crossTileID)
                  continue;
                const r5 = this._symbolsByKey[o5.key];
                if (!r5)
                  continue;
                const n3 = this.getScaledCoordinates(o5, e4);
                if (r5.index) {
                  const t5 = r5.index.range(n3.x - s5, n3.y - s5, n3.x + s5, n3.y + s5).sort();
                  for (const e5 of t5) {
                    const t6 = r5.crossTileIDs[e5];
                    if (!i5[t6]) {
                      i5[t6] = true, o5.crossTileID = t6;
                      break;
                    }
                  }
                } else if (r5.positions)
                  for (let t5 = 0; t5 < r5.positions.length; t5++) {
                    const e5 = r5.positions[t5], a6 = r5.crossTileIDs[t5];
                    if (Math.abs(e5.x - n3.x) <= s5 && Math.abs(e5.y - n3.y) <= s5 && !i5[a6]) {
                      i5[a6] = true, o5.crossTileID = a6;
                      break;
                    }
                  }
              }
            }
            getCrossTileIDsLists() {
              return Object.values(this._symbolsByKey).map(({ crossTileIDs: t4 }) => t4);
            }
          }
          class Kt {
            constructor() {
              this.maxCrossTileID = 0;
            }
            generate() {
              return ++this.maxCrossTileID;
            }
          }
          class Yt {
            constructor() {
              this.indexes = {}, this.usedCrossTileIDs = {}, this.lng = 0;
            }
            handleWrapJump(t4) {
              const e4 = Math.round((t4 - this.lng) / 360);
              if (0 !== e4)
                for (const t5 in this.indexes) {
                  const i5 = this.indexes[t5], s5 = {};
                  for (const t6 in i5) {
                    const a5 = i5[t6];
                    a5.tileID = a5.tileID.unwrapTo(a5.tileID.wrap + e4), s5[a5.tileID.key] = a5;
                  }
                  this.indexes[t5] = s5;
                }
              this.lng = t4;
            }
            addBucket(t4, e4, i5) {
              if (this.indexes[t4.overscaledZ] && this.indexes[t4.overscaledZ][t4.key]) {
                if (this.indexes[t4.overscaledZ][t4.key].bucketInstanceId === e4.bucketInstanceId)
                  return false;
                this.removeBucketCrossTileIDs(t4.overscaledZ, this.indexes[t4.overscaledZ][t4.key]);
              }
              for (let t5 = 0; t5 < e4.symbolInstances.length; t5++)
                e4.symbolInstances.get(t5).crossTileID = 0;
              this.usedCrossTileIDs[t4.overscaledZ] || (this.usedCrossTileIDs[t4.overscaledZ] = {});
              const s5 = this.usedCrossTileIDs[t4.overscaledZ];
              for (const i6 in this.indexes) {
                const a5 = this.indexes[i6];
                if (Number(i6) > t4.overscaledZ)
                  for (const i7 in a5) {
                    const o5 = a5[i7];
                    o5.tileID.isChildOf(t4) && o5.findMatches(e4.symbolInstances, t4, s5);
                  }
                else {
                  const o5 = a5[t4.scaledTo(Number(i6)).key];
                  o5 && o5.findMatches(e4.symbolInstances, t4, s5);
                }
              }
              for (let t5 = 0; t5 < e4.symbolInstances.length; t5++) {
                const a5 = e4.symbolInstances.get(t5);
                a5.crossTileID || (a5.crossTileID = i5.generate(), s5[a5.crossTileID] = true);
              }
              return void 0 === this.indexes[t4.overscaledZ] && (this.indexes[t4.overscaledZ] = {}), this.indexes[t4.overscaledZ][t4.key] = new Ht(t4, e4.symbolInstances, e4.bucketInstanceId), true;
            }
            removeBucketCrossTileIDs(t4, e4) {
              for (const i5 of e4.getCrossTileIDsLists())
                for (const e5 of i5)
                  delete this.usedCrossTileIDs[t4][e5];
            }
            removeStaleBuckets(t4) {
              let e4 = false;
              for (const i5 in this.indexes) {
                const s5 = this.indexes[i5];
                for (const a5 in s5)
                  t4[s5[a5].bucketInstanceId] || (this.removeBucketCrossTileIDs(i5, s5[a5]), delete s5[a5], e4 = true);
              }
              return e4;
            }
          }
          class Jt {
            constructor() {
              this.layerIndexes = {}, this.crossTileIDs = new Kt(), this.maxBucketInstanceId = 0, this.bucketsInCurrentPlacement = {};
            }
            addLayer(t4, e4, i5) {
              let s5 = this.layerIndexes[t4.id];
              void 0 === s5 && (s5 = this.layerIndexes[t4.id] = new Yt());
              let a5 = false;
              const o5 = {};
              s5.handleWrapJump(i5);
              for (const i6 of e4) {
                const e5 = i6.getBucket(t4);
                e5 && t4.id === e5.layerIds[0] && (e5.bucketInstanceId || (e5.bucketInstanceId = ++this.maxBucketInstanceId), s5.addBucket(i6.tileID, e5, this.crossTileIDs) && (a5 = true), o5[e5.bucketInstanceId] = true);
              }
              return s5.removeStaleBuckets(o5) && (a5 = true), a5;
            }
            pruneUnusedLayers(t4) {
              const e4 = {};
              t4.forEach((t5) => {
                e4[t5] = true;
              });
              for (const t5 in this.layerIndexes)
                e4[t5] || delete this.layerIndexes[t5];
            }
          }
          const Qt = (e4, i5) => t3.emitValidationErrors(e4, i5 && i5.filter((t4) => "source.canvas" !== t4.identifier)), te = t3.pick(t3.operations, ["addLayer", "removeLayer", "setPaintProperty", "setLayoutProperty", "setFilter", "addSource", "removeSource", "setLayerZoomRange", "setLight", "setTransition", "setGeoJSONSourceData", "setGlyphs", "setSprite"]), ee = t3.pick(t3.operations, ["setCenter", "setZoom", "setBearing", "setPitch"]), ie = t3.emptyStyle();
          class se extends t3.Evented {
            constructor(e4, i5 = {}) {
              super(), this.map = e4, this.dispatcher = new M2(st(), this, e4._getMapId()), this.imageManager = new b3(), this.imageManager.setEventedParent(this), this.glyphManager = new I2(e4._requestManager, i5.localIdeographFontFamily), this.lineAtlas = new D2(256, 512), this.crossTileSymbolIndex = new Jt(), this._spritesImagesIds = {}, this._layers = {}, this._order = [], this.sourceCaches = {}, this.zoomHistory = new t3.ZoomHistory(), this._loaded = false, this._availableImages = [], this._resetUpdates(), this.dispatcher.broadcast("setReferrer", t3.getReferrer());
              const s5 = this;
              this._rtlTextPluginCallback = se.registerForPluginStateChange((e5) => {
                s5.dispatcher.broadcast("syncRTLPluginState", { pluginStatus: e5.pluginStatus, pluginURL: e5.pluginURL }, (e6, i6) => {
                  if (t3.triggerPluginCompletionEvent(e6), i6 && i6.every((t4) => t4))
                    for (const t4 in s5.sourceCaches) {
                      const e7 = s5.sourceCaches[t4].getSource().type;
                      "vector" !== e7 && "geojson" !== e7 || s5.sourceCaches[t4].reload();
                    }
                });
              }), this.on("data", (t4) => {
                if ("source" !== t4.dataType || "metadata" !== t4.sourceDataType)
                  return;
                const e5 = this.sourceCaches[t4.sourceId];
                if (!e5)
                  return;
                const i6 = e5.getSource();
                if (i6 && i6.vectorLayerIds)
                  for (const t5 in this._layers) {
                    const e6 = this._layers[t5];
                    e6.source === i6.id && this._validateLayer(e6);
                  }
              });
            }
            loadURL(e4, i5 = {}, s5) {
              this.fire(new t3.Event("dataloading", { dataType: "style" })), i5.validate = "boolean" != typeof i5.validate || i5.validate;
              const a5 = this.map._requestManager.transformRequest(e4, h3.Style);
              this._request = t3.getJSON(a5, (e5, a6) => {
                this._request = null, e5 ? this.fire(new t3.ErrorEvent(e5)) : a6 && this._load(a6, i5, s5);
              });
            }
            loadJSON(e4, i5 = {}, s5) {
              this.fire(new t3.Event("dataloading", { dataType: "style" })), this._request = t3.browser.frame(() => {
                this._request = null, i5.validate = false !== i5.validate, this._load(e4, i5, s5);
              });
            }
            loadEmpty() {
              this.fire(new t3.Event("dataloading", { dataType: "style" })), this._load(ie, { validate: false });
            }
            _load(e4, i5, s5) {
              var a5;
              const o5 = i5.transformStyle ? i5.transformStyle(s5, e4) : e4;
              if (!i5.validate || !Qt(this, t3.validateStyle(o5))) {
                this._loaded = true, this.stylesheet = o5;
                for (const t4 in o5.sources)
                  this.addSource(t4, o5.sources[t4], { validate: false });
                o5.sprite ? this._loadSprite(o5.sprite) : this.imageManager.setLoaded(true), this.glyphManager.setURL(o5.glyphs), this._createLayers(), this.light = new P2(this.stylesheet.light), this.map.setTerrain(null !== (a5 = this.stylesheet.terrain) && void 0 !== a5 ? a5 : null), this.fire(new t3.Event("data", { dataType: "style" })), this.fire(new t3.Event("style.load"));
              }
            }
            _createLayers() {
              const e4 = t3.derefLayers(this.stylesheet.layers);
              this.dispatcher.broadcast("setLayers", e4), this._order = e4.map((t4) => t4.id), this._layers = {}, this._serializedLayers = null;
              for (const i5 of e4) {
                const e5 = t3.createStyleLayer(i5);
                e5.setEventedParent(this, { layer: { id: i5.id } }), this._layers[i5.id] = e5;
              }
            }
            _loadSprite(e4, i5 = false, s5 = void 0) {
              this.imageManager.setLoaded(false), this._spriteRequest = function(e5, i6, s6, a5) {
                const o5 = g3(e5), r5 = o5.length, n3 = s6 > 1 ? "@2x" : "", l5 = {}, u5 = {}, d4 = {};
                for (const { id: e6, url: s7 } of o5) {
                  const o6 = i6.transformRequest(i6.normalizeSpriteURL(s7, n3, ".json"), h3.SpriteJSON), _4 = `${e6}_${o6.url}`;
                  l5[_4] = t3.getJSON(o6, (t4, i7) => {
                    delete l5[_4], u5[e6] = i7, v3(a5, u5, d4, t4, r5);
                  });
                  const m4 = i6.transformRequest(i6.normalizeSpriteURL(s7, n3, ".png"), h3.SpriteImage), p7 = `${e6}_${m4.url}`;
                  l5[p7] = c4.getImage(m4, (t4, i7) => {
                    delete l5[p7], d4[e6] = i7, v3(a5, u5, d4, t4, r5);
                  });
                }
                return { cancel() {
                  for (const t4 of Object.values(l5))
                    t4.cancel();
                } };
              }(e4, this.map._requestManager, this.map.getPixelRatio(), (e5, a5) => {
                if (this._spriteRequest = null, e5)
                  this.fire(new t3.ErrorEvent(e5));
                else if (a5)
                  for (const t4 in a5) {
                    this._spritesImagesIds[t4] = [];
                    const e6 = this._spritesImagesIds[t4] ? this._spritesImagesIds[t4].filter((t5) => !(t5 in a5)) : [];
                    for (const t5 of e6)
                      this.imageManager.removeImage(t5), this._changedImages[t5] = true;
                    for (const e7 in a5[t4]) {
                      const s6 = "default" === t4 ? e7 : `${t4}:${e7}`;
                      this._spritesImagesIds[t4].push(s6), s6 in this.imageManager.images ? this.imageManager.updateImage(s6, a5[t4][e7], false) : this.imageManager.addImage(s6, a5[t4][e7]), i5 && (this._changedImages[s6] = true);
                    }
                  }
                this.imageManager.setLoaded(true), this._availableImages = this.imageManager.listImages(), i5 && (this._changed = true), this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t3.Event("data", { dataType: "style" })), s5 && s5(e5);
              });
            }
            _unloadSprite() {
              for (const t4 of Object.values(this._spritesImagesIds).flat())
                this.imageManager.removeImage(t4), this._changedImages[t4] = true;
              this._spritesImagesIds = {}, this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t3.Event("data", { dataType: "style" }));
            }
            _validateLayer(e4) {
              const i5 = this.sourceCaches[e4.source];
              if (!i5)
                return;
              const s5 = e4.sourceLayer;
              if (!s5)
                return;
              const a5 = i5.getSource();
              ("geojson" === a5.type || a5.vectorLayerIds && -1 === a5.vectorLayerIds.indexOf(s5)) && this.fire(new t3.ErrorEvent(new Error(`Source layer "${s5}" does not exist on source "${a5.id}" as specified by style layer "${e4.id}".`)));
            }
            loaded() {
              if (!this._loaded)
                return false;
              if (Object.keys(this._updatedSources).length)
                return false;
              for (const t4 in this.sourceCaches)
                if (!this.sourceCaches[t4].loaded())
                  return false;
              return !!this.imageManager.isLoaded();
            }
            _serializeByIds(t4) {
              const e4 = this._serializedAllLayers();
              if (!t4 || 0 === t4.length)
                return Object.values(e4);
              const i5 = [];
              for (const s5 of t4)
                e4[s5] && i5.push(e4[s5]);
              return i5;
            }
            _serializedAllLayers() {
              let t4 = this._serializedLayers;
              if (t4)
                return t4;
              t4 = this._serializedLayers = {};
              const e4 = Object.keys(this._layers);
              for (const i5 of e4) {
                const e5 = this._layers[i5];
                "custom" !== e5.type && (t4[i5] = e5.serialize());
              }
              return t4;
            }
            hasTransitions() {
              if (this.light && this.light.hasTransition())
                return true;
              for (const t4 in this.sourceCaches)
                if (this.sourceCaches[t4].hasTransition())
                  return true;
              for (const t4 in this._layers)
                if (this._layers[t4].hasTransition())
                  return true;
              return false;
            }
            _checkLoaded() {
              if (!this._loaded)
                throw new Error("Style is not done loading.");
            }
            update(e4) {
              if (!this._loaded)
                return;
              const i5 = this._changed;
              if (this._changed) {
                const t4 = Object.keys(this._updatedLayers), i6 = Object.keys(this._removedLayers);
                (t4.length || i6.length) && this._updateWorkerLayers(t4, i6);
                for (const t5 in this._updatedSources) {
                  const e5 = this._updatedSources[t5];
                  if ("reload" === e5)
                    this._reloadSource(t5);
                  else {
                    if ("clear" !== e5)
                      throw new Error(`Invalid action ${e5}`);
                    this._clearSource(t5);
                  }
                }
                this._updateTilesForChangedImages(), this._updateTilesForChangedGlyphs();
                for (const t5 in this._updatedPaintProps)
                  this._layers[t5].updateTransitions(e4);
                this.light.updateTransitions(e4), this._resetUpdates();
              }
              const s5 = {};
              for (const t4 in this.sourceCaches) {
                const e5 = this.sourceCaches[t4];
                s5[t4] = e5.used, e5.used = false;
              }
              for (const t4 of this._order) {
                const i6 = this._layers[t4];
                i6.recalculate(e4, this._availableImages), !i6.isHidden(e4.zoom) && i6.source && (this.sourceCaches[i6.source].used = true);
              }
              for (const e5 in s5) {
                const i6 = this.sourceCaches[e5];
                s5[e5] !== i6.used && i6.fire(new t3.Event("data", { sourceDataType: "visibility", dataType: "source", sourceId: e5 }));
              }
              this.light.recalculate(e4), this.z = e4.zoom, i5 && this.fire(new t3.Event("data", { dataType: "style" }));
            }
            _updateTilesForChangedImages() {
              const t4 = Object.keys(this._changedImages);
              if (t4.length) {
                for (const e4 in this.sourceCaches)
                  this.sourceCaches[e4].reloadTilesForDependencies(["icons", "patterns"], t4);
                this._changedImages = {};
              }
            }
            _updateTilesForChangedGlyphs() {
              if (this._glyphsDidChange) {
                for (const t4 in this.sourceCaches)
                  this.sourceCaches[t4].reloadTilesForDependencies(["glyphs"], [""]);
                this._glyphsDidChange = false;
              }
            }
            _updateWorkerLayers(t4, e4) {
              this.dispatcher.broadcast("updateLayers", { layers: this._serializeByIds(t4), removedIds: e4 });
            }
            _resetUpdates() {
              this._changed = false, this._updatedLayers = {}, this._removedLayers = {}, this._updatedSources = {}, this._updatedPaintProps = {}, this._changedImages = {}, this._glyphsDidChange = false;
            }
            setState(e4, i5 = {}) {
              this._checkLoaded();
              const s5 = this.serialize();
              if (e4 = i5.transformStyle ? i5.transformStyle(s5, e4) : e4, Qt(this, t3.validateStyle(e4)))
                return false;
              (e4 = t3.clone$1(e4)).layers = t3.derefLayers(e4.layers);
              const a5 = t3.diffStyles(s5, e4).filter((t4) => !(t4.command in ee));
              if (0 === a5.length)
                return false;
              const o5 = a5.filter((t4) => !(t4.command in te));
              if (o5.length > 0)
                throw new Error(`Unimplemented: ${o5.map((t4) => t4.command).join(", ")}.`);
              for (const t4 of a5)
                "setTransition" !== t4.command && this[t4.command].apply(this, t4.args);
              return this.stylesheet = e4, this._serializedLayers = null, true;
            }
            addImage(e4, i5) {
              if (this.getImage(e4))
                return this.fire(new t3.ErrorEvent(new Error(`An image named "${e4}" already exists.`)));
              this.imageManager.addImage(e4, i5), this._afterImageUpdated(e4);
            }
            updateImage(t4, e4) {
              this.imageManager.updateImage(t4, e4);
            }
            getImage(t4) {
              return this.imageManager.getImage(t4);
            }
            removeImage(e4) {
              if (!this.getImage(e4))
                return this.fire(new t3.ErrorEvent(new Error(`An image named "${e4}" does not exist.`)));
              this.imageManager.removeImage(e4), this._afterImageUpdated(e4);
            }
            _afterImageUpdated(e4) {
              this._availableImages = this.imageManager.listImages(), this._changedImages[e4] = true, this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t3.Event("data", { dataType: "style" }));
            }
            listImages() {
              return this._checkLoaded(), this.imageManager.listImages();
            }
            addSource(e4, i5, s5 = {}) {
              if (this._checkLoaded(), void 0 !== this.sourceCaches[e4])
                throw new Error(`Source "${e4}" already exists.`);
              if (!i5.type)
                throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i5).join(", ")}.`);
              if (["vector", "raster", "geojson", "video", "image"].indexOf(i5.type) >= 0 && this._validate(t3.validateStyle.source, `sources.${e4}`, i5, null, s5))
                return;
              this.map && this.map._collectResourceTiming && (i5.collectResourceTiming = true);
              const a5 = this.sourceCaches[e4] = new K(e4, i5, this.dispatcher);
              a5.style = this, a5.setEventedParent(this, () => ({ isSourceLoaded: a5.loaded(), source: a5.serialize(), sourceId: e4 })), a5.onAdd(this.map), this._changed = true;
            }
            removeSource(e4) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[e4])
                throw new Error("There is no source with this ID");
              for (const i6 in this._layers)
                if (this._layers[i6].source === e4)
                  return this.fire(new t3.ErrorEvent(new Error(`Source "${e4}" cannot be removed while layer "${i6}" is using it.`)));
              const i5 = this.sourceCaches[e4];
              delete this.sourceCaches[e4], delete this._updatedSources[e4], i5.fire(new t3.Event("data", { sourceDataType: "metadata", dataType: "source", sourceId: e4 })), i5.setEventedParent(null), i5.onRemove(this.map), this._changed = true;
            }
            setGeoJSONSourceData(t4, e4) {
              if (this._checkLoaded(), void 0 === this.sourceCaches[t4])
                throw new Error(`There is no source with this ID=${t4}`);
              const i5 = this.sourceCaches[t4].getSource();
              if ("geojson" !== i5.type)
                throw new Error(`geojsonSource.type is ${i5.type}, which is !== 'geojson`);
              i5.setData(e4), this._changed = true;
            }
            getSource(t4) {
              return this.sourceCaches[t4] && this.sourceCaches[t4].getSource();
            }
            addLayer(e4, i5, s5 = {}) {
              this._checkLoaded();
              const a5 = e4.id;
              if (this.getLayer(a5))
                return void this.fire(new t3.ErrorEvent(new Error(`Layer "${a5}" already exists on this map.`)));
              let o5;
              if ("custom" === e4.type) {
                if (Qt(this, t3.validateCustomStyleLayer(e4)))
                  return;
                o5 = t3.createStyleLayer(e4);
              } else {
                if ("source" in e4 && "object" == typeof e4.source && (this.addSource(a5, e4.source), e4 = t3.clone$1(e4), e4 = t3.extend(e4, { source: a5 })), this._validate(t3.validateStyle.layer, `layers.${a5}`, e4, { arrayIndex: -1 }, s5))
                  return;
                o5 = t3.createStyleLayer(e4), this._validateLayer(o5), o5.setEventedParent(this, { layer: { id: a5 } });
              }
              const r5 = i5 ? this._order.indexOf(i5) : this._order.length;
              if (i5 && -1 === r5)
                this.fire(new t3.ErrorEvent(new Error(`Cannot add layer "${a5}" before non-existing layer "${i5}".`)));
              else {
                if (this._order.splice(r5, 0, a5), this._layerOrderChanged = true, this._layers[a5] = o5, this._removedLayers[a5] && o5.source && "custom" !== o5.type) {
                  const t4 = this._removedLayers[a5];
                  delete this._removedLayers[a5], t4.type !== o5.type ? this._updatedSources[o5.source] = "clear" : (this._updatedSources[o5.source] = "reload", this.sourceCaches[o5.source].pause());
                }
                this._updateLayer(o5), o5.onAdd && o5.onAdd(this.map);
              }
            }
            moveLayer(e4, i5) {
              if (this._checkLoaded(), this._changed = true, !this._layers[e4])
                return void this.fire(new t3.ErrorEvent(new Error(`The layer '${e4}' does not exist in the map's style and cannot be moved.`)));
              if (e4 === i5)
                return;
              const s5 = this._order.indexOf(e4);
              this._order.splice(s5, 1);
              const a5 = i5 ? this._order.indexOf(i5) : this._order.length;
              i5 && -1 === a5 ? this.fire(new t3.ErrorEvent(new Error(`Cannot move layer "${e4}" before non-existing layer "${i5}".`))) : (this._order.splice(a5, 0, e4), this._layerOrderChanged = true);
            }
            removeLayer(e4) {
              this._checkLoaded();
              const i5 = this._layers[e4];
              if (!i5)
                return void this.fire(new t3.ErrorEvent(new Error(`Cannot remove non-existing layer "${e4}".`)));
              i5.setEventedParent(null);
              const s5 = this._order.indexOf(e4);
              this._order.splice(s5, 1), this._layerOrderChanged = true, this._changed = true, this._removedLayers[e4] = i5, delete this._layers[e4], this._serializedLayers && delete this._serializedLayers[e4], delete this._updatedLayers[e4], delete this._updatedPaintProps[e4], i5.onRemove && i5.onRemove(this.map);
            }
            getLayer(t4) {
              return this._layers[t4];
            }
            hasLayer(t4) {
              return t4 in this._layers;
            }
            setLayerZoomRange(e4, i5, s5) {
              this._checkLoaded();
              const a5 = this.getLayer(e4);
              a5 ? a5.minzoom === i5 && a5.maxzoom === s5 || (null != i5 && (a5.minzoom = i5), null != s5 && (a5.maxzoom = s5), this._updateLayer(a5)) : this.fire(new t3.ErrorEvent(new Error(`Cannot set the zoom range of non-existing layer "${e4}".`)));
            }
            setFilter(e4, i5, s5 = {}) {
              this._checkLoaded();
              const a5 = this.getLayer(e4);
              if (a5) {
                if (!t3.deepEqual(a5.filter, i5))
                  return null == i5 ? (a5.filter = void 0, void this._updateLayer(a5)) : void (this._validate(t3.validateStyle.filter, `layers.${a5.id}.filter`, i5, null, s5) || (a5.filter = t3.clone$1(i5), this._updateLayer(a5)));
              } else
                this.fire(new t3.ErrorEvent(new Error(`Cannot filter non-existing layer "${e4}".`)));
            }
            getFilter(e4) {
              return t3.clone$1(this.getLayer(e4).filter);
            }
            setLayoutProperty(e4, i5, s5, a5 = {}) {
              this._checkLoaded();
              const o5 = this.getLayer(e4);
              o5 ? t3.deepEqual(o5.getLayoutProperty(i5), s5) || (o5.setLayoutProperty(i5, s5, a5), this._updateLayer(o5)) : this.fire(new t3.ErrorEvent(new Error(`Cannot style non-existing layer "${e4}".`)));
            }
            getLayoutProperty(e4, i5) {
              const s5 = this.getLayer(e4);
              if (s5)
                return s5.getLayoutProperty(i5);
              this.fire(new t3.ErrorEvent(new Error(`Cannot get style of non-existing layer "${e4}".`)));
            }
            setPaintProperty(e4, i5, s5, a5 = {}) {
              this._checkLoaded();
              const o5 = this.getLayer(e4);
              o5 ? t3.deepEqual(o5.getPaintProperty(i5), s5) || (o5.setPaintProperty(i5, s5, a5) && this._updateLayer(o5), this._changed = true, this._updatedPaintProps[e4] = true) : this.fire(new t3.ErrorEvent(new Error(`Cannot style non-existing layer "${e4}".`)));
            }
            getPaintProperty(t4, e4) {
              return this.getLayer(t4).getPaintProperty(e4);
            }
            setFeatureState(e4, i5) {
              this._checkLoaded();
              const s5 = e4.source, a5 = e4.sourceLayer, o5 = this.sourceCaches[s5];
              if (void 0 === o5)
                return void this.fire(new t3.ErrorEvent(new Error(`The source '${s5}' does not exist in the map's style.`)));
              const r5 = o5.getSource().type;
              "geojson" === r5 && a5 ? this.fire(new t3.ErrorEvent(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : "vector" !== r5 || a5 ? (void 0 === e4.id && this.fire(new t3.ErrorEvent(new Error("The feature id parameter must be provided."))), o5.setFeatureState(a5, e4.id, i5)) : this.fire(new t3.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            removeFeatureState(e4, i5) {
              this._checkLoaded();
              const s5 = e4.source, a5 = this.sourceCaches[s5];
              if (void 0 === a5)
                return void this.fire(new t3.ErrorEvent(new Error(`The source '${s5}' does not exist in the map's style.`)));
              const o5 = a5.getSource().type, r5 = "vector" === o5 ? e4.sourceLayer : void 0;
              "vector" !== o5 || r5 ? i5 && "string" != typeof e4.id && "number" != typeof e4.id ? this.fire(new t3.ErrorEvent(new Error("A feature id is required to remove its specific state property."))) : a5.removeFeatureState(r5, e4.id, i5) : this.fire(new t3.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
            }
            getFeatureState(e4) {
              this._checkLoaded();
              const i5 = e4.source, s5 = e4.sourceLayer, a5 = this.sourceCaches[i5];
              if (void 0 !== a5)
                return "vector" !== a5.getSource().type || s5 ? (void 0 === e4.id && this.fire(new t3.ErrorEvent(new Error("The feature id parameter must be provided."))), a5.getFeatureState(s5, e4.id)) : void this.fire(new t3.ErrorEvent(new Error("The sourceLayer parameter must be provided for vector source types.")));
              this.fire(new t3.ErrorEvent(new Error(`The source '${i5}' does not exist in the map's style.`)));
            }
            getTransition() {
              return t3.extend({ duration: 300, delay: 0 }, this.stylesheet && this.stylesheet.transition);
            }
            serialize() {
              if (!this._loaded)
                return;
              const e4 = t3.mapObject(this.sourceCaches, (t4) => t4.serialize()), i5 = this._serializeByIds(this._order), s5 = this.stylesheet;
              return t3.filterObject({ version: s5.version, name: s5.name, metadata: s5.metadata, light: s5.light, center: s5.center, zoom: s5.zoom, bearing: s5.bearing, pitch: s5.pitch, sprite: s5.sprite, glyphs: s5.glyphs, transition: s5.transition, sources: e4, layers: i5 }, (t4) => void 0 !== t4);
            }
            _updateLayer(t4) {
              this._updatedLayers[t4.id] = true, t4.source && !this._updatedSources[t4.source] && "raster" !== this.sourceCaches[t4.source].getSource().type && (this._updatedSources[t4.source] = "reload", this.sourceCaches[t4.source].pause()), this._serializedLayers = null, this._changed = true;
            }
            _flattenAndSortRenderedFeatures(t4) {
              const e4 = (t5) => "fill-extrusion" === this._layers[t5].type, i5 = {}, s5 = [];
              for (let a6 = this._order.length - 1; a6 >= 0; a6--) {
                const o5 = this._order[a6];
                if (e4(o5)) {
                  i5[o5] = a6;
                  for (const e5 of t4) {
                    const t5 = e5[o5];
                    if (t5)
                      for (const e6 of t5)
                        s5.push(e6);
                  }
                }
              }
              s5.sort((t5, e5) => e5.intersectionZ - t5.intersectionZ);
              const a5 = [];
              for (let o5 = this._order.length - 1; o5 >= 0; o5--) {
                const r5 = this._order[o5];
                if (e4(r5))
                  for (let t5 = s5.length - 1; t5 >= 0; t5--) {
                    const e5 = s5[t5].feature;
                    if (i5[e5.layer.id] < o5)
                      break;
                    a5.push(e5), s5.pop();
                  }
                else
                  for (const e5 of t4) {
                    const t5 = e5[r5];
                    if (t5)
                      for (const e6 of t5)
                        a5.push(e6.feature);
                  }
              }
              return a5;
            }
            queryRenderedFeatures(e4, i5, s5) {
              i5 && i5.filter && this._validate(t3.validateStyle.filter, "queryRenderedFeatures.filter", i5.filter, null, i5);
              const a5 = {};
              if (i5 && i5.layers) {
                if (!Array.isArray(i5.layers))
                  return this.fire(new t3.ErrorEvent(new Error("parameters.layers must be an Array."))), [];
                for (const e5 of i5.layers) {
                  const i6 = this._layers[e5];
                  if (!i6)
                    return this.fire(new t3.ErrorEvent(new Error(`The layer '${e5}' does not exist in the map's style and cannot be queried for features.`))), [];
                  a5[i6.source] = true;
                }
              }
              const o5 = [];
              i5.availableImages = this._availableImages;
              const r5 = this._serializedAllLayers();
              for (const t4 in this.sourceCaches)
                i5.layers && !a5[t4] || o5.push(j3(this.sourceCaches[t4], this._layers, r5, e4, i5, s5));
              return this.placement && o5.push(function(t4, e5, i6, s6, a6, o6, r6) {
                const n3 = {}, l5 = o6.queryRenderedSymbols(s6), c5 = [];
                for (const t5 of Object.keys(l5).map(Number))
                  c5.push(r6[t5]);
                c5.sort($2);
                for (const i7 of c5) {
                  const s7 = i7.featureIndex.lookupSymbolFeatures(l5[i7.bucketInstanceId], e5, i7.bucketIndex, i7.sourceLayerIndex, a6.filter, a6.layers, a6.availableImages, t4);
                  for (const t5 in s7) {
                    const e6 = n3[t5] = n3[t5] || [], a7 = s7[t5];
                    a7.sort((t6, e7) => {
                      const s8 = i7.featureSortOrder;
                      if (s8) {
                        const i8 = s8.indexOf(t6.featureIndex);
                        return s8.indexOf(e7.featureIndex) - i8;
                      }
                      return e7.featureIndex - t6.featureIndex;
                    });
                    for (const t6 of a7)
                      e6.push(t6);
                  }
                }
                for (const e6 in n3)
                  n3[e6].forEach((s7) => {
                    const a7 = s7.feature, o7 = i6[t4[e6].source].getFeatureState(a7.layer["source-layer"], a7.id);
                    a7.source = a7.layer.source, a7.layer["source-layer"] && (a7.sourceLayer = a7.layer["source-layer"]), a7.state = o7;
                  });
                return n3;
              }(this._layers, r5, this.sourceCaches, e4, i5, this.placement.collisionIndex, this.placement.retainedQueryData)), this._flattenAndSortRenderedFeatures(o5);
            }
            querySourceFeatures(e4, i5) {
              i5 && i5.filter && this._validate(t3.validateStyle.filter, "querySourceFeatures.filter", i5.filter, null, i5);
              const s5 = this.sourceCaches[e4];
              return s5 ? function(t4, e5) {
                const i6 = t4.getRenderableIds().map((e6) => t4.getTileByID(e6)), s6 = [], a5 = {};
                for (let t5 = 0; t5 < i6.length; t5++) {
                  const o5 = i6[t5], r5 = o5.tileID.canonical.key;
                  a5[r5] || (a5[r5] = true, o5.querySourceFeatures(s6, e5));
                }
                return s6;
              }(s5, i5) : [];
            }
            addSourceType(t4, e4, i5) {
              return V(t4) ? i5(new Error(`A source type called "${t4}" already exists.`)) : (((t5, e5) => {
                G2[t5] = e5;
              })(t4, e4), e4.workerSourceURL ? void this.dispatcher.broadcast("loadWorkerSource", { name: t4, url: e4.workerSourceURL }, i5) : i5(null, null));
            }
            getLight() {
              return this.light.getLight();
            }
            setLight(e4, i5 = {}) {
              this._checkLoaded();
              const s5 = this.light.getLight();
              let a5 = false;
              for (const i6 in e4)
                if (!t3.deepEqual(e4[i6], s5[i6])) {
                  a5 = true;
                  break;
                }
              if (!a5)
                return;
              const o5 = { now: t3.browser.now(), transition: t3.extend({ duration: 300, delay: 0 }, this.stylesheet.transition) };
              this.light.setLight(e4, i5), this.light.updateTransitions(o5);
            }
            _validate(e4, i5, s5, a5, o5 = {}) {
              return (!o5 || false !== o5.validate) && Qt(this, e4.call(t3.validateStyle, t3.extend({ key: i5, style: this.serialize(), value: s5, styleSpec: t3.v8Spec }, a5)));
            }
            _remove(e4 = true) {
              this._request && (this._request.cancel(), this._request = null), this._spriteRequest && (this._spriteRequest.cancel(), this._spriteRequest = null), t3.evented.off("pluginStateChange", this._rtlTextPluginCallback);
              for (const t4 in this._layers)
                this._layers[t4].setEventedParent(null);
              for (const t4 in this.sourceCaches) {
                const e5 = this.sourceCaches[t4];
                e5.setEventedParent(null), e5.onRemove(this.map);
              }
              this.imageManager.setEventedParent(null), this.setEventedParent(null), this.dispatcher.remove(e4);
            }
            _clearSource(t4) {
              this.sourceCaches[t4].clearTiles();
            }
            _reloadSource(t4) {
              this.sourceCaches[t4].resume(), this.sourceCaches[t4].reload();
            }
            _updateSources(t4) {
              for (const e4 in this.sourceCaches)
                this.sourceCaches[e4].update(t4, this.map.terrain);
            }
            _generateCollisionBoxes() {
              for (const t4 in this.sourceCaches)
                this._reloadSource(t4);
            }
            _updatePlacement(e4, i5, s5, a5, o5 = false) {
              let r5 = false, n3 = false;
              const l5 = {};
              for (const t4 of this._order) {
                const i6 = this._layers[t4];
                if ("symbol" !== i6.type)
                  continue;
                if (!l5[i6.source]) {
                  const t5 = this.sourceCaches[i6.source];
                  l5[i6.source] = t5.getRenderableIds(true).map((e5) => t5.getTileByID(e5)).sort((t6, e5) => e5.tileID.overscaledZ - t6.tileID.overscaledZ || (t6.tileID.isLessThan(e5.tileID) ? -1 : 1));
                }
                const s6 = this.crossTileSymbolIndex.addLayer(i6, l5[i6.source], e4.center.lng);
                r5 = r5 || s6;
              }
              if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order), ((o5 = o5 || this._layerOrderChanged || 0 === s5) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(t3.browser.now(), e4.zoom)) && (this.pauseablePlacement = new Xt(e4, this.map.terrain, this._order, o5, i5, s5, a5, this.placement), this._layerOrderChanged = false), this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, l5), this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(t3.browser.now()), n3 = true), r5 && this.pauseablePlacement.placement.setStale()), n3 || r5)
                for (const t4 of this._order) {
                  const e5 = this._layers[t4];
                  "symbol" === e5.type && this.placement.updateLayerOpacities(e5, l5[e5.source]);
                }
              return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(t3.browser.now());
            }
            _releaseSymbolFadeTiles() {
              for (const t4 in this.sourceCaches)
                this.sourceCaches[t4].releaseSymbolFadeTiles();
            }
            getImages(t4, e4, i5) {
              this.imageManager.getImages(e4.icons, i5), this._updateTilesForChangedImages();
              const s5 = this.sourceCaches[e4.source];
              s5 && s5.setDependencies(e4.tileID.key, e4.type, e4.icons);
            }
            getGlyphs(t4, e4, i5) {
              this.glyphManager.getGlyphs(e4.stacks, i5);
              const s5 = this.sourceCaches[e4.source];
              s5 && s5.setDependencies(e4.tileID.key, e4.type, [""]);
            }
            getResource(e4, i5, s5) {
              return t3.makeRequest(i5, s5);
            }
            getGlyphsUrl() {
              return this.stylesheet.glyphs || null;
            }
            setGlyphs(e4, i5 = {}) {
              this._checkLoaded(), e4 && this._validate(t3.validateStyle.glyphs, "glyphs", e4, null, i5) || (this._glyphsDidChange = true, this.stylesheet.glyphs = e4, this.glyphManager.entries = {}, this.glyphManager.setURL(e4));
            }
            addSprite(e4, i5, s5 = {}, a5) {
              this._checkLoaded();
              const o5 = [{ id: e4, url: i5 }], r5 = [...g3(this.stylesheet.sprite), ...o5];
              this._validate(t3.validateStyle.sprite, "sprite", r5, null, s5) || (this.stylesheet.sprite = r5, this._loadSprite(o5, true, a5));
            }
            removeSprite(e4) {
              this._checkLoaded();
              const i5 = g3(this.stylesheet.sprite);
              if (i5.find((t4) => t4.id === e4)) {
                if (this._spritesImagesIds[e4])
                  for (const t4 of this._spritesImagesIds[e4])
                    this.imageManager.removeImage(t4), this._changedImages[t4] = true;
                i5.splice(i5.findIndex((t4) => t4.id === e4), 1), this.stylesheet.sprite = i5.length > 0 ? i5 : void 0, delete this._spritesImagesIds[e4], this._availableImages = this.imageManager.listImages(), this._changed = true, this.dispatcher.broadcast("setImages", this._availableImages), this.fire(new t3.Event("data", { dataType: "style" }));
              } else
                this.fire(new t3.ErrorEvent(new Error(`Sprite "${e4}" doesn't exists on this map.`)));
            }
            getSprite() {
              return g3(this.stylesheet.sprite);
            }
            setSprite(e4, i5 = {}, s5) {
              this._checkLoaded(), e4 && this._validate(t3.validateStyle.sprite, "sprite", e4, null, i5) || (this.stylesheet.sprite = e4, e4 ? this._loadSprite(e4, true, s5) : (this._unloadSprite(), s5 && s5(null)));
            }
          }
          se.registerForPluginStateChange = t3.registerForPluginStateChange;
          var ae = t3.createLayout([{ name: "a_pos", type: "Int16", components: 2 }]), oe = "attribute vec3 a_pos3d;uniform mat4 u_matrix;uniform float u_ele_delta;varying vec2 v_texture_pos;varying float v_depth;void main() {float extent=8192.0;float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/extent;gl_Position=u_matrix*vec4(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta,1.0);v_depth=gl_Position.z/gl_Position.w;}";
          const re = { prelude: ne("#ifdef GL_ES\nprecision mediump float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\n", "#ifdef GL_ES\nprecision highp float;\n#else\n#if !defined(lowp)\n#define lowp\n#endif\n#if !defined(mediump)\n#define mediump\n#endif\n#if !defined(highp)\n#define highp\n#endif\n#endif\nvec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0\n);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}\n#ifdef TERRAIN3D\nuniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;\n#endif\nconst highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {\n#ifdef TERRAIN3D\nhighp float d=unpack(texture2D(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));\n#else\nreturn 1.0;\n#endif\n}float calculate_visibility(vec4 pos) {\n#ifdef TERRAIN3D\nvec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;\n#else\nreturn 1.0;\n#endif\n}float ele(vec2 pos) {\n#ifdef TERRAIN3D\nvec4 rgb=(texture2D(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;\n#else\nreturn 0.0;\n#endif\n}float get_elevation(vec2 pos) {\n#ifdef TERRAIN3D\nvec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;\n#else\nreturn 0.0;\n#endif\n}"), background: ne("uniform vec4 u_color;uniform float u_opacity;void main() {gl_FragColor=u_color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), backgroundPattern: ne("uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_mix)*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"), circle: ne("varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=v_data.xy;float extrude_length=length(extrude);lowp float antialiasblur=v_data.z;float antialiased_blur=-max(blur,antialiasblur);float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));gl_FragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;attribute vec2 a_pos;varying vec3 v_data;varying float v_visibility;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define mediump float radius\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define highp vec4 stroke_color\n#pragma mapbox: define mediump float stroke_width\n#pragma mapbox: define lowp float stroke_opacity\nvoid main(void) {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize mediump float radius\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize highp vec4 stroke_color\n#pragma mapbox: initialize mediump float stroke_width\n#pragma mapbox: initialize lowp float stroke_opacity\nvec2 extrude=vec2(mod(a_pos,2.0)*2.0-1.0);vec2 circle_center=floor(a_pos*0.5);float ele=get_elevation(circle_center);v_visibility=calculate_visibility(u_matrix*vec4(circle_center,ele,1.0));if (u_pitch_with_map) {vec2 corner_position=circle_center;if (u_scale_with_map) {corner_position+=extrude*(radius+stroke_width)*u_extrude_scale;} else {vec4 projected_center=u_matrix*vec4(circle_center,0,1);corner_position+=extrude*(radius+stroke_width)*u_extrude_scale*(projected_center.w/u_camera_to_center_distance);}gl_Position=u_matrix*vec4(corner_position,ele,1);} else {gl_Position=u_matrix*vec4(circle_center,ele,1);if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}lowp float antialiasblur=1.0/u_device_pixel_ratio/(radius+stroke_width);v_data=vec3(extrude.x,extrude.y,antialiasblur);}"), clippingMask: ne("void main() {gl_FragColor=vec4(1.0);}", "attribute vec2 a_pos;uniform mat4 u_matrix;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);}"), heatmap: ne("uniform highp float u_intensity;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#define GAUSS_COEF 0.3989422804014327\nvoid main() {\n#pragma mapbox: initialize highp float weight\nfloat d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);gl_FragColor=vec4(val,1.0,1.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;attribute vec2 a_pos;varying vec2 v_extrude;\n#pragma mapbox: define highp float weight\n#pragma mapbox: define mediump float radius\nconst highp float ZERO=1.0/255.0/16.0;\n#define GAUSS_COEF 0.3989422804014327\nvoid main(void) {\n#pragma mapbox: initialize highp float weight\n#pragma mapbox: initialize mediump float radius\nvec2 unscaled_extrude=vec2(mod(a_pos,2.0)*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec4 pos=vec4(floor(a_pos*0.5)+extrude,0,1);gl_Position=u_matrix*pos;}"), heatmapTexture: ne("uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;varying vec2 v_pos;void main() {float t=texture2D(u_image,v_pos).r;vec4 color=texture2D(u_color_ramp,vec2(t,0.5));gl_FragColor=color*u_opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(0.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;attribute vec2 a_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"), collisionBox: ne("varying float v_placed;varying float v_notUsed;void main() {float alpha=0.5;gl_FragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {gl_FragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {gl_FragColor*=.1;}}", "attribute vec2 a_pos;attribute vec2 a_anchor_pos;attribute vec2 a_extrude;attribute vec2 a_placed;attribute vec2 a_shift;uniform mat4 u_matrix;uniform vec2 u_extrude_scale;uniform float u_camera_to_center_distance;varying float v_placed;varying float v_notUsed;void main() {vec4 projectedPoint=u_matrix*vec4(a_anchor_pos,0,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);gl_Position=u_matrix*vec4(a_pos,get_elevation(a_pos),1.0);gl_Position.xy+=(a_extrude+a_shift)*u_extrude_scale*gl_Position.w*collision_perspective_ratio;v_placed=a_placed.x;v_notUsed=a_placed.y;}"), collisionCircle: ne("varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;void main() {float alpha=0.5*min(v_perspective_ratio,1.0);float stroke_radius=0.9*max(v_perspective_ratio,1.0);float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);gl_FragColor=color*alpha*opacity_t;}", "attribute vec2 a_pos;attribute float a_radius;attribute vec2 a_flags;uniform mat4 u_matrix;uniform mat4 u_inv_matrix;uniform vec2 u_viewport_size;uniform float u_camera_to_center_distance;varying float v_radius;varying vec2 v_extrude;varying float v_perspective_ratio;varying float v_collision;vec3 toTilePosition(vec2 screenPos) {vec4 rayStart=u_inv_matrix*vec4(screenPos,-1.0,1.0);vec4 rayEnd  =u_inv_matrix*vec4(screenPos, 1.0,1.0);rayStart.xyz/=rayStart.w;rayEnd.xyz  /=rayEnd.w;highp float t=(0.0-rayStart.z)/(rayEnd.z-rayStart.z);return mix(rayStart.xyz,rayEnd.xyz,t);}void main() {vec2 quadCenterPos=a_pos;float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;vec3 tilePos=toTilePosition(quadCenterPos);vec4 clipPos=u_matrix*vec4(tilePos,1.0);highp float camera_to_anchor_distance=clipPos.w;highp float collision_perspective_ratio=clamp(0.5+0.5*(u_camera_to_center_distance/camera_to_anchor_distance),0.0,4.0);float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_perspective_ratio=collision_perspective_ratio;v_collision=collision;gl_Position=vec4(clipPos.xyz/clipPos.w,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"), debug: ne("uniform highp vec4 u_color;uniform sampler2D u_overlay;varying vec2 v_uv;void main() {vec4 overlay_color=texture2D(u_overlay,v_uv);gl_FragColor=mix(u_color,overlay_color,overlay_color.a);}", "attribute vec2 a_pos;varying vec2 v_uv;uniform mat4 u_matrix;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=u_matrix*vec4(a_pos*u_overlay_scale,get_elevation(a_pos),1);}"), fill: ne("#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_FragColor=color*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);}"), fillOutline: ne("varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=outline_color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "attribute vec2 a_pos;uniform mat4 u_matrix;uniform vec2 u_world;varying vec2 v_pos;\n#pragma mapbox: define highp vec4 outline_color\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 outline_color\n#pragma mapbox: initialize lowp float opacity\ngl_Position=u_matrix*vec4(a_pos,0,1);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillOutlinePattern: ne("uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);gl_FragColor=mix(color1,color2,u_fade)*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec2 v_pos;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=u_matrix*vec4(a_pos,0,1);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;}"), fillPattern: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);gl_FragColor=mix(color1,color2,u_fade)*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;attribute vec2 a_pos;varying vec2 v_pos_a;varying vec2 v_pos_b;\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=u_matrix*vec4(a_pos,0,1);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}"), fillExtrusion: ne("varying vec4 v_color;void main() {gl_FragColor=v_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec4 v_color;\n#pragma mapbox: define highp float base\n#pragma mapbox: define highp float height\n#pragma mapbox: define highp vec4 color\nvoid main() {\n#pragma mapbox: initialize highp float base\n#pragma mapbox: initialize highp float height\n#pragma mapbox: initialize highp vec4 color\nvec3 normal=a_normal_ed.xyz;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);gl_Position=u_matrix*vec4(a_pos,t > 0.0 ? height : base,1);float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;float directional=clamp(dot(normal/16384.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}"), fillExtrusionPattern: ne("uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;varying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture2D(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture2D(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);gl_FragColor=mixedColor*v_lighting;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp float u_lightintensity;attribute vec2 a_pos;attribute vec4 a_normal_ed;\n#ifdef TERRAIN3D\nattribute vec2 a_centroid;\n#endif\nvarying vec2 v_pos_a;varying vec2 v_pos_b;varying vec4 v_lighting;\n#pragma mapbox: define lowp float base\n#pragma mapbox: define lowp float height\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float base\n#pragma mapbox: initialize lowp float height\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;\n#ifdef TERRAIN3D\nfloat height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);\n#else\nfloat height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;\n#endif\nbase=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float z=t > 0.0 ? height : base;gl_Position=u_matrix*vec4(a_pos,z,1);vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0\n? a_pos\n: vec2(edgedistance,z*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}"), hillshadePrepare: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture2D(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));gl_FragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_dimension;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"), hillshade: ne("uniform sampler2D u_image;varying vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;\n#define PI 3.141592653589793\nvoid main() {vec4 pixel=texture2D(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);gl_FragColor=accent_color*(1.0-shade_color.a)+shade_color;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos=a_texture_pos/8192.0;}"), line: ne("uniform lowp float u_device_pixel_ratio;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp float v_linesofar;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), lineGradient: ne("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;varying vec2 v_width2;varying vec2 v_normal;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture2D(u_image,v_uv);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\nattribute vec2 a_pos_normal;attribute vec4 a_data;attribute float a_uv_x;attribute float a_split_index;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;varying vec2 v_normal;varying vec2 v_width2;varying float v_gamma_scale;varying highp vec2 v_uv;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_width2=vec2(outset,inset);}"), linePattern: ne("#ifdef GL_ES\nprecision highp float;\n#endif\nuniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\nvec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture2D(u_image,pos_a),texture2D(u_image,pos_b),u_fade);gl_FragColor=color*alpha*opacity;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;varying vec2 v_normal;varying vec2 v_width2;varying float v_linesofar;varying float v_gamma_scale;varying float v_width;\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\n#pragma mapbox: define lowp vec4 pattern_from\n#pragma mapbox: define lowp vec4 pattern_to\n#pragma mapbox: define lowp float pixel_ratio_from\n#pragma mapbox: define lowp float pixel_ratio_to\nvoid main() {\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\n#pragma mapbox: initialize mediump vec4 pattern_from\n#pragma mapbox: initialize mediump vec4 pattern_to\n#pragma mapbox: initialize lowp float pixel_ratio_from\n#pragma mapbox: initialize lowp float pixel_ratio_to\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}"), lineSDF: ne("uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture2D(u_image,v_tex_a).a;float sdfdist_b=texture2D(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);gl_FragColor=color*(alpha*opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "\n#define scale 0.015873016\n#define LINE_DISTANCE_SCALE 2.0\nattribute vec2 a_pos_normal;attribute vec4 a_data;uniform mat4 u_matrix;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;varying vec2 v_normal;varying vec2 v_width2;varying vec2 v_tex_a;varying vec2 v_tex_b;varying float v_gamma_scale;\n#pragma mapbox: define highp vec4 color\n#pragma mapbox: define lowp float blur\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define mediump float gapwidth\n#pragma mapbox: define lowp float offset\n#pragma mapbox: define mediump float width\n#pragma mapbox: define lowp float floorwidth\nvoid main() {\n#pragma mapbox: initialize highp vec4 color\n#pragma mapbox: initialize lowp float blur\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize mediump float gapwidth\n#pragma mapbox: initialize lowp float offset\n#pragma mapbox: initialize mediump float width\n#pragma mapbox: initialize lowp float floorwidth\nfloat ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);vec4 projected_extrude=u_matrix*vec4(dist/u_ratio,0.0,0.0);gl_Position=u_matrix*vec4(pos+offset2/u_ratio,0.0,1.0)+projected_extrude;\n#ifdef TERRAIN3D\nv_gamma_scale=1.0;\n#else\nfloat extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length(projected_extrude.xy/gl_Position.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;\n#endif\nv_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}"), raster: ne("uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;varying vec2 v_pos0;varying vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture2D(u_image0,v_pos0);vec4 color1=texture2D(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);gl_FragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "uniform mat4 u_matrix;uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;attribute vec2 a_pos;attribute vec2 a_texture_pos;varying vec2 v_pos0;varying vec2 v_pos1;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);v_pos0=(((a_texture_pos/8192.0)-0.5)/u_buffer_scale )+0.5;v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}"), symbolIcon: ne("uniform sampler2D u_texture;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nlowp float alpha=opacity*v_fade_opacity;gl_FragColor=texture2D(u_texture,v_tex)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;varying vec2 v_tex;varying float v_fade_opacity;\n#pragma mapbox: define lowp float opacity\nvoid main() {\n#pragma mapbox: initialize lowp float opacity\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0),z,1.0);v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}"), symbolSDF: ne("#define SDF_PX 8.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec4 a_pixeloffset;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;varying vec2 v_data0;varying vec3 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}"), symbolTextAndIcon: ne("#define SDF_PX 8.0\n#define SDF 1.0\n#define ICON 0.0\nuniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nfloat fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;gl_FragColor=texture2D(u_texture_icon,tex_icon)*alpha;\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\nreturn;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture2D(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);gl_FragColor=color*(alpha*opacity*fade_opacity);\n#ifdef OVERDRAW_INSPECTOR\ngl_FragColor=vec4(1.0);\n#endif\n}", "const float PI=3.141592653589793;attribute vec4 a_pos_offset;attribute vec4 a_data;attribute vec3 a_projected_pos;attribute float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_matrix;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;varying vec4 v_data0;varying vec4 v_data1;\n#pragma mapbox: define highp vec4 fill_color\n#pragma mapbox: define highp vec4 halo_color\n#pragma mapbox: define lowp float opacity\n#pragma mapbox: define lowp float halo_width\n#pragma mapbox: define lowp float halo_blur\nvoid main() {\n#pragma mapbox: initialize highp vec4 fill_color\n#pragma mapbox: initialize highp vec4 halo_color\n#pragma mapbox: initialize lowp float opacity\n#pragma mapbox: initialize lowp float halo_width\n#pragma mapbox: initialize lowp float halo_blur\nvec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec4 projectedPoint=u_matrix*vec4(a_pos,ele,1);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?\ncamera_to_anchor_distance/u_camera_to_center_distance :\nu_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=u_matrix*vec4(a_pos+vec2(1,0),ele,1);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy,ele,1.0);float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;gl_Position=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale),z,1.0);float gamma_scale=gl_Position.w;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}"), terrain: ne("uniform sampler2D u_texture;varying vec2 v_texture_pos;void main() {gl_FragColor=texture2D(u_texture,v_texture_pos);}", oe), terrainDepth: ne("varying float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {gl_FragColor=pack(v_depth);}", oe), terrainCoords: ne("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;varying vec2 v_texture_pos;void main() {vec4 rgba=texture2D(u_texture,v_texture_pos);gl_FragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", oe) };
          function ne(t4, e4) {
            const i5 = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g, s5 = e4.match(/attribute ([\w]+) ([\w]+)/g), a5 = t4.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), o5 = e4.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g), r5 = o5 ? o5.concat(a5) : a5, n3 = {};
            return { fragmentSource: t4 = t4.replace(i5, (t5, e5, i6, s6, a6) => (n3[a6] = true, "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a6}
varying ${i6} ${s6} ${a6};
#else
uniform ${i6} ${s6} u_${a6};
#endif
` : `
#ifdef HAS_UNIFORM_u_${a6}
    ${i6} ${s6} ${a6} = u_${a6};
#endif
`)), vertexSource: e4 = e4.replace(i5, (t5, e5, i6, s6, a6) => {
              const o6 = "float" === s6 ? "vec2" : "vec4", r6 = a6.match(/color/) ? "color" : o6;
              return n3[a6] ? "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a6}
uniform lowp float u_${a6}_t;
attribute ${i6} ${o6} a_${a6};
varying ${i6} ${s6} ${a6};
#else
uniform ${i6} ${s6} u_${a6};
#endif
` : "vec4" === r6 ? `
#ifndef HAS_UNIFORM_u_${a6}
    ${a6} = a_${a6};
#else
    ${i6} ${s6} ${a6} = u_${a6};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a6}
    ${a6} = unpack_mix_${r6}(a_${a6}, u_${a6}_t);
#else
    ${i6} ${s6} ${a6} = u_${a6};
#endif
` : "define" === e5 ? `
#ifndef HAS_UNIFORM_u_${a6}
uniform lowp float u_${a6}_t;
attribute ${i6} ${o6} a_${a6};
#else
uniform ${i6} ${s6} u_${a6};
#endif
` : "vec4" === r6 ? `
#ifndef HAS_UNIFORM_u_${a6}
    ${i6} ${s6} ${a6} = a_${a6};
#else
    ${i6} ${s6} ${a6} = u_${a6};
#endif
` : `
#ifndef HAS_UNIFORM_u_${a6}
    ${i6} ${s6} ${a6} = unpack_mix_${r6}(a_${a6}, u_${a6}_t);
#else
    ${i6} ${s6} ${a6} = u_${a6};
#endif
`;
            }), staticAttributes: s5, staticUniforms: r5 };
          }
          class le {
            constructor() {
              this.boundProgram = null, this.boundLayoutVertexBuffer = null, this.boundPaintVertexBuffers = [], this.boundIndexBuffer = null, this.boundVertexOffset = null, this.boundDynamicVertexBuffer = null, this.vao = null;
            }
            bind(t4, e4, i5, s5, a5, o5, r5, n3, l5) {
              this.context = t4;
              let c5 = this.boundPaintVertexBuffers.length !== s5.length;
              for (let t5 = 0; !c5 && t5 < s5.length; t5++)
                this.boundPaintVertexBuffers[t5] !== s5[t5] && (c5 = true);
              !this.vao || this.boundProgram !== e4 || this.boundLayoutVertexBuffer !== i5 || c5 || this.boundIndexBuffer !== a5 || this.boundVertexOffset !== o5 || this.boundDynamicVertexBuffer !== r5 || this.boundDynamicVertexBuffer2 !== n3 || this.boundDynamicVertexBuffer3 !== l5 ? this.freshBind(e4, i5, s5, a5, o5, r5, n3, l5) : (t4.bindVertexArray.set(this.vao), r5 && r5.bind(), a5 && a5.dynamicDraw && a5.bind(), n3 && n3.bind(), l5 && l5.bind());
            }
            freshBind(t4, e4, i5, s5, a5, o5, r5, n3) {
              const l5 = t4.numAttributes, c5 = this.context, h4 = c5.gl;
              this.vao && this.destroy(), this.vao = c5.createVertexArray(), c5.bindVertexArray.set(this.vao), this.boundProgram = t4, this.boundLayoutVertexBuffer = e4, this.boundPaintVertexBuffers = i5, this.boundIndexBuffer = s5, this.boundVertexOffset = a5, this.boundDynamicVertexBuffer = o5, this.boundDynamicVertexBuffer2 = r5, this.boundDynamicVertexBuffer3 = n3, e4.enableAttributes(h4, t4);
              for (const e5 of i5)
                e5.enableAttributes(h4, t4);
              o5 && o5.enableAttributes(h4, t4), r5 && r5.enableAttributes(h4, t4), n3 && n3.enableAttributes(h4, t4), e4.bind(), e4.setVertexAttribPointers(h4, t4, a5);
              for (const e5 of i5)
                e5.bind(), e5.setVertexAttribPointers(h4, t4, a5);
              o5 && (o5.bind(), o5.setVertexAttribPointers(h4, t4, a5)), s5 && s5.bind(), r5 && (r5.bind(), r5.setVertexAttribPointers(h4, t4, a5)), n3 && (n3.bind(), n3.setVertexAttribPointers(h4, t4, a5)), c5.currentNumAttributes = l5;
            }
            destroy() {
              this.vao && (this.context.deleteVertexArray(this.vao), this.vao = null);
            }
          }
          function ce(t4) {
            const e4 = [];
            for (let i5 = 0; i5 < t4.length; i5++) {
              if (null === t4[i5])
                continue;
              const s5 = t4[i5].split(" ");
              e4.push(s5.pop());
            }
            return e4;
          }
          class he {
            constructor(e4, i5, s5, a5, o5, r5) {
              const n3 = e4.gl;
              this.program = n3.createProgram();
              const l5 = ce(i5.staticAttributes), c5 = s5 ? s5.getBinderAttributes() : [], h4 = l5.concat(c5), u5 = re.prelude.staticUniforms ? ce(re.prelude.staticUniforms) : [], d4 = i5.staticUniforms ? ce(i5.staticUniforms) : [], _4 = s5 ? s5.getBinderUniforms() : [], m4 = u5.concat(d4).concat(_4), p7 = [];
              for (const t4 of m4)
                p7.indexOf(t4) < 0 && p7.push(t4);
              const f4 = s5 ? s5.defines() : [];
              o5 && f4.push("#define OVERDRAW_INSPECTOR;"), r5 && f4.push("#define TERRAIN3D;");
              const g4 = f4.concat(re.prelude.fragmentSource, i5.fragmentSource).join("\n"), v5 = f4.concat(re.prelude.vertexSource, i5.vertexSource).join("\n"), x3 = n3.createShader(n3.FRAGMENT_SHADER);
              if (n3.isContextLost())
                return void (this.failedToCreate = true);
              if (n3.shaderSource(x3, g4), n3.compileShader(x3), !n3.getShaderParameter(x3, n3.COMPILE_STATUS))
                throw new Error(`Could not compile fragment shader: ${n3.getShaderInfoLog(x3)}`);
              n3.attachShader(this.program, x3);
              const y3 = n3.createShader(n3.VERTEX_SHADER);
              if (n3.isContextLost())
                return void (this.failedToCreate = true);
              if (n3.shaderSource(y3, v5), n3.compileShader(y3), !n3.getShaderParameter(y3, n3.COMPILE_STATUS))
                throw new Error(`Could not compile vertex shader: ${n3.getShaderInfoLog(y3)}`);
              n3.attachShader(this.program, y3), this.attributes = {};
              const b4 = {};
              this.numAttributes = h4.length;
              for (let t4 = 0; t4 < this.numAttributes; t4++)
                h4[t4] && (n3.bindAttribLocation(this.program, t4, h4[t4]), this.attributes[h4[t4]] = t4);
              if (n3.linkProgram(this.program), !n3.getProgramParameter(this.program, n3.LINK_STATUS))
                throw new Error(`Program failed to link: ${n3.getProgramInfoLog(this.program)}`);
              n3.deleteShader(y3), n3.deleteShader(x3);
              for (let t4 = 0; t4 < p7.length; t4++) {
                const e5 = p7[t4];
                if (e5 && !b4[e5]) {
                  const t5 = n3.getUniformLocation(this.program, e5);
                  t5 && (b4[e5] = t5);
                }
              }
              this.fixedUniforms = a5(e4, b4), this.terrainUniforms = ((e5, i6) => ({ u_depth: new t3.Uniform1i(e5, i6.u_depth), u_terrain: new t3.Uniform1i(e5, i6.u_terrain), u_terrain_dim: new t3.Uniform1f(e5, i6.u_terrain_dim), u_terrain_matrix: new t3.UniformMatrix4f(e5, i6.u_terrain_matrix), u_terrain_unpack: new t3.Uniform4f(e5, i6.u_terrain_unpack), u_terrain_exaggeration: new t3.Uniform1f(e5, i6.u_terrain_exaggeration) }))(e4, b4), this.binderUniforms = s5 ? s5.getUniforms(e4, b4) : [];
            }
            draw(t4, e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4, _4, m4, p7, f4, g4) {
              const v5 = t4.gl;
              if (this.failedToCreate)
                return;
              if (t4.program.set(this.program), t4.setDepthMode(i5), t4.setStencilMode(s5), t4.setColorMode(a5), t4.setCullFace(o5), n3) {
                t4.activeTexture.set(v5.TEXTURE2), v5.bindTexture(v5.TEXTURE_2D, n3.depthTexture), t4.activeTexture.set(v5.TEXTURE3), v5.bindTexture(v5.TEXTURE_2D, n3.texture);
                for (const t5 in this.terrainUniforms)
                  this.terrainUniforms[t5].set(n3[t5]);
              }
              for (const t5 in this.fixedUniforms)
                this.fixedUniforms[t5].set(r5[t5]);
              m4 && m4.setUniforms(t4, this.binderUniforms, d4, { zoom: _4 });
              let x3 = 0;
              switch (e4) {
                case v5.LINES:
                  x3 = 2;
                  break;
                case v5.TRIANGLES:
                  x3 = 3;
                  break;
                case v5.LINE_STRIP:
                  x3 = 1;
              }
              for (const i6 of u5.get()) {
                const s6 = i6.vaos || (i6.vaos = {});
                (s6[l5] || (s6[l5] = new le())).bind(t4, this, c5, m4 ? m4.getPaintVertexBuffers() : [], h4, i6.vertexOffset, p7, f4, g4), v5.drawElements(e4, i6.primitiveLength * x3, v5.UNSIGNED_SHORT, i6.primitiveOffset * x3 * 2);
              }
            }
          }
          function ue(t4, e4, i5) {
            const s5 = 1 / St(i5, 1, e4.transform.tileZoom), a5 = Math.pow(2, i5.tileID.overscaledZ), o5 = i5.tileSize * Math.pow(2, e4.transform.tileZoom) / a5, r5 = o5 * (i5.tileID.canonical.x + i5.tileID.wrap * a5), n3 = o5 * i5.tileID.canonical.y;
            return { u_image: 0, u_texsize: i5.imageAtlasTexture.size, u_scale: [s5, t4.fromScale, t4.toScale], u_fade: t4.t, u_pixel_coord_upper: [r5 >> 16, n3 >> 16], u_pixel_coord_lower: [65535 & r5, 65535 & n3] };
          }
          const de = (e4, i5, s5, a5) => {
            const o5 = i5.style.light, r5 = o5.properties.get("position"), n3 = [r5.x, r5.y, r5.z], l5 = function() {
              var e5 = new t3.ARRAY_TYPE(9);
              return t3.ARRAY_TYPE != Float32Array && (e5[1] = 0, e5[2] = 0, e5[3] = 0, e5[5] = 0, e5[6] = 0, e5[7] = 0), e5[0] = 1, e5[4] = 1, e5[8] = 1, e5;
            }();
            "viewport" === o5.properties.get("anchor") && function(t4, e5) {
              var i6 = Math.sin(e5), s6 = Math.cos(e5);
              t4[0] = s6, t4[1] = i6, t4[2] = 0, t4[3] = -i6, t4[4] = s6, t4[5] = 0, t4[6] = 0, t4[7] = 0, t4[8] = 1;
            }(l5, -i5.transform.angle), function(t4, e5, i6) {
              var s6 = e5[0], a6 = e5[1], o6 = e5[2];
              t4[0] = s6 * i6[0] + a6 * i6[3] + o6 * i6[6], t4[1] = s6 * i6[1] + a6 * i6[4] + o6 * i6[7], t4[2] = s6 * i6[2] + a6 * i6[5] + o6 * i6[8];
            }(n3, n3, l5);
            const c5 = o5.properties.get("color");
            return { u_matrix: e4, u_lightpos: n3, u_lightintensity: o5.properties.get("intensity"), u_lightcolor: [c5.r, c5.g, c5.b], u_vertical_gradient: +s5, u_opacity: a5 };
          }, _e = (e4, i5, s5, a5, o5, r5, n3) => t3.extend(de(e4, i5, s5, a5), ue(r5, i5, n3), { u_height_factor: -Math.pow(2, o5.overscaledZ) / n3.tileSize / 8 }), me = (t4) => ({ u_matrix: t4 }), pe = (e4, i5, s5, a5) => t3.extend(me(e4), ue(s5, i5, a5)), fe = (t4, e4) => ({ u_matrix: t4, u_world: e4 }), ge = (e4, i5, s5, a5, o5) => t3.extend(pe(e4, i5, s5, a5), { u_world: o5 }), ve = (t4, e4, i5, s5) => {
            const a5 = t4.transform;
            let o5, r5;
            if ("map" === s5.paint.get("circle-pitch-alignment")) {
              const t5 = St(i5, 1, a5.zoom);
              o5 = true, r5 = [t5, t5];
            } else
              o5 = false, r5 = a5.pixelsToGLUnits;
            return { u_camera_to_center_distance: a5.cameraToCenterDistance, u_scale_with_map: +("map" === s5.paint.get("circle-pitch-scale")), u_matrix: t4.translatePosMatrix(e4.posMatrix, i5, s5.paint.get("circle-translate"), s5.paint.get("circle-translate-anchor")), u_pitch_with_map: +o5, u_device_pixel_ratio: t4.pixelRatio, u_extrude_scale: r5 };
          }, xe = (t4, e4, i5) => {
            const s5 = St(i5, 1, e4.zoom), a5 = Math.pow(2, e4.zoom - i5.tileID.overscaledZ), o5 = i5.tileID.overscaleFactor();
            return { u_matrix: t4, u_camera_to_center_distance: e4.cameraToCenterDistance, u_pixels_to_tile_units: s5, u_extrude_scale: [e4.pixelsToGLUnits[0] / (s5 * a5), e4.pixelsToGLUnits[1] / (s5 * a5)], u_overscale_factor: o5 };
          }, ye = (t4, e4, i5 = 1) => ({ u_matrix: t4, u_color: e4, u_overlay: 0, u_overlay_scale: i5 }), be = (t4) => ({ u_matrix: t4 }), we = (t4, e4, i5, s5) => ({ u_matrix: t4, u_extrude_scale: St(e4, 1, i5), u_intensity: s5 });
          function Te(e4, i5) {
            const s5 = Math.pow(2, i5.canonical.z), a5 = i5.canonical.y;
            return [new t3.MercatorCoordinate(0, a5 / s5).toLngLat().lat, new t3.MercatorCoordinate(0, (a5 + 1) / s5).toLngLat().lat];
          }
          const Ee = (t4, e4, i5, s5) => {
            const a5 = t4.transform;
            return { u_matrix: De(t4, e4, i5, s5), u_ratio: 1 / St(e4, 1, a5.zoom), u_device_pixel_ratio: t4.pixelRatio, u_units_to_pixels: [1 / a5.pixelsToGLUnits[0], 1 / a5.pixelsToGLUnits[1]] };
          }, Ie = (e4, i5, s5, a5, o5) => t3.extend(Ee(e4, i5, s5, o5), { u_image: 0, u_image_height: a5 }), Se = (t4, e4, i5, s5, a5) => {
            const o5 = t4.transform, r5 = Pe(e4, o5);
            return { u_matrix: De(t4, e4, i5, a5), u_texsize: e4.imageAtlasTexture.size, u_ratio: 1 / St(e4, 1, o5.zoom), u_device_pixel_ratio: t4.pixelRatio, u_image: 0, u_scale: [r5, s5.fromScale, s5.toScale], u_fade: s5.t, u_units_to_pixels: [1 / o5.pixelsToGLUnits[0], 1 / o5.pixelsToGLUnits[1]] };
          }, Ce = (e4, i5, s5, a5, o5, r5) => {
            const n3 = e4.lineAtlas, l5 = Pe(i5, e4.transform), c5 = "round" === s5.layout.get("line-cap"), h4 = n3.getDash(a5.from, c5), u5 = n3.getDash(a5.to, c5), d4 = h4.width * o5.fromScale, _4 = u5.width * o5.toScale;
            return t3.extend(Ee(e4, i5, s5, r5), { u_patternscale_a: [l5 / d4, -h4.height / 2], u_patternscale_b: [l5 / _4, -u5.height / 2], u_sdfgamma: n3.width / (256 * Math.min(d4, _4) * e4.pixelRatio) / 2, u_image: 0, u_tex_y_a: h4.y, u_tex_y_b: u5.y, u_mix: o5.t });
          };
          function Pe(t4, e4) {
            return 1 / St(t4, 1, e4.tileZoom);
          }
          function De(t4, e4, i5, s5) {
            return t4.translatePosMatrix(s5 ? s5.posMatrix : e4.tileID.posMatrix, e4, i5.paint.get("line-translate"), i5.paint.get("line-translate-anchor"));
          }
          const Me = (t4, e4, i5, s5, a5) => {
            return { u_matrix: t4, u_tl_parent: e4, u_scale_parent: i5, u_buffer_scale: 1, u_fade_t: s5.mix, u_opacity: s5.opacity * a5.paint.get("raster-opacity"), u_image0: 0, u_image1: 1, u_brightness_low: a5.paint.get("raster-brightness-min"), u_brightness_high: a5.paint.get("raster-brightness-max"), u_saturation_factor: (r5 = a5.paint.get("raster-saturation"), r5 > 0 ? 1 - 1 / (1.001 - r5) : -r5), u_contrast_factor: (o5 = a5.paint.get("raster-contrast"), o5 > 0 ? 1 / (1 - o5) : 1 + o5), u_spin_weights: ze(a5.paint.get("raster-hue-rotate")) };
            var o5, r5;
          };
          function ze(t4) {
            t4 *= Math.PI / 180;
            const e4 = Math.sin(t4), i5 = Math.cos(t4);
            return [(2 * i5 + 1) / 3, (-Math.sqrt(3) * e4 - i5 + 1) / 3, (Math.sqrt(3) * e4 - i5 + 1) / 3];
          }
          const Ae = (t4, e4, i5, s5, a5, o5, r5, n3, l5, c5) => {
            const h4 = a5.transform;
            return { u_is_size_zoom_constant: +("constant" === t4 || "source" === t4), u_is_size_feature_constant: +("constant" === t4 || "camera" === t4), u_size_t: e4 ? e4.uSizeT : 0, u_size: e4 ? e4.uSize : 0, u_camera_to_center_distance: h4.cameraToCenterDistance, u_pitch: h4.pitch / 360 * 2 * Math.PI, u_rotate_symbol: +i5, u_aspect_ratio: h4.width / h4.height, u_fade_change: a5.options.fadeDuration ? a5.symbolFadeChange : 1, u_matrix: o5, u_label_plane_matrix: r5, u_coord_matrix: n3, u_is_text: +l5, u_pitch_with_map: +s5, u_texsize: c5, u_texture: 0 };
          }, Le = (e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5) => {
            const d4 = o5.transform;
            return t3.extend(Ae(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4), { u_gamma_scale: a5 ? Math.cos(d4._pitch) * d4.cameraToCenterDistance : 1, u_device_pixel_ratio: o5.pixelRatio, u_is_halo: +u5 });
          }, Re = (e4, i5, s5, a5, o5, r5, n3, l5, c5, h4) => t3.extend(Le(e4, i5, s5, a5, o5, r5, n3, l5, true, c5, true), { u_texsize_icon: h4, u_texture_icon: 1 }), ke = (t4, e4, i5) => ({ u_matrix: t4, u_opacity: e4, u_color: i5 }), Fe = (e4, i5, s5, a5, o5, r5) => t3.extend(function(t4, e5, i6, s6) {
            const a6 = i6.imageManager.getPattern(t4.from.toString()), o6 = i6.imageManager.getPattern(t4.to.toString()), { width: r6, height: n3 } = i6.imageManager.getPixelSize(), l5 = Math.pow(2, s6.tileID.overscaledZ), c5 = s6.tileSize * Math.pow(2, i6.transform.tileZoom) / l5, h4 = c5 * (s6.tileID.canonical.x + s6.tileID.wrap * l5), u5 = c5 * s6.tileID.canonical.y;
            return { u_image: 0, u_pattern_tl_a: a6.tl, u_pattern_br_a: a6.br, u_pattern_tl_b: o6.tl, u_pattern_br_b: o6.br, u_texsize: [r6, n3], u_mix: e5.t, u_pattern_size_a: a6.displaySize, u_pattern_size_b: o6.displaySize, u_scale_a: e5.fromScale, u_scale_b: e5.toScale, u_tile_units_to_pixels: 1 / St(s6, 1, i6.transform.tileZoom), u_pixel_coord_upper: [h4 >> 16, u5 >> 16], u_pixel_coord_lower: [65535 & h4, 65535 & u5] };
          }(a5, r5, s5, o5), { u_matrix: e4, u_opacity: i5 }), Be = { fillExtrusion: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_lightpos: new t3.Uniform3f(e4, i5.u_lightpos), u_lightintensity: new t3.Uniform1f(e4, i5.u_lightintensity), u_lightcolor: new t3.Uniform3f(e4, i5.u_lightcolor), u_vertical_gradient: new t3.Uniform1f(e4, i5.u_vertical_gradient), u_opacity: new t3.Uniform1f(e4, i5.u_opacity) }), fillExtrusionPattern: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_lightpos: new t3.Uniform3f(e4, i5.u_lightpos), u_lightintensity: new t3.Uniform1f(e4, i5.u_lightintensity), u_lightcolor: new t3.Uniform3f(e4, i5.u_lightcolor), u_vertical_gradient: new t3.Uniform1f(e4, i5.u_vertical_gradient), u_height_factor: new t3.Uniform1f(e4, i5.u_height_factor), u_image: new t3.Uniform1i(e4, i5.u_image), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_pixel_coord_upper: new t3.Uniform2f(e4, i5.u_pixel_coord_upper), u_pixel_coord_lower: new t3.Uniform2f(e4, i5.u_pixel_coord_lower), u_scale: new t3.Uniform3f(e4, i5.u_scale), u_fade: new t3.Uniform1f(e4, i5.u_fade), u_opacity: new t3.Uniform1f(e4, i5.u_opacity) }), fill: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix) }), fillPattern: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_image: new t3.Uniform1i(e4, i5.u_image), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_pixel_coord_upper: new t3.Uniform2f(e4, i5.u_pixel_coord_upper), u_pixel_coord_lower: new t3.Uniform2f(e4, i5.u_pixel_coord_lower), u_scale: new t3.Uniform3f(e4, i5.u_scale), u_fade: new t3.Uniform1f(e4, i5.u_fade) }), fillOutline: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_world: new t3.Uniform2f(e4, i5.u_world) }), fillOutlinePattern: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_world: new t3.Uniform2f(e4, i5.u_world), u_image: new t3.Uniform1i(e4, i5.u_image), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_pixel_coord_upper: new t3.Uniform2f(e4, i5.u_pixel_coord_upper), u_pixel_coord_lower: new t3.Uniform2f(e4, i5.u_pixel_coord_lower), u_scale: new t3.Uniform3f(e4, i5.u_scale), u_fade: new t3.Uniform1f(e4, i5.u_fade) }), circle: (e4, i5) => ({ u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_scale_with_map: new t3.Uniform1i(e4, i5.u_scale_with_map), u_pitch_with_map: new t3.Uniform1i(e4, i5.u_pitch_with_map), u_extrude_scale: new t3.Uniform2f(e4, i5.u_extrude_scale), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix) }), collisionBox: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_pixels_to_tile_units: new t3.Uniform1f(e4, i5.u_pixels_to_tile_units), u_extrude_scale: new t3.Uniform2f(e4, i5.u_extrude_scale), u_overscale_factor: new t3.Uniform1f(e4, i5.u_overscale_factor) }), collisionCircle: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_inv_matrix: new t3.UniformMatrix4f(e4, i5.u_inv_matrix), u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_viewport_size: new t3.Uniform2f(e4, i5.u_viewport_size) }), debug: (e4, i5) => ({ u_color: new t3.UniformColor(e4, i5.u_color), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_overlay: new t3.Uniform1i(e4, i5.u_overlay), u_overlay_scale: new t3.Uniform1f(e4, i5.u_overlay_scale) }), clippingMask: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix) }), heatmap: (e4, i5) => ({ u_extrude_scale: new t3.Uniform1f(e4, i5.u_extrude_scale), u_intensity: new t3.Uniform1f(e4, i5.u_intensity), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix) }), heatmapTexture: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_world: new t3.Uniform2f(e4, i5.u_world), u_image: new t3.Uniform1i(e4, i5.u_image), u_color_ramp: new t3.Uniform1i(e4, i5.u_color_ramp), u_opacity: new t3.Uniform1f(e4, i5.u_opacity) }), hillshade: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_image: new t3.Uniform1i(e4, i5.u_image), u_latrange: new t3.Uniform2f(e4, i5.u_latrange), u_light: new t3.Uniform2f(e4, i5.u_light), u_shadow: new t3.UniformColor(e4, i5.u_shadow), u_highlight: new t3.UniformColor(e4, i5.u_highlight), u_accent: new t3.UniformColor(e4, i5.u_accent) }), hillshadePrepare: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_image: new t3.Uniform1i(e4, i5.u_image), u_dimension: new t3.Uniform2f(e4, i5.u_dimension), u_zoom: new t3.Uniform1f(e4, i5.u_zoom), u_unpack: new t3.Uniform4f(e4, i5.u_unpack) }), line: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_ratio: new t3.Uniform1f(e4, i5.u_ratio), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_units_to_pixels: new t3.Uniform2f(e4, i5.u_units_to_pixels) }), lineGradient: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_ratio: new t3.Uniform1f(e4, i5.u_ratio), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_units_to_pixels: new t3.Uniform2f(e4, i5.u_units_to_pixels), u_image: new t3.Uniform1i(e4, i5.u_image), u_image_height: new t3.Uniform1f(e4, i5.u_image_height) }), linePattern: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_ratio: new t3.Uniform1f(e4, i5.u_ratio), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_image: new t3.Uniform1i(e4, i5.u_image), u_units_to_pixels: new t3.Uniform2f(e4, i5.u_units_to_pixels), u_scale: new t3.Uniform3f(e4, i5.u_scale), u_fade: new t3.Uniform1f(e4, i5.u_fade) }), lineSDF: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_ratio: new t3.Uniform1f(e4, i5.u_ratio), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_units_to_pixels: new t3.Uniform2f(e4, i5.u_units_to_pixels), u_patternscale_a: new t3.Uniform2f(e4, i5.u_patternscale_a), u_patternscale_b: new t3.Uniform2f(e4, i5.u_patternscale_b), u_sdfgamma: new t3.Uniform1f(e4, i5.u_sdfgamma), u_image: new t3.Uniform1i(e4, i5.u_image), u_tex_y_a: new t3.Uniform1f(e4, i5.u_tex_y_a), u_tex_y_b: new t3.Uniform1f(e4, i5.u_tex_y_b), u_mix: new t3.Uniform1f(e4, i5.u_mix) }), raster: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_tl_parent: new t3.Uniform2f(e4, i5.u_tl_parent), u_scale_parent: new t3.Uniform1f(e4, i5.u_scale_parent), u_buffer_scale: new t3.Uniform1f(e4, i5.u_buffer_scale), u_fade_t: new t3.Uniform1f(e4, i5.u_fade_t), u_opacity: new t3.Uniform1f(e4, i5.u_opacity), u_image0: new t3.Uniform1i(e4, i5.u_image0), u_image1: new t3.Uniform1i(e4, i5.u_image1), u_brightness_low: new t3.Uniform1f(e4, i5.u_brightness_low), u_brightness_high: new t3.Uniform1f(e4, i5.u_brightness_high), u_saturation_factor: new t3.Uniform1f(e4, i5.u_saturation_factor), u_contrast_factor: new t3.Uniform1f(e4, i5.u_contrast_factor), u_spin_weights: new t3.Uniform3f(e4, i5.u_spin_weights) }), symbolIcon: (e4, i5) => ({ u_is_size_zoom_constant: new t3.Uniform1i(e4, i5.u_is_size_zoom_constant), u_is_size_feature_constant: new t3.Uniform1i(e4, i5.u_is_size_feature_constant), u_size_t: new t3.Uniform1f(e4, i5.u_size_t), u_size: new t3.Uniform1f(e4, i5.u_size), u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_pitch: new t3.Uniform1f(e4, i5.u_pitch), u_rotate_symbol: new t3.Uniform1i(e4, i5.u_rotate_symbol), u_aspect_ratio: new t3.Uniform1f(e4, i5.u_aspect_ratio), u_fade_change: new t3.Uniform1f(e4, i5.u_fade_change), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_label_plane_matrix: new t3.UniformMatrix4f(e4, i5.u_label_plane_matrix), u_coord_matrix: new t3.UniformMatrix4f(e4, i5.u_coord_matrix), u_is_text: new t3.Uniform1i(e4, i5.u_is_text), u_pitch_with_map: new t3.Uniform1i(e4, i5.u_pitch_with_map), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_texture: new t3.Uniform1i(e4, i5.u_texture) }), symbolSDF: (e4, i5) => ({ u_is_size_zoom_constant: new t3.Uniform1i(e4, i5.u_is_size_zoom_constant), u_is_size_feature_constant: new t3.Uniform1i(e4, i5.u_is_size_feature_constant), u_size_t: new t3.Uniform1f(e4, i5.u_size_t), u_size: new t3.Uniform1f(e4, i5.u_size), u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_pitch: new t3.Uniform1f(e4, i5.u_pitch), u_rotate_symbol: new t3.Uniform1i(e4, i5.u_rotate_symbol), u_aspect_ratio: new t3.Uniform1f(e4, i5.u_aspect_ratio), u_fade_change: new t3.Uniform1f(e4, i5.u_fade_change), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_label_plane_matrix: new t3.UniformMatrix4f(e4, i5.u_label_plane_matrix), u_coord_matrix: new t3.UniformMatrix4f(e4, i5.u_coord_matrix), u_is_text: new t3.Uniform1i(e4, i5.u_is_text), u_pitch_with_map: new t3.Uniform1i(e4, i5.u_pitch_with_map), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_texture: new t3.Uniform1i(e4, i5.u_texture), u_gamma_scale: new t3.Uniform1f(e4, i5.u_gamma_scale), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_is_halo: new t3.Uniform1i(e4, i5.u_is_halo) }), symbolTextAndIcon: (e4, i5) => ({ u_is_size_zoom_constant: new t3.Uniform1i(e4, i5.u_is_size_zoom_constant), u_is_size_feature_constant: new t3.Uniform1i(e4, i5.u_is_size_feature_constant), u_size_t: new t3.Uniform1f(e4, i5.u_size_t), u_size: new t3.Uniform1f(e4, i5.u_size), u_camera_to_center_distance: new t3.Uniform1f(e4, i5.u_camera_to_center_distance), u_pitch: new t3.Uniform1f(e4, i5.u_pitch), u_rotate_symbol: new t3.Uniform1i(e4, i5.u_rotate_symbol), u_aspect_ratio: new t3.Uniform1f(e4, i5.u_aspect_ratio), u_fade_change: new t3.Uniform1f(e4, i5.u_fade_change), u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_label_plane_matrix: new t3.UniformMatrix4f(e4, i5.u_label_plane_matrix), u_coord_matrix: new t3.UniformMatrix4f(e4, i5.u_coord_matrix), u_is_text: new t3.Uniform1i(e4, i5.u_is_text), u_pitch_with_map: new t3.Uniform1i(e4, i5.u_pitch_with_map), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_texsize_icon: new t3.Uniform2f(e4, i5.u_texsize_icon), u_texture: new t3.Uniform1i(e4, i5.u_texture), u_texture_icon: new t3.Uniform1i(e4, i5.u_texture_icon), u_gamma_scale: new t3.Uniform1f(e4, i5.u_gamma_scale), u_device_pixel_ratio: new t3.Uniform1f(e4, i5.u_device_pixel_ratio), u_is_halo: new t3.Uniform1i(e4, i5.u_is_halo) }), background: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_opacity: new t3.Uniform1f(e4, i5.u_opacity), u_color: new t3.UniformColor(e4, i5.u_color) }), backgroundPattern: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_opacity: new t3.Uniform1f(e4, i5.u_opacity), u_image: new t3.Uniform1i(e4, i5.u_image), u_pattern_tl_a: new t3.Uniform2f(e4, i5.u_pattern_tl_a), u_pattern_br_a: new t3.Uniform2f(e4, i5.u_pattern_br_a), u_pattern_tl_b: new t3.Uniform2f(e4, i5.u_pattern_tl_b), u_pattern_br_b: new t3.Uniform2f(e4, i5.u_pattern_br_b), u_texsize: new t3.Uniform2f(e4, i5.u_texsize), u_mix: new t3.Uniform1f(e4, i5.u_mix), u_pattern_size_a: new t3.Uniform2f(e4, i5.u_pattern_size_a), u_pattern_size_b: new t3.Uniform2f(e4, i5.u_pattern_size_b), u_scale_a: new t3.Uniform1f(e4, i5.u_scale_a), u_scale_b: new t3.Uniform1f(e4, i5.u_scale_b), u_pixel_coord_upper: new t3.Uniform2f(e4, i5.u_pixel_coord_upper), u_pixel_coord_lower: new t3.Uniform2f(e4, i5.u_pixel_coord_lower), u_tile_units_to_pixels: new t3.Uniform1f(e4, i5.u_tile_units_to_pixels) }), terrain: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_texture: new t3.Uniform1i(e4, i5.u_texture), u_ele_delta: new t3.Uniform1f(e4, i5.u_ele_delta) }), terrainDepth: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_ele_delta: new t3.Uniform1f(e4, i5.u_ele_delta) }), terrainCoords: (e4, i5) => ({ u_matrix: new t3.UniformMatrix4f(e4, i5.u_matrix), u_texture: new t3.Uniform1i(e4, i5.u_texture), u_terrain_coords_id: new t3.Uniform1f(e4, i5.u_terrain_coords_id), u_ele_delta: new t3.Uniform1f(e4, i5.u_ele_delta) }) };
          class Ue {
            constructor(t4, e4, i5) {
              this.context = t4;
              const s5 = t4.gl;
              this.buffer = s5.createBuffer(), this.dynamicDraw = Boolean(i5), this.context.unbindVAO(), t4.bindElementBuffer.set(this.buffer), s5.bufferData(s5.ELEMENT_ARRAY_BUFFER, e4.arrayBuffer, this.dynamicDraw ? s5.DYNAMIC_DRAW : s5.STATIC_DRAW), this.dynamicDraw || delete e4.arrayBuffer;
            }
            bind() {
              this.context.bindElementBuffer.set(this.buffer);
            }
            updateData(t4) {
              const e4 = this.context.gl;
              if (!this.dynamicDraw)
                throw new Error("Attempted to update data while not in dynamic mode.");
              this.context.unbindVAO(), this.bind(), e4.bufferSubData(e4.ELEMENT_ARRAY_BUFFER, 0, t4.arrayBuffer);
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Oe = { Int8: "BYTE", Uint8: "UNSIGNED_BYTE", Int16: "SHORT", Uint16: "UNSIGNED_SHORT", Int32: "INT", Uint32: "UNSIGNED_INT", Float32: "FLOAT" };
          class Ne {
            constructor(t4, e4, i5, s5) {
              this.length = e4.length, this.attributes = i5, this.itemSize = e4.bytesPerElement, this.dynamicDraw = s5, this.context = t4;
              const a5 = t4.gl;
              this.buffer = a5.createBuffer(), t4.bindVertexBuffer.set(this.buffer), a5.bufferData(a5.ARRAY_BUFFER, e4.arrayBuffer, this.dynamicDraw ? a5.DYNAMIC_DRAW : a5.STATIC_DRAW), this.dynamicDraw || delete e4.arrayBuffer;
            }
            bind() {
              this.context.bindVertexBuffer.set(this.buffer);
            }
            updateData(t4) {
              if (t4.length !== this.length)
                throw new Error(`Length of new data is ${t4.length}, which doesn't match current length of ${this.length}`);
              const e4 = this.context.gl;
              this.bind(), e4.bufferSubData(e4.ARRAY_BUFFER, 0, t4.arrayBuffer);
            }
            enableAttributes(t4, e4) {
              for (let i5 = 0; i5 < this.attributes.length; i5++) {
                const s5 = e4.attributes[this.attributes[i5].name];
                void 0 !== s5 && t4.enableVertexAttribArray(s5);
              }
            }
            setVertexAttribPointers(t4, e4, i5) {
              for (let s5 = 0; s5 < this.attributes.length; s5++) {
                const a5 = this.attributes[s5], o5 = e4.attributes[a5.name];
                void 0 !== o5 && t4.vertexAttribPointer(o5, a5.components, t4[Oe[a5.type]], false, this.itemSize, a5.offset + this.itemSize * (i5 || 0));
              }
            }
            destroy() {
              this.buffer && (this.context.gl.deleteBuffer(this.buffer), delete this.buffer);
            }
          }
          const Ze = /* @__PURE__ */ new WeakMap();
          function Ge(t4) {
            if (Ze.has(t4))
              return Ze.get(t4);
            {
              const e4 = t4.getParameter(t4.VERSION).startsWith("WebGL 2.0");
              return Ze.set(t4, e4), e4;
            }
          }
          class Ve {
            constructor(t4) {
              this.gl = t4.gl, this.default = this.getDefault(), this.current = this.default, this.dirty = false;
            }
            get() {
              return this.current;
            }
            set(t4) {
            }
            getDefault() {
              return this.default;
            }
            setDefault() {
              this.set(this.default);
            }
          }
          class qe extends Ve {
            getDefault() {
              return t3.Color.transparent;
            }
            set(t4) {
              const e4 = this.current;
              (t4.r !== e4.r || t4.g !== e4.g || t4.b !== e4.b || t4.a !== e4.a || this.dirty) && (this.gl.clearColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
            }
          }
          class je extends Ve {
            getDefault() {
              return 1;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.clearDepth(t4), this.current = t4, this.dirty = false);
            }
          }
          class $e extends Ve {
            getDefault() {
              return 0;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.clearStencil(t4), this.current = t4, this.dirty = false);
            }
          }
          class Xe extends Ve {
            getDefault() {
              return [true, true, true, true];
            }
            set(t4) {
              const e4 = this.current;
              (t4[0] !== e4[0] || t4[1] !== e4[1] || t4[2] !== e4[2] || t4[3] !== e4[3] || this.dirty) && (this.gl.colorMask(t4[0], t4[1], t4[2], t4[3]), this.current = t4, this.dirty = false);
            }
          }
          class We extends Ve {
            getDefault() {
              return true;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.depthMask(t4), this.current = t4, this.dirty = false);
            }
          }
          class He extends Ve {
            getDefault() {
              return 255;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.stencilMask(t4), this.current = t4, this.dirty = false);
            }
          }
          class Ke extends Ve {
            getDefault() {
              return { func: this.gl.ALWAYS, ref: 0, mask: 255 };
            }
            set(t4) {
              const e4 = this.current;
              (t4.func !== e4.func || t4.ref !== e4.ref || t4.mask !== e4.mask || this.dirty) && (this.gl.stencilFunc(t4.func, t4.ref, t4.mask), this.current = t4, this.dirty = false);
            }
          }
          class Ye extends Ve {
            getDefault() {
              const t4 = this.gl;
              return [t4.KEEP, t4.KEEP, t4.KEEP];
            }
            set(t4) {
              const e4 = this.current;
              (t4[0] !== e4[0] || t4[1] !== e4[1] || t4[2] !== e4[2] || this.dirty) && (this.gl.stencilOp(t4[0], t4[1], t4[2]), this.current = t4, this.dirty = false);
            }
          }
          class Je extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              t4 ? e4.enable(e4.STENCIL_TEST) : e4.disable(e4.STENCIL_TEST), this.current = t4, this.dirty = false;
            }
          }
          class Qe extends Ve {
            getDefault() {
              return [0, 1];
            }
            set(t4) {
              const e4 = this.current;
              (t4[0] !== e4[0] || t4[1] !== e4[1] || this.dirty) && (this.gl.depthRange(t4[0], t4[1]), this.current = t4, this.dirty = false);
            }
          }
          class ti extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              t4 ? e4.enable(e4.DEPTH_TEST) : e4.disable(e4.DEPTH_TEST), this.current = t4, this.dirty = false;
            }
          }
          class ei extends Ve {
            getDefault() {
              return this.gl.LESS;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.depthFunc(t4), this.current = t4, this.dirty = false);
            }
          }
          class ii extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              t4 ? e4.enable(e4.BLEND) : e4.disable(e4.BLEND), this.current = t4, this.dirty = false;
            }
          }
          class si extends Ve {
            getDefault() {
              const t4 = this.gl;
              return [t4.ONE, t4.ZERO];
            }
            set(t4) {
              const e4 = this.current;
              (t4[0] !== e4[0] || t4[1] !== e4[1] || this.dirty) && (this.gl.blendFunc(t4[0], t4[1]), this.current = t4, this.dirty = false);
            }
          }
          class ai extends Ve {
            getDefault() {
              return t3.Color.transparent;
            }
            set(t4) {
              const e4 = this.current;
              (t4.r !== e4.r || t4.g !== e4.g || t4.b !== e4.b || t4.a !== e4.a || this.dirty) && (this.gl.blendColor(t4.r, t4.g, t4.b, t4.a), this.current = t4, this.dirty = false);
            }
          }
          class oi extends Ve {
            getDefault() {
              return this.gl.FUNC_ADD;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.blendEquation(t4), this.current = t4, this.dirty = false);
            }
          }
          class ri extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              t4 ? e4.enable(e4.CULL_FACE) : e4.disable(e4.CULL_FACE), this.current = t4, this.dirty = false;
            }
          }
          class ni extends Ve {
            getDefault() {
              return this.gl.BACK;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.cullFace(t4), this.current = t4, this.dirty = false);
            }
          }
          class li extends Ve {
            getDefault() {
              return this.gl.CCW;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.frontFace(t4), this.current = t4, this.dirty = false);
            }
          }
          class ci extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.useProgram(t4), this.current = t4, this.dirty = false);
            }
          }
          class hi extends Ve {
            getDefault() {
              return this.gl.TEXTURE0;
            }
            set(t4) {
              (t4 !== this.current || this.dirty) && (this.gl.activeTexture(t4), this.current = t4, this.dirty = false);
            }
          }
          class ui extends Ve {
            getDefault() {
              const t4 = this.gl;
              return [0, 0, t4.drawingBufferWidth, t4.drawingBufferHeight];
            }
            set(t4) {
              const e4 = this.current;
              (t4[0] !== e4[0] || t4[1] !== e4[1] || t4[2] !== e4[2] || t4[3] !== e4[3] || this.dirty) && (this.gl.viewport(t4[0], t4[1], t4[2], t4[3]), this.current = t4, this.dirty = false);
            }
          }
          class di extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.bindFramebuffer(e4.FRAMEBUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class _i extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.bindRenderbuffer(e4.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class mi extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.bindTexture(e4.TEXTURE_2D, t4), this.current = t4, this.dirty = false;
            }
          }
          class pi extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.bindBuffer(e4.ARRAY_BUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class fi extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              const e4 = this.gl;
              e4.bindBuffer(e4.ELEMENT_ARRAY_BUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class gi extends Ve {
            getDefault() {
              return null;
            }
            set(t4) {
              var e4;
              if (t4 === this.current && !this.dirty)
                return;
              const i5 = this.gl;
              Ge(i5) ? i5.bindVertexArray(t4) : null === (e4 = i5.getExtension("OES_vertex_array_object")) || void 0 === e4 || e4.bindVertexArrayOES(t4), this.current = t4, this.dirty = false;
            }
          }
          class vi extends Ve {
            getDefault() {
              return 4;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.pixelStorei(e4.UNPACK_ALIGNMENT, t4), this.current = t4, this.dirty = false;
            }
          }
          class xi extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.pixelStorei(e4.UNPACK_PREMULTIPLY_ALPHA_WEBGL, t4), this.current = t4, this.dirty = false;
            }
          }
          class yi extends Ve {
            getDefault() {
              return false;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              const e4 = this.gl;
              e4.pixelStorei(e4.UNPACK_FLIP_Y_WEBGL, t4), this.current = t4, this.dirty = false;
            }
          }
          class bi extends Ve {
            constructor(t4, e4) {
              super(t4), this.context = t4, this.parent = e4;
            }
            getDefault() {
              return null;
            }
          }
          class wi extends bi {
            setDirty() {
              this.dirty = true;
            }
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e4 = this.gl;
              e4.framebufferTexture2D(e4.FRAMEBUFFER, e4.COLOR_ATTACHMENT0, e4.TEXTURE_2D, t4, 0), this.current = t4, this.dirty = false;
            }
          }
          class Ti extends bi {
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e4 = this.gl;
              e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.DEPTH_ATTACHMENT, e4.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class Ei extends bi {
            set(t4) {
              if (t4 === this.current && !this.dirty)
                return;
              this.context.bindFramebuffer.set(this.parent);
              const e4 = this.gl;
              e4.framebufferRenderbuffer(e4.FRAMEBUFFER, e4.DEPTH_STENCIL_ATTACHMENT, e4.RENDERBUFFER, t4), this.current = t4, this.dirty = false;
            }
          }
          class Ii {
            constructor(t4, e4, i5, s5, a5) {
              this.context = t4, this.width = e4, this.height = i5;
              const o5 = t4.gl, r5 = this.framebuffer = o5.createFramebuffer();
              if (this.colorAttachment = new wi(t4, r5), s5)
                this.depthAttachment = a5 ? new Ei(t4, r5) : new Ti(t4, r5);
              else if (a5)
                throw new Error("Stencil cannot be setted without depth");
              if (o5.checkFramebufferStatus(o5.FRAMEBUFFER) !== o5.FRAMEBUFFER_COMPLETE)
                throw new Error("Framebuffer is not complete");
            }
            destroy() {
              const t4 = this.context.gl, e4 = this.colorAttachment.get();
              if (e4 && t4.deleteTexture(e4), this.depthAttachment) {
                const e5 = this.depthAttachment.get();
                e5 && t4.deleteRenderbuffer(e5);
              }
              t4.deleteFramebuffer(this.framebuffer);
            }
          }
          class Si {
            constructor(t4, e4, i5) {
              this.blendFunction = t4, this.blendColor = e4, this.mask = i5;
            }
          }
          Si.Replace = [1, 0], Si.disabled = new Si(Si.Replace, t3.Color.transparent, [false, false, false, false]), Si.unblended = new Si(Si.Replace, t3.Color.transparent, [true, true, true, true]), Si.alphaBlended = new Si([1, 771], t3.Color.transparent, [true, true, true, true]);
          class Ci {
            constructor(t4) {
              var e4, i5;
              if (this.gl = t4, this.clearColor = new qe(this), this.clearDepth = new je(this), this.clearStencil = new $e(this), this.colorMask = new Xe(this), this.depthMask = new We(this), this.stencilMask = new He(this), this.stencilFunc = new Ke(this), this.stencilOp = new Ye(this), this.stencilTest = new Je(this), this.depthRange = new Qe(this), this.depthTest = new ti(this), this.depthFunc = new ei(this), this.blend = new ii(this), this.blendFunc = new si(this), this.blendColor = new ai(this), this.blendEquation = new oi(this), this.cullFace = new ri(this), this.cullFaceSide = new ni(this), this.frontFace = new li(this), this.program = new ci(this), this.activeTexture = new hi(this), this.viewport = new ui(this), this.bindFramebuffer = new di(this), this.bindRenderbuffer = new _i(this), this.bindTexture = new mi(this), this.bindVertexBuffer = new pi(this), this.bindElementBuffer = new fi(this), this.bindVertexArray = new gi(this), this.pixelStoreUnpack = new vi(this), this.pixelStoreUnpackPremultiplyAlpha = new xi(this), this.pixelStoreUnpackFlipY = new yi(this), this.extTextureFilterAnisotropic = t4.getExtension("EXT_texture_filter_anisotropic") || t4.getExtension("MOZ_EXT_texture_filter_anisotropic") || t4.getExtension("WEBKIT_EXT_texture_filter_anisotropic"), this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = t4.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)), this.maxTextureSize = t4.getParameter(t4.MAX_TEXTURE_SIZE), Ge(t4)) {
                this.HALF_FLOAT = t4.HALF_FLOAT;
                const s5 = t4.getExtension("EXT_color_buffer_half_float");
                this.RGBA16F = null !== (e4 = t4.RGBA16F) && void 0 !== e4 ? e4 : null == s5 ? void 0 : s5.RGBA16F_EXT, this.RGB16F = null !== (i5 = t4.RGB16F) && void 0 !== i5 ? i5 : null == s5 ? void 0 : s5.RGB16F_EXT, t4.getExtension("EXT_color_buffer_float");
              } else {
                t4.getExtension("EXT_color_buffer_half_float"), t4.getExtension("OES_texture_half_float_linear");
                const e5 = t4.getExtension("OES_texture_half_float");
                this.HALF_FLOAT = null == e5 ? void 0 : e5.HALF_FLOAT_OES;
              }
            }
            setDefault() {
              this.unbindVAO(), this.clearColor.setDefault(), this.clearDepth.setDefault(), this.clearStencil.setDefault(), this.colorMask.setDefault(), this.depthMask.setDefault(), this.stencilMask.setDefault(), this.stencilFunc.setDefault(), this.stencilOp.setDefault(), this.stencilTest.setDefault(), this.depthRange.setDefault(), this.depthTest.setDefault(), this.depthFunc.setDefault(), this.blend.setDefault(), this.blendFunc.setDefault(), this.blendColor.setDefault(), this.blendEquation.setDefault(), this.cullFace.setDefault(), this.cullFaceSide.setDefault(), this.frontFace.setDefault(), this.program.setDefault(), this.activeTexture.setDefault(), this.bindFramebuffer.setDefault(), this.pixelStoreUnpack.setDefault(), this.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.pixelStoreUnpackFlipY.setDefault();
            }
            setDirty() {
              this.clearColor.dirty = true, this.clearDepth.dirty = true, this.clearStencil.dirty = true, this.colorMask.dirty = true, this.depthMask.dirty = true, this.stencilMask.dirty = true, this.stencilFunc.dirty = true, this.stencilOp.dirty = true, this.stencilTest.dirty = true, this.depthRange.dirty = true, this.depthTest.dirty = true, this.depthFunc.dirty = true, this.blend.dirty = true, this.blendFunc.dirty = true, this.blendColor.dirty = true, this.blendEquation.dirty = true, this.cullFace.dirty = true, this.cullFaceSide.dirty = true, this.frontFace.dirty = true, this.program.dirty = true, this.activeTexture.dirty = true, this.viewport.dirty = true, this.bindFramebuffer.dirty = true, this.bindRenderbuffer.dirty = true, this.bindTexture.dirty = true, this.bindVertexBuffer.dirty = true, this.bindElementBuffer.dirty = true, this.bindVertexArray.dirty = true, this.pixelStoreUnpack.dirty = true, this.pixelStoreUnpackPremultiplyAlpha.dirty = true, this.pixelStoreUnpackFlipY.dirty = true;
            }
            createIndexBuffer(t4, e4) {
              return new Ue(this, t4, e4);
            }
            createVertexBuffer(t4, e4, i5) {
              return new Ne(this, t4, e4, i5);
            }
            createRenderbuffer(t4, e4, i5) {
              const s5 = this.gl, a5 = s5.createRenderbuffer();
              return this.bindRenderbuffer.set(a5), s5.renderbufferStorage(s5.RENDERBUFFER, t4, e4, i5), this.bindRenderbuffer.set(null), a5;
            }
            createFramebuffer(t4, e4, i5, s5) {
              return new Ii(this, t4, e4, i5, s5);
            }
            clear({ color: t4, depth: e4, stencil: i5 }) {
              const s5 = this.gl;
              let a5 = 0;
              t4 && (a5 |= s5.COLOR_BUFFER_BIT, this.clearColor.set(t4), this.colorMask.set([true, true, true, true])), void 0 !== e4 && (a5 |= s5.DEPTH_BUFFER_BIT, this.depthRange.set([0, 1]), this.clearDepth.set(e4), this.depthMask.set(true)), void 0 !== i5 && (a5 |= s5.STENCIL_BUFFER_BIT, this.clearStencil.set(i5), this.stencilMask.set(255)), s5.clear(a5);
            }
            setCullFace(t4) {
              false === t4.enable ? this.cullFace.set(false) : (this.cullFace.set(true), this.cullFaceSide.set(t4.mode), this.frontFace.set(t4.frontFace));
            }
            setDepthMode(t4) {
              t4.func !== this.gl.ALWAYS || t4.mask ? (this.depthTest.set(true), this.depthFunc.set(t4.func), this.depthMask.set(t4.mask), this.depthRange.set(t4.range)) : this.depthTest.set(false);
            }
            setStencilMode(t4) {
              t4.test.func !== this.gl.ALWAYS || t4.mask ? (this.stencilTest.set(true), this.stencilMask.set(t4.mask), this.stencilOp.set([t4.fail, t4.depthFail, t4.pass]), this.stencilFunc.set({ func: t4.test.func, ref: t4.ref, mask: t4.test.mask })) : this.stencilTest.set(false);
            }
            setColorMode(e4) {
              t3.deepEqual(e4.blendFunction, Si.Replace) ? this.blend.set(false) : (this.blend.set(true), this.blendFunc.set(e4.blendFunction), this.blendColor.set(e4.blendColor)), this.colorMask.set(e4.mask);
            }
            createVertexArray() {
              var t4;
              return Ge(this.gl) ? this.gl.createVertexArray() : null === (t4 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === t4 ? void 0 : t4.createVertexArrayOES();
            }
            deleteVertexArray(t4) {
              var e4;
              return Ge(this.gl) ? this.gl.deleteVertexArray(t4) : null === (e4 = this.gl.getExtension("OES_vertex_array_object")) || void 0 === e4 ? void 0 : e4.deleteVertexArrayOES(t4);
            }
            unbindVAO() {
              this.bindVertexArray.set(null);
            }
          }
          class Pi {
            constructor(t4, e4, i5) {
              this.func = t4, this.mask = e4, this.range = i5;
            }
          }
          Pi.ReadOnly = false, Pi.ReadWrite = true, Pi.disabled = new Pi(519, Pi.ReadOnly, [0, 1]);
          const Di = 7680;
          class Mi {
            constructor(t4, e4, i5, s5, a5, o5) {
              this.test = t4, this.ref = e4, this.mask = i5, this.fail = s5, this.depthFail = a5, this.pass = o5;
            }
          }
          Mi.disabled = new Mi({ func: 519, mask: 0 }, 0, 0, Di, Di, Di);
          class zi {
            constructor(t4, e4, i5) {
              this.enable = t4, this.mode = e4, this.frontFace = i5;
            }
          }
          let Ai;
          function Li(e4, i5, s5, a5, o5, r5, n3) {
            const l5 = e4.context, c5 = l5.gl, h4 = e4.useProgram("collisionBox"), u5 = [];
            let d4 = 0, _4 = 0;
            for (let m5 = 0; m5 < a5.length; m5++) {
              const p8 = a5[m5], f5 = i5.getTile(p8), g5 = f5.getBucket(s5);
              if (!g5)
                continue;
              let v6 = p8.posMatrix;
              0 === o5[0] && 0 === o5[1] || (v6 = e4.translatePosMatrix(p8.posMatrix, f5, o5, r5));
              const x4 = n3 ? g5.textCollisionBox : g5.iconCollisionBox, y3 = g5.collisionCircleArray;
              if (y3.length > 0) {
                const i6 = t3.create(), s6 = v6;
                t3.mul(i6, g5.placementInvProjMatrix, e4.transform.glCoordMatrix), t3.mul(i6, i6, g5.placementViewportMatrix), u5.push({ circleArray: y3, circleOffset: _4, transform: s6, invTransform: i6, coord: p8 }), d4 += y3.length / 4, _4 = d4;
              }
              x4 && h4.draw(l5, c5.LINES, Pi.disabled, Mi.disabled, e4.colorModeForRenderPass(), zi.disabled, xe(v6, e4.transform, f5), e4.style.map.terrain && e4.style.map.terrain.getTerrainData(p8), s5.id, x4.layoutVertexBuffer, x4.indexBuffer, x4.segments, null, e4.transform.zoom, null, null, x4.collisionVertexBuffer);
            }
            if (!n3 || !u5.length)
              return;
            const m4 = e4.useProgram("collisionCircle"), p7 = new t3.CollisionCircleLayoutArray();
            p7.resize(4 * d4), p7._trim();
            let f4 = 0;
            for (const t4 of u5)
              for (let e5 = 0; e5 < t4.circleArray.length / 4; e5++) {
                const i6 = 4 * e5, s6 = t4.circleArray[i6 + 0], a6 = t4.circleArray[i6 + 1], o6 = t4.circleArray[i6 + 2], r6 = t4.circleArray[i6 + 3];
                p7.emplace(f4++, s6, a6, o6, r6, 0), p7.emplace(f4++, s6, a6, o6, r6, 1), p7.emplace(f4++, s6, a6, o6, r6, 2), p7.emplace(f4++, s6, a6, o6, r6, 3);
              }
            (!Ai || Ai.length < 2 * d4) && (Ai = function(e5) {
              const i6 = 2 * e5, s6 = new t3.QuadTriangleArray();
              s6.resize(i6), s6._trim();
              for (let t4 = 0; t4 < i6; t4++) {
                const e6 = 6 * t4;
                s6.uint16[e6 + 0] = 4 * t4 + 0, s6.uint16[e6 + 1] = 4 * t4 + 1, s6.uint16[e6 + 2] = 4 * t4 + 2, s6.uint16[e6 + 3] = 4 * t4 + 2, s6.uint16[e6 + 4] = 4 * t4 + 3, s6.uint16[e6 + 5] = 4 * t4 + 0;
              }
              return s6;
            }(d4));
            const g4 = l5.createIndexBuffer(Ai, true), v5 = l5.createVertexBuffer(p7, t3.collisionCircleLayout.members, true);
            for (const i6 of u5) {
              const a6 = { u_matrix: i6.transform, u_inv_matrix: i6.invTransform, u_camera_to_center_distance: (x3 = e4.transform).cameraToCenterDistance, u_viewport_size: [x3.width, x3.height] };
              m4.draw(l5, c5.TRIANGLES, Pi.disabled, Mi.disabled, e4.colorModeForRenderPass(), zi.disabled, a6, e4.style.map.terrain && e4.style.map.terrain.getTerrainData(i6.coord), s5.id, v5, g4, t3.SegmentVector.simpleSegment(0, 2 * i6.circleOffset, i6.circleArray.length, i6.circleArray.length / 2), null, e4.transform.zoom, null, null, null);
            }
            var x3;
            v5.destroy(), g4.destroy();
          }
          zi.disabled = new zi(false, 1029, 2305), zi.backCCW = new zi(true, 1029, 2305);
          const Ri = t3.identity(new Float32Array(16));
          function ki(e4, i5, s5, a5, o5, r5) {
            const { horizontalAlign: n3, verticalAlign: l5 } = t3.getAnchorAlignment(e4);
            return new t3.Point((-(n3 - 0.5) * i5 / o5 + a5[0]) * r5, (-(l5 - 0.5) * s5 / o5 + a5[1]) * r5);
          }
          function Fi(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5) {
            const d4 = e4.text.placedSymbolArray, _4 = e4.text.dynamicLayoutVertexArray, m4 = e4.icon.dynamicLayoutVertexArray, p7 = {};
            _4.clear();
            for (let m5 = 0; m5 < d4.length; m5++) {
              const f4 = d4.get(m5), g4 = f4.hidden || !f4.crossTileID || e4.allowVerticalPlacement && !f4.placedOrientation ? null : a5[f4.crossTileID];
              if (g4) {
                const a6 = new t3.Point(f4.anchorX, f4.anchorY), d5 = ct(a6, s5 ? n3 : r5, u5), m6 = ht(o5.cameraToCenterDistance, d5.signedDistanceFromCamera);
                let v5 = t3.evaluateSizeForFeature(e4.textSizeData, c5, f4) * m6 / t3.ONE_EM;
                s5 && (v5 *= e4.tilePixelRatio / l5);
                const { width: x3, height: y3, anchor: b4, textOffset: w4, textBoxScale: T3 } = g4, E3 = ki(b4, x3, y3, w4, T3, v5), I3 = s5 ? ct(a6.add(E3), r5, u5).point : d5.point.add(i5 ? E3.rotate(-o5.angle) : E3), S3 = e4.allowVerticalPlacement && f4.placedOrientation === t3.WritingMode.vertical ? Math.PI / 2 : 0;
                for (let e5 = 0; e5 < f4.numGlyphs; e5++)
                  t3.addDynamicAttributes(_4, I3, S3);
                h4 && f4.associatedIconIndex >= 0 && (p7[f4.associatedIconIndex] = { shiftedAnchor: I3, angle: S3 });
              } else
                wt(f4.numGlyphs, _4);
            }
            if (h4) {
              m4.clear();
              const i6 = e4.icon.placedSymbolArray;
              for (let e5 = 0; e5 < i6.length; e5++) {
                const s6 = i6.get(e5);
                if (s6.hidden)
                  wt(s6.numGlyphs, m4);
                else {
                  const i7 = p7[e5];
                  if (i7)
                    for (let e6 = 0; e6 < s6.numGlyphs; e6++)
                      t3.addDynamicAttributes(m4, i7.shiftedAnchor, i7.angle);
                  else
                    wt(s6.numGlyphs, m4);
                }
              }
              e4.icon.dynamicLayoutVertexBuffer.updateData(m4);
            }
            e4.text.dynamicLayoutVertexBuffer.updateData(_4);
          }
          function Bi(t4, e4, i5) {
            return i5.iconsInText && e4 ? "symbolTextAndIcon" : t4 ? "symbolSDF" : "symbolIcon";
          }
          function Ui(e4, i5, s5, a5, o5, r5, n3, l5, c5, h4, u5, d4) {
            const _4 = e4.context, m4 = _4.gl, p7 = e4.transform, f4 = "map" === l5, g4 = "map" === c5, v5 = "viewport" !== l5 && "point" !== s5.layout.get("symbol-placement"), x3 = f4 && !g4 && !v5, y3 = !s5.layout.get("symbol-sort-key").isConstant();
            let b4 = false;
            const w4 = e4.depthModeForSublayer(0, Pi.ReadOnly), T3 = s5._unevaluatedLayout.hasValue("text-variable-anchor") || s5._unevaluatedLayout.hasValue("text-variable-anchor-offset"), E3 = [];
            for (const l6 of a5) {
              const a6 = i5.getTile(l6), c6 = a6.getBucket(s5);
              if (!c6)
                continue;
              const u6 = o5 ? c6.text : c6.icon;
              if (!u6 || !u6.segments.get().length || !u6.hasVisibleVertices)
                continue;
              const d5 = u6.programConfigurations.get(s5.id), _5 = o5 || c6.sdfIcons, w5 = o5 ? c6.textSizeData : c6.iconSizeData, I3 = g4 || 0 !== p7.pitch, S3 = e4.useProgram(Bi(_5, o5, c6), d5), C2 = t3.evaluateSizeForZoom(w5, p7.zoom), P3 = e4.style.map.terrain && e4.style.map.terrain.getTerrainData(l6);
              let D3, M3, z4, A3, L3 = [0, 0], R2 = null;
              if (o5)
                M3 = a6.glyphAtlasTexture, z4 = m4.LINEAR, D3 = a6.glyphAtlasTexture.size, c6.iconsInText && (L3 = a6.imageAtlasTexture.size, R2 = a6.imageAtlasTexture, A3 = I3 || e4.options.rotating || e4.options.zooming || "composite" === w5.kind || "camera" === w5.kind ? m4.LINEAR : m4.NEAREST);
              else {
                const t4 = 1 !== s5.layout.get("icon-size").constantOr(0) || c6.iconsNeedLinear;
                M3 = a6.imageAtlasTexture, z4 = _5 || e4.options.rotating || e4.options.zooming || t4 || I3 ? m4.LINEAR : m4.NEAREST, D3 = a6.imageAtlasTexture.size;
              }
              const k4 = St(a6, 1, e4.transform.zoom), F4 = nt(l6.posMatrix, g4, f4, e4.transform, k4), B4 = lt(l6.posMatrix, g4, f4, e4.transform, k4), U2 = T3 && c6.hasTextData(), O3 = "none" !== s5.layout.get("icon-text-fit") && U2 && c6.hasIconData();
              if (v5) {
                const t4 = e4.style.map.terrain ? (t5, i7) => e4.style.map.terrain.getElevation(l6, t5, i7) : null, i6 = "map" === s5.layout.get("text-rotation-alignment");
                dt(c6, l6.posMatrix, e4, o5, F4, B4, g4, h4, i6, t4);
              }
              const N3 = e4.translatePosMatrix(l6.posMatrix, a6, r5, n3), Z2 = v5 || o5 && T3 || O3 ? Ri : F4, G3 = e4.translatePosMatrix(B4, a6, r5, n3, true), V2 = _5 && 0 !== s5.paint.get(o5 ? "text-halo-width" : "icon-halo-width").constantOr(1);
              let q4;
              q4 = _5 ? c6.iconsInText ? Re(w5.kind, C2, x3, g4, e4, N3, Z2, G3, D3, L3) : Le(w5.kind, C2, x3, g4, e4, N3, Z2, G3, o5, D3, true) : Ae(w5.kind, C2, x3, g4, e4, N3, Z2, G3, o5, D3);
              const j4 = { program: S3, buffers: u6, uniformValues: q4, atlasTexture: M3, atlasTextureIcon: R2, atlasInterpolation: z4, atlasInterpolationIcon: A3, isSDF: _5, hasHalo: V2 };
              if (y3 && c6.canOverlap) {
                b4 = true;
                const e5 = u6.segments.get();
                for (const i6 of e5)
                  E3.push({ segments: new t3.SegmentVector([i6]), sortKey: i6.sortKey, state: j4, terrainData: P3 });
              } else
                E3.push({ segments: u6.segments, sortKey: 0, state: j4, terrainData: P3 });
            }
            b4 && E3.sort((t4, e5) => t4.sortKey - e5.sortKey);
            for (const t4 of E3) {
              const i6 = t4.state;
              if (_4.activeTexture.set(m4.TEXTURE0), i6.atlasTexture.bind(i6.atlasInterpolation, m4.CLAMP_TO_EDGE), i6.atlasTextureIcon && (_4.activeTexture.set(m4.TEXTURE1), i6.atlasTextureIcon && i6.atlasTextureIcon.bind(i6.atlasInterpolationIcon, m4.CLAMP_TO_EDGE)), i6.isSDF) {
                const a6 = i6.uniformValues;
                i6.hasHalo && (a6.u_is_halo = 1, Oi(i6.buffers, t4.segments, s5, e4, i6.program, w4, u5, d4, a6, t4.terrainData)), a6.u_is_halo = 0;
              }
              Oi(i6.buffers, t4.segments, s5, e4, i6.program, w4, u5, d4, i6.uniformValues, t4.terrainData);
            }
          }
          function Oi(t4, e4, i5, s5, a5, o5, r5, n3, l5, c5) {
            const h4 = s5.context;
            a5.draw(h4, h4.gl.TRIANGLES, o5, r5, n3, zi.disabled, l5, c5, i5.id, t4.layoutVertexBuffer, t4.indexBuffer, e4, i5.paint, s5.transform.zoom, t4.programConfigurations.get(i5.id), t4.dynamicLayoutVertexBuffer, t4.opacityVertexBuffer);
          }
          function Ni(t4, e4, i5, s5, a5) {
            if (!i5 || !s5 || !s5.imageAtlas)
              return;
            const o5 = s5.imageAtlas.patternPositions;
            let r5 = o5[i5.to.toString()], n3 = o5[i5.from.toString()];
            if (!r5 || !n3) {
              const t5 = a5.getPaintProperty(e4);
              r5 = o5[t5], n3 = o5[t5];
            }
            r5 && n3 && t4.setConstantPatternPositions(r5, n3);
          }
          function Zi(t4, e4, i5, s5, a5, o5, r5) {
            const n3 = t4.context.gl, l5 = "fill-pattern", c5 = i5.paint.get(l5), h4 = c5 && c5.constantOr(1), u5 = i5.getCrossfadeParameters();
            let d4, _4, m4, p7, f4;
            r5 ? (_4 = h4 && !i5.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline", d4 = n3.LINES) : (_4 = h4 ? "fillPattern" : "fill", d4 = n3.TRIANGLES);
            const g4 = c5.constantOr(null);
            for (const c6 of s5) {
              const s6 = e4.getTile(c6);
              if (h4 && !s6.patternsLoaded())
                continue;
              const v5 = s6.getBucket(i5);
              if (!v5)
                continue;
              const x3 = v5.programConfigurations.get(i5.id), y3 = t4.useProgram(_4, x3), b4 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(c6);
              h4 && (t4.context.activeTexture.set(n3.TEXTURE0), s6.imageAtlasTexture.bind(n3.LINEAR, n3.CLAMP_TO_EDGE), x3.updatePaintBuffers(u5)), Ni(x3, l5, g4, s6, i5);
              const w4 = b4 ? c6 : null, T3 = t4.translatePosMatrix(w4 ? w4.posMatrix : c6.posMatrix, s6, i5.paint.get("fill-translate"), i5.paint.get("fill-translate-anchor"));
              if (r5) {
                p7 = v5.indexBuffer2, f4 = v5.segments2;
                const e5 = [n3.drawingBufferWidth, n3.drawingBufferHeight];
                m4 = "fillOutlinePattern" === _4 && h4 ? ge(T3, t4, u5, s6, e5) : fe(T3, e5);
              } else
                p7 = v5.indexBuffer, f4 = v5.segments, m4 = h4 ? pe(T3, t4, u5, s6) : me(T3);
              y3.draw(t4.context, d4, a5, t4.stencilModeForClipping(c6), o5, zi.disabled, m4, b4, i5.id, v5.layoutVertexBuffer, p7, f4, i5.paint, t4.transform.zoom, x3);
            }
          }
          function Gi(t4, e4, i5, s5, a5, o5, r5) {
            const n3 = t4.context, l5 = n3.gl, c5 = "fill-extrusion-pattern", h4 = i5.paint.get(c5), u5 = h4.constantOr(1), d4 = i5.getCrossfadeParameters(), _4 = i5.paint.get("fill-extrusion-opacity"), m4 = h4.constantOr(null);
            for (const h5 of s5) {
              const s6 = e4.getTile(h5), p7 = s6.getBucket(i5);
              if (!p7)
                continue;
              const f4 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(h5), g4 = p7.programConfigurations.get(i5.id), v5 = t4.useProgram(u5 ? "fillExtrusionPattern" : "fillExtrusion", g4);
              u5 && (t4.context.activeTexture.set(l5.TEXTURE0), s6.imageAtlasTexture.bind(l5.LINEAR, l5.CLAMP_TO_EDGE), g4.updatePaintBuffers(d4)), Ni(g4, c5, m4, s6, i5);
              const x3 = t4.translatePosMatrix(h5.posMatrix, s6, i5.paint.get("fill-extrusion-translate"), i5.paint.get("fill-extrusion-translate-anchor")), y3 = i5.paint.get("fill-extrusion-vertical-gradient"), b4 = u5 ? _e(x3, t4, y3, _4, h5, d4, s6) : de(x3, t4, y3, _4);
              v5.draw(n3, n3.gl.TRIANGLES, a5, o5, r5, zi.backCCW, b4, f4, i5.id, p7.layoutVertexBuffer, p7.indexBuffer, p7.segments, i5.paint, t4.transform.zoom, g4, t4.style.map.terrain && p7.centroidVertexBuffer);
            }
          }
          function Vi(t4, e4, i5, s5, a5, o5, r5) {
            const n3 = t4.context, l5 = n3.gl, c5 = i5.fbo;
            if (!c5)
              return;
            const h4 = t4.useProgram("hillshade"), u5 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(e4);
            n3.activeTexture.set(l5.TEXTURE0), l5.bindTexture(l5.TEXTURE_2D, c5.colorAttachment.get()), h4.draw(n3, l5.TRIANGLES, a5, o5, r5, zi.disabled, ((t5, e5, i6, s6) => {
              const a6 = i6.paint.get("hillshade-shadow-color"), o6 = i6.paint.get("hillshade-highlight-color"), r6 = i6.paint.get("hillshade-accent-color");
              let n4 = i6.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
              "viewport" === i6.paint.get("hillshade-illumination-anchor") && (n4 -= t5.transform.angle);
              const l6 = !t5.options.moving;
              return { u_matrix: s6 ? s6.posMatrix : t5.transform.calculatePosMatrix(e5.tileID.toUnwrapped(), l6), u_image: 0, u_latrange: Te(0, e5.tileID), u_light: [i6.paint.get("hillshade-exaggeration"), n4], u_shadow: a6, u_highlight: o6, u_accent: r6 };
            })(t4, i5, s5, u5 ? e4 : null), u5, s5.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
          }
          function qi(e4, i5, s5, a5, o5, r5) {
            const n3 = e4.context, l5 = n3.gl, c5 = i5.dem;
            if (c5 && c5.data) {
              const h4 = c5.dim, u5 = c5.stride, d4 = c5.getPixels();
              if (n3.activeTexture.set(l5.TEXTURE1), n3.pixelStoreUnpackPremultiplyAlpha.set(false), i5.demTexture = i5.demTexture || e4.getTileTexture(u5), i5.demTexture) {
                const t4 = i5.demTexture;
                t4.update(d4, { premultiply: false }), t4.bind(l5.NEAREST, l5.CLAMP_TO_EDGE);
              } else
                i5.demTexture = new x2(n3, d4, l5.RGBA, { premultiply: false }), i5.demTexture.bind(l5.NEAREST, l5.CLAMP_TO_EDGE);
              n3.activeTexture.set(l5.TEXTURE0);
              let _4 = i5.fbo;
              if (!_4) {
                const t4 = new x2(n3, { width: h4, height: h4, data: null }, l5.RGBA);
                t4.bind(l5.LINEAR, l5.CLAMP_TO_EDGE), _4 = i5.fbo = n3.createFramebuffer(h4, h4, true, false), _4.colorAttachment.set(t4.texture);
              }
              n3.bindFramebuffer.set(_4.framebuffer), n3.viewport.set([0, 0, h4, h4]), e4.useProgram("hillshadePrepare").draw(n3, l5.TRIANGLES, a5, o5, r5, zi.disabled, ((e5, i6) => {
                const s6 = i6.stride, a6 = t3.create();
                return t3.ortho(a6, 0, t3.EXTENT, -t3.EXTENT, 0, 0, 1), t3.translate(a6, a6, [0, -t3.EXTENT, 0]), { u_matrix: a6, u_image: 1, u_dimension: [s6, s6], u_zoom: e5.overscaledZ, u_unpack: i6.getUnpackVector() };
              })(i5.tileID, c5), null, s5.id, e4.rasterBoundsBuffer, e4.quadTriangleIndexBuffer, e4.rasterBoundsSegments), i5.needsHillshadePrepare = false;
            }
          }
          function ji(e4, i5, s5, a5, o5, r5) {
            const n3 = a5.paint.get("raster-fade-duration");
            if (!r5 && n3 > 0) {
              const a6 = t3.browser.now(), r6 = (a6 - e4.timeAdded) / n3, l5 = i5 ? (a6 - i5.timeAdded) / n3 : -1, c5 = s5.getSource(), h4 = o5.coveringZoomLevel({ tileSize: c5.tileSize, roundZoom: c5.roundZoom }), u5 = !i5 || Math.abs(i5.tileID.overscaledZ - h4) > Math.abs(e4.tileID.overscaledZ - h4), d4 = u5 && e4.refreshedUponExpiration ? 1 : t3.clamp(u5 ? r6 : 1 - l5, 0, 1);
              return e4.refreshedUponExpiration && r6 >= 1 && (e4.refreshedUponExpiration = false), i5 ? { opacity: 1, mix: 1 - d4 } : { opacity: d4, mix: 0 };
            }
            return { opacity: 1, mix: 0 };
          }
          const $i = new t3.Color(1, 0, 0, 1), Xi = new t3.Color(0, 1, 0, 1), Wi = new t3.Color(0, 0, 1, 1), Hi = new t3.Color(1, 0, 1, 1), Ki = new t3.Color(0, 1, 1, 1);
          function Yi(t4, e4, i5, s5) {
            Qi(t4, 0, e4 + i5 / 2, t4.transform.width, i5, s5);
          }
          function Ji(t4, e4, i5, s5) {
            Qi(t4, e4 - i5 / 2, 0, i5, t4.transform.height, s5);
          }
          function Qi(t4, e4, i5, s5, a5, o5) {
            const r5 = t4.context, n3 = r5.gl;
            n3.enable(n3.SCISSOR_TEST), n3.scissor(e4 * t4.pixelRatio, i5 * t4.pixelRatio, s5 * t4.pixelRatio, a5 * t4.pixelRatio), r5.clear({ color: o5 }), n3.disable(n3.SCISSOR_TEST);
          }
          function ts(e4, i5, s5) {
            const a5 = e4.context, o5 = a5.gl, r5 = s5.posMatrix, n3 = e4.useProgram("debug"), l5 = Pi.disabled, c5 = Mi.disabled, h4 = e4.colorModeForRenderPass(), u5 = "$debug", d4 = e4.style.map.terrain && e4.style.map.terrain.getTerrainData(s5);
            a5.activeTexture.set(o5.TEXTURE0);
            const _4 = i5.getTileByID(s5.key).latestRawTileData, m4 = Math.floor((_4 && _4.byteLength || 0) / 1024), p7 = i5.getTile(s5).tileSize, f4 = 512 / Math.min(p7, 512) * (s5.overscaledZ / e4.transform.zoom) * 0.5;
            let g4 = s5.canonical.toString();
            s5.overscaledZ !== s5.canonical.z && (g4 += ` => ${s5.overscaledZ}`), function(t4, e5) {
              t4.initDebugOverlayCanvas();
              const i6 = t4.debugOverlayCanvas, s6 = t4.context.gl, a6 = t4.debugOverlayCanvas.getContext("2d");
              a6.clearRect(0, 0, i6.width, i6.height), a6.shadowColor = "white", a6.shadowBlur = 2, a6.lineWidth = 1.5, a6.strokeStyle = "white", a6.textBaseline = "top", a6.font = "bold 36px Open Sans, sans-serif", a6.fillText(e5, 5, 5), a6.strokeText(e5, 5, 5), t4.debugOverlayTexture.update(i6), t4.debugOverlayTexture.bind(s6.LINEAR, s6.CLAMP_TO_EDGE);
            }(e4, `${g4} ${m4}kB`), n3.draw(a5, o5.TRIANGLES, l5, c5, Si.alphaBlended, zi.disabled, ye(r5, t3.Color.transparent, f4), null, u5, e4.debugBuffer, e4.quadTriangleIndexBuffer, e4.debugSegments), n3.draw(a5, o5.LINE_STRIP, l5, c5, h4, zi.disabled, ye(r5, t3.Color.red), d4, u5, e4.debugBuffer, e4.tileBorderIndexBuffer, e4.debugSegments);
          }
          function es(t4, e4, i5) {
            const s5 = t4.context, a5 = s5.gl, o5 = t4.colorModeForRenderPass(), r5 = new Pi(a5.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D), n3 = t4.useProgram("terrain"), l5 = e4.getTerrainMesh();
            s5.bindFramebuffer.set(null), s5.viewport.set([0, 0, t4.width, t4.height]);
            for (const c5 of i5) {
              const i6 = t4.renderToTexture.getTexture(c5), h4 = e4.getTerrainData(c5.tileID);
              s5.activeTexture.set(a5.TEXTURE0), a5.bindTexture(a5.TEXTURE_2D, i6.texture);
              const u5 = { u_matrix: t4.transform.calculatePosMatrix(c5.tileID.toUnwrapped()), u_texture: 0, u_ele_delta: e4.getMeshFrameDelta(t4.transform.zoom) };
              n3.draw(s5, a5.TRIANGLES, r5, Mi.disabled, o5, zi.backCCW, u5, h4, "terrain", l5.vertexBuffer, l5.indexBuffer, l5.segments);
            }
          }
          class is {
            constructor(e4, i5) {
              this.context = new Ci(e4), this.transform = i5, this._tileTextures = {}, this.terrainFacilitator = { dirty: true, matrix: t3.create(), renderTime: 0 }, this.setup(), this.numSublayers = K.maxUnderzooming + K.maxOverzooming + 1, this.depthEpsilon = 1 / Math.pow(2, 16), this.crossTileSymbolIndex = new Jt();
            }
            resize(t4, e4, i5) {
              if (this.width = Math.floor(t4 * i5), this.height = Math.floor(e4 * i5), this.pixelRatio = i5, this.context.viewport.set([0, 0, this.width, this.height]), this.style)
                for (const t5 of this.style._order)
                  this.style._layers[t5].resize();
            }
            setup() {
              const e4 = this.context, i5 = new t3.PosArray();
              i5.emplaceBack(0, 0), i5.emplaceBack(t3.EXTENT, 0), i5.emplaceBack(0, t3.EXTENT), i5.emplaceBack(t3.EXTENT, t3.EXTENT), this.tileExtentBuffer = e4.createVertexBuffer(i5, ae.members), this.tileExtentSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2);
              const s5 = new t3.PosArray();
              s5.emplaceBack(0, 0), s5.emplaceBack(t3.EXTENT, 0), s5.emplaceBack(0, t3.EXTENT), s5.emplaceBack(t3.EXTENT, t3.EXTENT), this.debugBuffer = e4.createVertexBuffer(s5, ae.members), this.debugSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 5);
              const a5 = new t3.RasterBoundsArray();
              a5.emplaceBack(0, 0, 0, 0), a5.emplaceBack(t3.EXTENT, 0, t3.EXTENT, 0), a5.emplaceBack(0, t3.EXTENT, 0, t3.EXTENT), a5.emplaceBack(t3.EXTENT, t3.EXTENT, t3.EXTENT, t3.EXTENT), this.rasterBoundsBuffer = e4.createVertexBuffer(a5, U.members), this.rasterBoundsSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2);
              const o5 = new t3.PosArray();
              o5.emplaceBack(0, 0), o5.emplaceBack(1, 0), o5.emplaceBack(0, 1), o5.emplaceBack(1, 1), this.viewportBuffer = e4.createVertexBuffer(o5, ae.members), this.viewportSegments = t3.SegmentVector.simpleSegment(0, 0, 4, 2);
              const r5 = new t3.LineStripIndexArray();
              r5.emplaceBack(0), r5.emplaceBack(1), r5.emplaceBack(3), r5.emplaceBack(2), r5.emplaceBack(0), this.tileBorderIndexBuffer = e4.createIndexBuffer(r5);
              const n3 = new t3.TriangleIndexArray();
              n3.emplaceBack(0, 1, 2), n3.emplaceBack(2, 1, 3), this.quadTriangleIndexBuffer = e4.createIndexBuffer(n3);
              const l5 = this.context.gl;
              this.stencilClearMode = new Mi({ func: l5.ALWAYS, mask: 0 }, 0, 255, l5.ZERO, l5.ZERO, l5.ZERO);
            }
            clearStencil() {
              const e4 = this.context, i5 = e4.gl;
              this.nextStencilID = 1, this.currentStencilSource = void 0;
              const s5 = t3.create();
              t3.ortho(s5, 0, this.width, this.height, 0, 0, 1), t3.scale(s5, s5, [i5.drawingBufferWidth, i5.drawingBufferHeight, 0]), this.useProgram("clippingMask").draw(e4, i5.TRIANGLES, Pi.disabled, this.stencilClearMode, Si.disabled, zi.disabled, be(s5), null, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments);
            }
            _renderTileClippingMasks(t4, e4) {
              if (this.currentStencilSource === t4.source || !t4.isTileClipped() || !e4 || !e4.length)
                return;
              this.currentStencilSource = t4.source;
              const i5 = this.context, s5 = i5.gl;
              this.nextStencilID + e4.length > 256 && this.clearStencil(), i5.setColorMode(Si.disabled), i5.setDepthMode(Pi.disabled);
              const a5 = this.useProgram("clippingMask");
              this._tileClippingMaskIDs = {};
              for (const t5 of e4) {
                const e5 = this._tileClippingMaskIDs[t5.key] = this.nextStencilID++, o5 = this.style.map.terrain && this.style.map.terrain.getTerrainData(t5);
                a5.draw(i5, s5.TRIANGLES, Pi.disabled, new Mi({ func: s5.ALWAYS, mask: 0 }, e5, 255, s5.KEEP, s5.KEEP, s5.REPLACE), Si.disabled, zi.disabled, be(t5.posMatrix), o5, "$clipping", this.tileExtentBuffer, this.quadTriangleIndexBuffer, this.tileExtentSegments);
              }
            }
            stencilModeFor3D() {
              this.currentStencilSource = void 0, this.nextStencilID + 1 > 256 && this.clearStencil();
              const t4 = this.nextStencilID++, e4 = this.context.gl;
              return new Mi({ func: e4.NOTEQUAL, mask: 255 }, t4, 255, e4.KEEP, e4.KEEP, e4.REPLACE);
            }
            stencilModeForClipping(t4) {
              const e4 = this.context.gl;
              return new Mi({ func: e4.EQUAL, mask: 255 }, this._tileClippingMaskIDs[t4.key], 0, e4.KEEP, e4.KEEP, e4.REPLACE);
            }
            stencilConfigForOverlap(t4) {
              const e4 = this.context.gl, i5 = t4.sort((t5, e5) => e5.overscaledZ - t5.overscaledZ), s5 = i5[i5.length - 1].overscaledZ, a5 = i5[0].overscaledZ - s5 + 1;
              if (a5 > 1) {
                this.currentStencilSource = void 0, this.nextStencilID + a5 > 256 && this.clearStencil();
                const t5 = {};
                for (let i6 = 0; i6 < a5; i6++)
                  t5[i6 + s5] = new Mi({ func: e4.GEQUAL, mask: 255 }, i6 + this.nextStencilID, 255, e4.KEEP, e4.KEEP, e4.REPLACE);
                return this.nextStencilID += a5, [t5, i5];
              }
              return [{ [s5]: Mi.disabled }, i5];
            }
            colorModeForRenderPass() {
              const e4 = this.context.gl;
              if (this._showOverdrawInspector) {
                const i5 = 1 / 8;
                return new Si([e4.CONSTANT_COLOR, e4.ONE], new t3.Color(i5, i5, i5, 0), [true, true, true, true]);
              }
              return "opaque" === this.renderPass ? Si.unblended : Si.alphaBlended;
            }
            depthModeForSublayer(t4, e4, i5) {
              if (!this.opaquePassEnabledForLayer())
                return Pi.disabled;
              const s5 = 1 - ((1 + this.currentLayer) * this.numSublayers + t4) * this.depthEpsilon;
              return new Pi(i5 || this.context.gl.LEQUAL, e4, [s5, s5]);
            }
            opaquePassEnabledForLayer() {
              return this.currentLayer < this.opaquePassCutoff;
            }
            render(e4, i5) {
              this.style = e4, this.options = i5, this.lineAtlas = e4.lineAtlas, this.imageManager = e4.imageManager, this.glyphManager = e4.glyphManager, this.symbolFadeChange = e4.placement.symbolFadeChange(t3.browser.now()), this.imageManager.beginFrame();
              const s5 = this.style._order, a5 = this.style.sourceCaches, o5 = {}, r5 = {}, n3 = {};
              for (const t4 in a5) {
                const e5 = a5[t4];
                e5.used && e5.prepare(this.context), o5[t4] = e5.getVisibleCoordinates(), r5[t4] = o5[t4].slice().reverse(), n3[t4] = e5.getVisibleCoordinates(true).reverse();
              }
              this.opaquePassCutoff = 1 / 0;
              for (let t4 = 0; t4 < s5.length; t4++)
                if (this.style._layers[s5[t4]].is3D()) {
                  this.opaquePassCutoff = t4;
                  break;
                }
              if (this.renderToTexture) {
                this.renderToTexture.prepareForRender(this.style, this.transform.zoom), this.opaquePassCutoff = 0;
                const e5 = this.style.map.terrain.sourceCache.tilesAfterTime(this.terrainFacilitator.renderTime);
                (this.terrainFacilitator.dirty || !t3.equals(this.terrainFacilitator.matrix, this.transform.projMatrix) || e5.length) && (t3.copy(this.terrainFacilitator.matrix, this.transform.projMatrix), this.terrainFacilitator.renderTime = Date.now(), this.terrainFacilitator.dirty = false, function(e6, i6) {
                  const s6 = e6.context, a6 = s6.gl, o6 = Si.unblended, r6 = new Pi(a6.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i6.getTerrainMesh(), l5 = i6.sourceCache.getRenderableTiles(), c5 = e6.useProgram("terrainDepth");
                  s6.bindFramebuffer.set(i6.getFramebuffer("depth").framebuffer), s6.viewport.set([0, 0, e6.width / devicePixelRatio, e6.height / devicePixelRatio]), s6.clear({ color: t3.Color.transparent, depth: 1 });
                  for (const t4 of l5) {
                    const l6 = i6.getTerrainData(t4.tileID), h4 = { u_matrix: e6.transform.calculatePosMatrix(t4.tileID.toUnwrapped()), u_ele_delta: i6.getMeshFrameDelta(e6.transform.zoom) };
                    c5.draw(s6, a6.TRIANGLES, r6, Mi.disabled, o6, zi.backCCW, h4, l6, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments);
                  }
                  s6.bindFramebuffer.set(null), s6.viewport.set([0, 0, e6.width, e6.height]);
                }(this, this.style.map.terrain), function(e6, i6) {
                  const s6 = e6.context, a6 = s6.gl, o6 = Si.unblended, r6 = new Pi(a6.LEQUAL, Pi.ReadWrite, [0, 1]), n4 = i6.getTerrainMesh(), l5 = i6.getCoordsTexture(), c5 = i6.sourceCache.getRenderableTiles(), h4 = e6.useProgram("terrainCoords");
                  s6.bindFramebuffer.set(i6.getFramebuffer("coords").framebuffer), s6.viewport.set([0, 0, e6.width / devicePixelRatio, e6.height / devicePixelRatio]), s6.clear({ color: t3.Color.transparent, depth: 1 }), i6.coordsIndex = [];
                  for (const t4 of c5) {
                    const c6 = i6.getTerrainData(t4.tileID);
                    s6.activeTexture.set(a6.TEXTURE0), a6.bindTexture(a6.TEXTURE_2D, l5.texture);
                    const u5 = { u_matrix: e6.transform.calculatePosMatrix(t4.tileID.toUnwrapped()), u_terrain_coords_id: (255 - i6.coordsIndex.length) / 255, u_texture: 0, u_ele_delta: i6.getMeshFrameDelta(e6.transform.zoom) };
                    h4.draw(s6, a6.TRIANGLES, r6, Mi.disabled, o6, zi.backCCW, u5, c6, "terrain", n4.vertexBuffer, n4.indexBuffer, n4.segments), i6.coordsIndex.push(t4.tileID.key);
                  }
                  s6.bindFramebuffer.set(null), s6.viewport.set([0, 0, e6.width, e6.height]);
                }(this, this.style.map.terrain));
              }
              this.renderPass = "offscreen";
              for (const t4 of s5) {
                const e5 = this.style._layers[t4];
                if (!e5.hasOffscreenPass() || e5.isHidden(this.transform.zoom))
                  continue;
                const i6 = r5[e5.source];
                ("custom" === e5.type || i6.length) && this.renderLayer(this, a5[e5.source], e5, i6);
              }
              if (this.context.bindFramebuffer.set(null), this.context.clear({ color: i5.showOverdrawInspector ? t3.Color.black : t3.Color.transparent, depth: 1 }), this.clearStencil(), this._showOverdrawInspector = i5.showOverdrawInspector, this.depthRangeFor3D = [0, 1 - (e4._order.length + 2) * this.numSublayers * this.depthEpsilon], !this.renderToTexture)
                for (this.renderPass = "opaque", this.currentLayer = s5.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                  const t4 = this.style._layers[s5[this.currentLayer]], e5 = a5[t4.source], i6 = o5[t4.source];
                  this._renderTileClippingMasks(t4, i6), this.renderLayer(this, e5, t4, i6);
                }
              for (this.renderPass = "translucent", this.currentLayer = 0; this.currentLayer < s5.length; this.currentLayer++) {
                const t4 = this.style._layers[s5[this.currentLayer]], e5 = a5[t4.source];
                if (this.renderToTexture && this.renderToTexture.renderLayer(t4))
                  continue;
                const i6 = ("symbol" === t4.type ? n3 : r5)[t4.source];
                this._renderTileClippingMasks(t4, o5[t4.source]), this.renderLayer(this, e5, t4, i6);
              }
              if (this.options.showTileBoundaries) {
                const t4 = function(t5, e5) {
                  let i6 = null;
                  const s6 = Object.values(t5._layers).flatMap((i7) => i7.source && !i7.isHidden(e5) ? [t5.sourceCaches[i7.source]] : []), a6 = s6.filter((t6) => "vector" === t6.getSource().type), o6 = s6.filter((t6) => "vector" !== t6.getSource().type), r6 = (t6) => {
                    (!i6 || i6.getSource().maxzoom < t6.getSource().maxzoom) && (i6 = t6);
                  };
                  return a6.forEach((t6) => r6(t6)), i6 || o6.forEach((t6) => r6(t6)), i6;
                }(this.style, this.transform.zoom);
                t4 && function(t5, e5, i6) {
                  for (let s6 = 0; s6 < i6.length; s6++)
                    ts(t5, e5, i6[s6]);
                }(this, t4, t4.getVisibleCoordinates());
              }
              this.options.showPadding && function(t4) {
                const e5 = t4.transform.padding;
                Yi(t4, t4.transform.height - (e5.top || 0), 3, $i), Yi(t4, e5.bottom || 0, 3, Xi), Ji(t4, e5.left || 0, 3, Wi), Ji(t4, t4.transform.width - (e5.right || 0), 3, Hi);
                const i6 = t4.transform.centerPoint;
                !function(t5, e6, i7, s6) {
                  Qi(t5, e6 - 1, i7 - 10, 2, 20, s6), Qi(t5, e6 - 10, i7 - 1, 20, 2, s6);
                }(t4, i6.x, t4.transform.height - i6.y, Ki);
              }(this), this.context.setDefault();
            }
            renderLayer(e4, i5, s5, a5) {
              if (!s5.isHidden(this.transform.zoom) && ("background" === s5.type || "custom" === s5.type || (a5 || []).length))
                switch (this.id = s5.id, s5.type) {
                  case "symbol":
                    !function(e5, i6, s6, a6, o5) {
                      if ("translucent" !== e5.renderPass)
                        return;
                      const r5 = Mi.disabled, n3 = e5.colorModeForRenderPass();
                      (s6._unevaluatedLayout.hasValue("text-variable-anchor") || s6._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(e6, i7, s7, a7, o6, r6, n4) {
                        const l5 = i7.transform, c5 = "map" === o6, h4 = "map" === r6;
                        for (const o7 of e6) {
                          const e7 = a7.getTile(o7), r7 = e7.getBucket(s7);
                          if (!r7 || !r7.text || !r7.text.segments.get().length)
                            continue;
                          const u5 = t3.evaluateSizeForZoom(r7.textSizeData, l5.zoom), d4 = St(e7, 1, i7.transform.zoom), _4 = nt(o7.posMatrix, h4, c5, i7.transform, d4), m4 = "none" !== s7.layout.get("icon-text-fit") && r7.hasIconData();
                          if (u5) {
                            const t4 = Math.pow(2, l5.zoom - e7.tileID.overscaledZ);
                            Fi(r7, c5, h4, n4, l5, _4, o7.posMatrix, t4, u5, m4, i7.style.map.terrain ? (t5, e8) => i7.style.map.terrain.getElevation(o7, t5, e8) : null);
                          }
                        }
                      }(a6, e5, s6, i6, s6.layout.get("text-rotation-alignment"), s6.layout.get("text-pitch-alignment"), o5), 0 !== s6.paint.get("icon-opacity").constantOr(1) && Ui(e5, i6, s6, a6, false, s6.paint.get("icon-translate"), s6.paint.get("icon-translate-anchor"), s6.layout.get("icon-rotation-alignment"), s6.layout.get("icon-pitch-alignment"), s6.layout.get("icon-keep-upright"), r5, n3), 0 !== s6.paint.get("text-opacity").constantOr(1) && Ui(e5, i6, s6, a6, true, s6.paint.get("text-translate"), s6.paint.get("text-translate-anchor"), s6.layout.get("text-rotation-alignment"), s6.layout.get("text-pitch-alignment"), s6.layout.get("text-keep-upright"), r5, n3), i6.map.showCollisionBoxes && (Li(e5, i6, s6, a6, s6.paint.get("text-translate"), s6.paint.get("text-translate-anchor"), true), Li(e5, i6, s6, a6, s6.paint.get("icon-translate"), s6.paint.get("icon-translate-anchor"), false));
                    }(e4, i5, s5, a5, this.style.placement.variableOffsets);
                    break;
                  case "circle":
                    !function(e5, i6, s6, a6) {
                      if ("translucent" !== e5.renderPass)
                        return;
                      const o5 = s6.paint.get("circle-opacity"), r5 = s6.paint.get("circle-stroke-width"), n3 = s6.paint.get("circle-stroke-opacity"), l5 = !s6.layout.get("circle-sort-key").isConstant();
                      if (0 === o5.constantOr(1) && (0 === r5.constantOr(1) || 0 === n3.constantOr(1)))
                        return;
                      const c5 = e5.context, h4 = c5.gl, u5 = e5.depthModeForSublayer(0, Pi.ReadOnly), d4 = Mi.disabled, _4 = e5.colorModeForRenderPass(), m4 = [];
                      for (let o6 = 0; o6 < a6.length; o6++) {
                        const r6 = a6[o6], n4 = i6.getTile(r6), c6 = n4.getBucket(s6);
                        if (!c6)
                          continue;
                        const h5 = c6.programConfigurations.get(s6.id), u6 = e5.useProgram("circle", h5), d5 = c6.layoutVertexBuffer, _5 = c6.indexBuffer, p7 = e5.style.map.terrain && e5.style.map.terrain.getTerrainData(r6), f4 = { programConfiguration: h5, program: u6, layoutVertexBuffer: d5, indexBuffer: _5, uniformValues: ve(e5, r6, n4, s6), terrainData: p7 };
                        if (l5) {
                          const e6 = c6.segments.get();
                          for (const i7 of e6)
                            m4.push({ segments: new t3.SegmentVector([i7]), sortKey: i7.sortKey, state: f4 });
                        } else
                          m4.push({ segments: c6.segments, sortKey: 0, state: f4 });
                      }
                      l5 && m4.sort((t4, e6) => t4.sortKey - e6.sortKey);
                      for (const t4 of m4) {
                        const { programConfiguration: i7, program: a7, layoutVertexBuffer: o6, indexBuffer: r6, uniformValues: n4, terrainData: l6 } = t4.state;
                        a7.draw(c5, h4.TRIANGLES, u5, d4, _4, zi.disabled, n4, l6, s6.id, o6, r6, t4.segments, s6.paint, e5.transform.zoom, i7);
                      }
                    }(e4, i5, s5, a5);
                    break;
                  case "heatmap":
                    !function(e5, i6, s6, a6) {
                      if (0 !== s6.paint.get("heatmap-opacity"))
                        if ("offscreen" === e5.renderPass) {
                          const o5 = e5.context, r5 = o5.gl, n3 = Mi.disabled, l5 = new Si([r5.ONE, r5.ONE], t3.Color.transparent, [true, true, true, true]);
                          !function(t4, e6, i7) {
                            const s7 = t4.gl;
                            t4.activeTexture.set(s7.TEXTURE1), t4.viewport.set([0, 0, e6.width / 4, e6.height / 4]);
                            let a7 = i7.heatmapFbo;
                            if (a7)
                              s7.bindTexture(s7.TEXTURE_2D, a7.colorAttachment.get()), t4.bindFramebuffer.set(a7.framebuffer);
                            else {
                              const o6 = s7.createTexture();
                              s7.bindTexture(s7.TEXTURE_2D, o6), s7.texParameteri(s7.TEXTURE_2D, s7.TEXTURE_WRAP_S, s7.CLAMP_TO_EDGE), s7.texParameteri(s7.TEXTURE_2D, s7.TEXTURE_WRAP_T, s7.CLAMP_TO_EDGE), s7.texParameteri(s7.TEXTURE_2D, s7.TEXTURE_MIN_FILTER, s7.LINEAR), s7.texParameteri(s7.TEXTURE_2D, s7.TEXTURE_MAG_FILTER, s7.LINEAR), a7 = i7.heatmapFbo = t4.createFramebuffer(e6.width / 4, e6.height / 4, false, false), function(t5, e7, i8, s8) {
                                var a8, o7;
                                const r6 = t5.gl, n4 = null !== (a8 = t5.HALF_FLOAT) && void 0 !== a8 ? a8 : r6.UNSIGNED_BYTE, l6 = null !== (o7 = t5.RGBA16F) && void 0 !== o7 ? o7 : r6.RGBA;
                                r6.texImage2D(r6.TEXTURE_2D, 0, l6, e7.width / 4, e7.height / 4, 0, r6.RGBA, n4, null), s8.colorAttachment.set(i8);
                              }(t4, e6, o6, a7);
                            }
                          }(o5, e5, s6), o5.clear({ color: t3.Color.transparent });
                          for (let t4 = 0; t4 < a6.length; t4++) {
                            const c5 = a6[t4];
                            if (i6.hasRenderableParent(c5))
                              continue;
                            const h4 = i6.getTile(c5), u5 = h4.getBucket(s6);
                            if (!u5)
                              continue;
                            const d4 = u5.programConfigurations.get(s6.id), _4 = e5.useProgram("heatmap", d4), { zoom: m4 } = e5.transform;
                            _4.draw(o5, r5.TRIANGLES, Pi.disabled, n3, l5, zi.disabled, we(c5.posMatrix, h4, m4, s6.paint.get("heatmap-intensity")), null, s6.id, u5.layoutVertexBuffer, u5.indexBuffer, u5.segments, s6.paint, e5.transform.zoom, d4);
                          }
                          o5.viewport.set([0, 0, e5.width, e5.height]);
                        } else
                          "translucent" === e5.renderPass && (e5.context.setColorMode(e5.colorModeForRenderPass()), function(e6, i7) {
                            const s7 = e6.context, a7 = s7.gl, o5 = i7.heatmapFbo;
                            if (!o5)
                              return;
                            s7.activeTexture.set(a7.TEXTURE0), a7.bindTexture(a7.TEXTURE_2D, o5.colorAttachment.get()), s7.activeTexture.set(a7.TEXTURE1);
                            let r5 = i7.colorRampTexture;
                            r5 || (r5 = i7.colorRampTexture = new x2(s7, i7.colorRamp, a7.RGBA)), r5.bind(a7.LINEAR, a7.CLAMP_TO_EDGE), e6.useProgram("heatmapTexture").draw(s7, a7.TRIANGLES, Pi.disabled, Mi.disabled, e6.colorModeForRenderPass(), zi.disabled, ((e7, i8, s8, a8) => {
                              const o6 = t3.create();
                              t3.ortho(o6, 0, e7.width, e7.height, 0, 0, 1);
                              const r6 = e7.context.gl;
                              return { u_matrix: o6, u_world: [r6.drawingBufferWidth, r6.drawingBufferHeight], u_image: 0, u_color_ramp: 1, u_opacity: i8.paint.get("heatmap-opacity") };
                            })(e6, i7), null, i7.id, e6.viewportBuffer, e6.quadTriangleIndexBuffer, e6.viewportSegments, i7.paint, e6.transform.zoom);
                          }(e5, s6));
                    }(e4, i5, s5, a5);
                    break;
                  case "line":
                    !function(e5, i6, s6, a6) {
                      if ("translucent" !== e5.renderPass)
                        return;
                      const o5 = s6.paint.get("line-opacity"), r5 = s6.paint.get("line-width");
                      if (0 === o5.constantOr(1) || 0 === r5.constantOr(1))
                        return;
                      const n3 = e5.depthModeForSublayer(0, Pi.ReadOnly), l5 = e5.colorModeForRenderPass(), c5 = s6.paint.get("line-dasharray"), h4 = s6.paint.get("line-pattern"), u5 = h4.constantOr(1), d4 = s6.paint.get("line-gradient"), _4 = s6.getCrossfadeParameters(), m4 = u5 ? "linePattern" : c5 ? "lineSDF" : d4 ? "lineGradient" : "line", p7 = e5.context, f4 = p7.gl;
                      let g4 = true;
                      for (const o6 of a6) {
                        const a7 = i6.getTile(o6);
                        if (u5 && !a7.patternsLoaded())
                          continue;
                        const r6 = a7.getBucket(s6);
                        if (!r6)
                          continue;
                        const v5 = r6.programConfigurations.get(s6.id), y3 = e5.context.program.get(), b4 = e5.useProgram(m4, v5), w4 = g4 || b4.program !== y3, T3 = e5.style.map.terrain && e5.style.map.terrain.getTerrainData(o6), E3 = h4.constantOr(null);
                        if (E3 && a7.imageAtlas) {
                          const t4 = a7.imageAtlas, e6 = t4.patternPositions[E3.to.toString()], i7 = t4.patternPositions[E3.from.toString()];
                          e6 && i7 && v5.setConstantPatternPositions(e6, i7);
                        }
                        const I3 = T3 ? o6 : null, S3 = u5 ? Se(e5, a7, s6, _4, I3) : c5 ? Ce(e5, a7, s6, c5, _4, I3) : d4 ? Ie(e5, a7, s6, r6.lineClipsArray.length, I3) : Ee(e5, a7, s6, I3);
                        if (u5)
                          p7.activeTexture.set(f4.TEXTURE0), a7.imageAtlasTexture.bind(f4.LINEAR, f4.CLAMP_TO_EDGE), v5.updatePaintBuffers(_4);
                        else if (c5 && (w4 || e5.lineAtlas.dirty))
                          p7.activeTexture.set(f4.TEXTURE0), e5.lineAtlas.bind(p7);
                        else if (d4) {
                          const a8 = r6.gradients[s6.id];
                          let n4 = a8.texture;
                          if (s6.gradientVersion !== a8.version) {
                            let l6 = 256;
                            if (s6.stepInterpolant) {
                              const s7 = i6.getSource().maxzoom, a9 = o6.canonical.z === s7 ? Math.ceil(1 << e5.transform.maxZoom - o6.canonical.z) : 1;
                              l6 = t3.clamp(t3.nextPowerOfTwo(r6.maxLineLength / t3.EXTENT * 1024 * a9), 256, p7.maxTextureSize);
                            }
                            a8.gradient = t3.renderColorRamp({ expression: s6.gradientExpression(), evaluationKey: "lineProgress", resolution: l6, image: a8.gradient || void 0, clips: r6.lineClipsArray }), a8.texture ? a8.texture.update(a8.gradient) : a8.texture = new x2(p7, a8.gradient, f4.RGBA), a8.version = s6.gradientVersion, n4 = a8.texture;
                          }
                          p7.activeTexture.set(f4.TEXTURE0), n4.bind(s6.stepInterpolant ? f4.NEAREST : f4.LINEAR, f4.CLAMP_TO_EDGE);
                        }
                        b4.draw(p7, f4.TRIANGLES, n3, e5.stencilModeForClipping(o6), l5, zi.disabled, S3, T3, s6.id, r6.layoutVertexBuffer, r6.indexBuffer, r6.segments, s6.paint, e5.transform.zoom, v5, r6.layoutVertexBuffer2), g4 = false;
                      }
                    }(e4, i5, s5, a5);
                    break;
                  case "fill":
                    !function(e5, i6, s6, a6) {
                      const o5 = s6.paint.get("fill-color"), r5 = s6.paint.get("fill-opacity");
                      if (0 === r5.constantOr(1))
                        return;
                      const n3 = e5.colorModeForRenderPass(), l5 = s6.paint.get("fill-pattern"), c5 = e5.opaquePassEnabledForLayer() && !l5.constantOr(1) && 1 === o5.constantOr(t3.Color.transparent).a && 1 === r5.constantOr(0) ? "opaque" : "translucent";
                      if (e5.renderPass === c5) {
                        const t4 = e5.depthModeForSublayer(1, "opaque" === e5.renderPass ? Pi.ReadWrite : Pi.ReadOnly);
                        Zi(e5, i6, s6, a6, t4, n3, false);
                      }
                      if ("translucent" === e5.renderPass && s6.paint.get("fill-antialias")) {
                        const t4 = e5.depthModeForSublayer(s6.getPaintProperty("fill-outline-color") ? 2 : 0, Pi.ReadOnly);
                        Zi(e5, i6, s6, a6, t4, n3, true);
                      }
                    }(e4, i5, s5, a5);
                    break;
                  case "fill-extrusion":
                    !function(t4, e5, i6, s6) {
                      const a6 = i6.paint.get("fill-extrusion-opacity");
                      if (0 !== a6 && "translucent" === t4.renderPass) {
                        const o5 = new Pi(t4.context.gl.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D);
                        if (1 !== a6 || i6.paint.get("fill-extrusion-pattern").constantOr(1))
                          Gi(t4, e5, i6, s6, o5, Mi.disabled, Si.disabled), Gi(t4, e5, i6, s6, o5, t4.stencilModeFor3D(), t4.colorModeForRenderPass());
                        else {
                          const a7 = t4.colorModeForRenderPass();
                          Gi(t4, e5, i6, s6, o5, Mi.disabled, a7);
                        }
                      }
                    }(e4, i5, s5, a5);
                    break;
                  case "hillshade":
                    !function(t4, e5, i6, s6) {
                      if ("offscreen" !== t4.renderPass && "translucent" !== t4.renderPass)
                        return;
                      const a6 = t4.context, o5 = t4.depthModeForSublayer(0, Pi.ReadOnly), r5 = t4.colorModeForRenderPass(), [n3, l5] = "translucent" === t4.renderPass ? t4.stencilConfigForOverlap(s6) : [{}, s6];
                      for (const s7 of l5) {
                        const a7 = e5.getTile(s7);
                        void 0 !== a7.needsHillshadePrepare && a7.needsHillshadePrepare && "offscreen" === t4.renderPass ? qi(t4, a7, i6, o5, Mi.disabled, r5) : "translucent" === t4.renderPass && Vi(t4, s7, a7, i6, o5, n3[s7.overscaledZ], r5);
                      }
                      a6.viewport.set([0, 0, t4.width, t4.height]);
                    }(e4, i5, s5, a5);
                    break;
                  case "raster":
                    !function(t4, e5, i6, s6) {
                      if ("translucent" !== t4.renderPass)
                        return;
                      if (0 === i6.paint.get("raster-opacity"))
                        return;
                      if (!s6.length)
                        return;
                      const a6 = t4.context, o5 = a6.gl, r5 = e5.getSource(), n3 = t4.useProgram("raster"), l5 = t4.colorModeForRenderPass(), [c5, h4] = r5 instanceof O2 ? [{}, s6] : t4.stencilConfigForOverlap(s6), u5 = h4[h4.length - 1].overscaledZ, d4 = !t4.options.moving;
                      for (const s7 of h4) {
                        const h5 = t4.depthModeForSublayer(s7.overscaledZ - u5, 1 === i6.paint.get("raster-opacity") ? Pi.ReadWrite : Pi.ReadOnly, o5.LESS), _4 = e5.getTile(s7);
                        _4.registerFadeDuration(i6.paint.get("raster-fade-duration"));
                        const m4 = e5.findLoadedParent(s7, 0), p7 = ji(_4, m4, e5, i6, t4.transform, t4.style.map.terrain);
                        let f4, g4;
                        const v5 = "nearest" === i6.paint.get("raster-resampling") ? o5.NEAREST : o5.LINEAR;
                        a6.activeTexture.set(o5.TEXTURE0), _4.texture.bind(v5, o5.CLAMP_TO_EDGE, o5.LINEAR_MIPMAP_NEAREST), a6.activeTexture.set(o5.TEXTURE1), m4 ? (m4.texture.bind(v5, o5.CLAMP_TO_EDGE, o5.LINEAR_MIPMAP_NEAREST), f4 = Math.pow(2, m4.tileID.overscaledZ - _4.tileID.overscaledZ), g4 = [_4.tileID.canonical.x * f4 % 1, _4.tileID.canonical.y * f4 % 1]) : _4.texture.bind(v5, o5.CLAMP_TO_EDGE, o5.LINEAR_MIPMAP_NEAREST);
                        const x3 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(s7), y3 = x3 ? s7 : null, b4 = y3 ? y3.posMatrix : t4.transform.calculatePosMatrix(s7.toUnwrapped(), d4), w4 = Me(b4, g4 || [0, 0], f4 || 1, p7, i6);
                        r5 instanceof O2 ? n3.draw(a6, o5.TRIANGLES, h5, Mi.disabled, l5, zi.disabled, w4, x3, i6.id, r5.boundsBuffer, t4.quadTriangleIndexBuffer, r5.boundsSegments) : n3.draw(a6, o5.TRIANGLES, h5, c5[s7.overscaledZ], l5, zi.disabled, w4, x3, i6.id, t4.rasterBoundsBuffer, t4.quadTriangleIndexBuffer, t4.rasterBoundsSegments);
                      }
                    }(e4, i5, s5, a5);
                    break;
                  case "background":
                    !function(t4, e5, i6, s6) {
                      const a6 = i6.paint.get("background-color"), o5 = i6.paint.get("background-opacity");
                      if (0 === o5)
                        return;
                      const r5 = t4.context, n3 = r5.gl, l5 = t4.transform, c5 = l5.tileSize, h4 = i6.paint.get("background-pattern");
                      if (t4.isPatternMissing(h4))
                        return;
                      const u5 = !h4 && 1 === a6.a && 1 === o5 && t4.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                      if (t4.renderPass !== u5)
                        return;
                      const d4 = Mi.disabled, _4 = t4.depthModeForSublayer(0, "opaque" === u5 ? Pi.ReadWrite : Pi.ReadOnly), m4 = t4.colorModeForRenderPass(), p7 = t4.useProgram(h4 ? "backgroundPattern" : "background"), f4 = s6 || l5.coveringTiles({ tileSize: c5, terrain: t4.style.map.terrain });
                      h4 && (r5.activeTexture.set(n3.TEXTURE0), t4.imageManager.bind(t4.context));
                      const g4 = i6.getCrossfadeParameters();
                      for (const e6 of f4) {
                        const l6 = s6 ? e6.posMatrix : t4.transform.calculatePosMatrix(e6.toUnwrapped()), u6 = h4 ? Fe(l6, o5, t4, h4, { tileID: e6, tileSize: c5 }, g4) : ke(l6, o5, a6), f5 = t4.style.map.terrain && t4.style.map.terrain.getTerrainData(e6);
                        p7.draw(r5, n3.TRIANGLES, _4, d4, m4, zi.disabled, u6, f5, i6.id, t4.tileExtentBuffer, t4.quadTriangleIndexBuffer, t4.tileExtentSegments);
                      }
                    }(e4, 0, s5, a5);
                    break;
                  case "custom":
                    !function(t4, e5, i6) {
                      const s6 = t4.context, a6 = i6.implementation;
                      if ("offscreen" === t4.renderPass) {
                        const e6 = a6.prerender;
                        e6 && (t4.setCustomLayerDefaults(), s6.setColorMode(t4.colorModeForRenderPass()), e6.call(a6, s6.gl, t4.transform.customLayerMatrix()), s6.setDirty(), t4.setBaseState());
                      } else if ("translucent" === t4.renderPass) {
                        t4.setCustomLayerDefaults(), s6.setColorMode(t4.colorModeForRenderPass()), s6.setStencilMode(Mi.disabled);
                        const e6 = "3d" === a6.renderingMode ? new Pi(t4.context.gl.LEQUAL, Pi.ReadWrite, t4.depthRangeFor3D) : t4.depthModeForSublayer(0, Pi.ReadOnly);
                        s6.setDepthMode(e6), a6.render(s6.gl, t4.transform.customLayerMatrix()), s6.setDirty(), t4.setBaseState(), s6.bindFramebuffer.set(null);
                      }
                    }(e4, 0, s5);
                }
            }
            translatePosMatrix(e4, i5, s5, a5, o5) {
              if (!s5[0] && !s5[1])
                return e4;
              const r5 = o5 ? "map" === a5 ? this.transform.angle : 0 : "viewport" === a5 ? -this.transform.angle : 0;
              if (r5) {
                const t4 = Math.sin(r5), e5 = Math.cos(r5);
                s5 = [s5[0] * e5 - s5[1] * t4, s5[0] * t4 + s5[1] * e5];
              }
              const n3 = [o5 ? s5[0] : St(i5, s5[0], this.transform.zoom), o5 ? s5[1] : St(i5, s5[1], this.transform.zoom), 0], l5 = new Float32Array(16);
              return t3.translate(l5, e4, n3), l5;
            }
            saveTileTexture(t4) {
              const e4 = this._tileTextures[t4.size[0]];
              e4 ? e4.push(t4) : this._tileTextures[t4.size[0]] = [t4];
            }
            getTileTexture(t4) {
              const e4 = this._tileTextures[t4];
              return e4 && e4.length > 0 ? e4.pop() : null;
            }
            isPatternMissing(t4) {
              if (!t4)
                return false;
              if (!t4.from || !t4.to)
                return true;
              const e4 = this.imageManager.getPattern(t4.from.toString()), i5 = this.imageManager.getPattern(t4.to.toString());
              return !e4 || !i5;
            }
            useProgram(t4, e4) {
              this.cache = this.cache || {};
              const i5 = t4 + (e4 ? e4.cacheKey : "") + (this._showOverdrawInspector ? "/overdraw" : "") + (this.style.map.terrain ? "/terrain" : "");
              return this.cache[i5] || (this.cache[i5] = new he(this.context, re[t4], e4, Be[t4], this._showOverdrawInspector, this.style.map.terrain)), this.cache[i5];
            }
            setCustomLayerDefaults() {
              this.context.unbindVAO(), this.context.cullFace.setDefault(), this.context.activeTexture.setDefault(), this.context.pixelStoreUnpack.setDefault(), this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(), this.context.pixelStoreUnpackFlipY.setDefault();
            }
            setBaseState() {
              const t4 = this.context.gl;
              this.context.cullFace.set(false), this.context.viewport.set([0, 0, this.width, this.height]), this.context.blendEquation.set(t4.FUNC_ADD);
            }
            initDebugOverlayCanvas() {
              null == this.debugOverlayCanvas && (this.debugOverlayCanvas = document.createElement("canvas"), this.debugOverlayCanvas.width = 512, this.debugOverlayCanvas.height = 512, this.debugOverlayTexture = new x2(this.context, this.debugOverlayCanvas, this.context.gl.RGBA));
            }
            destroy() {
              this.debugOverlayTexture && this.debugOverlayTexture.destroy();
            }
            overLimit() {
              const { drawingBufferWidth: t4, drawingBufferHeight: e4 } = this.context.gl;
              return this.width !== t4 || this.height !== e4;
            }
          }
          class ss {
            constructor(t4, e4) {
              this.points = t4, this.planes = e4;
            }
            static fromInvProjectionMatrix(e4, i5, s5) {
              const a5 = Math.pow(2, s5), o5 = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map((s6) => {
                const o6 = 1 / (s6 = t3.transformMat4([], s6, e4))[3] / i5 * a5;
                return t3.mul$1(s6, s6, [o6, o6, 1 / s6[3], o6]);
              }), r5 = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map((t4) => {
                const e5 = function(t5, e6) {
                  var i7 = e6[0], s7 = e6[1], a7 = e6[2], o6 = i7 * i7 + s7 * s7 + a7 * a7;
                  return o6 > 0 && (o6 = 1 / Math.sqrt(o6)), t5[0] = e6[0] * o6, t5[1] = e6[1] * o6, t5[2] = e6[2] * o6, t5;
                }([], function(t5, e6, i7) {
                  var s7 = e6[0], a7 = e6[1], o6 = e6[2], r6 = i7[0], n3 = i7[1], l5 = i7[2];
                  return t5[0] = a7 * l5 - o6 * n3, t5[1] = o6 * r6 - s7 * l5, t5[2] = s7 * n3 - a7 * r6, t5;
                }([], p6([], o5[t4[0]], o5[t4[1]]), p6([], o5[t4[2]], o5[t4[1]]))), i6 = -((s6 = e5)[0] * (a6 = o5[t4[1]])[0] + s6[1] * a6[1] + s6[2] * a6[2]);
                var s6, a6;
                return e5.concat(i6);
              });
              return new ss(o5, r5);
            }
          }
          class as {
            constructor(t4, e4) {
              this.min = t4, this.max = e4, this.center = function(t5, e5, i5) {
                return t5[0] = 0.5 * e5[0], t5[1] = 0.5 * e5[1], t5[2] = 0.5 * e5[2], t5;
              }([], function(t5, e5, i5) {
                return t5[0] = e5[0] + i5[0], t5[1] = e5[1] + i5[1], t5[2] = e5[2] + i5[2], t5;
              }([], this.min, this.max));
            }
            quadrant(t4) {
              const e4 = [t4 % 2 == 0, t4 < 2], i5 = _3(this.min), s5 = _3(this.max);
              for (let t5 = 0; t5 < e4.length; t5++)
                i5[t5] = e4[t5] ? this.min[t5] : this.center[t5], s5[t5] = e4[t5] ? this.center[t5] : this.max[t5];
              return s5[2] = this.max[2], new as(i5, s5);
            }
            distanceX(t4) {
              return Math.max(Math.min(this.max[0], t4[0]), this.min[0]) - t4[0];
            }
            distanceY(t4) {
              return Math.max(Math.min(this.max[1], t4[1]), this.min[1]) - t4[1];
            }
            intersects(e4) {
              const i5 = [[this.min[0], this.min[1], this.min[2], 1], [this.max[0], this.min[1], this.min[2], 1], [this.max[0], this.max[1], this.min[2], 1], [this.min[0], this.max[1], this.min[2], 1], [this.min[0], this.min[1], this.max[2], 1], [this.max[0], this.min[1], this.max[2], 1], [this.max[0], this.max[1], this.max[2], 1], [this.min[0], this.max[1], this.max[2], 1]];
              let s5 = true;
              for (let a5 = 0; a5 < e4.planes.length; a5++) {
                const o5 = e4.planes[a5];
                let r5 = 0;
                for (let e5 = 0; e5 < i5.length; e5++)
                  t3.dot(o5, i5[e5]) >= 0 && r5++;
                if (0 === r5)
                  return 0;
                r5 !== i5.length && (s5 = false);
              }
              if (s5)
                return 2;
              for (let t4 = 0; t4 < 3; t4++) {
                let i6 = Number.MAX_VALUE, s6 = -Number.MAX_VALUE;
                for (let a5 = 0; a5 < e4.points.length; a5++) {
                  const o5 = e4.points[a5][t4] - this.min[t4];
                  i6 = Math.min(i6, o5), s6 = Math.max(s6, o5);
                }
                if (s6 < 0 || i6 > this.max[t4] - this.min[t4])
                  return 0;
              }
              return 1;
            }
          }
          class os {
            constructor(t4 = 0, e4 = 0, i5 = 0, s5 = 0) {
              if (isNaN(t4) || t4 < 0 || isNaN(e4) || e4 < 0 || isNaN(i5) || i5 < 0 || isNaN(s5) || s5 < 0)
                throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
              this.top = t4, this.bottom = e4, this.left = i5, this.right = s5;
            }
            interpolate(e4, i5, s5) {
              return null != i5.top && null != e4.top && (this.top = t3.interpolate.number(e4.top, i5.top, s5)), null != i5.bottom && null != e4.bottom && (this.bottom = t3.interpolate.number(e4.bottom, i5.bottom, s5)), null != i5.left && null != e4.left && (this.left = t3.interpolate.number(e4.left, i5.left, s5)), null != i5.right && null != e4.right && (this.right = t3.interpolate.number(e4.right, i5.right, s5)), this;
            }
            getCenter(e4, i5) {
              const s5 = t3.clamp((this.left + e4 - this.right) / 2, 0, e4), a5 = t3.clamp((this.top + i5 - this.bottom) / 2, 0, i5);
              return new t3.Point(s5, a5);
            }
            equals(t4) {
              return this.top === t4.top && this.bottom === t4.bottom && this.left === t4.left && this.right === t4.right;
            }
            clone() {
              return new os(this.top, this.bottom, this.left, this.right);
            }
            toJSON() {
              return { top: this.top, bottom: this.bottom, left: this.left, right: this.right };
            }
          }
          class rs {
            constructor(e4, i5, s5, a5, o5) {
              this.tileSize = 512, this.maxValidLatitude = 85.051129, this._renderWorldCopies = void 0 === o5 || !!o5, this._minZoom = e4 || 0, this._maxZoom = i5 || 22, this._minPitch = null == s5 ? 0 : s5, this._maxPitch = null == a5 ? 60 : a5, this.setMaxBounds(), this.width = 0, this.height = 0, this._center = new t3.LngLat(0, 0), this._elevation = 0, this.zoom = 0, this.angle = 0, this._fov = 0.6435011087932844, this._pitch = 0, this._unmodified = true, this._edgeInsets = new os(), this._posMatrixCache = {}, this._alignedPosMatrixCache = {}, this._minEleveationForCurrentTile = 0;
            }
            clone() {
              const t4 = new rs(this._minZoom, this._maxZoom, this._minPitch, this.maxPitch, this._renderWorldCopies);
              return t4.apply(this), t4;
            }
            apply(t4) {
              this.tileSize = t4.tileSize, this.latRange = t4.latRange, this.width = t4.width, this.height = t4.height, this._center = t4._center, this._elevation = t4._elevation, this._minEleveationForCurrentTile = t4._minEleveationForCurrentTile, this.zoom = t4.zoom, this.angle = t4.angle, this._fov = t4._fov, this._pitch = t4._pitch, this._unmodified = t4._unmodified, this._edgeInsets = t4._edgeInsets.clone(), this._calcMatrices();
            }
            get minZoom() {
              return this._minZoom;
            }
            set minZoom(t4) {
              this._minZoom !== t4 && (this._minZoom = t4, this.zoom = Math.max(this.zoom, t4));
            }
            get maxZoom() {
              return this._maxZoom;
            }
            set maxZoom(t4) {
              this._maxZoom !== t4 && (this._maxZoom = t4, this.zoom = Math.min(this.zoom, t4));
            }
            get minPitch() {
              return this._minPitch;
            }
            set minPitch(t4) {
              this._minPitch !== t4 && (this._minPitch = t4, this.pitch = Math.max(this.pitch, t4));
            }
            get maxPitch() {
              return this._maxPitch;
            }
            set maxPitch(t4) {
              this._maxPitch !== t4 && (this._maxPitch = t4, this.pitch = Math.min(this.pitch, t4));
            }
            get renderWorldCopies() {
              return this._renderWorldCopies;
            }
            set renderWorldCopies(t4) {
              void 0 === t4 ? t4 = true : null === t4 && (t4 = false), this._renderWorldCopies = t4;
            }
            get worldSize() {
              return this.tileSize * this.scale;
            }
            get centerOffset() {
              return this.centerPoint._sub(this.size._div(2));
            }
            get size() {
              return new t3.Point(this.width, this.height);
            }
            get bearing() {
              return -this.angle / Math.PI * 180;
            }
            set bearing(e4) {
              const i5 = -t3.wrap(e4, -180, 180) * Math.PI / 180;
              this.angle !== i5 && (this._unmodified = false, this.angle = i5, this._calcMatrices(), this.rotationMatrix = function() {
                var e5 = new t3.ARRAY_TYPE(4);
                return t3.ARRAY_TYPE != Float32Array && (e5[1] = 0, e5[2] = 0), e5[0] = 1, e5[3] = 1, e5;
              }(), function(t4, e5, i6) {
                var s5 = e5[0], a5 = e5[1], o5 = e5[2], r5 = e5[3], n3 = Math.sin(i6), l5 = Math.cos(i6);
                t4[0] = s5 * l5 + o5 * n3, t4[1] = a5 * l5 + r5 * n3, t4[2] = s5 * -n3 + o5 * l5, t4[3] = a5 * -n3 + r5 * l5;
              }(this.rotationMatrix, this.rotationMatrix, this.angle));
            }
            get pitch() {
              return this._pitch / Math.PI * 180;
            }
            set pitch(e4) {
              const i5 = t3.clamp(e4, this.minPitch, this.maxPitch) / 180 * Math.PI;
              this._pitch !== i5 && (this._unmodified = false, this._pitch = i5, this._calcMatrices());
            }
            get fov() {
              return this._fov / Math.PI * 180;
            }
            set fov(t4) {
              t4 = Math.max(0.01, Math.min(60, t4)), this._fov !== t4 && (this._unmodified = false, this._fov = t4 / 180 * Math.PI, this._calcMatrices());
            }
            get zoom() {
              return this._zoom;
            }
            set zoom(t4) {
              const e4 = Math.min(Math.max(t4, this.minZoom), this.maxZoom);
              this._zoom !== e4 && (this._unmodified = false, this._zoom = e4, this.tileZoom = Math.max(0, Math.floor(e4)), this.scale = this.zoomScale(e4), this._constrain(), this._calcMatrices());
            }
            get center() {
              return this._center;
            }
            set center(t4) {
              t4.lat === this._center.lat && t4.lng === this._center.lng || (this._unmodified = false, this._center = t4, this._constrain(), this._calcMatrices());
            }
            get elevation() {
              return this._elevation;
            }
            set elevation(t4) {
              t4 !== this._elevation && (this._elevation = t4, this._constrain(), this._calcMatrices());
            }
            get padding() {
              return this._edgeInsets.toJSON();
            }
            set padding(t4) {
              this._edgeInsets.equals(t4) || (this._unmodified = false, this._edgeInsets.interpolate(this._edgeInsets, t4, 1), this._calcMatrices());
            }
            get centerPoint() {
              return this._edgeInsets.getCenter(this.width, this.height);
            }
            isPaddingEqual(t4) {
              return this._edgeInsets.equals(t4);
            }
            interpolatePadding(t4, e4, i5) {
              this._unmodified = false, this._edgeInsets.interpolate(t4, e4, i5), this._constrain(), this._calcMatrices();
            }
            coveringZoomLevel(t4) {
              const e4 = (t4.roundZoom ? Math.round : Math.floor)(this.zoom + this.scaleZoom(this.tileSize / t4.tileSize));
              return Math.max(0, e4);
            }
            getVisibleUnwrappedCoordinates(e4) {
              const i5 = [new t3.UnwrappedTileID(0, e4)];
              if (this._renderWorldCopies) {
                const s5 = this.pointCoordinate(new t3.Point(0, 0)), a5 = this.pointCoordinate(new t3.Point(this.width, 0)), o5 = this.pointCoordinate(new t3.Point(this.width, this.height)), r5 = this.pointCoordinate(new t3.Point(0, this.height)), n3 = Math.floor(Math.min(s5.x, a5.x, o5.x, r5.x)), l5 = Math.floor(Math.max(s5.x, a5.x, o5.x, r5.x)), c5 = 1;
                for (let s6 = n3 - c5; s6 <= l5 + c5; s6++)
                  0 !== s6 && i5.push(new t3.UnwrappedTileID(s6, e4));
              }
              return i5;
            }
            coveringTiles(e4) {
              var i5, s5;
              let a5 = this.coveringZoomLevel(e4);
              const o5 = a5;
              if (void 0 !== e4.minzoom && a5 < e4.minzoom)
                return [];
              void 0 !== e4.maxzoom && a5 > e4.maxzoom && (a5 = e4.maxzoom);
              const r5 = this.pointCoordinate(this.getCameraPoint()), n3 = t3.MercatorCoordinate.fromLngLat(this.center), l5 = Math.pow(2, a5), c5 = [l5 * r5.x, l5 * r5.y, 0], h4 = [l5 * n3.x, l5 * n3.y, 0], u5 = ss.fromInvProjectionMatrix(this.invProjMatrix, this.worldSize, a5);
              let d4 = e4.minzoom || 0;
              !e4.terrain && this.pitch <= 60 && this._edgeInsets.top < 0.1 && (d4 = a5);
              const _4 = e4.terrain ? 2 / Math.min(this.tileSize, e4.tileSize) * this.tileSize : 3, m4 = (t4) => ({ aabb: new as([t4 * l5, 0, 0], [(t4 + 1) * l5, l5, 0]), zoom: 0, x: 0, y: 0, wrap: t4, fullyVisible: false }), p7 = [], g4 = [], v5 = a5, x3 = e4.reparseOverscaled ? o5 : a5;
              if (this._renderWorldCopies)
                for (let t4 = 1; t4 <= 3; t4++)
                  p7.push(m4(-t4)), p7.push(m4(t4));
              for (p7.push(m4(0)); p7.length > 0; ) {
                const a6 = p7.pop(), o6 = a6.x, r6 = a6.y;
                let n4 = a6.fullyVisible;
                if (!n4) {
                  const t4 = a6.aabb.intersects(u5);
                  if (0 === t4)
                    continue;
                  n4 = 2 === t4;
                }
                const l6 = e4.terrain ? c5 : h4, m5 = a6.aabb.distanceX(l6), y3 = a6.aabb.distanceY(l6), b4 = Math.max(Math.abs(m5), Math.abs(y3));
                if (a6.zoom === v5 || b4 > _4 + (1 << v5 - a6.zoom) - 2 && a6.zoom >= d4) {
                  const e5 = v5 - a6.zoom, i6 = c5[0] - 0.5 - (o6 << e5), s6 = c5[1] - 0.5 - (r6 << e5);
                  g4.push({ tileID: new t3.OverscaledTileID(a6.zoom === v5 ? x3 : a6.zoom, a6.wrap, a6.zoom, o6, r6), distanceSq: f3([h4[0] - 0.5 - o6, h4[1] - 0.5 - r6]), tileDistanceToCamera: Math.sqrt(i6 * i6 + s6 * s6) });
                } else
                  for (let l7 = 0; l7 < 4; l7++) {
                    const c6 = (o6 << 1) + l7 % 2, h5 = (r6 << 1) + (l7 >> 1), u6 = a6.zoom + 1;
                    let d5 = a6.aabb.quadrant(l7);
                    if (e4.terrain) {
                      const o7 = new t3.OverscaledTileID(u6, a6.wrap, u6, c6, h5), r7 = e4.terrain.getMinMaxElevation(o7), n5 = null !== (i5 = r7.minElevation) && void 0 !== i5 ? i5 : this.elevation, l8 = null !== (s5 = r7.maxElevation) && void 0 !== s5 ? s5 : this.elevation;
                      d5 = new as([d5.min[0], d5.min[1], n5], [d5.max[0], d5.max[1], l8]);
                    }
                    p7.push({ aabb: d5, zoom: u6, x: c6, y: h5, wrap: a6.wrap, fullyVisible: n4 });
                  }
              }
              return g4.sort((t4, e5) => t4.distanceSq - e5.distanceSq).map((t4) => t4.tileID);
            }
            resize(t4, e4) {
              this.width = t4, this.height = e4, this.pixelsToGLUnits = [2 / t4, -2 / e4], this._constrain(), this._calcMatrices();
            }
            get unmodified() {
              return this._unmodified;
            }
            zoomScale(t4) {
              return Math.pow(2, t4);
            }
            scaleZoom(t4) {
              return Math.log(t4) / Math.LN2;
            }
            project(e4) {
              const i5 = t3.clamp(e4.lat, -this.maxValidLatitude, this.maxValidLatitude);
              return new t3.Point(t3.mercatorXfromLng(e4.lng) * this.worldSize, t3.mercatorYfromLat(i5) * this.worldSize);
            }
            unproject(e4) {
              return new t3.MercatorCoordinate(e4.x / this.worldSize, e4.y / this.worldSize).toLngLat();
            }
            get point() {
              return this.project(this.center);
            }
            getCameraPosition() {
              return { lngLat: this.pointLocation(this.getCameraPoint()), altitude: Math.cos(this._pitch) * this.cameraToCenterDistance / this._pixelPerMeter + this.elevation };
            }
            recalculateZoom(e4) {
              const i5 = this.pointLocation(this.centerPoint, e4), s5 = e4.getElevationForLngLatZoom(i5, this.tileZoom);
              if (!(this.elevation - s5))
                return;
              const a5 = this.getCameraPosition(), o5 = t3.MercatorCoordinate.fromLngLat(a5.lngLat, a5.altitude), r5 = t3.MercatorCoordinate.fromLngLat(i5, s5), n3 = o5.x - r5.x, l5 = o5.y - r5.y, c5 = o5.z - r5.z, h4 = Math.sqrt(n3 * n3 + l5 * l5 + c5 * c5), u5 = this.scaleZoom(this.cameraToCenterDistance / h4 / this.tileSize);
              this._elevation = s5, this._center = i5, this.zoom = u5;
            }
            setLocationAtPoint(e4, i5) {
              const s5 = this.pointCoordinate(i5), a5 = this.pointCoordinate(this.centerPoint), o5 = this.locationCoordinate(e4), r5 = new t3.MercatorCoordinate(o5.x - (s5.x - a5.x), o5.y - (s5.y - a5.y));
              this.center = this.coordinateLocation(r5), this._renderWorldCopies && (this.center = this.center.wrap());
            }
            locationPoint(t4, e4) {
              return e4 ? this.coordinatePoint(this.locationCoordinate(t4), e4.getElevationForLngLatZoom(t4, this.tileZoom), this.pixelMatrix3D) : this.coordinatePoint(this.locationCoordinate(t4));
            }
            pointLocation(t4, e4) {
              return this.coordinateLocation(this.pointCoordinate(t4, e4));
            }
            locationCoordinate(e4) {
              return t3.MercatorCoordinate.fromLngLat(e4);
            }
            coordinateLocation(t4) {
              return t4 && t4.toLngLat();
            }
            pointCoordinate(e4, i5) {
              if (i5) {
                const t4 = i5.pointCoordinate(e4);
                if (null != t4)
                  return t4;
              }
              const s5 = [e4.x, e4.y, 0, 1], a5 = [e4.x, e4.y, 1, 1];
              t3.transformMat4(s5, s5, this.pixelMatrixInverse), t3.transformMat4(a5, a5, this.pixelMatrixInverse);
              const o5 = s5[3], r5 = a5[3], n3 = s5[1] / o5, l5 = a5[1] / r5, c5 = s5[2] / o5, h4 = a5[2] / r5, u5 = c5 === h4 ? 0 : (0 - c5) / (h4 - c5);
              return new t3.MercatorCoordinate(t3.interpolate.number(s5[0] / o5, a5[0] / r5, u5) / this.worldSize, t3.interpolate.number(n3, l5, u5) / this.worldSize);
            }
            coordinatePoint(e4, i5 = 0, s5 = this.pixelMatrix) {
              const a5 = [e4.x * this.worldSize, e4.y * this.worldSize, i5, 1];
              return t3.transformMat4(a5, a5, s5), new t3.Point(a5[0] / a5[3], a5[1] / a5[3]);
            }
            getBounds() {
              const e4 = Math.max(0, this.height / 2 - this.getHorizon());
              return new A2().extend(this.pointLocation(new t3.Point(0, e4))).extend(this.pointLocation(new t3.Point(this.width, e4))).extend(this.pointLocation(new t3.Point(this.width, this.height))).extend(this.pointLocation(new t3.Point(0, this.height)));
            }
            getMaxBounds() {
              return this.latRange && 2 === this.latRange.length && this.lngRange && 2 === this.lngRange.length ? new A2([this.lngRange[0], this.latRange[0]], [this.lngRange[1], this.latRange[1]]) : null;
            }
            getHorizon() {
              return Math.tan(Math.PI / 2 - this._pitch) * this.cameraToCenterDistance * 0.85;
            }
            setMaxBounds(t4) {
              t4 ? (this.lngRange = [t4.getWest(), t4.getEast()], this.latRange = [t4.getSouth(), t4.getNorth()], this._constrain()) : (this.lngRange = null, this.latRange = [-this.maxValidLatitude, this.maxValidLatitude]);
            }
            calculatePosMatrix(e4, i5 = false) {
              const s5 = e4.key, a5 = i5 ? this._alignedPosMatrixCache : this._posMatrixCache;
              if (a5[s5])
                return a5[s5];
              const o5 = e4.canonical, r5 = this.worldSize / this.zoomScale(o5.z), n3 = o5.x + Math.pow(2, o5.z) * e4.wrap, l5 = t3.identity(new Float64Array(16));
              return t3.translate(l5, l5, [n3 * r5, o5.y * r5, 0]), t3.scale(l5, l5, [r5 / t3.EXTENT, r5 / t3.EXTENT, 1]), t3.multiply(l5, i5 ? this.alignedProjMatrix : this.projMatrix, l5), a5[s5] = new Float32Array(l5), a5[s5];
            }
            customLayerMatrix() {
              return this.mercatorMatrix.slice();
            }
            _constrain() {
              if (!this.center || !this.width || !this.height || this._constraining)
                return;
              this._constraining = true;
              let e4, i5, s5, a5, o5 = -90, r5 = 90, n3 = -180, l5 = 180;
              const c5 = this.size, h4 = this._unmodified;
              if (this.latRange) {
                const i6 = this.latRange;
                o5 = t3.mercatorYfromLat(i6[1]) * this.worldSize, r5 = t3.mercatorYfromLat(i6[0]) * this.worldSize, e4 = r5 - o5 < c5.y ? c5.y / (r5 - o5) : 0;
              }
              if (this.lngRange) {
                const e5 = this.lngRange;
                n3 = t3.wrap(t3.mercatorXfromLng(e5[0]) * this.worldSize, 0, this.worldSize), l5 = t3.wrap(t3.mercatorXfromLng(e5[1]) * this.worldSize, 0, this.worldSize), l5 < n3 && (l5 += this.worldSize), i5 = l5 - n3 < c5.x ? c5.x / (l5 - n3) : 0;
              }
              const u5 = this.point, d4 = Math.max(i5 || 0, e4 || 0);
              if (d4)
                return this.center = this.unproject(new t3.Point(i5 ? (l5 + n3) / 2 : u5.x, e4 ? (r5 + o5) / 2 : u5.y)), this.zoom += this.scaleZoom(d4), this._unmodified = h4, void (this._constraining = false);
              if (this.latRange) {
                const t4 = u5.y, e5 = c5.y / 2;
                t4 - e5 < o5 && (a5 = o5 + e5), t4 + e5 > r5 && (a5 = r5 - e5);
              }
              if (this.lngRange) {
                const e5 = (n3 + l5) / 2, i6 = t3.wrap(u5.x, e5 - this.worldSize / 2, e5 + this.worldSize / 2), a6 = c5.x / 2;
                i6 - a6 < n3 && (s5 = n3 + a6), i6 + a6 > l5 && (s5 = l5 - a6);
              }
              void 0 === s5 && void 0 === a5 || (this.center = this.unproject(new t3.Point(void 0 !== s5 ? s5 : u5.x, void 0 !== a5 ? a5 : u5.y)).wrap()), this._unmodified = h4, this._constraining = false;
            }
            _calcMatrices() {
              if (!this.height)
                return;
              const e4 = this.centerOffset, i5 = this.point.x, s5 = this.point.y;
              this.cameraToCenterDistance = 0.5 / Math.tan(this._fov / 2) * this.height, this._pixelPerMeter = t3.mercatorZfromAltitude(1, this.center.lat) * this.worldSize;
              let a5 = t3.identity(new Float64Array(16));
              t3.scale(a5, a5, [this.width / 2, -this.height / 2, 1]), t3.translate(a5, a5, [1, -1, 0]), this.labelPlaneMatrix = a5, a5 = t3.identity(new Float64Array(16)), t3.scale(a5, a5, [1, -1, 1]), t3.translate(a5, a5, [-1, -1, 0]), t3.scale(a5, a5, [2 / this.width, 2 / this.height, 1]), this.glCoordMatrix = a5;
              const o5 = this.cameraToCenterDistance + this._elevation * this._pixelPerMeter / Math.cos(this._pitch), r5 = Math.min(this.elevation, this._minEleveationForCurrentTile), n3 = o5 - r5 * this._pixelPerMeter / Math.cos(this._pitch), l5 = r5 < 0 ? n3 : o5, c5 = Math.PI / 2 + this._pitch, h4 = this._fov * (0.5 + e4.y / this.height), u5 = Math.sin(h4) * l5 / Math.sin(t3.clamp(Math.PI - c5 - h4, 0.01, Math.PI - 0.01)), d4 = this.getHorizon(), _4 = 2 * Math.atan(d4 / this.cameraToCenterDistance) * (0.5 + e4.y / (2 * d4)), m4 = Math.sin(_4) * l5 / Math.sin(t3.clamp(Math.PI - c5 - _4, 0.01, Math.PI - 0.01)), p7 = Math.min(u5, m4), f4 = 1.01 * (Math.cos(Math.PI / 2 - this._pitch) * p7 + l5), g4 = this.height / 50;
              a5 = new Float64Array(16), t3.perspective(a5, this._fov, this.width / this.height, g4, f4), a5[8] = 2 * -e4.x / this.width, a5[9] = 2 * e4.y / this.height, t3.scale(a5, a5, [1, -1, 1]), t3.translate(a5, a5, [0, 0, -this.cameraToCenterDistance]), t3.rotateX(a5, a5, this._pitch), t3.rotateZ(a5, a5, this.angle), t3.translate(a5, a5, [-i5, -s5, 0]), this.mercatorMatrix = t3.scale([], a5, [this.worldSize, this.worldSize, this.worldSize]), t3.scale(a5, a5, [1, 1, this._pixelPerMeter]), this.pixelMatrix = t3.multiply(new Float64Array(16), this.labelPlaneMatrix, a5), t3.translate(a5, a5, [0, 0, -this.elevation]), this.projMatrix = a5, this.invProjMatrix = t3.invert([], a5), this.pixelMatrix3D = t3.multiply(new Float64Array(16), this.labelPlaneMatrix, a5);
              const v5 = this.width % 2 / 2, x3 = this.height % 2 / 2, y3 = Math.cos(this.angle), b4 = Math.sin(this.angle), w4 = i5 - Math.round(i5) + y3 * v5 + b4 * x3, T3 = s5 - Math.round(s5) + y3 * x3 + b4 * v5, E3 = new Float64Array(a5);
              if (t3.translate(E3, E3, [w4 > 0.5 ? w4 - 1 : w4, T3 > 0.5 ? T3 - 1 : T3, 0]), this.alignedProjMatrix = E3, a5 = t3.invert(new Float64Array(16), this.pixelMatrix), !a5)
                throw new Error("failed to invert matrix");
              this.pixelMatrixInverse = a5, this._posMatrixCache = {}, this._alignedPosMatrixCache = {};
            }
            maxPitchScaleFactor() {
              if (!this.pixelMatrixInverse)
                return 1;
              const e4 = this.pointCoordinate(new t3.Point(0, 0)), i5 = [e4.x * this.worldSize, e4.y * this.worldSize, 0, 1];
              return t3.transformMat4(i5, i5, this.pixelMatrix)[3] / this.cameraToCenterDistance;
            }
            getCameraPoint() {
              const e4 = Math.tan(this._pitch) * (this.cameraToCenterDistance || 1);
              return this.centerPoint.add(new t3.Point(0, e4));
            }
            getCameraQueryGeometry(e4) {
              const i5 = this.getCameraPoint();
              if (1 === e4.length)
                return [e4[0], i5];
              {
                let s5 = i5.x, a5 = i5.y, o5 = i5.x, r5 = i5.y;
                for (const t4 of e4)
                  s5 = Math.min(s5, t4.x), a5 = Math.min(a5, t4.y), o5 = Math.max(o5, t4.x), r5 = Math.max(r5, t4.y);
                return [new t3.Point(s5, a5), new t3.Point(o5, a5), new t3.Point(o5, r5), new t3.Point(s5, r5), new t3.Point(s5, a5)];
              }
            }
          }
          function ns(t4, e4) {
            let i5, s5 = false, a5 = null, o5 = null;
            const r5 = () => {
              a5 = null, s5 && (t4.apply(o5, i5), a5 = setTimeout(r5, e4), s5 = false);
            };
            return (...t5) => (s5 = true, o5 = this, i5 = t5, a5 || r5(), a5);
          }
          class ls {
            constructor(t4) {
              this._getCurrentHash = () => {
                const t5 = window.location.hash.replace("#", "");
                if (this._hashName) {
                  let e4;
                  return t5.split("&").map((t6) => t6.split("=")).forEach((t6) => {
                    t6[0] === this._hashName && (e4 = t6);
                  }), (e4 && e4[1] || "").split("/");
                }
                return t5.split("/");
              }, this._onHashChange = () => {
                const t5 = this._getCurrentHash();
                if (t5.length >= 3 && !t5.some((t6) => isNaN(t6))) {
                  const e4 = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(t5[3] || 0) : this._map.getBearing();
                  return this._map.jumpTo({ center: [+t5[2], +t5[1]], zoom: +t5[0], bearing: e4, pitch: +(t5[4] || 0) }), true;
                }
                return false;
              }, this._updateHashUnthrottled = () => {
                const t5 = window.location.href.replace(/(#.+)?$/, this.getHashString());
                try {
                  window.history.replaceState(window.history.state, null, t5);
                } catch (t6) {
                }
              }, this._updateHash = ns(this._updateHashUnthrottled, 300), this._hashName = t4 && encodeURIComponent(t4);
            }
            addTo(t4) {
              return this._map = t4, addEventListener("hashchange", this._onHashChange, false), this._map.on("moveend", this._updateHash), this;
            }
            remove() {
              return removeEventListener("hashchange", this._onHashChange, false), this._map.off("moveend", this._updateHash), clearTimeout(this._updateHash()), delete this._map, this;
            }
            getHashString(t4) {
              const e4 = this._map.getCenter(), i5 = Math.round(100 * this._map.getZoom()) / 100, s5 = Math.ceil((i5 * Math.LN2 + Math.log(512 / 360 / 0.5)) / Math.LN10), a5 = Math.pow(10, s5), o5 = Math.round(e4.lng * a5) / a5, r5 = Math.round(e4.lat * a5) / a5, n3 = this._map.getBearing(), l5 = this._map.getPitch();
              let c5 = "";
              if (c5 += t4 ? `/${o5}/${r5}/${i5}` : `${i5}/${r5}/${o5}`, (n3 || l5) && (c5 += "/" + Math.round(10 * n3) / 10), l5 && (c5 += `/${Math.round(l5)}`), this._hashName) {
                const t5 = this._hashName;
                let e5 = false;
                const i6 = window.location.hash.slice(1).split("&").map((i7) => {
                  const s6 = i7.split("=")[0];
                  return s6 === t5 ? (e5 = true, `${s6}=${c5}`) : i7;
                }).filter((t6) => t6);
                return e5 || i6.push(`${t5}=${c5}`), `#${i6.join("&")}`;
              }
              return `#${c5}`;
            }
          }
          const cs = { linearity: 0.3, easing: t3.bezier(0, 0, 0.3, 1) }, hs = t3.extend({ deceleration: 2500, maxSpeed: 1400 }, cs), us = t3.extend({ deceleration: 20, maxSpeed: 1400 }, cs), ds = t3.extend({ deceleration: 1e3, maxSpeed: 360 }, cs), _s = t3.extend({ deceleration: 1e3, maxSpeed: 90 }, cs);
          class ms {
            constructor(t4) {
              this._map = t4, this.clear();
            }
            clear() {
              this._inertiaBuffer = [];
            }
            record(e4) {
              this._drainInertiaBuffer(), this._inertiaBuffer.push({ time: t3.browser.now(), settings: e4 });
            }
            _drainInertiaBuffer() {
              const e4 = this._inertiaBuffer, i5 = t3.browser.now();
              for (; e4.length > 0 && i5 - e4[0].time > 160; )
                e4.shift();
            }
            _onMoveEnd(e4) {
              if (this._drainInertiaBuffer(), this._inertiaBuffer.length < 2)
                return;
              const i5 = { zoom: 0, bearing: 0, pitch: 0, pan: new t3.Point(0, 0), pinchAround: void 0, around: void 0 };
              for (const { settings: t4 } of this._inertiaBuffer)
                i5.zoom += t4.zoomDelta || 0, i5.bearing += t4.bearingDelta || 0, i5.pitch += t4.pitchDelta || 0, t4.panDelta && i5.pan._add(t4.panDelta), t4.around && (i5.around = t4.around), t4.pinchAround && (i5.pinchAround = t4.pinchAround);
              const s5 = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time, a5 = {};
              if (i5.pan.mag()) {
                const o5 = fs(i5.pan.mag(), s5, t3.extend({}, hs, e4 || {}));
                a5.offset = i5.pan.mult(o5.amount / i5.pan.mag()), a5.center = this._map.transform.center, ps(a5, o5);
              }
              if (i5.zoom) {
                const t4 = fs(i5.zoom, s5, us);
                a5.zoom = this._map.transform.zoom + t4.amount, ps(a5, t4);
              }
              if (i5.bearing) {
                const e5 = fs(i5.bearing, s5, ds);
                a5.bearing = this._map.transform.bearing + t3.clamp(e5.amount, -179, 179), ps(a5, e5);
              }
              if (i5.pitch) {
                const t4 = fs(i5.pitch, s5, _s);
                a5.pitch = this._map.transform.pitch + t4.amount, ps(a5, t4);
              }
              if (a5.zoom || a5.bearing) {
                const t4 = void 0 === i5.pinchAround ? i5.around : i5.pinchAround;
                a5.around = t4 ? this._map.unproject(t4) : this._map.getCenter();
              }
              return this.clear(), t3.extend(a5, { noMoveStart: true });
            }
          }
          function ps(t4, e4) {
            (!t4.duration || t4.duration < e4.duration) && (t4.duration = e4.duration, t4.easing = e4.easing);
          }
          function fs(e4, i5, s5) {
            const { maxSpeed: a5, linearity: o5, deceleration: r5 } = s5, n3 = t3.clamp(e4 * o5 / (i5 / 1e3), -a5, a5), l5 = Math.abs(n3) / (r5 * o5);
            return { easing: s5.easing, duration: 1e3 * l5, amount: n3 * (l5 / 2) };
          }
          class gs extends t3.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e4, s5, a5, o5 = {}) {
              const r5 = i4.mousePos(s5.getCanvasContainer(), a5), n3 = s5.unproject(r5);
              super(e4, t3.extend({ point: r5, lngLat: n3, originalEvent: a5 }, o5)), this._defaultPrevented = false, this.target = s5;
            }
          }
          class vs extends t3.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(e4, s5, a5) {
              const o5 = "touchend" === e4 ? a5.changedTouches : a5.touches, r5 = i4.touchPos(s5.getCanvasContainer(), o5), n3 = r5.map((t4) => s5.unproject(t4)), l5 = r5.reduce((t4, e5, i5, s6) => t4.add(e5.div(s6.length)), new t3.Point(0, 0));
              super(e4, { points: r5, point: l5, lngLats: n3, lngLat: s5.unproject(l5), originalEvent: a5 }), this._defaultPrevented = false;
            }
          }
          class xs extends t3.Event {
            preventDefault() {
              this._defaultPrevented = true;
            }
            get defaultPrevented() {
              return this._defaultPrevented;
            }
            constructor(t4, e4, i5) {
              super(t4, { originalEvent: i5 }), this._defaultPrevented = false;
            }
          }
          class ys {
            constructor(t4, e4) {
              this._map = t4, this._clickTolerance = e4.clickTolerance;
            }
            reset() {
              delete this._mousedownPos;
            }
            wheel(t4) {
              return this._firePreventable(new xs(t4.type, this._map, t4));
            }
            mousedown(t4, e4) {
              return this._mousedownPos = e4, this._firePreventable(new gs(t4.type, this._map, t4));
            }
            mouseup(t4) {
              this._map.fire(new gs(t4.type, this._map, t4));
            }
            click(t4, e4) {
              this._mousedownPos && this._mousedownPos.dist(e4) >= this._clickTolerance || this._map.fire(new gs(t4.type, this._map, t4));
            }
            dblclick(t4) {
              return this._firePreventable(new gs(t4.type, this._map, t4));
            }
            mouseover(t4) {
              this._map.fire(new gs(t4.type, this._map, t4));
            }
            mouseout(t4) {
              this._map.fire(new gs(t4.type, this._map, t4));
            }
            touchstart(t4) {
              return this._firePreventable(new vs(t4.type, this._map, t4));
            }
            touchmove(t4) {
              this._map.fire(new vs(t4.type, this._map, t4));
            }
            touchend(t4) {
              this._map.fire(new vs(t4.type, this._map, t4));
            }
            touchcancel(t4) {
              this._map.fire(new vs(t4.type, this._map, t4));
            }
            _firePreventable(t4) {
              if (this._map.fire(t4), t4.defaultPrevented)
                return {};
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class bs {
            constructor(t4) {
              this._map = t4;
            }
            reset() {
              this._delayContextMenu = false, this._ignoreContextMenu = true, delete this._contextMenuEvent;
            }
            mousemove(t4) {
              this._map.fire(new gs(t4.type, this._map, t4));
            }
            mousedown() {
              this._delayContextMenu = true, this._ignoreContextMenu = false;
            }
            mouseup() {
              this._delayContextMenu = false, this._contextMenuEvent && (this._map.fire(new gs("contextmenu", this._map, this._contextMenuEvent)), delete this._contextMenuEvent);
            }
            contextmenu(t4) {
              this._delayContextMenu ? this._contextMenuEvent = t4 : this._ignoreContextMenu || this._map.fire(new gs(t4.type, this._map, t4)), this._map.listens("contextmenu") && t4.preventDefault();
            }
            isEnabled() {
              return true;
            }
            isActive() {
              return false;
            }
            enable() {
            }
            disable() {
            }
          }
          class ws {
            constructor(t4) {
              this._map = t4;
            }
            get transform() {
              return this._map._requestedCameraState || this._map.transform;
            }
            get center() {
              return { lng: this.transform.center.lng, lat: this.transform.center.lat };
            }
            get zoom() {
              return this.transform.zoom;
            }
            get pitch() {
              return this.transform.pitch;
            }
            get bearing() {
              return this.transform.bearing;
            }
            unproject(e4) {
              return this.transform.pointLocation(t3.Point.convert(e4), this._map.terrain);
            }
          }
          class Ts {
            constructor(t4, e4) {
              this._map = t4, this._tr = new ws(t4), this._el = t4.getCanvasContainer(), this._container = t4.getContainer(), this._clickTolerance = e4.clickTolerance || 1;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active;
            }
            enable() {
              this.isEnabled() || (this._enabled = true);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            mousedown(t4, e4) {
              this.isEnabled() && t4.shiftKey && 0 === t4.button && (i4.disableDrag(), this._startPos = this._lastPos = e4, this._active = true);
            }
            mousemoveWindow(t4, e4) {
              if (!this._active)
                return;
              const s5 = e4;
              if (this._lastPos.equals(s5) || !this._box && s5.dist(this._startPos) < this._clickTolerance)
                return;
              const a5 = this._startPos;
              this._lastPos = s5, this._box || (this._box = i4.create("div", "maplibregl-boxzoom", this._container), this._container.classList.add("maplibregl-crosshair"), this._fireEvent("boxzoomstart", t4));
              const o5 = Math.min(a5.x, s5.x), r5 = Math.max(a5.x, s5.x), n3 = Math.min(a5.y, s5.y), l5 = Math.max(a5.y, s5.y);
              i4.setTransform(this._box, `translate(${o5}px,${n3}px)`), this._box.style.width = r5 - o5 + "px", this._box.style.height = l5 - n3 + "px";
            }
            mouseupWindow(e4, s5) {
              if (!this._active)
                return;
              if (0 !== e4.button)
                return;
              const a5 = this._startPos, o5 = s5;
              if (this.reset(), i4.suppressClick(), a5.x !== o5.x || a5.y !== o5.y)
                return this._map.fire(new t3.Event("boxzoomend", { originalEvent: e4 })), { cameraAnimation: (t4) => t4.fitScreenCoordinates(a5, o5, this._tr.bearing, { linear: true }) };
              this._fireEvent("boxzoomcancel", e4);
            }
            keydown(t4) {
              this._active && 27 === t4.keyCode && (this.reset(), this._fireEvent("boxzoomcancel", t4));
            }
            reset() {
              this._active = false, this._container.classList.remove("maplibregl-crosshair"), this._box && (i4.remove(this._box), this._box = null), i4.enableDrag(), delete this._startPos, delete this._lastPos;
            }
            _fireEvent(e4, i5) {
              return this._map.fire(new t3.Event(e4, { originalEvent: i5 }));
            }
          }
          function Es(t4, e4) {
            if (t4.length !== e4.length)
              throw new Error(`The number of touches and points are not equal - touches ${t4.length}, points ${e4.length}`);
            const i5 = {};
            for (let s5 = 0; s5 < t4.length; s5++)
              i5[t4[s5].identifier] = e4[s5];
            return i5;
          }
          class Is {
            constructor(t4) {
              this.reset(), this.numTouches = t4.numTouches;
            }
            reset() {
              delete this.centroid, delete this.startTime, delete this.touches, this.aborted = false;
            }
            touchstart(e4, i5, s5) {
              (this.centroid || s5.length > this.numTouches) && (this.aborted = true), this.aborted || (void 0 === this.startTime && (this.startTime = e4.timeStamp), s5.length === this.numTouches && (this.centroid = function(e5) {
                const i6 = new t3.Point(0, 0);
                for (const t4 of e5)
                  i6._add(t4);
                return i6.div(e5.length);
              }(i5), this.touches = Es(s5, i5)));
            }
            touchmove(t4, e4, i5) {
              if (this.aborted || !this.centroid)
                return;
              const s5 = Es(i5, e4);
              for (const t5 in this.touches) {
                const e5 = s5[t5];
                (!e5 || e5.dist(this.touches[t5]) > 30) && (this.aborted = true);
              }
            }
            touchend(t4, e4, i5) {
              if ((!this.centroid || t4.timeStamp - this.startTime > 500) && (this.aborted = true), 0 === i5.length) {
                const t5 = !this.aborted && this.centroid;
                if (this.reset(), t5)
                  return t5;
              }
            }
          }
          class Ss {
            constructor(t4) {
              this.singleTap = new Is(t4), this.numTaps = t4.numTaps, this.reset();
            }
            reset() {
              this.lastTime = 1 / 0, delete this.lastTap, this.count = 0, this.singleTap.reset();
            }
            touchstart(t4, e4, i5) {
              this.singleTap.touchstart(t4, e4, i5);
            }
            touchmove(t4, e4, i5) {
              this.singleTap.touchmove(t4, e4, i5);
            }
            touchend(t4, e4, i5) {
              const s5 = this.singleTap.touchend(t4, e4, i5);
              if (s5) {
                const e5 = t4.timeStamp - this.lastTime < 500, i6 = !this.lastTap || this.lastTap.dist(s5) < 30;
                if (e5 && i6 || this.reset(), this.count++, this.lastTime = t4.timeStamp, this.lastTap = s5, this.count === this.numTaps)
                  return this.reset(), s5;
              }
            }
          }
          class Cs {
            constructor(t4) {
              this._tr = new ws(t4), this._zoomIn = new Ss({ numTouches: 1, numTaps: 2 }), this._zoomOut = new Ss({ numTouches: 2, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, this._zoomIn.reset(), this._zoomOut.reset();
            }
            touchstart(t4, e4, i5) {
              this._zoomIn.touchstart(t4, e4, i5), this._zoomOut.touchstart(t4, e4, i5);
            }
            touchmove(t4, e4, i5) {
              this._zoomIn.touchmove(t4, e4, i5), this._zoomOut.touchmove(t4, e4, i5);
            }
            touchend(t4, e4, i5) {
              const s5 = this._zoomIn.touchend(t4, e4, i5), a5 = this._zoomOut.touchend(t4, e4, i5), o5 = this._tr;
              return s5 ? (this._active = true, t4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e5) => e5.easeTo({ duration: 300, zoom: o5.zoom + 1, around: o5.unproject(s5) }, { originalEvent: t4 }) }) : a5 ? (this._active = true, t4.preventDefault(), setTimeout(() => this.reset(), 0), { cameraAnimation: (e5) => e5.easeTo({ duration: 300, zoom: o5.zoom - 1, around: o5.unproject(a5) }, { originalEvent: t4 }) }) : void 0;
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ps {
            constructor(t4) {
              this._enabled = !!t4.enable, this._moveStateManager = t4.moveStateManager, this._clickTolerance = t4.clickTolerance || 1, this._moveFunction = t4.move, this._activateOnStart = !!t4.activateOnStart, t4.assignEvents(this), this.reset();
            }
            reset(t4) {
              this._active = false, this._moved = false, delete this._lastPoint, this._moveStateManager.endMove(t4);
            }
            _move(...t4) {
              const e4 = this._moveFunction(...t4);
              if (e4.bearingDelta || e4.pitchDelta || e4.around || e4.panDelta)
                return this._active = true, e4;
            }
            dragStart(t4, e4) {
              this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(t4) && (this._moveStateManager.startMove(t4), this._lastPoint = e4.length ? e4[0] : e4, this._activateOnStart && this._lastPoint && (this._active = true));
            }
            dragMove(t4, e4) {
              if (!this.isEnabled())
                return;
              const i5 = this._lastPoint;
              if (!i5)
                return;
              if (t4.preventDefault(), !this._moveStateManager.isValidMoveEvent(t4))
                return void this.reset(t4);
              const s5 = e4.length ? e4[0] : e4;
              return !this._moved && s5.dist(i5) < this._clickTolerance ? void 0 : (this._moved = true, this._lastPoint = s5, this._move(i5, s5));
            }
            dragEnd(t4) {
              this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(t4) && (this._moved && i4.suppressClick(), this.reset(t4));
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            getClickTolerance() {
              return this._clickTolerance;
            }
          }
          const Ds = { 0: 1, 2: 2 };
          class Ms {
            constructor(t4) {
              this._correctEvent = t4.checkCorrectEvent;
            }
            startMove(t4) {
              const e4 = i4.mouseButton(t4);
              this._eventButton = e4;
            }
            endMove(t4) {
              delete this._eventButton;
            }
            isValidStartEvent(t4) {
              return this._correctEvent(t4);
            }
            isValidMoveEvent(t4) {
              return !function(t5, e4) {
                const i5 = Ds[e4];
                return void 0 === t5.buttons || (t5.buttons & i5) !== i5;
              }(t4, this._eventButton);
            }
            isValidEndEvent(t4) {
              return i4.mouseButton(t4) === this._eventButton;
            }
          }
          class zs {
            constructor() {
              this._firstTouch = void 0;
            }
            _isOneFingerTouch(t4) {
              return 1 === t4.targetTouches.length;
            }
            _isSameTouchEvent(t4) {
              return t4.targetTouches[0].identifier === this._firstTouch;
            }
            startMove(t4) {
              this._firstTouch = t4.targetTouches[0].identifier;
            }
            endMove(t4) {
              delete this._firstTouch;
            }
            isValidStartEvent(t4) {
              return this._isOneFingerTouch(t4);
            }
            isValidMoveEvent(t4) {
              return this._isOneFingerTouch(t4) && this._isSameTouchEvent(t4);
            }
            isValidEndEvent(t4) {
              return this._isOneFingerTouch(t4) && this._isSameTouchEvent(t4);
            }
          }
          const As = (t4) => {
            t4.mousedown = t4.dragStart, t4.mousemoveWindow = t4.dragMove, t4.mouseup = t4.dragEnd, t4.contextmenu = function(t5) {
              t5.preventDefault();
            };
          }, Ls = ({ enable: t4, clickTolerance: e4, bearingDegreesPerPixelMoved: s5 = 0.8 }) => {
            const a5 = new Ms({ checkCorrectEvent: (t5) => 0 === i4.mouseButton(t5) && t5.ctrlKey || 2 === i4.mouseButton(t5) });
            return new Ps({ clickTolerance: e4, move: (t5, e5) => ({ bearingDelta: (e5.x - t5.x) * s5 }), moveStateManager: a5, enable: t4, assignEvents: As });
          }, Rs = ({ enable: t4, clickTolerance: e4, pitchDegreesPerPixelMoved: s5 = -0.5 }) => {
            const a5 = new Ms({ checkCorrectEvent: (t5) => 0 === i4.mouseButton(t5) && t5.ctrlKey || 2 === i4.mouseButton(t5) });
            return new Ps({ clickTolerance: e4, move: (t5, e5) => ({ pitchDelta: (e5.y - t5.y) * s5 }), moveStateManager: a5, enable: t4, assignEvents: As });
          };
          class ks {
            constructor(t4, e4) {
              this._minTouches = t4.cooperativeGestures ? 2 : 1, this._clickTolerance = t4.clickTolerance || 1, this._map = e4, this.reset();
            }
            reset() {
              this._active = false, this._touches = {}, this._sum = new t3.Point(0, 0), setTimeout(() => {
                this._cancelCooperativeMessage = false;
              }, 200);
            }
            touchstart(t4, e4, i5) {
              return this._calculateTransform(t4, e4, i5);
            }
            touchmove(t4, e4, i5) {
              if (this._map._cooperativeGestures && (2 === this._minTouches && i5.length < 2 && !this._cancelCooperativeMessage ? this._map._onCooperativeGesture(t4, false, i5.length) : this._cancelCooperativeMessage || (this._cancelCooperativeMessage = true)), this._active && !(i5.length < this._minTouches))
                return t4.preventDefault(), this._calculateTransform(t4, e4, i5);
            }
            touchend(t4, e4, i5) {
              this._calculateTransform(t4, e4, i5), this._active && i5.length < this._minTouches && this.reset();
            }
            touchcancel() {
              this.reset();
            }
            _calculateTransform(e4, i5, s5) {
              s5.length > 0 && (this._active = true);
              const a5 = Es(s5, i5), o5 = new t3.Point(0, 0), r5 = new t3.Point(0, 0);
              let n3 = 0;
              for (const t4 in a5) {
                const e5 = a5[t4], i6 = this._touches[t4];
                i6 && (o5._add(e5), r5._add(e5.sub(i6)), n3++, a5[t4] = e5);
              }
              if (this._touches = a5, n3 < this._minTouches || !r5.mag())
                return;
              const l5 = r5.div(n3);
              return this._sum._add(l5), this._sum.mag() < this._clickTolerance ? void 0 : { around: o5.div(n3), panDelta: l5 };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Fs {
            constructor() {
              this.reset();
            }
            reset() {
              this._active = false, delete this._firstTwoTouches;
            }
            touchstart(t4, e4, i5) {
              this._firstTwoTouches || i5.length < 2 || (this._firstTwoTouches = [i5[0].identifier, i5[1].identifier], this._start([e4[0], e4[1]]));
            }
            touchmove(t4, e4, i5) {
              if (!this._firstTwoTouches)
                return;
              t4.preventDefault();
              const [s5, a5] = this._firstTwoTouches, o5 = Bs(i5, e4, s5), r5 = Bs(i5, e4, a5);
              if (!o5 || !r5)
                return;
              const n3 = this._aroundCenter ? null : o5.add(r5).div(2);
              return this._move([o5, r5], n3, t4);
            }
            touchend(t4, e4, s5) {
              if (!this._firstTwoTouches)
                return;
              const [a5, o5] = this._firstTwoTouches, r5 = Bs(s5, e4, a5), n3 = Bs(s5, e4, o5);
              r5 && n3 || (this._active && i4.suppressClick(), this.reset());
            }
            touchcancel() {
              this.reset();
            }
            enable(t4) {
              this._enabled = true, this._aroundCenter = !!t4 && "center" === t4.around;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          function Bs(t4, e4, i5) {
            for (let s5 = 0; s5 < t4.length; s5++)
              if (t4[s5].identifier === i5)
                return e4[s5];
          }
          function Us(t4, e4) {
            return Math.log(t4 / e4) / Math.LN2;
          }
          class Os extends Fs {
            reset() {
              super.reset(), delete this._distance, delete this._startDistance;
            }
            _start(t4) {
              this._startDistance = this._distance = t4[0].dist(t4[1]);
            }
            _move(t4, e4) {
              const i5 = this._distance;
              if (this._distance = t4[0].dist(t4[1]), this._active || !(Math.abs(Us(this._distance, this._startDistance)) < 0.1))
                return this._active = true, { zoomDelta: Us(this._distance, i5), pinchAround: e4 };
            }
          }
          function Ns(t4, e4) {
            return 180 * t4.angleWith(e4) / Math.PI;
          }
          class Zs extends Fs {
            reset() {
              super.reset(), delete this._minDiameter, delete this._startVector, delete this._vector;
            }
            _start(t4) {
              this._startVector = this._vector = t4[0].sub(t4[1]), this._minDiameter = t4[0].dist(t4[1]);
            }
            _move(t4, e4) {
              const i5 = this._vector;
              if (this._vector = t4[0].sub(t4[1]), this._active || !this._isBelowThreshold(this._vector))
                return this._active = true, { bearingDelta: Ns(this._vector, i5), pinchAround: e4 };
            }
            _isBelowThreshold(t4) {
              this._minDiameter = Math.min(this._minDiameter, t4.mag());
              const e4 = 25 / (Math.PI * this._minDiameter) * 360, i5 = Ns(t4, this._startVector);
              return Math.abs(i5) < e4;
            }
          }
          function Gs(t4) {
            return Math.abs(t4.y) > Math.abs(t4.x);
          }
          class Vs extends Fs {
            constructor(t4) {
              super(), this._map = t4;
            }
            reset() {
              super.reset(), this._valid = void 0, delete this._firstMove, delete this._lastPoints;
            }
            touchstart(t4, e4, i5) {
              super.touchstart(t4, e4, i5), this._currentTouchCount = i5.length;
            }
            _start(t4) {
              this._lastPoints = t4, Gs(t4[0].sub(t4[1])) && (this._valid = false);
            }
            _move(t4, e4, i5) {
              if (this._map._cooperativeGestures && this._currentTouchCount < 3)
                return;
              const s5 = t4[0].sub(this._lastPoints[0]), a5 = t4[1].sub(this._lastPoints[1]);
              return this._valid = this.gestureBeginsVertically(s5, a5, i5.timeStamp), this._valid ? (this._lastPoints = t4, this._active = true, { pitchDelta: (s5.y + a5.y) / 2 * -0.5 }) : void 0;
            }
            gestureBeginsVertically(t4, e4, i5) {
              if (void 0 !== this._valid)
                return this._valid;
              const s5 = t4.mag() >= 2, a5 = e4.mag() >= 2;
              if (!s5 && !a5)
                return;
              if (!s5 || !a5)
                return void 0 === this._firstMove && (this._firstMove = i5), i5 - this._firstMove < 100 && void 0;
              const o5 = t4.y > 0 == e4.y > 0;
              return Gs(t4) && Gs(e4) && o5;
            }
          }
          const qs = { panStep: 100, bearingStep: 15, pitchStep: 10 };
          class js {
            constructor(t4) {
              this._tr = new ws(t4);
              const e4 = qs;
              this._panStep = e4.panStep, this._bearingStep = e4.bearingStep, this._pitchStep = e4.pitchStep, this._rotationDisabled = false;
            }
            reset() {
              this._active = false;
            }
            keydown(t4) {
              if (t4.altKey || t4.ctrlKey || t4.metaKey)
                return;
              let e4 = 0, i5 = 0, s5 = 0, a5 = 0, o5 = 0;
              switch (t4.keyCode) {
                case 61:
                case 107:
                case 171:
                case 187:
                  e4 = 1;
                  break;
                case 189:
                case 109:
                case 173:
                  e4 = -1;
                  break;
                case 37:
                  t4.shiftKey ? i5 = -1 : (t4.preventDefault(), a5 = -1);
                  break;
                case 39:
                  t4.shiftKey ? i5 = 1 : (t4.preventDefault(), a5 = 1);
                  break;
                case 38:
                  t4.shiftKey ? s5 = 1 : (t4.preventDefault(), o5 = -1);
                  break;
                case 40:
                  t4.shiftKey ? s5 = -1 : (t4.preventDefault(), o5 = 1);
                  break;
                default:
                  return;
              }
              return this._rotationDisabled && (i5 = 0, s5 = 0), { cameraAnimation: (r5) => {
                const n3 = this._tr;
                r5.easeTo({ duration: 300, easeId: "keyboardHandler", easing: $s, zoom: e4 ? Math.round(n3.zoom) + e4 * (t4.shiftKey ? 2 : 1) : n3.zoom, bearing: n3.bearing + i5 * this._bearingStep, pitch: n3.pitch + s5 * this._pitchStep, offset: [-a5 * this._panStep, -o5 * this._panStep], center: n3.center }, { originalEvent: t4 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
            disableRotation() {
              this._rotationDisabled = true;
            }
            enableRotation() {
              this._rotationDisabled = false;
            }
          }
          function $s(t4) {
            return t4 * (2 - t4);
          }
          const Xs = 4.000244140625;
          class Ws {
            constructor(t4, e4) {
              this._onTimeout = (t5) => {
                this._type = "wheel", this._delta -= this._lastValue, this._active || this._start(t5);
              }, this._map = t4, this._tr = new ws(t4), this._el = t4.getCanvasContainer(), this._triggerRenderFrame = e4, this._delta = 0, this._defaultZoomRate = 0.01, this._wheelZoomRate = 0.0022222222222222222;
            }
            setZoomRate(t4) {
              this._defaultZoomRate = t4;
            }
            setWheelZoomRate(t4) {
              this._wheelZoomRate = t4;
            }
            isEnabled() {
              return !!this._enabled;
            }
            isActive() {
              return !!this._active || void 0 !== this._finishTimeout;
            }
            isZooming() {
              return !!this._zooming;
            }
            enable(t4) {
              this.isEnabled() || (this._enabled = true, this._aroundCenter = !!t4 && "center" === t4.around);
            }
            disable() {
              this.isEnabled() && (this._enabled = false);
            }
            wheel(e4) {
              if (!this.isEnabled())
                return;
              if (this._map._cooperativeGestures) {
                if (!e4[this._map._metaKey])
                  return;
                e4.preventDefault();
              }
              let i5 = e4.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e4.deltaY : e4.deltaY;
              const s5 = t3.browser.now(), a5 = s5 - (this._lastWheelEventTime || 0);
              this._lastWheelEventTime = s5, 0 !== i5 && i5 % Xs == 0 ? this._type = "wheel" : 0 !== i5 && Math.abs(i5) < 4 ? this._type = "trackpad" : a5 > 400 ? (this._type = null, this._lastValue = i5, this._timeout = setTimeout(this._onTimeout, 40, e4)) : this._type || (this._type = Math.abs(a5 * i5) < 200 ? "trackpad" : "wheel", this._timeout && (clearTimeout(this._timeout), this._timeout = null, i5 += this._lastValue)), e4.shiftKey && i5 && (i5 /= 4), this._type && (this._lastWheelEvent = e4, this._delta -= i5, this._active || this._start(e4)), e4.preventDefault();
            }
            _start(e4) {
              if (!this._delta)
                return;
              this._frameId && (this._frameId = null), this._active = true, this.isZooming() || (this._zooming = true), this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
              const s5 = i4.mousePos(this._el, e4), a5 = this._tr;
              this._around = t3.LngLat.convert(this._aroundCenter ? a5.center : a5.unproject(s5)), this._aroundPoint = a5.transform.locationPoint(this._around), this._frameId || (this._frameId = true, this._triggerRenderFrame());
            }
            renderFrame() {
              if (!this._frameId)
                return;
              if (this._frameId = null, !this.isActive())
                return;
              const e4 = this._tr.transform;
              if (0 !== this._delta) {
                const t4 = "wheel" === this._type && Math.abs(this._delta) > Xs ? this._wheelZoomRate : this._defaultZoomRate;
                let i6 = 2 / (1 + Math.exp(-Math.abs(this._delta * t4)));
                this._delta < 0 && 0 !== i6 && (i6 = 1 / i6);
                const s6 = "number" == typeof this._targetZoom ? e4.zoomScale(this._targetZoom) : e4.scale;
                this._targetZoom = Math.min(e4.maxZoom, Math.max(e4.minZoom, e4.scaleZoom(s6 * i6))), "wheel" === this._type && (this._startZoom = e4.zoom, this._easing = this._smoothOutEasing(200)), this._delta = 0;
              }
              const i5 = "number" == typeof this._targetZoom ? this._targetZoom : e4.zoom, s5 = this._startZoom, a5 = this._easing;
              let o5, r5 = false;
              if ("wheel" === this._type && s5 && a5) {
                const e5 = Math.min((t3.browser.now() - this._lastWheelEventTime) / 200, 1), n3 = a5(e5);
                o5 = t3.interpolate.number(s5, i5, n3), e5 < 1 ? this._frameId || (this._frameId = true) : r5 = true;
              } else
                o5 = i5, r5 = true;
              return this._active = true, r5 && (this._active = false, this._finishTimeout = setTimeout(() => {
                this._zooming = false, this._triggerRenderFrame(), delete this._targetZoom, delete this._finishTimeout;
              }, 200)), { noInertia: true, needsRenderFrame: !r5, zoomDelta: o5 - e4.zoom, around: this._aroundPoint, originalEvent: this._lastWheelEvent };
            }
            _smoothOutEasing(e4) {
              let i5 = t3.defaultEasing;
              if (this._prevEase) {
                const e5 = this._prevEase, s5 = (t3.browser.now() - e5.start) / e5.duration, a5 = e5.easing(s5 + 0.01) - e5.easing(s5), o5 = 0.27 / Math.sqrt(a5 * a5 + 1e-4) * 0.01, r5 = Math.sqrt(0.0729 - o5 * o5);
                i5 = t3.bezier(o5, r5, 0.25, 1);
              }
              return this._prevEase = { start: t3.browser.now(), duration: e4, easing: i5 }, i5;
            }
            reset() {
              this._active = false, this._zooming = false, delete this._targetZoom, this._finishTimeout && (clearTimeout(this._finishTimeout), delete this._finishTimeout);
            }
          }
          class Hs {
            constructor(t4, e4) {
              this._clickZoom = t4, this._tapZoom = e4;
            }
            enable() {
              this._clickZoom.enable(), this._tapZoom.enable();
            }
            disable() {
              this._clickZoom.disable(), this._tapZoom.disable();
            }
            isEnabled() {
              return this._clickZoom.isEnabled() && this._tapZoom.isEnabled();
            }
            isActive() {
              return this._clickZoom.isActive() || this._tapZoom.isActive();
            }
          }
          class Ks {
            constructor(t4) {
              this._tr = new ws(t4), this.reset();
            }
            reset() {
              this._active = false;
            }
            dblclick(t4, e4) {
              return t4.preventDefault(), { cameraAnimation: (i5) => {
                i5.easeTo({ duration: 300, zoom: this._tr.zoom + (t4.shiftKey ? -1 : 1), around: this._tr.unproject(e4) }, { originalEvent: t4 });
              } };
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Ys {
            constructor() {
              this._tap = new Ss({ numTouches: 1, numTaps: 1 }), this.reset();
            }
            reset() {
              this._active = false, delete this._swipePoint, delete this._swipeTouch, delete this._tapTime, delete this._tapPoint, this._tap.reset();
            }
            touchstart(t4, e4, i5) {
              if (!this._swipePoint)
                if (this._tapTime) {
                  const s5 = e4[0], a5 = t4.timeStamp - this._tapTime < 500, o5 = this._tapPoint.dist(s5) < 30;
                  a5 && o5 ? i5.length > 0 && (this._swipePoint = s5, this._swipeTouch = i5[0].identifier) : this.reset();
                } else
                  this._tap.touchstart(t4, e4, i5);
            }
            touchmove(t4, e4, i5) {
              if (this._tapTime) {
                if (this._swipePoint) {
                  if (i5[0].identifier !== this._swipeTouch)
                    return;
                  const s5 = e4[0], a5 = s5.y - this._swipePoint.y;
                  return this._swipePoint = s5, t4.preventDefault(), this._active = true, { zoomDelta: a5 / 128 };
                }
              } else
                this._tap.touchmove(t4, e4, i5);
            }
            touchend(t4, e4, i5) {
              if (this._tapTime)
                this._swipePoint && 0 === i5.length && this.reset();
              else {
                const s5 = this._tap.touchend(t4, e4, i5);
                s5 && (this._tapTime = t4.timeStamp, this._tapPoint = s5);
              }
            }
            touchcancel() {
              this.reset();
            }
            enable() {
              this._enabled = true;
            }
            disable() {
              this._enabled = false, this.reset();
            }
            isEnabled() {
              return this._enabled;
            }
            isActive() {
              return this._active;
            }
          }
          class Js {
            constructor(t4, e4, i5) {
              this._el = t4, this._mousePan = e4, this._touchPan = i5;
            }
            enable(t4) {
              this._inertiaOptions = t4 || {}, this._mousePan.enable(), this._touchPan.enable(), this._el.classList.add("maplibregl-touch-drag-pan");
            }
            disable() {
              this._mousePan.disable(), this._touchPan.disable(), this._el.classList.remove("maplibregl-touch-drag-pan");
            }
            isEnabled() {
              return this._mousePan.isEnabled() && this._touchPan.isEnabled();
            }
            isActive() {
              return this._mousePan.isActive() || this._touchPan.isActive();
            }
          }
          class Qs {
            constructor(t4, e4, i5) {
              this._pitchWithRotate = t4.pitchWithRotate, this._mouseRotate = e4, this._mousePitch = i5;
            }
            enable() {
              this._mouseRotate.enable(), this._pitchWithRotate && this._mousePitch.enable();
            }
            disable() {
              this._mouseRotate.disable(), this._mousePitch.disable();
            }
            isEnabled() {
              return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled());
            }
            isActive() {
              return this._mouseRotate.isActive() || this._mousePitch.isActive();
            }
          }
          class ta {
            constructor(t4, e4, i5, s5) {
              this._el = t4, this._touchZoom = e4, this._touchRotate = i5, this._tapDragZoom = s5, this._rotationDisabled = false, this._enabled = true;
            }
            enable(t4) {
              this._touchZoom.enable(t4), this._rotationDisabled || this._touchRotate.enable(t4), this._tapDragZoom.enable(), this._el.classList.add("maplibregl-touch-zoom-rotate");
            }
            disable() {
              this._touchZoom.disable(), this._touchRotate.disable(), this._tapDragZoom.disable(), this._el.classList.remove("maplibregl-touch-zoom-rotate");
            }
            isEnabled() {
              return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled();
            }
            isActive() {
              return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive();
            }
            disableRotation() {
              this._rotationDisabled = true, this._touchRotate.disable();
            }
            enableRotation() {
              this._rotationDisabled = false, this._touchZoom.isEnabled() && this._touchRotate.enable();
            }
          }
          const ea = (t4) => t4.zoom || t4.drag || t4.pitch || t4.rotate;
          class ia extends t3.Event {
          }
          function sa(t4) {
            return t4.panDelta && t4.panDelta.mag() || t4.zoomDelta || t4.bearingDelta || t4.pitchDelta;
          }
          class aa {
            constructor(t4, e4) {
              this.handleWindowEvent = (t5) => {
                this.handleEvent(t5, `${t5.type}Window`);
              }, this.handleEvent = (t5, e5) => {
                if ("blur" === t5.type)
                  return void this.stop(true);
                this._updatingCamera = true;
                const s6 = "renderFrame" === t5.type ? void 0 : t5, a5 = { needsRenderFrame: false }, o5 = {}, r5 = {}, n3 = t5.touches, l5 = n3 ? this._getMapTouches(n3) : void 0, c5 = l5 ? i4.touchPos(this._el, l5) : i4.mousePos(this._el, t5);
                for (const { handlerName: i5, handler: n4, allowed: h5 } of this._handlers) {
                  if (!n4.isEnabled())
                    continue;
                  let u6;
                  this._blockedByActive(r5, h5, i5) ? n4.reset() : n4[e5 || t5.type] && (u6 = n4[e5 || t5.type](t5, c5, l5), this.mergeHandlerResult(a5, o5, u6, i5, s6), u6 && u6.needsRenderFrame && this._triggerRenderFrame()), (u6 || n4.isActive()) && (r5[i5] = n4);
                }
                const h4 = {};
                for (const t6 in this._previousActiveHandlers)
                  r5[t6] || (h4[t6] = s6);
                this._previousActiveHandlers = r5, (Object.keys(h4).length || sa(a5)) && (this._changes.push([a5, o5, h4]), this._triggerRenderFrame()), (Object.keys(r5).length || sa(a5)) && this._map._stop(true), this._updatingCamera = false;
                const { cameraAnimation: u5 } = a5;
                u5 && (this._inertia.clear(), this._fireEvents({}, {}, true), this._changes = [], u5(this._map));
              }, this._map = t4, this._el = this._map.getCanvasContainer(), this._handlers = [], this._handlersById = {}, this._changes = [], this._inertia = new ms(t4), this._bearingSnap = e4.bearingSnap, this._previousActiveHandlers = {}, this._eventsInProgress = {}, this._addDefaultHandlers(e4);
              const s5 = this._el;
              this._listeners = [[s5, "touchstart", { passive: true }], [s5, "touchmove", { passive: false }], [s5, "touchend", void 0], [s5, "touchcancel", void 0], [s5, "mousedown", void 0], [s5, "mousemove", void 0], [s5, "mouseup", void 0], [document, "mousemove", { capture: true }], [document, "mouseup", void 0], [s5, "mouseover", void 0], [s5, "mouseout", void 0], [s5, "dblclick", void 0], [s5, "click", void 0], [s5, "keydown", { capture: false }], [s5, "keyup", void 0], [s5, "wheel", { passive: false }], [s5, "contextmenu", void 0], [window, "blur", void 0]];
              for (const [t5, e5, s6] of this._listeners)
                i4.addEventListener(t5, e5, t5 === document ? this.handleWindowEvent : this.handleEvent, s6);
            }
            destroy() {
              for (const [t4, e4, s5] of this._listeners)
                i4.removeEventListener(t4, e4, t4 === document ? this.handleWindowEvent : this.handleEvent, s5);
            }
            _addDefaultHandlers(t4) {
              const e4 = this._map, s5 = e4.getCanvasContainer();
              this._add("mapEvent", new ys(e4, t4));
              const a5 = e4.boxZoom = new Ts(e4, t4);
              this._add("boxZoom", a5), t4.interactive && t4.boxZoom && a5.enable();
              const o5 = new Cs(e4), r5 = new Ks(e4);
              e4.doubleClickZoom = new Hs(r5, o5), this._add("tapZoom", o5), this._add("clickZoom", r5), t4.interactive && t4.doubleClickZoom && e4.doubleClickZoom.enable();
              const n3 = new Ys();
              this._add("tapDragZoom", n3);
              const l5 = e4.touchPitch = new Vs(e4);
              this._add("touchPitch", l5), t4.interactive && t4.touchPitch && e4.touchPitch.enable(t4.touchPitch);
              const c5 = Ls(t4), h4 = Rs(t4);
              e4.dragRotate = new Qs(t4, c5, h4), this._add("mouseRotate", c5, ["mousePitch"]), this._add("mousePitch", h4, ["mouseRotate"]), t4.interactive && t4.dragRotate && e4.dragRotate.enable();
              const u5 = (({ enable: t5, clickTolerance: e5 }) => {
                const s6 = new Ms({ checkCorrectEvent: (t6) => 0 === i4.mouseButton(t6) && !t6.ctrlKey });
                return new Ps({ clickTolerance: e5, move: (t6, e6) => ({ around: e6, panDelta: e6.sub(t6) }), activateOnStart: true, moveStateManager: s6, enable: t5, assignEvents: As });
              })(t4), d4 = new ks(t4, e4);
              e4.dragPan = new Js(s5, u5, d4), this._add("mousePan", u5), this._add("touchPan", d4, ["touchZoom", "touchRotate"]), t4.interactive && t4.dragPan && e4.dragPan.enable(t4.dragPan);
              const _4 = new Zs(), m4 = new Os();
              e4.touchZoomRotate = new ta(s5, m4, _4, n3), this._add("touchRotate", _4, ["touchPan", "touchZoom"]), this._add("touchZoom", m4, ["touchPan", "touchRotate"]), t4.interactive && t4.touchZoomRotate && e4.touchZoomRotate.enable(t4.touchZoomRotate);
              const p7 = e4.scrollZoom = new Ws(e4, () => this._triggerRenderFrame());
              this._add("scrollZoom", p7, ["mousePan"]), t4.interactive && t4.scrollZoom && e4.scrollZoom.enable(t4.scrollZoom);
              const f4 = e4.keyboard = new js(e4);
              this._add("keyboard", f4), t4.interactive && t4.keyboard && e4.keyboard.enable(), this._add("blockableMapEvent", new bs(e4));
            }
            _add(t4, e4, i5) {
              this._handlers.push({ handlerName: t4, handler: e4, allowed: i5 }), this._handlersById[t4] = e4;
            }
            stop(t4) {
              if (!this._updatingCamera) {
                for (const { handler: t5 } of this._handlers)
                  t5.reset();
                this._inertia.clear(), this._fireEvents({}, {}, t4), this._changes = [];
              }
            }
            isActive() {
              for (const { handler: t4 } of this._handlers)
                if (t4.isActive())
                  return true;
              return false;
            }
            isZooming() {
              return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming();
            }
            isRotating() {
              return !!this._eventsInProgress.rotate;
            }
            isMoving() {
              return Boolean(ea(this._eventsInProgress)) || this.isZooming();
            }
            _blockedByActive(t4, e4, i5) {
              for (const s5 in t4)
                if (s5 !== i5 && (!e4 || e4.indexOf(s5) < 0))
                  return true;
              return false;
            }
            _getMapTouches(t4) {
              const e4 = [];
              for (const i5 of t4)
                this._el.contains(i5.target) && e4.push(i5);
              return e4;
            }
            mergeHandlerResult(e4, i5, s5, a5, o5) {
              if (!s5)
                return;
              t3.extend(e4, s5);
              const r5 = { handlerName: a5, originalEvent: s5.originalEvent || o5 };
              void 0 !== s5.zoomDelta && (i5.zoom = r5), void 0 !== s5.panDelta && (i5.drag = r5), void 0 !== s5.pitchDelta && (i5.pitch = r5), void 0 !== s5.bearingDelta && (i5.rotate = r5);
            }
            _applyChanges() {
              const e4 = {}, i5 = {}, s5 = {};
              for (const [a5, o5, r5] of this._changes)
                a5.panDelta && (e4.panDelta = (e4.panDelta || new t3.Point(0, 0))._add(a5.panDelta)), a5.zoomDelta && (e4.zoomDelta = (e4.zoomDelta || 0) + a5.zoomDelta), a5.bearingDelta && (e4.bearingDelta = (e4.bearingDelta || 0) + a5.bearingDelta), a5.pitchDelta && (e4.pitchDelta = (e4.pitchDelta || 0) + a5.pitchDelta), void 0 !== a5.around && (e4.around = a5.around), void 0 !== a5.pinchAround && (e4.pinchAround = a5.pinchAround), a5.noInertia && (e4.noInertia = a5.noInertia), t3.extend(i5, o5), t3.extend(s5, r5);
              this._updateMapTransform(e4, i5, s5), this._changes = [];
            }
            _updateMapTransform(t4, e4, i5) {
              const s5 = this._map, a5 = s5._getTransformForUpdate(), o5 = s5.terrain;
              if (!(sa(t4) || o5 && this._terrainMovement))
                return this._fireEvents(e4, i5, true);
              let { panDelta: r5, zoomDelta: n3, bearingDelta: l5, pitchDelta: c5, around: h4, pinchAround: u5 } = t4;
              void 0 !== u5 && (h4 = u5), s5._stop(true), h4 = h4 || s5.transform.centerPoint;
              const d4 = a5.pointLocation(r5 ? h4.sub(r5) : h4);
              l5 && (a5.bearing += l5), c5 && (a5.pitch += c5), n3 && (a5.zoom += n3), o5 ? this._terrainMovement || !e4.drag && !e4.zoom ? e4.drag && this._terrainMovement ? a5.center = a5.pointLocation(a5.centerPoint.sub(r5)) : a5.setLocationAtPoint(d4, h4) : (this._terrainMovement = true, this._map._elevationFreeze = true, a5.setLocationAtPoint(d4, h4), this._map.once("moveend", () => {
                this._map._elevationFreeze = false, this._terrainMovement = false, a5.recalculateZoom(s5.terrain);
              })) : a5.setLocationAtPoint(d4, h4), s5._applyUpdatedTransform(a5), this._map._update(), t4.noInertia || this._inertia.record(t4), this._fireEvents(e4, i5, true);
            }
            _fireEvents(e4, i5, s5) {
              const a5 = ea(this._eventsInProgress), o5 = ea(e4), r5 = {};
              for (const t4 in e4) {
                const { originalEvent: i6 } = e4[t4];
                this._eventsInProgress[t4] || (r5[`${t4}start`] = i6), this._eventsInProgress[t4] = e4[t4];
              }
              !a5 && o5 && this._fireEvent("movestart", o5.originalEvent);
              for (const t4 in r5)
                this._fireEvent(t4, r5[t4]);
              o5 && this._fireEvent("move", o5.originalEvent);
              for (const t4 in e4) {
                const { originalEvent: i6 } = e4[t4];
                this._fireEvent(t4, i6);
              }
              const n3 = {};
              let l5;
              for (const t4 in this._eventsInProgress) {
                const { handlerName: e5, originalEvent: s6 } = this._eventsInProgress[t4];
                this._handlersById[e5].isActive() || (delete this._eventsInProgress[t4], l5 = i5[e5] || s6, n3[`${t4}end`] = l5);
              }
              for (const t4 in n3)
                this._fireEvent(t4, n3[t4]);
              const c5 = ea(this._eventsInProgress);
              if (s5 && (a5 || o5) && !c5) {
                this._updatingCamera = true;
                const e5 = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions), i6 = (t4) => 0 !== t4 && -this._bearingSnap < t4 && t4 < this._bearingSnap;
                !e5 || !e5.essential && t3.browser.prefersReducedMotion ? (this._map.fire(new t3.Event("moveend", { originalEvent: l5 })), i6(this._map.getBearing()) && this._map.resetNorth()) : (i6(e5.bearing || this._map.getBearing()) && (e5.bearing = 0), e5.freezeElevation = true, this._map.easeTo(e5, { originalEvent: l5 })), this._updatingCamera = false;
              }
            }
            _fireEvent(e4, i5) {
              this._map.fire(new t3.Event(e4, i5 ? { originalEvent: i5 } : {}));
            }
            _requestFrame() {
              return this._map.triggerRepaint(), this._map._renderTaskQueue.add((t4) => {
                delete this._frameId, this.handleEvent(new ia("renderFrame", { timeStamp: t4 })), this._applyChanges();
              });
            }
            _triggerRenderFrame() {
              void 0 === this._frameId && (this._frameId = this._requestFrame());
            }
          }
          class oa extends t3.Evented {
            constructor(e4, i5) {
              super(), this._renderFrameCallback = () => {
                const e5 = Math.min((t3.browser.now() - this._easeStart) / this._easeOptions.duration, 1);
                this._onEaseFrame(this._easeOptions.easing(e5)), e5 < 1 ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop();
              }, this._moving = false, this._zooming = false, this.transform = e4, this._bearingSnap = i5.bearingSnap, this.on("moveend", () => {
                delete this._requestedCameraState;
              });
            }
            getCenter() {
              return new t3.LngLat(this.transform.center.lng, this.transform.center.lat);
            }
            setCenter(t4, e4) {
              return this.jumpTo({ center: t4 }, e4);
            }
            panBy(e4, i5, s5) {
              return e4 = t3.Point.convert(e4).mult(-1), this.panTo(this.transform.center, t3.extend({ offset: e4 }, i5), s5);
            }
            panTo(e4, i5, s5) {
              return this.easeTo(t3.extend({ center: e4 }, i5), s5);
            }
            getZoom() {
              return this.transform.zoom;
            }
            setZoom(t4, e4) {
              return this.jumpTo({ zoom: t4 }, e4), this;
            }
            zoomTo(e4, i5, s5) {
              return this.easeTo(t3.extend({ zoom: e4 }, i5), s5);
            }
            zoomIn(t4, e4) {
              return this.zoomTo(this.getZoom() + 1, t4, e4), this;
            }
            zoomOut(t4, e4) {
              return this.zoomTo(this.getZoom() - 1, t4, e4), this;
            }
            getBearing() {
              return this.transform.bearing;
            }
            setBearing(t4, e4) {
              return this.jumpTo({ bearing: t4 }, e4), this;
            }
            getPadding() {
              return this.transform.padding;
            }
            setPadding(t4, e4) {
              return this.jumpTo({ padding: t4 }, e4), this;
            }
            rotateTo(e4, i5, s5) {
              return this.easeTo(t3.extend({ bearing: e4 }, i5), s5);
            }
            resetNorth(e4, i5) {
              return this.rotateTo(0, t3.extend({ duration: 1e3 }, e4), i5), this;
            }
            resetNorthPitch(e4, i5) {
              return this.easeTo(t3.extend({ bearing: 0, pitch: 0, duration: 1e3 }, e4), i5), this;
            }
            snapToNorth(t4, e4) {
              return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(t4, e4) : this;
            }
            getPitch() {
              return this.transform.pitch;
            }
            setPitch(t4, e4) {
              return this.jumpTo({ pitch: t4 }, e4), this;
            }
            cameraForBounds(t4, e4) {
              t4 = A2.convert(t4);
              const i5 = e4 && e4.bearing || 0;
              return this._cameraForBoxAndBearing(t4.getNorthWest(), t4.getSouthEast(), i5, e4);
            }
            _cameraForBoxAndBearing(e4, i5, s5, a5) {
              const o5 = { top: 0, bottom: 0, right: 0, left: 0 };
              if ("number" == typeof (a5 = t3.extend({ padding: o5, offset: [0, 0], maxZoom: this.transform.maxZoom }, a5)).padding) {
                const t4 = a5.padding;
                a5.padding = { top: t4, bottom: t4, right: t4, left: t4 };
              }
              a5.padding = t3.extend(o5, a5.padding);
              const r5 = this.transform, n3 = r5.padding, l5 = r5.project(t3.LngLat.convert(e4)), c5 = r5.project(t3.LngLat.convert(i5)), h4 = l5.rotate(-s5 * Math.PI / 180), u5 = c5.rotate(-s5 * Math.PI / 180), d4 = new t3.Point(Math.max(h4.x, u5.x), Math.max(h4.y, u5.y)), _4 = new t3.Point(Math.min(h4.x, u5.x), Math.min(h4.y, u5.y)), m4 = d4.sub(_4), p7 = (r5.width - (n3.left + n3.right + a5.padding.left + a5.padding.right)) / m4.x, f4 = (r5.height - (n3.top + n3.bottom + a5.padding.top + a5.padding.bottom)) / m4.y;
              if (f4 < 0 || p7 < 0)
                return void t3.warnOnce("Map cannot fit within canvas with the given bounds, padding, and/or offset.");
              const g4 = Math.min(r5.scaleZoom(r5.scale * Math.min(p7, f4)), a5.maxZoom), v5 = t3.Point.convert(a5.offset), x3 = new t3.Point((a5.padding.left - a5.padding.right) / 2, (a5.padding.top - a5.padding.bottom) / 2).rotate(s5 * Math.PI / 180), y3 = v5.add(x3).mult(r5.scale / r5.zoomScale(g4));
              return { center: r5.unproject(l5.add(c5).div(2).sub(y3)), zoom: g4, bearing: s5 };
            }
            fitBounds(t4, e4, i5) {
              return this._fitInternal(this.cameraForBounds(t4, e4), e4, i5);
            }
            fitScreenCoordinates(e4, i5, s5, a5, o5) {
              return this._fitInternal(this._cameraForBoxAndBearing(this.transform.pointLocation(t3.Point.convert(e4)), this.transform.pointLocation(t3.Point.convert(i5)), s5, a5), a5, o5);
            }
            _fitInternal(e4, i5, s5) {
              return e4 ? (delete (i5 = t3.extend(e4, i5)).padding, i5.linear ? this.easeTo(i5, s5) : this.flyTo(i5, s5)) : this;
            }
            jumpTo(e4, i5) {
              this.stop();
              const s5 = this._getTransformForUpdate();
              let a5 = false, o5 = false, r5 = false;
              return "zoom" in e4 && s5.zoom !== +e4.zoom && (a5 = true, s5.zoom = +e4.zoom), void 0 !== e4.center && (s5.center = t3.LngLat.convert(e4.center)), "bearing" in e4 && s5.bearing !== +e4.bearing && (o5 = true, s5.bearing = +e4.bearing), "pitch" in e4 && s5.pitch !== +e4.pitch && (r5 = true, s5.pitch = +e4.pitch), null == e4.padding || s5.isPaddingEqual(e4.padding) || (s5.padding = e4.padding), this._applyUpdatedTransform(s5), this.fire(new t3.Event("movestart", i5)).fire(new t3.Event("move", i5)), a5 && this.fire(new t3.Event("zoomstart", i5)).fire(new t3.Event("zoom", i5)).fire(new t3.Event("zoomend", i5)), o5 && this.fire(new t3.Event("rotatestart", i5)).fire(new t3.Event("rotate", i5)).fire(new t3.Event("rotateend", i5)), r5 && this.fire(new t3.Event("pitchstart", i5)).fire(new t3.Event("pitch", i5)).fire(new t3.Event("pitchend", i5)), this.fire(new t3.Event("moveend", i5));
            }
            calculateCameraOptionsFromTo(e4, i5, s5, a5 = 0) {
              const o5 = t3.MercatorCoordinate.fromLngLat(e4, i5), r5 = t3.MercatorCoordinate.fromLngLat(s5, a5), n3 = r5.x - o5.x, l5 = r5.y - o5.y, c5 = r5.z - o5.z, h4 = Math.hypot(n3, l5, c5);
              if (0 === h4)
                throw new Error("Can't calculate camera options with same From and To");
              const u5 = Math.hypot(n3, l5), d4 = this.transform.scaleZoom(this.transform.cameraToCenterDistance / h4 / this.transform.tileSize), _4 = 180 * Math.atan2(n3, -l5) / Math.PI;
              let m4 = 180 * Math.acos(u5 / h4) / Math.PI;
              return m4 = c5 < 0 ? 90 - m4 : 90 + m4, { center: r5.toLngLat(), zoom: d4, pitch: m4, bearing: _4 };
            }
            easeTo(e4, i5) {
              this._stop(false, e4.easeId), (false === (e4 = t3.extend({ offset: [0, 0], duration: 500, easing: t3.defaultEasing }, e4)).animate || !e4.essential && t3.browser.prefersReducedMotion) && (e4.duration = 0);
              const s5 = this._getTransformForUpdate(), a5 = this.getZoom(), o5 = this.getBearing(), r5 = this.getPitch(), n3 = this.getPadding(), l5 = "zoom" in e4 ? +e4.zoom : a5, c5 = "bearing" in e4 ? this._normalizeBearing(e4.bearing, o5) : o5, h4 = "pitch" in e4 ? +e4.pitch : r5, u5 = "padding" in e4 ? e4.padding : s5.padding, d4 = t3.Point.convert(e4.offset);
              let _4 = s5.centerPoint.add(d4);
              const m4 = s5.pointLocation(_4), p7 = t3.LngLat.convert(e4.center || m4);
              this._normalizeCenter(p7);
              const f4 = s5.project(m4), g4 = s5.project(p7).sub(f4), v5 = s5.zoomScale(l5 - a5);
              let x3, y3;
              e4.around && (x3 = t3.LngLat.convert(e4.around), y3 = s5.locationPoint(x3));
              const b4 = { moving: this._moving, zooming: this._zooming, rotating: this._rotating, pitching: this._pitching };
              return this._zooming = this._zooming || l5 !== a5, this._rotating = this._rotating || o5 !== c5, this._pitching = this._pitching || h4 !== r5, this._padding = !s5.isPaddingEqual(u5), this._easeId = e4.easeId, this._prepareEase(i5, e4.noMoveStart, b4), this.terrain && this._prepareElevation(p7), this._ease((m5) => {
                if (this._zooming && (s5.zoom = t3.interpolate.number(a5, l5, m5)), this._rotating && (s5.bearing = t3.interpolate.number(o5, c5, m5)), this._pitching && (s5.pitch = t3.interpolate.number(r5, h4, m5)), this._padding && (s5.interpolatePadding(n3, u5, m5), _4 = s5.centerPoint.add(d4)), this.terrain && !e4.freezeElevation && this._updateElevation(m5), x3)
                  s5.setLocationAtPoint(x3, y3);
                else {
                  const t4 = s5.zoomScale(s5.zoom - a5), e5 = l5 > a5 ? Math.min(2, v5) : Math.max(0.5, v5), i6 = Math.pow(e5, 1 - m5), o6 = s5.unproject(f4.add(g4.mult(m5 * i6)).mult(t4));
                  s5.setLocationAtPoint(s5.renderWorldCopies ? o6.wrap() : o6, _4);
                }
                this._applyUpdatedTransform(s5), this._fireMoveEvents(i5);
              }, (t4) => {
                this.terrain && this._finalizeElevation(), this._afterEase(i5, t4);
              }, e4), this;
            }
            _prepareEase(e4, i5, s5 = {}) {
              this._moving = true, i5 || s5.moving || this.fire(new t3.Event("movestart", e4)), this._zooming && !s5.zooming && this.fire(new t3.Event("zoomstart", e4)), this._rotating && !s5.rotating && this.fire(new t3.Event("rotatestart", e4)), this._pitching && !s5.pitching && this.fire(new t3.Event("pitchstart", e4));
            }
            _prepareElevation(t4) {
              this._elevationCenter = t4, this._elevationStart = this.transform.elevation, this._elevationTarget = this.terrain.getElevationForLngLatZoom(t4, this.transform.tileZoom), this._elevationFreeze = true;
            }
            _updateElevation(e4) {
              this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
              const i5 = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
              if (e4 < 1 && i5 !== this._elevationTarget) {
                const t4 = this._elevationTarget - this._elevationStart;
                this._elevationStart += e4 * (t4 - (i5 - (t4 * e4 + this._elevationStart)) / (1 - e4)), this._elevationTarget = i5;
              }
              this.transform.elevation = t3.interpolate.number(this._elevationStart, this._elevationTarget, e4);
            }
            _finalizeElevation() {
              this._elevationFreeze = false, this.transform.recalculateZoom(this.terrain);
            }
            _getTransformForUpdate() {
              return this.transformCameraUpdate ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()), this._requestedCameraState) : this.transform;
            }
            _applyUpdatedTransform(t4) {
              if (!this.transformCameraUpdate)
                return;
              const e4 = t4.clone(), { center: i5, zoom: s5, pitch: a5, bearing: o5, elevation: r5 } = this.transformCameraUpdate(e4);
              i5 && (e4.center = i5), void 0 !== s5 && (e4.zoom = s5), void 0 !== a5 && (e4.pitch = a5), void 0 !== o5 && (e4.bearing = o5), void 0 !== r5 && (e4.elevation = r5), this.transform.apply(e4);
            }
            _fireMoveEvents(e4) {
              this.fire(new t3.Event("move", e4)), this._zooming && this.fire(new t3.Event("zoom", e4)), this._rotating && this.fire(new t3.Event("rotate", e4)), this._pitching && this.fire(new t3.Event("pitch", e4));
            }
            _afterEase(e4, i5) {
              if (this._easeId && i5 && this._easeId === i5)
                return;
              delete this._easeId;
              const s5 = this._zooming, a5 = this._rotating, o5 = this._pitching;
              this._moving = false, this._zooming = false, this._rotating = false, this._pitching = false, this._padding = false, s5 && this.fire(new t3.Event("zoomend", e4)), a5 && this.fire(new t3.Event("rotateend", e4)), o5 && this.fire(new t3.Event("pitchend", e4)), this.fire(new t3.Event("moveend", e4));
            }
            flyTo(e4, i5) {
              if (!e4.essential && t3.browser.prefersReducedMotion) {
                const s6 = t3.pick(e4, ["center", "zoom", "bearing", "pitch", "around"]);
                return this.jumpTo(s6, i5);
              }
              this.stop(), e4 = t3.extend({ offset: [0, 0], speed: 1.2, curve: 1.42, easing: t3.defaultEasing }, e4);
              const s5 = this._getTransformForUpdate(), a5 = this.getZoom(), o5 = this.getBearing(), r5 = this.getPitch(), n3 = this.getPadding(), l5 = "zoom" in e4 ? t3.clamp(+e4.zoom, s5.minZoom, s5.maxZoom) : a5, c5 = "bearing" in e4 ? this._normalizeBearing(e4.bearing, o5) : o5, h4 = "pitch" in e4 ? +e4.pitch : r5, u5 = "padding" in e4 ? e4.padding : s5.padding, d4 = s5.zoomScale(l5 - a5), _4 = t3.Point.convert(e4.offset);
              let m4 = s5.centerPoint.add(_4);
              const p7 = s5.pointLocation(m4), f4 = t3.LngLat.convert(e4.center || p7);
              this._normalizeCenter(f4);
              const g4 = s5.project(p7), v5 = s5.project(f4).sub(g4);
              let x3 = e4.curve;
              const y3 = Math.max(s5.width, s5.height), b4 = y3 / d4, w4 = v5.mag();
              if ("minZoom" in e4) {
                const i6 = t3.clamp(Math.min(e4.minZoom, a5, l5), s5.minZoom, s5.maxZoom), o6 = y3 / s5.zoomScale(i6 - a5);
                x3 = Math.sqrt(o6 / w4 * 2);
              }
              const T3 = x3 * x3;
              function E3(t4) {
                const e5 = (b4 * b4 - y3 * y3 + (t4 ? -1 : 1) * T3 * T3 * w4 * w4) / (2 * (t4 ? b4 : y3) * T3 * w4);
                return Math.log(Math.sqrt(e5 * e5 + 1) - e5);
              }
              function I3(t4) {
                return (Math.exp(t4) - Math.exp(-t4)) / 2;
              }
              function S3(t4) {
                return (Math.exp(t4) + Math.exp(-t4)) / 2;
              }
              const C2 = E3(false);
              let P3 = function(t4) {
                return S3(C2) / S3(C2 + x3 * t4);
              }, D3 = function(t4) {
                return y3 * ((S3(C2) * (I3(e5 = C2 + x3 * t4) / S3(e5)) - I3(C2)) / T3) / w4;
                var e5;
              }, M3 = (E3(true) - C2) / x3;
              if (Math.abs(w4) < 1e-6 || !isFinite(M3)) {
                if (Math.abs(y3 - b4) < 1e-6)
                  return this.easeTo(e4, i5);
                const t4 = b4 < y3 ? -1 : 1;
                M3 = Math.abs(Math.log(b4 / y3)) / x3, D3 = function() {
                  return 0;
                }, P3 = function(e5) {
                  return Math.exp(t4 * x3 * e5);
                };
              }
              return e4.duration = "duration" in e4 ? +e4.duration : 1e3 * M3 / ("screenSpeed" in e4 ? +e4.screenSpeed / x3 : +e4.speed), e4.maxDuration && e4.duration > e4.maxDuration && (e4.duration = 0), this._zooming = true, this._rotating = o5 !== c5, this._pitching = h4 !== r5, this._padding = !s5.isPaddingEqual(u5), this._prepareEase(i5, false), this.terrain && this._prepareElevation(f4), this._ease((d5) => {
                const p8 = d5 * M3, x4 = 1 / P3(p8);
                s5.zoom = 1 === d5 ? l5 : a5 + s5.scaleZoom(x4), this._rotating && (s5.bearing = t3.interpolate.number(o5, c5, d5)), this._pitching && (s5.pitch = t3.interpolate.number(r5, h4, d5)), this._padding && (s5.interpolatePadding(n3, u5, d5), m4 = s5.centerPoint.add(_4)), this.terrain && !e4.freezeElevation && this._updateElevation(d5);
                const y4 = 1 === d5 ? f4 : s5.unproject(g4.add(v5.mult(D3(p8))).mult(x4));
                s5.setLocationAtPoint(s5.renderWorldCopies ? y4.wrap() : y4, m4), this._applyUpdatedTransform(s5), this._fireMoveEvents(i5);
              }, () => {
                this.terrain && this._finalizeElevation(), this._afterEase(i5);
              }, e4), this;
            }
            isEasing() {
              return !!this._easeFrameId;
            }
            stop() {
              return this._stop();
            }
            _stop(t4, e4) {
              if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId), delete this._easeFrameId, delete this._onEaseFrame), this._onEaseEnd) {
                const t5 = this._onEaseEnd;
                delete this._onEaseEnd, t5.call(this, e4);
              }
              if (!t4) {
                const t5 = this.handlers;
                t5 && t5.stop(false);
              }
              return this;
            }
            _ease(e4, i5, s5) {
              false === s5.animate || 0 === s5.duration ? (e4(1), i5()) : (this._easeStart = t3.browser.now(), this._easeOptions = s5, this._onEaseFrame = e4, this._onEaseEnd = i5, this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback));
            }
            _normalizeBearing(e4, i5) {
              e4 = t3.wrap(e4, -180, 180);
              const s5 = Math.abs(e4 - i5);
              return Math.abs(e4 - 360 - i5) < s5 && (e4 -= 360), Math.abs(e4 + 360 - i5) < s5 && (e4 += 360), e4;
            }
            _normalizeCenter(t4) {
              const e4 = this.transform;
              if (!e4.renderWorldCopies || e4.lngRange)
                return;
              const i5 = t4.lng - e4.center.lng;
              t4.lng += i5 > 180 ? -360 : i5 < -180 ? 360 : 0;
            }
            queryTerrainElevation(e4) {
              return this.terrain ? this.terrain.getElevationForLngLatZoom(t3.LngLat.convert(e4), this.transform.tileZoom) - this.transform.elevation : null;
            }
          }
          class ra {
            constructor(t4 = {}) {
              this._toggleAttribution = () => {
                this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""), this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"), this._container.removeAttribute("open")));
              }, this._updateData = (t5) => {
                !t5 || "metadata" !== t5.sourceDataType && "visibility" !== t5.sourceDataType && "style" !== t5.dataType && "terrain" !== t5.type || this._updateAttributions();
              }, this._updateCompact = () => {
                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false === this._compact ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""), this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""), this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"));
              }, this._updateCompactMinimize = () => {
                this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show");
              }, this.options = t4;
            }
            getDefaultPosition() {
              return "bottom-right";
            }
            onAdd(t4) {
              return this._map = t4, this._compact = this.options && this.options.compact, this._container = i4.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"), this._compactButton = i4.create("summary", "maplibregl-ctrl-attrib-button", this._container), this._compactButton.addEventListener("click", this._toggleAttribution), this._setElementTitle(this._compactButton, "ToggleAttribution"), this._innerContainer = i4.create("div", "maplibregl-ctrl-attrib-inner", this._container), this._updateAttributions(), this._updateCompact(), this._map.on("styledata", this._updateData), this._map.on("sourcedata", this._updateData), this._map.on("terrain", this._updateData), this._map.on("resize", this._updateCompact), this._map.on("drag", this._updateCompactMinimize), this._container;
            }
            onRemove() {
              i4.remove(this._container), this._map.off("styledata", this._updateData), this._map.off("sourcedata", this._updateData), this._map.off("terrain", this._updateData), this._map.off("resize", this._updateCompact), this._map.off("drag", this._updateCompactMinimize), this._map = void 0, this._compact = void 0, this._attribHTML = void 0;
            }
            _setElementTitle(t4, e4) {
              const i5 = this._map._getUIString(`AttributionControl.${e4}`);
              t4.title = i5, t4.setAttribute("aria-label", i5);
            }
            _updateAttributions() {
              if (!this._map.style)
                return;
              let t4 = [];
              if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? t4 = t4.concat(this.options.customAttribution.map((t5) => "string" != typeof t5 ? "" : t5)) : "string" == typeof this.options.customAttribution && t4.push(this.options.customAttribution)), this._map.style.stylesheet) {
                const t5 = this._map.style.stylesheet;
                this.styleOwner = t5.owner, this.styleId = t5.id;
              }
              const e4 = this._map.style.sourceCaches;
              for (const i6 in e4) {
                const s5 = e4[i6];
                if (s5.used || s5.usedForTerrain) {
                  const e5 = s5.getSource();
                  e5.attribution && t4.indexOf(e5.attribution) < 0 && t4.push(e5.attribution);
                }
              }
              t4 = t4.filter((t5) => String(t5).trim()), t4.sort((t5, e5) => t5.length - e5.length), t4 = t4.filter((e5, i6) => {
                for (let s5 = i6 + 1; s5 < t4.length; s5++)
                  if (t4[s5].indexOf(e5) >= 0)
                    return false;
                return true;
              });
              const i5 = t4.join(" | ");
              i5 !== this._attribHTML && (this._attribHTML = i5, t4.length ? (this._innerContainer.innerHTML = i5, this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"), this._updateCompact(), this._editLink = null);
            }
          }
          class na {
            constructor(t4 = {}) {
              this._updateCompact = () => {
                const t5 = this._container.children;
                if (t5.length) {
                  const e4 = t5[0];
                  this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? false !== this._compact && e4.classList.add("maplibregl-compact") : e4.classList.remove("maplibregl-compact");
                }
              }, this.options = t4;
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t4) {
              this._map = t4, this._compact = this.options && this.options.compact, this._container = i4.create("div", "maplibregl-ctrl");
              const e4 = i4.create("a", "maplibregl-ctrl-logo");
              return e4.target = "_blank", e4.rel = "noopener nofollow", e4.href = "https://maplibre.org/", e4.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")), e4.setAttribute("rel", "noopener nofollow"), this._container.appendChild(e4), this._container.style.display = "block", this._map.on("resize", this._updateCompact), this._updateCompact(), this._container;
            }
            onRemove() {
              i4.remove(this._container), this._map.off("resize", this._updateCompact), this._map = void 0, this._compact = void 0;
            }
          }
          class la {
            constructor() {
              this._queue = [], this._id = 0, this._cleared = false, this._currentlyRunning = false;
            }
            add(t4) {
              const e4 = ++this._id;
              return this._queue.push({ callback: t4, id: e4, cancelled: false }), e4;
            }
            remove(t4) {
              const e4 = this._currentlyRunning, i5 = e4 ? this._queue.concat(e4) : this._queue;
              for (const e5 of i5)
                if (e5.id === t4)
                  return void (e5.cancelled = true);
            }
            run(t4 = 0) {
              if (this._currentlyRunning)
                throw new Error("Attempting to run(), but is already running.");
              const e4 = this._currentlyRunning = this._queue;
              this._queue = [];
              for (const i5 of e4)
                if (!i5.cancelled && (i5.callback(t4), this._cleared))
                  break;
              this._cleared = false, this._currentlyRunning = false;
            }
            clear() {
              this._currentlyRunning && (this._cleared = true), this._queue = [];
            }
          }
          const ca = { "AttributionControl.ToggleAttribution": "Toggle attribution", "AttributionControl.MapFeedback": "Map feedback", "FullscreenControl.Enter": "Enter fullscreen", "FullscreenControl.Exit": "Exit fullscreen", "GeolocateControl.FindMyLocation": "Find my location", "GeolocateControl.LocationNotAvailable": "Location not available", "LogoControl.Title": "Mapbox logo", "NavigationControl.ResetBearing": "Reset bearing to north", "NavigationControl.ZoomIn": "Zoom in", "NavigationControl.ZoomOut": "Zoom out", "ScaleControl.Feet": "ft", "ScaleControl.Meters": "m", "ScaleControl.Kilometers": "km", "ScaleControl.Miles": "mi", "ScaleControl.NauticalMiles": "nm", "TerrainControl.enableTerrain": "Enable terrain", "TerrainControl.disableTerrain": "Disable terrain" };
          var ha = t3.createLayout([{ name: "a_pos3d", type: "Int16", components: 3 }]);
          class ua2 extends t3.Evented {
            constructor(t4) {
              super(), this.sourceCache = t4, this._tiles = {}, this._renderableTilesKeys = [], this._sourceTileCache = {}, this.minzoom = 0, this.maxzoom = 22, this.tileSize = 512, this.deltaZoom = 1, t4.usedForTerrain = true, t4.tileSize = this.tileSize * 2 ** this.deltaZoom;
            }
            destruct() {
              this.sourceCache.usedForTerrain = false, this.sourceCache.tileSize = null;
            }
            update(e4, i5) {
              this.sourceCache.update(e4, i5), this._renderableTilesKeys = [];
              const s5 = {};
              for (const a5 of e4.coveringTiles({ tileSize: this.tileSize, minzoom: this.minzoom, maxzoom: this.maxzoom, reparseOverscaled: false, terrain: i5 }))
                s5[a5.key] = true, this._renderableTilesKeys.push(a5.key), this._tiles[a5.key] || (a5.posMatrix = new Float64Array(16), t3.ortho(a5.posMatrix, 0, t3.EXTENT, 0, t3.EXTENT, 0, 1), this._tiles[a5.key] = new X(a5, this.tileSize));
              for (const t4 in this._tiles)
                s5[t4] || delete this._tiles[t4];
            }
            freeRtt(t4) {
              for (const e4 in this._tiles) {
                const i5 = this._tiles[e4];
                (!t4 || i5.tileID.equals(t4) || i5.tileID.isChildOf(t4) || t4.isChildOf(i5.tileID)) && (i5.rtt = []);
              }
            }
            getRenderableTiles() {
              return this._renderableTilesKeys.map((t4) => this.getTileByID(t4));
            }
            getTileByID(t4) {
              return this._tiles[t4];
            }
            getTerrainCoords(e4) {
              const i5 = {};
              for (const s5 of this._renderableTilesKeys) {
                const a5 = this._tiles[s5].tileID;
                if (a5.canonical.equals(e4.canonical)) {
                  const a6 = e4.clone();
                  a6.posMatrix = new Float64Array(16), t3.ortho(a6.posMatrix, 0, t3.EXTENT, 0, t3.EXTENT, 0, 1), i5[s5] = a6;
                } else if (a5.canonical.isChildOf(e4.canonical)) {
                  const o5 = e4.clone();
                  o5.posMatrix = new Float64Array(16);
                  const r5 = a5.canonical.z - e4.canonical.z, n3 = a5.canonical.x - (a5.canonical.x >> r5 << r5), l5 = a5.canonical.y - (a5.canonical.y >> r5 << r5), c5 = t3.EXTENT >> r5;
                  t3.ortho(o5.posMatrix, 0, c5, 0, c5, 0, 1), t3.translate(o5.posMatrix, o5.posMatrix, [-n3 * c5, -l5 * c5, 0]), i5[s5] = o5;
                } else if (e4.canonical.isChildOf(a5.canonical)) {
                  const o5 = e4.clone();
                  o5.posMatrix = new Float64Array(16);
                  const r5 = e4.canonical.z - a5.canonical.z, n3 = e4.canonical.x - (e4.canonical.x >> r5 << r5), l5 = e4.canonical.y - (e4.canonical.y >> r5 << r5), c5 = t3.EXTENT >> r5;
                  t3.ortho(o5.posMatrix, 0, t3.EXTENT, 0, t3.EXTENT, 0, 1), t3.translate(o5.posMatrix, o5.posMatrix, [n3 * c5, l5 * c5, 0]), t3.scale(o5.posMatrix, o5.posMatrix, [1 / 2 ** r5, 1 / 2 ** r5, 0]), i5[s5] = o5;
                }
              }
              return i5;
            }
            getSourceTile(t4, e4) {
              const i5 = this.sourceCache._source;
              let s5 = t4.overscaledZ - this.deltaZoom;
              if (s5 > i5.maxzoom && (s5 = i5.maxzoom), s5 < i5.minzoom)
                return null;
              this._sourceTileCache[t4.key] || (this._sourceTileCache[t4.key] = t4.scaledTo(s5).key);
              let a5 = this.sourceCache.getTileByID(this._sourceTileCache[t4.key]);
              if ((!a5 || !a5.dem) && e4)
                for (; s5 >= i5.minzoom && (!a5 || !a5.dem); )
                  a5 = this.sourceCache.getTileByID(t4.scaledTo(s5--).key);
              return a5;
            }
            tilesAfterTime(t4 = Date.now()) {
              return Object.values(this._tiles).filter((e4) => e4.timeAdded >= t4);
            }
          }
          class da {
            constructor(t4, e4, i5) {
              this.painter = t4, this.sourceCache = new ua2(e4), this.options = i5, this.exaggeration = "number" == typeof i5.exaggeration ? i5.exaggeration : 1, this.qualityFactor = 2, this.meshSize = 128, this._demMatrixCache = {}, this.coordsIndex = [], this._coordsTextureSize = 1024;
            }
            getDEMElevation(e4, i5, s5, a5 = t3.EXTENT) {
              var o5;
              if (!(i5 >= 0 && i5 < a5 && s5 >= 0 && s5 < a5))
                return 0;
              const r5 = this.getTerrainData(e4), n3 = null === (o5 = r5.tile) || void 0 === o5 ? void 0 : o5.dem;
              if (!n3)
                return 0;
              const l5 = function(t4, e5, i6) {
                var s6 = e5[0], a6 = e5[1];
                return t4[0] = i6[0] * s6 + i6[4] * a6 + i6[12], t4[1] = i6[1] * s6 + i6[5] * a6 + i6[13], t4;
              }([], [i5 / a5 * t3.EXTENT, s5 / a5 * t3.EXTENT], r5.u_terrain_matrix), c5 = [l5[0] * n3.dim, l5[1] * n3.dim], h4 = Math.floor(c5[0]), u5 = Math.floor(c5[1]), d4 = c5[0] - h4, _4 = c5[1] - u5;
              return n3.get(h4, u5) * (1 - d4) * (1 - _4) + n3.get(h4 + 1, u5) * d4 * (1 - _4) + n3.get(h4, u5 + 1) * (1 - d4) * _4 + n3.get(h4 + 1, u5 + 1) * d4 * _4;
            }
            getElevationForLngLatZoom(e4, i5) {
              const { tileID: s5, mercatorX: a5, mercatorY: o5 } = this._getOverscaledTileIDFromLngLatZoom(e4, i5);
              return this.getElevation(s5, a5 % t3.EXTENT, o5 % t3.EXTENT, t3.EXTENT);
            }
            getElevation(e4, i5, s5, a5 = t3.EXTENT) {
              return this.getDEMElevation(e4, i5, s5, a5) * this.exaggeration;
            }
            getTerrainData(e4) {
              if (!this._emptyDemTexture) {
                const e5 = this.painter.context, i6 = new t3.RGBAImage({ width: 1, height: 1 }, new Uint8Array(4));
                this._emptyDepthTexture = new x2(e5, i6, e5.gl.RGBA, { premultiply: false }), this._emptyDemUnpack = [0, 0, 0, 0], this._emptyDemTexture = new x2(e5, new t3.RGBAImage({ width: 1, height: 1 }), e5.gl.RGBA, { premultiply: false }), this._emptyDemTexture.bind(e5.gl.NEAREST, e5.gl.CLAMP_TO_EDGE), this._emptyDemMatrix = t3.identity([]);
              }
              const i5 = this.sourceCache.getSourceTile(e4, true);
              if (i5 && i5.dem && (!i5.demTexture || i5.needsTerrainPrepare)) {
                const t4 = this.painter.context;
                i5.demTexture = this.painter.getTileTexture(i5.dem.stride), i5.demTexture ? i5.demTexture.update(i5.dem.getPixels(), { premultiply: false }) : i5.demTexture = new x2(t4, i5.dem.getPixels(), t4.gl.RGBA, { premultiply: false }), i5.demTexture.bind(t4.gl.NEAREST, t4.gl.CLAMP_TO_EDGE), i5.needsTerrainPrepare = false;
              }
              const s5 = i5 && i5 + i5.tileID.key + e4.key;
              if (s5 && !this._demMatrixCache[s5]) {
                const s6 = this.sourceCache.sourceCache._source.maxzoom;
                let a5 = e4.canonical.z - i5.tileID.canonical.z;
                e4.overscaledZ > e4.canonical.z && (e4.canonical.z >= s6 ? a5 = e4.canonical.z - s6 : t3.warnOnce("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                const o5 = e4.canonical.x - (e4.canonical.x >> a5 << a5), r5 = e4.canonical.y - (e4.canonical.y >> a5 << a5), n3 = t3.fromScaling(new Float64Array(16), [1 / (t3.EXTENT << a5), 1 / (t3.EXTENT << a5), 0]);
                t3.translate(n3, n3, [o5 * t3.EXTENT, r5 * t3.EXTENT, 0]), this._demMatrixCache[e4.key] = { matrix: n3, coord: e4 };
              }
              return { u_depth: 2, u_terrain: 3, u_terrain_dim: i5 && i5.dem && i5.dem.dim || 1, u_terrain_matrix: s5 ? this._demMatrixCache[e4.key].matrix : this._emptyDemMatrix, u_terrain_unpack: i5 && i5.dem && i5.dem.getUnpackVector() || this._emptyDemUnpack, u_terrain_exaggeration: this.exaggeration, texture: (i5 && i5.demTexture || this._emptyDemTexture).texture, depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture, tile: i5 };
            }
            getFramebuffer(t4) {
              const e4 = this.painter, i5 = e4.width / devicePixelRatio, s5 = e4.height / devicePixelRatio;
              return !this._fbo || this._fbo.width === i5 && this._fbo.height === s5 || (this._fbo.destroy(), this._fboCoordsTexture.destroy(), this._fboDepthTexture.destroy(), delete this._fbo, delete this._fboDepthTexture, delete this._fboCoordsTexture), this._fboCoordsTexture || (this._fboCoordsTexture = new x2(e4.context, { width: i5, height: s5, data: null }, e4.context.gl.RGBA, { premultiply: false }), this._fboCoordsTexture.bind(e4.context.gl.NEAREST, e4.context.gl.CLAMP_TO_EDGE)), this._fboDepthTexture || (this._fboDepthTexture = new x2(e4.context, { width: i5, height: s5, data: null }, e4.context.gl.RGBA, { premultiply: false }), this._fboDepthTexture.bind(e4.context.gl.NEAREST, e4.context.gl.CLAMP_TO_EDGE)), this._fbo || (this._fbo = e4.context.createFramebuffer(i5, s5, true, false), this._fbo.depthAttachment.set(e4.context.createRenderbuffer(e4.context.gl.DEPTH_COMPONENT16, i5, s5))), this._fbo.colorAttachment.set("coords" === t4 ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture), this._fbo;
            }
            getCoordsTexture() {
              const e4 = this.painter.context;
              if (this._coordsTexture)
                return this._coordsTexture;
              const i5 = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
              for (let t4 = 0, e5 = 0; t4 < this._coordsTextureSize; t4++)
                for (let s6 = 0; s6 < this._coordsTextureSize; s6++, e5 += 4)
                  i5[e5 + 0] = 255 & s6, i5[e5 + 1] = 255 & t4, i5[e5 + 2] = s6 >> 8 << 4 | t4 >> 8, i5[e5 + 3] = 0;
              const s5 = new t3.RGBAImage({ width: this._coordsTextureSize, height: this._coordsTextureSize }, new Uint8Array(i5.buffer)), a5 = new x2(e4, s5, e4.gl.RGBA, { premultiply: false });
              return a5.bind(e4.gl.NEAREST, e4.gl.CLAMP_TO_EDGE), this._coordsTexture = a5, a5;
            }
            pointCoordinate(e4) {
              const i5 = new Uint8Array(4), s5 = this.painter.context, a5 = s5.gl;
              s5.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer), a5.readPixels(e4.x, this.painter.height / devicePixelRatio - e4.y - 1, 1, 1, a5.RGBA, a5.UNSIGNED_BYTE, i5), s5.bindFramebuffer.set(null);
              const o5 = i5[0] + (i5[2] >> 4 << 8), r5 = i5[1] + ((15 & i5[2]) << 8), n3 = this.coordsIndex[255 - i5[3]], l5 = n3 && this.sourceCache.getTileByID(n3);
              if (!l5)
                return null;
              const c5 = this._coordsTextureSize, h4 = (1 << l5.tileID.canonical.z) * c5;
              return new t3.MercatorCoordinate((l5.tileID.canonical.x * c5 + o5) / h4, (l5.tileID.canonical.y * c5 + r5) / h4, this.getElevation(l5.tileID, o5, r5, c5));
            }
            getTerrainMesh() {
              if (this._mesh)
                return this._mesh;
              const e4 = this.painter.context, i5 = new t3.Pos3dArray(), s5 = new t3.TriangleIndexArray(), a5 = this.meshSize, o5 = t3.EXTENT / a5, r5 = a5 * a5;
              for (let t4 = 0; t4 <= a5; t4++)
                for (let e5 = 0; e5 <= a5; e5++)
                  i5.emplaceBack(e5 * o5, t4 * o5, 0);
              for (let t4 = 0; t4 < r5; t4 += a5 + 1)
                for (let e5 = 0; e5 < a5; e5++)
                  s5.emplaceBack(e5 + t4, a5 + e5 + t4 + 1, a5 + e5 + t4 + 2), s5.emplaceBack(e5 + t4, a5 + e5 + t4 + 2, e5 + t4 + 1);
              const n3 = i5.length, l5 = n3 + 2 * (a5 + 1);
              for (const e5 of [0, 1])
                for (let s6 = 0; s6 <= a5; s6++)
                  for (const a6 of [0, 1])
                    i5.emplaceBack(s6 * o5, e5 * t3.EXTENT, a6);
              for (let t4 = 0; t4 < 2 * a5; t4 += 2)
                s5.emplaceBack(l5 + t4, l5 + t4 + 1, l5 + t4 + 3), s5.emplaceBack(l5 + t4, l5 + t4 + 3, l5 + t4 + 2), s5.emplaceBack(n3 + t4, n3 + t4 + 3, n3 + t4 + 1), s5.emplaceBack(n3 + t4, n3 + t4 + 2, n3 + t4 + 3);
              const c5 = i5.length, h4 = c5 + 2 * (a5 + 1);
              for (const e5 of [0, 1])
                for (let s6 = 0; s6 <= a5; s6++)
                  for (const a6 of [0, 1])
                    i5.emplaceBack(e5 * t3.EXTENT, s6 * o5, a6);
              for (let t4 = 0; t4 < 2 * a5; t4 += 2)
                s5.emplaceBack(c5 + t4, c5 + t4 + 1, c5 + t4 + 3), s5.emplaceBack(c5 + t4, c5 + t4 + 3, c5 + t4 + 2), s5.emplaceBack(h4 + t4, h4 + t4 + 3, h4 + t4 + 1), s5.emplaceBack(h4 + t4, h4 + t4 + 2, h4 + t4 + 3);
              return this._mesh = { indexBuffer: e4.createIndexBuffer(s5), vertexBuffer: e4.createVertexBuffer(i5, ha.members), segments: t3.SegmentVector.simpleSegment(0, 0, i5.length, s5.length) }, this._mesh;
            }
            getMeshFrameDelta(e4) {
              return 2 * Math.PI * t3.earthRadius / Math.pow(2, e4) / 5;
            }
            getMinTileElevationForLngLatZoom(t4, e4) {
              var i5;
              const { tileID: s5 } = this._getOverscaledTileIDFromLngLatZoom(t4, e4);
              return null !== (i5 = this.getMinMaxElevation(s5).minElevation) && void 0 !== i5 ? i5 : 0;
            }
            getMinMaxElevation(t4) {
              const e4 = this.getTerrainData(t4).tile, i5 = { minElevation: null, maxElevation: null };
              return e4 && e4.dem && (i5.minElevation = e4.dem.min * this.exaggeration, i5.maxElevation = e4.dem.max * this.exaggeration), i5;
            }
            _getOverscaledTileIDFromLngLatZoom(e4, i5) {
              const s5 = t3.MercatorCoordinate.fromLngLat(e4.wrap()), a5 = (1 << i5) * t3.EXTENT, o5 = s5.x * a5, r5 = s5.y * a5, n3 = Math.floor(o5 / t3.EXTENT), l5 = Math.floor(r5 / t3.EXTENT);
              return { tileID: new t3.OverscaledTileID(i5, 0, i5, n3, l5), mercatorX: o5, mercatorY: r5 };
            }
          }
          class _a {
            constructor(t4, e4, i5) {
              this._context = t4, this._size = e4, this._tileSize = i5, this._objects = [], this._recentlyUsed = [], this._stamp = 0;
            }
            destruct() {
              for (const t4 of this._objects)
                t4.texture.destroy(), t4.fbo.destroy();
            }
            _createObject(t4) {
              const e4 = this._context.createFramebuffer(this._tileSize, this._tileSize, true, true), i5 = new x2(this._context, { width: this._tileSize, height: this._tileSize, data: null }, this._context.gl.RGBA);
              return i5.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE), e4.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)), e4.colorAttachment.set(i5.texture), { id: t4, fbo: e4, texture: i5, stamp: -1, inUse: false };
            }
            getObjectForId(t4) {
              return this._objects[t4];
            }
            useObject(t4) {
              t4.inUse = true, this._recentlyUsed = this._recentlyUsed.filter((e4) => t4.id !== e4), this._recentlyUsed.push(t4.id);
            }
            stampObject(t4) {
              t4.stamp = ++this._stamp;
            }
            getOrCreateFreeObject() {
              for (const t5 of this._recentlyUsed)
                if (!this._objects[t5].inUse)
                  return this._objects[t5];
              if (this._objects.length >= this._size)
                throw new Error("No free RenderPool available, call freeAllObjects() required!");
              const t4 = this._createObject(this._objects.length);
              return this._objects.push(t4), t4;
            }
            freeObject(t4) {
              t4.inUse = false;
            }
            freeAllObjects() {
              for (const t4 of this._objects)
                this.freeObject(t4);
            }
            isFull() {
              return !(this._objects.length < this._size) && false === this._objects.some((t4) => !t4.inUse);
            }
          }
          const ma = { background: true, fill: true, line: true, raster: true, hillshade: true };
          class pa {
            constructor(t4, e4) {
              this.painter = t4, this.terrain = e4, this.pool = new _a(t4.context, 30, e4.sourceCache.tileSize * e4.qualityFactor);
            }
            destruct() {
              this.pool.destruct();
            }
            getTexture(t4) {
              return this.pool.getObjectForId(t4.rtt[this._stacks.length - 1].id).texture;
            }
            prepareForRender(t4, e4) {
              this._stacks = [], this._prevType = null, this._rttTiles = [], this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(), this._renderableLayerIds = t4._order.filter((i5) => !t4._layers[i5].isHidden(e4)), this._coordsDescendingInv = {};
              for (const e5 in t4.sourceCaches) {
                this._coordsDescendingInv[e5] = {};
                const i5 = t4.sourceCaches[e5].getVisibleCoordinates();
                for (const t5 of i5) {
                  const i6 = this.terrain.sourceCache.getTerrainCoords(t5);
                  for (const t6 in i6)
                    this._coordsDescendingInv[e5][t6] || (this._coordsDescendingInv[e5][t6] = []), this._coordsDescendingInv[e5][t6].push(i6[t6]);
                }
              }
              this._coordsDescendingInvStr = {};
              for (const e5 of t4._order) {
                const i5 = t4._layers[e5], s5 = i5.source;
                if (ma[i5.type] && !this._coordsDescendingInvStr[s5]) {
                  this._coordsDescendingInvStr[s5] = {};
                  for (const t5 in this._coordsDescendingInv[s5])
                    this._coordsDescendingInvStr[s5][t5] = this._coordsDescendingInv[s5][t5].map((t6) => t6.key).sort().join();
                }
              }
              for (const t5 of this._renderableTiles)
                for (const e5 in this._coordsDescendingInvStr) {
                  const i5 = this._coordsDescendingInvStr[e5][t5.tileID.key];
                  i5 && i5 !== t5.rttCoords[e5] && (t5.rtt = []);
                }
            }
            renderLayer(e4) {
              if (e4.isHidden(this.painter.transform.zoom))
                return false;
              const i5 = e4.type, s5 = this.painter, a5 = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e4.id;
              if (ma[i5] && (this._prevType && ma[this._prevType] || this._stacks.push([]), this._prevType = i5, this._stacks[this._stacks.length - 1].push(e4.id), !a5))
                return true;
              if (ma[this._prevType] || ma[i5] && a5) {
                this._prevType = i5;
                const e5 = this._stacks.length - 1, a6 = this._stacks[e5] || [];
                for (const i6 of this._renderableTiles) {
                  if (this.pool.isFull() && (es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects()), this._rttTiles.push(i6), i6.rtt[e5]) {
                    const t4 = this.pool.getObjectForId(i6.rtt[e5].id);
                    if (t4.stamp === i6.rtt[e5].stamp) {
                      this.pool.useObject(t4);
                      continue;
                    }
                  }
                  const o5 = this.pool.getOrCreateFreeObject();
                  this.pool.useObject(o5), this.pool.stampObject(o5), i6.rtt[e5] = { id: o5.id, stamp: o5.stamp }, s5.context.bindFramebuffer.set(o5.fbo.framebuffer), s5.context.clear({ color: t3.Color.transparent, stencil: 0 }), s5.currentStencilSource = void 0;
                  for (let t4 = 0; t4 < a6.length; t4++) {
                    const e6 = s5.style._layers[a6[t4]], r5 = e6.source ? this._coordsDescendingInv[e6.source][i6.tileID.key] : [i6.tileID];
                    s5.context.viewport.set([0, 0, o5.fbo.width, o5.fbo.height]), s5._renderTileClippingMasks(e6, r5), s5.renderLayer(s5, s5.style.sourceCaches[e6.source], e6, r5), e6.source && (i6.rttCoords[e6.source] = this._coordsDescendingInvStr[e6.source][i6.tileID.key]);
                  }
                }
                return es(this.painter, this.terrain, this._rttTiles), this._rttTiles = [], this.pool.freeAllObjects(), ma[i5];
              }
              return false;
            }
          }
          const fa = e3, ga = { center: [0, 0], zoom: 0, bearing: 0, pitch: 0, minZoom: -2, maxZoom: 22, minPitch: 0, maxPitch: 60, interactive: true, scrollZoom: true, boxZoom: true, dragRotate: true, dragPan: true, keyboard: true, doubleClickZoom: true, touchZoomRotate: true, touchPitch: true, cooperativeGestures: void 0, bearingSnap: 7, clickTolerance: 3, pitchWithRotate: true, hash: false, attributionControl: true, maplibreLogo: false, failIfMajorPerformanceCaveat: false, preserveDrawingBuffer: false, trackResize: true, renderWorldCopies: true, refreshExpiredTiles: true, maxTileCacheSize: null, maxTileCacheZoomLevels: t3.config.MAX_TILE_CACHE_ZOOM_LEVELS, localIdeographFontFamily: "sans-serif", transformRequest: null, transformCameraUpdate: null, fadeDuration: 300, crossSourceCollisions: true, validateStyle: true, maxCanvasSize: [4096, 4096] }, va = (t4) => {
            t4.touchstart = t4.dragStart, t4.touchmoveWindow = t4.dragMove, t4.touchend = t4.dragEnd;
          }, xa = { showCompass: true, showZoom: true, visualizePitch: false };
          class ya {
            constructor(e4, s5, a5 = false) {
              this.mousedown = (e5) => {
                this.startMouse(t3.extend({}, e5, { ctrlKey: true, preventDefault: () => e5.preventDefault() }), i4.mousePos(this.element, e5)), i4.addEventListener(window, "mousemove", this.mousemove), i4.addEventListener(window, "mouseup", this.mouseup);
              }, this.mousemove = (t4) => {
                this.moveMouse(t4, i4.mousePos(this.element, t4));
              }, this.mouseup = (t4) => {
                this.mouseRotate.dragEnd(t4), this.mousePitch && this.mousePitch.dragEnd(t4), this.offTemp();
              }, this.touchstart = (t4) => {
                1 !== t4.targetTouches.length ? this.reset() : (this._startPos = this._lastPos = i4.touchPos(this.element, t4.targetTouches)[0], this.startTouch(t4, this._startPos), i4.addEventListener(window, "touchmove", this.touchmove, { passive: false }), i4.addEventListener(window, "touchend", this.touchend));
              }, this.touchmove = (t4) => {
                1 !== t4.targetTouches.length ? this.reset() : (this._lastPos = i4.touchPos(this.element, t4.targetTouches)[0], this.moveTouch(t4, this._lastPos));
              }, this.touchend = (t4) => {
                0 === t4.targetTouches.length && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this.reset = () => {
                this.mouseRotate.reset(), this.mousePitch && this.mousePitch.reset(), this.touchRotate.reset(), this.touchPitch && this.touchPitch.reset(), delete this._startPos, delete this._lastPos, this.offTemp();
              }, this._clickTolerance = 10;
              const o5 = e4.dragRotate._mouseRotate.getClickTolerance(), r5 = e4.dragRotate._mousePitch.getClickTolerance();
              this.element = s5, this.mouseRotate = Ls({ clickTolerance: o5, enable: true }), this.touchRotate = (({ enable: t4, clickTolerance: e5, bearingDegreesPerPixelMoved: i5 = 0.8 }) => {
                const s6 = new zs();
                return new Ps({ clickTolerance: e5, move: (t5, e6) => ({ bearingDelta: (e6.x - t5.x) * i5 }), moveStateManager: s6, enable: t4, assignEvents: va });
              })({ clickTolerance: o5, enable: true }), this.map = e4, a5 && (this.mousePitch = Rs({ clickTolerance: r5, enable: true }), this.touchPitch = (({ enable: t4, clickTolerance: e5, pitchDegreesPerPixelMoved: i5 = -0.5 }) => {
                const s6 = new zs();
                return new Ps({ clickTolerance: e5, move: (t5, e6) => ({ pitchDelta: (e6.y - t5.y) * i5 }), moveStateManager: s6, enable: t4, assignEvents: va });
              })({ clickTolerance: r5, enable: true })), i4.addEventListener(s5, "mousedown", this.mousedown), i4.addEventListener(s5, "touchstart", this.touchstart, { passive: false }), i4.addEventListener(s5, "touchcancel", this.reset);
            }
            startMouse(t4, e4) {
              this.mouseRotate.dragStart(t4, e4), this.mousePitch && this.mousePitch.dragStart(t4, e4), i4.disableDrag();
            }
            startTouch(t4, e4) {
              this.touchRotate.dragStart(t4, e4), this.touchPitch && this.touchPitch.dragStart(t4, e4), i4.disableDrag();
            }
            moveMouse(t4, e4) {
              const i5 = this.map, { bearingDelta: s5 } = this.mouseRotate.dragMove(t4, e4) || {};
              if (s5 && i5.setBearing(i5.getBearing() + s5), this.mousePitch) {
                const { pitchDelta: s6 } = this.mousePitch.dragMove(t4, e4) || {};
                s6 && i5.setPitch(i5.getPitch() + s6);
              }
            }
            moveTouch(t4, e4) {
              const i5 = this.map, { bearingDelta: s5 } = this.touchRotate.dragMove(t4, e4) || {};
              if (s5 && i5.setBearing(i5.getBearing() + s5), this.touchPitch) {
                const { pitchDelta: s6 } = this.touchPitch.dragMove(t4, e4) || {};
                s6 && i5.setPitch(i5.getPitch() + s6);
              }
            }
            off() {
              const t4 = this.element;
              i4.removeEventListener(t4, "mousedown", this.mousedown), i4.removeEventListener(t4, "touchstart", this.touchstart, { passive: false }), i4.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i4.removeEventListener(window, "touchend", this.touchend), i4.removeEventListener(t4, "touchcancel", this.reset), this.offTemp();
            }
            offTemp() {
              i4.enableDrag(), i4.removeEventListener(window, "mousemove", this.mousemove), i4.removeEventListener(window, "mouseup", this.mouseup), i4.removeEventListener(window, "touchmove", this.touchmove, { passive: false }), i4.removeEventListener(window, "touchend", this.touchend);
            }
          }
          let ba;
          function wa(e4, i5, s5) {
            if (e4 = new t3.LngLat(e4.lng, e4.lat), i5) {
              const a5 = new t3.LngLat(e4.lng - 360, e4.lat), o5 = new t3.LngLat(e4.lng + 360, e4.lat), r5 = s5.locationPoint(e4).distSqr(i5);
              s5.locationPoint(a5).distSqr(i5) < r5 ? e4 = a5 : s5.locationPoint(o5).distSqr(i5) < r5 && (e4 = o5);
            }
            for (; Math.abs(e4.lng - s5.center.lng) > 180; ) {
              const t4 = s5.locationPoint(e4);
              if (t4.x >= 0 && t4.y >= 0 && t4.x <= s5.width && t4.y <= s5.height)
                break;
              e4.lng > s5.center.lng ? e4.lng -= 360 : e4.lng += 360;
            }
            return e4;
          }
          const Ta = { center: "translate(-50%,-50%)", top: "translate(-50%,0)", "top-left": "translate(0,0)", "top-right": "translate(-100%,0)", bottom: "translate(-50%,-100%)", "bottom-left": "translate(0,-100%)", "bottom-right": "translate(-100%,-100%)", left: "translate(0,-50%)", right: "translate(-100%,-50%)" };
          function Ea(t4, e4, i5) {
            const s5 = t4.classList;
            for (const t5 in Ta)
              s5.remove(`maplibregl-${i5}-anchor-${t5}`);
            s5.add(`maplibregl-${i5}-anchor-${e4}`);
          }
          class Ia extends t3.Evented {
            constructor(e4) {
              if (super(), this._onKeyPress = (t4) => {
                const e5 = t4.code, i5 = t4.charCode || t4.keyCode;
                "Space" !== e5 && "Enter" !== e5 && 32 !== i5 && 13 !== i5 || this.togglePopup();
              }, this._onMapClick = (t4) => {
                const e5 = t4.originalEvent.target, i5 = this._element;
                this._popup && (e5 === i5 || i5.contains(e5)) && this.togglePopup();
              }, this._update = (t4) => {
                if (!this._map)
                  return;
                const e5 = this._map.loaded() && !this._map.isMoving();
                ("terrain" === (null == t4 ? void 0 : t4.type) || "render" === (null == t4 ? void 0 : t4.type) && !e5) && this._map.once("render", this._update), this._map.transform.renderWorldCopies && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._pos = this._map.project(this._lngLat)._add(this._offset);
                let s5 = "";
                "viewport" === this._rotationAlignment || "auto" === this._rotationAlignment ? s5 = `rotateZ(${this._rotation}deg)` : "map" === this._rotationAlignment && (s5 = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                let a5 = "";
                "viewport" === this._pitchAlignment || "auto" === this._pitchAlignment ? a5 = "rotateX(0deg)" : "map" === this._pitchAlignment && (a5 = `rotateX(${this._map.getPitch()}deg)`), t4 && "moveend" !== t4.type || (this._pos = this._pos.round()), i4.setTransform(this._element, `${Ta[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${a5} ${s5}`), this._map.terrain && !this._opacityTimeout && (this._opacityTimeout = setTimeout(() => {
                  const t5 = this._map.unproject(this._pos), e6 = 40075016686e-3 * Math.abs(Math.cos(this._lngLat.lat * Math.PI / 180)) / Math.pow(2, this._map.transform.tileZoom + 8);
                  this._element.style.opacity = t5.distanceTo(this._lngLat) > 20 * e6 ? "0.2" : "1.0", this._opacityTimeout = null;
                }, 100));
              }, this._onMove = (e5) => {
                if (!this._isDragging) {
                  const t4 = this._clickTolerance || this._map._clickTolerance;
                  this._isDragging = e5.point.dist(this._pointerdownPos) >= t4;
                }
                this._isDragging && (this._pos = e5.point.sub(this._positionDelta), this._lngLat = this._map.unproject(this._pos), this.setLngLat(this._lngLat), this._element.style.pointerEvents = "none", "pending" === this._state && (this._state = "active", this.fire(new t3.Event("dragstart"))), this.fire(new t3.Event("drag")));
              }, this._onUp = () => {
                this._element.style.pointerEvents = "auto", this._positionDelta = null, this._pointerdownPos = null, this._isDragging = false, this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), "active" === this._state && this.fire(new t3.Event("dragend")), this._state = "inactive";
              }, this._addDragHandler = (t4) => {
                this._element.contains(t4.originalEvent.target) && (t4.preventDefault(), this._positionDelta = t4.point.sub(this._pos).add(this._offset), this._pointerdownPos = t4.point, this._state = "pending", this._map.on("mousemove", this._onMove), this._map.on("touchmove", this._onMove), this._map.once("mouseup", this._onUp), this._map.once("touchend", this._onUp));
              }, this._anchor = e4 && e4.anchor || "center", this._color = e4 && e4.color || "#3FB1CE", this._scale = e4 && e4.scale || 1, this._draggable = e4 && e4.draggable || false, this._clickTolerance = e4 && e4.clickTolerance || 0, this._isDragging = false, this._state = "inactive", this._rotation = e4 && e4.rotation || 0, this._rotationAlignment = e4 && e4.rotationAlignment || "auto", this._pitchAlignment = e4 && e4.pitchAlignment && "auto" !== e4.pitchAlignment ? e4.pitchAlignment : this._rotationAlignment, e4 && e4.element)
                this._element = e4.element, this._offset = t3.Point.convert(e4 && e4.offset || [0, 0]);
              else {
                this._defaultMarker = true, this._element = i4.create("div"), this._element.setAttribute("aria-label", "Map marker");
                const s5 = i4.createNS("http://www.w3.org/2000/svg", "svg"), a5 = 41, o5 = 27;
                s5.setAttributeNS(null, "display", "block"), s5.setAttributeNS(null, "height", `${a5}px`), s5.setAttributeNS(null, "width", `${o5}px`), s5.setAttributeNS(null, "viewBox", `0 0 ${o5} ${a5}`);
                const r5 = i4.createNS("http://www.w3.org/2000/svg", "g");
                r5.setAttributeNS(null, "stroke", "none"), r5.setAttributeNS(null, "stroke-width", "1"), r5.setAttributeNS(null, "fill", "none"), r5.setAttributeNS(null, "fill-rule", "evenodd");
                const n3 = i4.createNS("http://www.w3.org/2000/svg", "g");
                n3.setAttributeNS(null, "fill-rule", "nonzero");
                const l5 = i4.createNS("http://www.w3.org/2000/svg", "g");
                l5.setAttributeNS(null, "transform", "translate(3.0, 29.0)"), l5.setAttributeNS(null, "fill", "#000000");
                const c5 = [{ rx: "10.5", ry: "5.25002273" }, { rx: "10.5", ry: "5.25002273" }, { rx: "9.5", ry: "4.77275007" }, { rx: "8.5", ry: "4.29549936" }, { rx: "7.5", ry: "3.81822308" }, { rx: "6.5", ry: "3.34094679" }, { rx: "5.5", ry: "2.86367051" }, { rx: "4.5", ry: "2.38636864" }];
                for (const t4 of c5) {
                  const e5 = i4.createNS("http://www.w3.org/2000/svg", "ellipse");
                  e5.setAttributeNS(null, "opacity", "0.04"), e5.setAttributeNS(null, "cx", "10.5"), e5.setAttributeNS(null, "cy", "5.80029008"), e5.setAttributeNS(null, "rx", t4.rx), e5.setAttributeNS(null, "ry", t4.ry), l5.appendChild(e5);
                }
                const h4 = i4.createNS("http://www.w3.org/2000/svg", "g");
                h4.setAttributeNS(null, "fill", this._color);
                const u5 = i4.createNS("http://www.w3.org/2000/svg", "path");
                u5.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"), h4.appendChild(u5);
                const d4 = i4.createNS("http://www.w3.org/2000/svg", "g");
                d4.setAttributeNS(null, "opacity", "0.25"), d4.setAttributeNS(null, "fill", "#000000");
                const _4 = i4.createNS("http://www.w3.org/2000/svg", "path");
                _4.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"), d4.appendChild(_4);
                const m4 = i4.createNS("http://www.w3.org/2000/svg", "g");
                m4.setAttributeNS(null, "transform", "translate(6.0, 7.0)"), m4.setAttributeNS(null, "fill", "#FFFFFF");
                const p7 = i4.createNS("http://www.w3.org/2000/svg", "g");
                p7.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                const f4 = i4.createNS("http://www.w3.org/2000/svg", "circle");
                f4.setAttributeNS(null, "fill", "#000000"), f4.setAttributeNS(null, "opacity", "0.25"), f4.setAttributeNS(null, "cx", "5.5"), f4.setAttributeNS(null, "cy", "5.5"), f4.setAttributeNS(null, "r", "5.4999962");
                const g4 = i4.createNS("http://www.w3.org/2000/svg", "circle");
                g4.setAttributeNS(null, "fill", "#FFFFFF"), g4.setAttributeNS(null, "cx", "5.5"), g4.setAttributeNS(null, "cy", "5.5"), g4.setAttributeNS(null, "r", "5.4999962"), p7.appendChild(f4), p7.appendChild(g4), n3.appendChild(l5), n3.appendChild(h4), n3.appendChild(d4), n3.appendChild(m4), n3.appendChild(p7), s5.appendChild(n3), s5.setAttributeNS(null, "height", a5 * this._scale + "px"), s5.setAttributeNS(null, "width", o5 * this._scale + "px"), this._element.appendChild(s5), this._offset = t3.Point.convert(e4 && e4.offset || [0, -14]);
              }
              if (this._element.classList.add("maplibregl-marker"), this._element.addEventListener("dragstart", (t4) => {
                t4.preventDefault();
              }), this._element.addEventListener("mousedown", (t4) => {
                t4.preventDefault();
              }), Ea(this._element, this._anchor, "marker"), e4 && e4.className)
                for (const t4 of e4.className.split(" "))
                  this._element.classList.add(t4);
              this._popup = null;
            }
            addTo(t4) {
              return this.remove(), this._map = t4, t4.getCanvasContainer().appendChild(this._element), t4.on("move", this._update), t4.on("moveend", this._update), t4.on("terrain", this._update), this.setDraggable(this._draggable), this._update(), this._map.on("click", this._onMapClick), this;
            }
            remove() {
              return this._opacityTimeout && (clearTimeout(this._opacityTimeout), delete this._opacityTimeout), this._map && (this._map.off("click", this._onMapClick), this._map.off("move", this._update), this._map.off("moveend", this._update), this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler), this._map.off("mouseup", this._onUp), this._map.off("touchend", this._onUp), this._map.off("mousemove", this._onMove), this._map.off("touchmove", this._onMove), delete this._map), i4.remove(this._element), this._popup && this._popup.remove(), this;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e4) {
              return this._lngLat = t3.LngLat.convert(e4), this._pos = null, this._popup && this._popup.setLngLat(this._lngLat), this._update(), this;
            }
            getElement() {
              return this._element;
            }
            setPopup(t4) {
              if (this._popup && (this._popup.remove(), this._popup = null, this._element.removeEventListener("keypress", this._onKeyPress), this._originalTabIndex || this._element.removeAttribute("tabindex")), t4) {
                if (!("offset" in t4.options)) {
                  const e4 = 38.1, i5 = 13.5, s5 = Math.abs(i5) / Math.SQRT2;
                  t4.options.offset = this._defaultMarker ? { top: [0, 0], "top-left": [0, 0], "top-right": [0, 0], bottom: [0, -e4], "bottom-left": [s5, -1 * (e4 - i5 + s5)], "bottom-right": [-s5, -1 * (e4 - i5 + s5)], left: [i5, -1 * (e4 - i5)], right: [-i5, -1 * (e4 - i5)] } : this._offset;
                }
                this._popup = t4, this._lngLat && this._popup.setLngLat(this._lngLat), this._originalTabIndex = this._element.getAttribute("tabindex"), this._originalTabIndex || this._element.setAttribute("tabindex", "0"), this._element.addEventListener("keypress", this._onKeyPress);
              }
              return this;
            }
            getPopup() {
              return this._popup;
            }
            togglePopup() {
              const t4 = this._popup;
              return t4 ? (t4.isOpen() ? t4.remove() : t4.addTo(this._map), this) : this;
            }
            getOffset() {
              return this._offset;
            }
            setOffset(e4) {
              return this._offset = t3.Point.convert(e4), this._update(), this;
            }
            addClassName(t4) {
              this._element.classList.add(t4);
            }
            removeClassName(t4) {
              this._element.classList.remove(t4);
            }
            toggleClassName(t4) {
              return this._element.classList.toggle(t4);
            }
            setDraggable(t4) {
              return this._draggable = !!t4, this._map && (t4 ? (this._map.on("mousedown", this._addDragHandler), this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler), this._map.off("touchstart", this._addDragHandler))), this;
            }
            isDraggable() {
              return this._draggable;
            }
            setRotation(t4) {
              return this._rotation = t4 || 0, this._update(), this;
            }
            getRotation() {
              return this._rotation;
            }
            setRotationAlignment(t4) {
              return this._rotationAlignment = t4 || "auto", this._update(), this;
            }
            getRotationAlignment() {
              return this._rotationAlignment;
            }
            setPitchAlignment(t4) {
              return this._pitchAlignment = t4 && "auto" !== t4 ? t4 : this._rotationAlignment, this._update(), this;
            }
            getPitchAlignment() {
              return this._pitchAlignment;
            }
          }
          const Sa = { positionOptions: { enableHighAccuracy: false, maximumAge: 0, timeout: 6e3 }, fitBoundsOptions: { maxZoom: 15 }, trackUserLocation: false, showAccuracyCircle: true, showUserLocation: true };
          let Ca = 0, Pa = false;
          const Da = { maxWidth: 100, unit: "metric" };
          function Ma(t4, e4, i5) {
            const s5 = i5 && i5.maxWidth || 100, a5 = t4._container.clientHeight / 2, o5 = t4.unproject([0, a5]), r5 = t4.unproject([s5, a5]), n3 = o5.distanceTo(r5);
            if (i5 && "imperial" === i5.unit) {
              const i6 = 3.2808 * n3;
              i6 > 5280 ? za(e4, s5, i6 / 5280, t4._getUIString("ScaleControl.Miles")) : za(e4, s5, i6, t4._getUIString("ScaleControl.Feet"));
            } else
              i5 && "nautical" === i5.unit ? za(e4, s5, n3 / 1852, t4._getUIString("ScaleControl.NauticalMiles")) : n3 >= 1e3 ? za(e4, s5, n3 / 1e3, t4._getUIString("ScaleControl.Kilometers")) : za(e4, s5, n3, t4._getUIString("ScaleControl.Meters"));
          }
          function za(t4, e4, i5, s5) {
            const a5 = function(t5) {
              const e5 = Math.pow(10, `${Math.floor(t5)}`.length - 1);
              let i6 = t5 / e5;
              return i6 = i6 >= 10 ? 10 : i6 >= 5 ? 5 : i6 >= 3 ? 3 : i6 >= 2 ? 2 : i6 >= 1 ? 1 : function(t6) {
                const e6 = Math.pow(10, Math.ceil(-Math.log(t6) / Math.LN10));
                return Math.round(t6 * e6) / e6;
              }(i6), e5 * i6;
            }(i5);
            t4.style.width = e4 * (a5 / i5) + "px", t4.innerHTML = `${a5}&nbsp;${s5}`;
          }
          const Aa = { closeButton: true, closeOnClick: true, focusAfterOpen: true, className: "", maxWidth: "240px" }, La = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
          function Ra(e4) {
            if (e4) {
              if ("number" == typeof e4) {
                const i5 = Math.round(Math.abs(e4) / Math.SQRT2);
                return { center: new t3.Point(0, 0), top: new t3.Point(0, e4), "top-left": new t3.Point(i5, i5), "top-right": new t3.Point(-i5, i5), bottom: new t3.Point(0, -e4), "bottom-left": new t3.Point(i5, -i5), "bottom-right": new t3.Point(-i5, -i5), left: new t3.Point(e4, 0), right: new t3.Point(-e4, 0) };
              }
              if (e4 instanceof t3.Point || Array.isArray(e4)) {
                const i5 = t3.Point.convert(e4);
                return { center: i5, top: i5, "top-left": i5, "top-right": i5, bottom: i5, "bottom-left": i5, "bottom-right": i5, left: i5, right: i5 };
              }
              return { center: t3.Point.convert(e4.center || [0, 0]), top: t3.Point.convert(e4.top || [0, 0]), "top-left": t3.Point.convert(e4["top-left"] || [0, 0]), "top-right": t3.Point.convert(e4["top-right"] || [0, 0]), bottom: t3.Point.convert(e4.bottom || [0, 0]), "bottom-left": t3.Point.convert(e4["bottom-left"] || [0, 0]), "bottom-right": t3.Point.convert(e4["bottom-right"] || [0, 0]), left: t3.Point.convert(e4.left || [0, 0]), right: t3.Point.convert(e4.right || [0, 0]) };
            }
            return Ra(new t3.Point(0, 0));
          }
          const ka = { extend: (e4, ...i5) => t3.extend(e4, ...i5), run(t4) {
            t4();
          }, logToElement(t4, e4 = false, i5 = "log") {
            const s5 = window.document.getElementById(i5);
            s5 && (e4 && (s5.innerHTML = ""), s5.innerHTML += `<br>${t4}`);
          } }, Fa = e3;
          class Ba {
            static get version() {
              return Fa;
            }
            static get workerCount() {
              return tt.workerCount;
            }
            static set workerCount(t4) {
              tt.workerCount = t4;
            }
            static get maxParallelImageRequests() {
              return t3.config.MAX_PARALLEL_IMAGE_REQUESTS;
            }
            static set maxParallelImageRequests(e4) {
              t3.config.MAX_PARALLEL_IMAGE_REQUESTS = e4;
            }
            static get workerUrl() {
              return t3.config.WORKER_URL;
            }
            static set workerUrl(e4) {
              t3.config.WORKER_URL = e4;
            }
            static addProtocol(e4, i5) {
              t3.config.REGISTERED_PROTOCOLS[e4] = i5;
            }
            static removeProtocol(e4) {
              delete t3.config.REGISTERED_PROTOCOLS[e4];
            }
          }
          return Ba.Map = class extends oa {
            constructor(e4) {
              if (t3.PerformanceUtils.mark(t3.PerformanceMarkers.create), null != (e4 = t3.extend({}, ga, e4)).minZoom && null != e4.maxZoom && e4.minZoom > e4.maxZoom)
                throw new Error("maxZoom must be greater than or equal to minZoom");
              if (null != e4.minPitch && null != e4.maxPitch && e4.minPitch > e4.maxPitch)
                throw new Error("maxPitch must be greater than or equal to minPitch");
              if (null != e4.minPitch && e4.minPitch < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (null != e4.maxPitch && e4.maxPitch > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (super(new rs(e4.minZoom, e4.maxZoom, e4.minPitch, e4.maxPitch, e4.renderWorldCopies), { bearingSnap: e4.bearingSnap }), this._cooperativeGesturesOnWheel = (t4) => {
                this._onCooperativeGesture(t4, t4[this._metaKey], 1);
              }, this._contextLost = (e5) => {
                e5.preventDefault(), this._frame && (this._frame.cancel(), this._frame = null), this.fire(new t3.Event("webglcontextlost", { originalEvent: e5 }));
              }, this._contextRestored = (e5) => {
                this._setupPainter(), this.resize(), this._update(), this.fire(new t3.Event("webglcontextrestored", { originalEvent: e5 }));
              }, this._onMapScroll = (t4) => {
                if (t4.target === this._container)
                  return this._container.scrollTop = 0, this._container.scrollLeft = 0, false;
              }, this._onWindowOnline = () => {
                this._update();
              }, this._interactive = e4.interactive, this._cooperativeGestures = e4.cooperativeGestures, this._metaKey = 0 === navigator.platform.indexOf("Mac") ? "metaKey" : "ctrlKey", this._maxTileCacheSize = e4.maxTileCacheSize, this._maxTileCacheZoomLevels = e4.maxTileCacheZoomLevels, this._failIfMajorPerformanceCaveat = e4.failIfMajorPerformanceCaveat, this._preserveDrawingBuffer = e4.preserveDrawingBuffer, this._antialias = e4.antialias, this._trackResize = e4.trackResize, this._bearingSnap = e4.bearingSnap, this._refreshExpiredTiles = e4.refreshExpiredTiles, this._fadeDuration = e4.fadeDuration, this._crossSourceCollisions = e4.crossSourceCollisions, this._crossFadingFactor = 1, this._collectResourceTiming = e4.collectResourceTiming, this._renderTaskQueue = new la(), this._controls = [], this._mapId = t3.uniqueId(), this._locale = t3.extend({}, ca, e4.locale), this._clickTolerance = e4.clickTolerance, this._overridePixelRatio = e4.pixelRatio, this._maxCanvasSize = e4.maxCanvasSize, this.transformCameraUpdate = e4.transformCameraUpdate, this._imageQueueHandle = c4.addThrottleControl(() => this.isMoving()), this._requestManager = new u4(e4.transformRequest), "string" == typeof e4.container) {
                if (this._container = document.getElementById(e4.container), !this._container)
                  throw new Error(`Container '${e4.container}' not found.`);
              } else {
                if (!(e4.container instanceof HTMLElement))
                  throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                this._container = e4.container;
              }
              if (e4.maxBounds && this.setMaxBounds(e4.maxBounds), this._setupContainer(), this._setupPainter(), this.on("move", () => this._update(false)), this.on("moveend", () => this._update(false)), this.on("zoom", () => this._update(true)), this.on("terrain", () => {
                this.painter.terrainFacilitator.dirty = true, this._update(true);
              }), this.once("idle", () => {
                this._idleTriggered = true;
              }), "undefined" != typeof window) {
                addEventListener("online", this._onWindowOnline, false);
                let t4 = false;
                const e5 = ns((t5) => {
                  this._trackResize && !this._removed && this.resize(t5)._update();
                }, 50);
                this._resizeObserver = new ResizeObserver((i5) => {
                  t4 ? e5(i5) : t4 = true;
                }), this._resizeObserver.observe(this._container);
              }
              this.handlers = new aa(this, e4), this._cooperativeGestures && this._setupCooperativeGestures(), this._hash = e4.hash && new ls("string" == typeof e4.hash && e4.hash || void 0).addTo(this), this._hash && this._hash._onHashChange() || (this.jumpTo({ center: e4.center, zoom: e4.zoom, bearing: e4.bearing, pitch: e4.pitch }), e4.bounds && (this.resize(), this.fitBounds(e4.bounds, t3.extend({}, e4.fitBoundsOptions, { duration: 0 })))), this.resize(), this._localIdeographFontFamily = e4.localIdeographFontFamily, this._validateStyle = e4.validateStyle, e4.style && this.setStyle(e4.style, { localIdeographFontFamily: e4.localIdeographFontFamily }), e4.attributionControl && this.addControl(new ra({ customAttribution: e4.customAttribution })), e4.maplibreLogo && this.addControl(new na(), e4.logoPosition), this.on("style.load", () => {
                this.transform.unmodified && this.jumpTo(this.style.stylesheet);
              }), this.on("data", (e5) => {
                this._update("style" === e5.dataType), this.fire(new t3.Event(`${e5.dataType}data`, e5));
              }), this.on("dataloading", (e5) => {
                this.fire(new t3.Event(`${e5.dataType}dataloading`, e5));
              }), this.on("dataabort", (e5) => {
                this.fire(new t3.Event("sourcedataabort", e5));
              });
            }
            _getMapId() {
              return this._mapId;
            }
            addControl(e4, i5) {
              if (void 0 === i5 && (i5 = e4.getDefaultPosition ? e4.getDefaultPosition() : "top-right"), !e4 || !e4.onAdd)
                return this.fire(new t3.ErrorEvent(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
              const s5 = e4.onAdd(this);
              this._controls.push(e4);
              const a5 = this._controlPositions[i5];
              return -1 !== i5.indexOf("bottom") ? a5.insertBefore(s5, a5.firstChild) : a5.appendChild(s5), this;
            }
            removeControl(e4) {
              if (!e4 || !e4.onRemove)
                return this.fire(new t3.ErrorEvent(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
              const i5 = this._controls.indexOf(e4);
              return i5 > -1 && this._controls.splice(i5, 1), e4.onRemove(this), this;
            }
            hasControl(t4) {
              return this._controls.indexOf(t4) > -1;
            }
            calculateCameraOptionsFromTo(t4, e4, i5, s5) {
              return null == s5 && this.terrain && (s5 = this.terrain.getElevationForLngLatZoom(i5, this.transform.tileZoom)), super.calculateCameraOptionsFromTo(t4, e4, i5, s5);
            }
            resize(e4) {
              var i5;
              const s5 = this._containerDimensions(), a5 = s5[0], o5 = s5[1], r5 = this._getClampedPixelRatio(a5, o5);
              if (this._resizeCanvas(a5, o5, r5), this.painter.resize(a5, o5, r5), this.painter.overLimit()) {
                const t4 = this.painter.context.gl;
                this._maxCanvasSize = [t4.drawingBufferWidth, t4.drawingBufferHeight];
                const e5 = this._getClampedPixelRatio(a5, o5);
                this._resizeCanvas(a5, o5, e5), this.painter.resize(a5, o5, e5);
              }
              this.transform.resize(a5, o5), null === (i5 = this._requestedCameraState) || void 0 === i5 || i5.resize(a5, o5);
              const n3 = !this._moving;
              return n3 && (this.stop(), this.fire(new t3.Event("movestart", e4)).fire(new t3.Event("move", e4))), this.fire(new t3.Event("resize", e4)), n3 && this.fire(new t3.Event("moveend", e4)), this;
            }
            _getClampedPixelRatio(t4, e4) {
              const { 0: i5, 1: s5 } = this._maxCanvasSize, a5 = this.getPixelRatio(), o5 = t4 * a5, r5 = e4 * a5;
              return Math.min(o5 > i5 ? i5 / o5 : 1, r5 > s5 ? s5 / r5 : 1) * a5;
            }
            getPixelRatio() {
              var t4;
              return null !== (t4 = this._overridePixelRatio) && void 0 !== t4 ? t4 : devicePixelRatio;
            }
            setPixelRatio(t4) {
              this._overridePixelRatio = t4, this.resize();
            }
            getBounds() {
              return this.transform.getBounds();
            }
            getMaxBounds() {
              return this.transform.getMaxBounds();
            }
            setMaxBounds(t4) {
              return this.transform.setMaxBounds(A2.convert(t4)), this._update();
            }
            setMinZoom(t4) {
              if ((t4 = null == t4 ? -2 : t4) >= -2 && t4 <= this.transform.maxZoom)
                return this.transform.minZoom = t4, this._update(), this.getZoom() < t4 && this.setZoom(t4), this;
              throw new Error("minZoom must be between -2 and the current maxZoom, inclusive");
            }
            getMinZoom() {
              return this.transform.minZoom;
            }
            setMaxZoom(t4) {
              if ((t4 = null == t4 ? 22 : t4) >= this.transform.minZoom)
                return this.transform.maxZoom = t4, this._update(), this.getZoom() > t4 && this.setZoom(t4), this;
              throw new Error("maxZoom must be greater than the current minZoom");
            }
            getMaxZoom() {
              return this.transform.maxZoom;
            }
            setMinPitch(t4) {
              if ((t4 = null == t4 ? 0 : t4) < 0)
                throw new Error("minPitch must be greater than or equal to 0");
              if (t4 >= 0 && t4 <= this.transform.maxPitch)
                return this.transform.minPitch = t4, this._update(), this.getPitch() < t4 && this.setPitch(t4), this;
              throw new Error("minPitch must be between 0 and the current maxPitch, inclusive");
            }
            getMinPitch() {
              return this.transform.minPitch;
            }
            setMaxPitch(t4) {
              if ((t4 = null == t4 ? 60 : t4) > 85)
                throw new Error("maxPitch must be less than or equal to 85");
              if (t4 >= this.transform.minPitch)
                return this.transform.maxPitch = t4, this._update(), this.getPitch() > t4 && this.setPitch(t4), this;
              throw new Error("maxPitch must be greater than the current minPitch");
            }
            getMaxPitch() {
              return this.transform.maxPitch;
            }
            getRenderWorldCopies() {
              return this.transform.renderWorldCopies;
            }
            setRenderWorldCopies(t4) {
              return this.transform.renderWorldCopies = t4, this._update();
            }
            getCooperativeGestures() {
              return this._cooperativeGestures;
            }
            setCooperativeGestures(t4) {
              return this._cooperativeGestures = t4, this._cooperativeGestures ? this._setupCooperativeGestures() : this._destroyCooperativeGestures(), this;
            }
            project(e4) {
              return this.transform.locationPoint(t3.LngLat.convert(e4), this.style && this.terrain);
            }
            unproject(e4) {
              return this.transform.pointLocation(t3.Point.convert(e4), this.terrain);
            }
            isMoving() {
              var t4;
              return this._moving || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isMoving());
            }
            isZooming() {
              var t4;
              return this._zooming || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isZooming());
            }
            isRotating() {
              var t4;
              return this._rotating || (null === (t4 = this.handlers) || void 0 === t4 ? void 0 : t4.isRotating());
            }
            _createDelegatedListener(t4, e4, i5) {
              if ("mouseenter" === t4 || "mouseover" === t4) {
                let s5 = false;
                const a5 = (a6) => {
                  const o5 = this.getLayer(e4) ? this.queryRenderedFeatures(a6.point, { layers: [e4] }) : [];
                  o5.length ? s5 || (s5 = true, i5.call(this, new gs(t4, this, a6.originalEvent, { features: o5 }))) : s5 = false;
                };
                return { layer: e4, listener: i5, delegates: { mousemove: a5, mouseout: () => {
                  s5 = false;
                } } };
              }
              if ("mouseleave" === t4 || "mouseout" === t4) {
                let s5 = false;
                const a5 = (a6) => {
                  (this.getLayer(e4) ? this.queryRenderedFeatures(a6.point, { layers: [e4] }) : []).length ? s5 = true : s5 && (s5 = false, i5.call(this, new gs(t4, this, a6.originalEvent)));
                }, o5 = (e5) => {
                  s5 && (s5 = false, i5.call(this, new gs(t4, this, e5.originalEvent)));
                };
                return { layer: e4, listener: i5, delegates: { mousemove: a5, mouseout: o5 } };
              }
              {
                const s5 = (t5) => {
                  const s6 = this.getLayer(e4) ? this.queryRenderedFeatures(t5.point, { layers: [e4] }) : [];
                  s6.length && (t5.features = s6, i5.call(this, t5), delete t5.features);
                };
                return { layer: e4, listener: i5, delegates: { [t4]: s5 } };
              }
            }
            on(t4, e4, i5) {
              if (void 0 === i5)
                return super.on(t4, e4);
              const s5 = this._createDelegatedListener(t4, e4, i5);
              this._delegatedListeners = this._delegatedListeners || {}, this._delegatedListeners[t4] = this._delegatedListeners[t4] || [], this._delegatedListeners[t4].push(s5);
              for (const t5 in s5.delegates)
                this.on(t5, s5.delegates[t5]);
              return this;
            }
            once(t4, e4, i5) {
              if (void 0 === i5)
                return super.once(t4, e4);
              const s5 = this._createDelegatedListener(t4, e4, i5);
              for (const t5 in s5.delegates)
                this.once(t5, s5.delegates[t5]);
              return this;
            }
            off(t4, e4, i5) {
              return void 0 === i5 ? super.off(t4, e4) : (this._delegatedListeners && this._delegatedListeners[t4] && ((s5) => {
                const a5 = this._delegatedListeners[t4];
                for (let t5 = 0; t5 < a5.length; t5++) {
                  const s6 = a5[t5];
                  if (s6.layer === e4 && s6.listener === i5) {
                    for (const t6 in s6.delegates)
                      this.off(t6, s6.delegates[t6]);
                    return a5.splice(t5, 1), this;
                  }
                }
              })(), this);
            }
            queryRenderedFeatures(e4, i5) {
              if (!this.style)
                return [];
              let s5;
              const a5 = e4 instanceof t3.Point || Array.isArray(e4), o5 = a5 ? e4 : [[0, 0], [this.transform.width, this.transform.height]];
              if (i5 = i5 || (a5 ? {} : e4) || {}, o5 instanceof t3.Point || "number" == typeof o5[0])
                s5 = [t3.Point.convert(o5)];
              else {
                const e5 = t3.Point.convert(o5[0]), i6 = t3.Point.convert(o5[1]);
                s5 = [e5, new t3.Point(i6.x, e5.y), i6, new t3.Point(e5.x, i6.y), e5];
              }
              return this.style.queryRenderedFeatures(s5, i5, this.transform);
            }
            querySourceFeatures(t4, e4) {
              return this.style.querySourceFeatures(t4, e4);
            }
            setStyle(e4, i5) {
              return false !== (i5 = t3.extend({}, { localIdeographFontFamily: this._localIdeographFontFamily, validate: this._validateStyle }, i5)).diff && i5.localIdeographFontFamily === this._localIdeographFontFamily && this.style && e4 ? (this._diffStyle(e4, i5), this) : (this._localIdeographFontFamily = i5.localIdeographFontFamily, this._updateStyle(e4, i5));
            }
            setTransformRequest(t4) {
              return this._requestManager.setTransformRequest(t4), this;
            }
            _getUIString(t4) {
              const e4 = this._locale[t4];
              if (null == e4)
                throw new Error(`Missing UI string '${t4}'`);
              return e4;
            }
            _updateStyle(t4, e4) {
              if (e4.transformStyle && this.style && !this.style._loaded)
                return void this.style.once("style.load", () => this._updateStyle(t4, e4));
              const i5 = this.style && e4.transformStyle ? this.style.serialize() : void 0;
              return this.style && (this.style.setEventedParent(null), this.style._remove(!t4)), t4 ? (this.style = new se(this, e4 || {}), this.style.setEventedParent(this, { style: this.style }), "string" == typeof t4 ? this.style.loadURL(t4, e4, i5) : this.style.loadJSON(t4, e4, i5), this) : (delete this.style, this);
            }
            _lazyInitEmptyStyle() {
              this.style || (this.style = new se(this, {}), this.style.setEventedParent(this, { style: this.style }), this.style.loadEmpty());
            }
            _diffStyle(e4, i5) {
              if ("string" == typeof e4) {
                const s5 = this._requestManager.transformRequest(e4, h3.Style);
                t3.getJSON(s5, (e5, s6) => {
                  e5 ? this.fire(new t3.ErrorEvent(e5)) : s6 && this._updateDiff(s6, i5);
                });
              } else
                "object" == typeof e4 && this._updateDiff(e4, i5);
            }
            _updateDiff(e4, i5) {
              try {
                this.style.setState(e4, i5) && this._update(true);
              } catch (s5) {
                t3.warnOnce(`Unable to perform style diff: ${s5.message || s5.error || s5}.  Rebuilding the style from scratch.`), this._updateStyle(e4, i5);
              }
            }
            getStyle() {
              if (this.style)
                return this.style.serialize();
            }
            isStyleLoaded() {
              return this.style ? this.style.loaded() : t3.warnOnce("There is no style added to the map.");
            }
            addSource(t4, e4) {
              return this._lazyInitEmptyStyle(), this.style.addSource(t4, e4), this._update(true);
            }
            isSourceLoaded(e4) {
              const i5 = this.style && this.style.sourceCaches[e4];
              if (void 0 !== i5)
                return i5.loaded();
              this.fire(new t3.ErrorEvent(new Error(`There is no source with ID '${e4}'`)));
            }
            setTerrain(e4) {
              if (this.style._checkLoaded(), this._terrainDataCallback && this.style.off("data", this._terrainDataCallback), e4) {
                const i5 = this.style.sourceCaches[e4.source];
                if (!i5)
                  throw new Error(`cannot load terrain, because there exists no source with ID: ${e4.source}`);
                for (const i6 in this.style._layers) {
                  const s5 = this.style._layers[i6];
                  "hillshade" === s5.type && s5.source === e4.source && t3.warnOnce("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.");
                }
                this.terrain = new da(this.painter, i5, e4), this.painter.renderToTexture = new pa(this.painter, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._terrainDataCallback = (t4) => {
                  "style" === t4.dataType ? this.terrain.sourceCache.freeRtt() : "source" === t4.dataType && t4.tile && (t4.sourceId !== e4.source || this._elevationFreeze || (this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)), this.terrain.sourceCache.freeRtt(t4.tile.tileID));
                }, this.style.on("data", this._terrainDataCallback);
              } else
                this.terrain && this.terrain.sourceCache.destruct(), this.terrain = null, this.painter.renderToTexture && this.painter.renderToTexture.destruct(), this.painter.renderToTexture = null, this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0;
              return this.fire(new t3.Event("terrain", { terrain: e4 })), this;
            }
            getTerrain() {
              var t4, e4;
              return null !== (e4 = null === (t4 = this.terrain) || void 0 === t4 ? void 0 : t4.options) && void 0 !== e4 ? e4 : null;
            }
            areTilesLoaded() {
              const t4 = this.style && this.style.sourceCaches;
              for (const e4 in t4) {
                const i5 = t4[e4]._tiles;
                for (const t5 in i5) {
                  const e5 = i5[t5];
                  if ("loaded" !== e5.state && "errored" !== e5.state)
                    return false;
                }
              }
              return true;
            }
            addSourceType(t4, e4, i5) {
              return this._lazyInitEmptyStyle(), this.style.addSourceType(t4, e4, i5);
            }
            removeSource(t4) {
              return this.style.removeSource(t4), this._update(true);
            }
            getSource(t4) {
              return this.style.getSource(t4);
            }
            addImage(e4, i5, s5 = {}) {
              const { pixelRatio: a5 = 1, sdf: o5 = false, stretchX: r5, stretchY: n3, content: l5 } = s5;
              if (this._lazyInitEmptyStyle(), !(i5 instanceof HTMLImageElement || t3.isImageBitmap(i5))) {
                if (void 0 === i5.width || void 0 === i5.height)
                  return this.fire(new t3.ErrorEvent(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                {
                  const { width: s6, height: c5, data: h4 } = i5, u5 = i5;
                  return this.style.addImage(e4, { data: new t3.RGBAImage({ width: s6, height: c5 }, new Uint8Array(h4)), pixelRatio: a5, stretchX: r5, stretchY: n3, content: l5, sdf: o5, version: 0, userImage: u5 }), u5.onAdd && u5.onAdd(this, e4), this;
                }
              }
              {
                const { width: s6, height: c5, data: h4 } = t3.browser.getImageData(i5);
                this.style.addImage(e4, { data: new t3.RGBAImage({ width: s6, height: c5 }, h4), pixelRatio: a5, stretchX: r5, stretchY: n3, content: l5, sdf: o5, version: 0 });
              }
            }
            updateImage(e4, i5) {
              const s5 = this.style.getImage(e4);
              if (!s5)
                return this.fire(new t3.ErrorEvent(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
              const a5 = i5 instanceof HTMLImageElement || t3.isImageBitmap(i5) ? t3.browser.getImageData(i5) : i5, { width: o5, height: r5, data: n3 } = a5;
              if (void 0 === o5 || void 0 === r5)
                return this.fire(new t3.ErrorEvent(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
              if (o5 !== s5.data.width || r5 !== s5.data.height)
                return this.fire(new t3.ErrorEvent(new Error("The width and height of the updated image must be that same as the previous version of the image")));
              const l5 = !(i5 instanceof HTMLImageElement || t3.isImageBitmap(i5));
              return s5.data.replace(n3, l5), this.style.updateImage(e4, s5), this;
            }
            getImage(t4) {
              return this.style.getImage(t4);
            }
            hasImage(e4) {
              return e4 ? !!this.style.getImage(e4) : (this.fire(new t3.ErrorEvent(new Error("Missing required image id"))), false);
            }
            removeImage(t4) {
              this.style.removeImage(t4);
            }
            loadImage(t4, e4) {
              c4.getImage(this._requestManager.transformRequest(t4, h3.Image), e4);
            }
            listImages() {
              return this.style.listImages();
            }
            addLayer(t4, e4) {
              return this._lazyInitEmptyStyle(), this.style.addLayer(t4, e4), this._update(true);
            }
            moveLayer(t4, e4) {
              return this.style.moveLayer(t4, e4), this._update(true);
            }
            removeLayer(t4) {
              return this.style.removeLayer(t4), this._update(true);
            }
            getLayer(t4) {
              return this.style.getLayer(t4);
            }
            setLayerZoomRange(t4, e4, i5) {
              return this.style.setLayerZoomRange(t4, e4, i5), this._update(true);
            }
            setFilter(t4, e4, i5 = {}) {
              return this.style.setFilter(t4, e4, i5), this._update(true);
            }
            getFilter(t4) {
              return this.style.getFilter(t4);
            }
            setPaintProperty(t4, e4, i5, s5 = {}) {
              return this.style.setPaintProperty(t4, e4, i5, s5), this._update(true);
            }
            getPaintProperty(t4, e4) {
              return this.style.getPaintProperty(t4, e4);
            }
            setLayoutProperty(t4, e4, i5, s5 = {}) {
              return this.style.setLayoutProperty(t4, e4, i5, s5), this._update(true);
            }
            getLayoutProperty(t4, e4) {
              return this.style.getLayoutProperty(t4, e4);
            }
            setGlyphs(t4, e4 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setGlyphs(t4, e4), this._update(true);
            }
            getGlyphs() {
              return this.style.getGlyphsUrl();
            }
            addSprite(t4, e4, i5 = {}) {
              return this._lazyInitEmptyStyle(), this.style.addSprite(t4, e4, i5, (t5) => {
                t5 || this._update(true);
              }), this;
            }
            removeSprite(t4) {
              return this._lazyInitEmptyStyle(), this.style.removeSprite(t4), this._update(true);
            }
            getSprite() {
              return this.style.getSprite();
            }
            setSprite(t4, e4 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setSprite(t4, e4, (t5) => {
                t5 || this._update(true);
              }), this;
            }
            setLight(t4, e4 = {}) {
              return this._lazyInitEmptyStyle(), this.style.setLight(t4, e4), this._update(true);
            }
            getLight() {
              return this.style.getLight();
            }
            setFeatureState(t4, e4) {
              return this.style.setFeatureState(t4, e4), this._update();
            }
            removeFeatureState(t4, e4) {
              return this.style.removeFeatureState(t4, e4), this._update();
            }
            getFeatureState(t4) {
              return this.style.getFeatureState(t4);
            }
            getContainer() {
              return this._container;
            }
            getCanvasContainer() {
              return this._canvasContainer;
            }
            getCanvas() {
              return this._canvas;
            }
            _containerDimensions() {
              let t4 = 0, e4 = 0;
              return this._container && (t4 = this._container.clientWidth || 400, e4 = this._container.clientHeight || 300), [t4, e4];
            }
            _setupContainer() {
              const t4 = this._container;
              t4.classList.add("maplibregl-map");
              const e4 = this._canvasContainer = i4.create("div", "maplibregl-canvas-container", t4);
              this._interactive && e4.classList.add("maplibregl-interactive"), this._canvas = i4.create("canvas", "maplibregl-canvas", e4), this._canvas.addEventListener("webglcontextlost", this._contextLost, false), this._canvas.addEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.setAttribute("tabindex", "0"), this._canvas.setAttribute("aria-label", "Map"), this._canvas.setAttribute("role", "region");
              const s5 = this._containerDimensions(), a5 = this._getClampedPixelRatio(s5[0], s5[1]);
              this._resizeCanvas(s5[0], s5[1], a5);
              const o5 = this._controlContainer = i4.create("div", "maplibregl-control-container", t4), r5 = this._controlPositions = {};
              ["top-left", "top-right", "bottom-left", "bottom-right"].forEach((t5) => {
                r5[t5] = i4.create("div", `maplibregl-ctrl-${t5} `, o5);
              }), this._container.addEventListener("scroll", this._onMapScroll, false);
            }
            _setupCooperativeGestures() {
              this._cooperativeGesturesScreen = i4.create("div", "maplibregl-cooperative-gesture-screen", this._container);
              let t4 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.windowsHelpText ? this._cooperativeGestures.windowsHelpText : "Use Ctrl + scroll to zoom the map";
              0 === navigator.platform.indexOf("Mac") && (t4 = "boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.macHelpText ? this._cooperativeGestures.macHelpText : "Use \u2318 + scroll to zoom the map"), this._cooperativeGesturesScreen.innerHTML = `
            <div class="maplibregl-desktop-message">${t4}</div>
            <div class="maplibregl-mobile-message">${"boolean" != typeof this._cooperativeGestures && this._cooperativeGestures.mobileHelpText ? this._cooperativeGestures.mobileHelpText : "Use two fingers to move the map"}</div>
        `, this._cooperativeGesturesScreen.setAttribute("aria-hidden", "true"), this._canvasContainer.addEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.add("maplibregl-cooperative-gestures");
            }
            _destroyCooperativeGestures() {
              i4.remove(this._cooperativeGesturesScreen), this._canvasContainer.removeEventListener("wheel", this._cooperativeGesturesOnWheel, false), this._canvasContainer.classList.remove("maplibregl-cooperative-gestures");
            }
            _resizeCanvas(t4, e4, i5) {
              this._canvas.width = Math.floor(i5 * t4), this._canvas.height = Math.floor(i5 * e4), this._canvas.style.width = `${t4}px`, this._canvas.style.height = `${e4}px`;
            }
            _setupPainter() {
              const t4 = { alpha: true, stencil: true, depth: true, failIfMajorPerformanceCaveat: this._failIfMajorPerformanceCaveat, preserveDrawingBuffer: this._preserveDrawingBuffer, antialias: this._antialias || false };
              let e4 = null;
              this._canvas.addEventListener("webglcontextcreationerror", (i6) => {
                e4 = { requestedAttributes: t4 }, i6 && (e4.statusMessage = i6.statusMessage, e4.type = i6.type);
              }, { once: true });
              const i5 = this._canvas.getContext("webgl2", t4) || this._canvas.getContext("webgl", t4);
              if (!i5) {
                const t5 = "Failed to initialize WebGL";
                throw e4 ? (e4.message = t5, new Error(JSON.stringify(e4))) : new Error(t5);
              }
              this.painter = new is(i5, this.transform), s4.testSupport(i5);
            }
            _onCooperativeGesture(t4, e4, i5) {
              return !e4 && i5 < 2 && (this._cooperativeGesturesScreen.classList.add("maplibregl-show"), setTimeout(() => {
                this._cooperativeGesturesScreen.classList.remove("maplibregl-show");
              }, 100)), false;
            }
            loaded() {
              return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded();
            }
            _update(t4) {
              return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || t4, this._sourcesDirty = true, this.triggerRepaint(), this) : this;
            }
            _requestRenderFrame(t4) {
              return this._update(), this._renderTaskQueue.add(t4);
            }
            _cancelRenderFrame(t4) {
              this._renderTaskQueue.remove(t4);
            }
            _render(e4) {
              const i5 = this._idleTriggered ? this._fadeDuration : 0;
              if (this.painter.context.setDirty(), this.painter.setBaseState(), this._renderTaskQueue.run(e4), this._removed)
                return;
              let s5 = false;
              if (this.style && this._styleDirty) {
                this._styleDirty = false;
                const e5 = this.transform.zoom, a6 = t3.browser.now();
                this.style.zoomHistory.update(e5, a6);
                const o5 = new t3.EvaluationParameters(e5, { now: a6, fadeDuration: i5, zoomHistory: this.style.zoomHistory, transition: this.style.getTransition() }), r5 = o5.crossFadingFactor();
                1 === r5 && r5 === this._crossFadingFactor || (s5 = true, this._crossFadingFactor = r5), this.style.update(o5);
              }
              this.style && this._sourcesDirty && (this._sourcesDirty = false, this.style._updateSources(this.transform)), this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain), this.transform._minEleveationForCurrentTile = this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom), this._elevationFreeze || (this.transform.elevation = this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform._minEleveationForCurrentTile = 0, this.transform.elevation = 0), this._placementDirty = this.style && this.style._updatePlacement(this.painter.transform, this.showCollisionBoxes, i5, this._crossSourceCollisions), this.painter.render(this.style, { showTileBoundaries: this.showTileBoundaries, showOverdrawInspector: this._showOverdrawInspector, rotating: this.isRotating(), zooming: this.isZooming(), moving: this.isMoving(), fadeDuration: i5, showPadding: this.showPadding }), this.fire(new t3.Event("render")), this.loaded() && !this._loaded && (this._loaded = true, t3.PerformanceUtils.mark(t3.PerformanceMarkers.load), this.fire(new t3.Event("load"))), this.style && (this.style.hasTransitions() || s5) && (this._styleDirty = true), this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
              const a5 = this._sourcesDirty || this._styleDirty || this._placementDirty;
              return a5 || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new t3.Event("idle")), !this._loaded || this._fullyLoaded || a5 || (this._fullyLoaded = true, t3.PerformanceUtils.mark(t3.PerformanceMarkers.fullLoad)), this;
            }
            redraw() {
              return this.style && (this._frame && (this._frame.cancel(), this._frame = null), this._render(0)), this;
            }
            remove() {
              var e4;
              this._hash && this._hash.remove();
              for (const t4 of this._controls)
                t4.onRemove(this);
              this._controls = [], this._frame && (this._frame.cancel(), this._frame = null), this._renderTaskQueue.clear(), this.painter.destroy(), this.handlers.destroy(), delete this.handlers, this.setStyle(null), "undefined" != typeof window && removeEventListener("online", this._onWindowOnline, false), c4.removeThrottleControl(this._imageQueueHandle), null === (e4 = this._resizeObserver) || void 0 === e4 || e4.disconnect();
              const s5 = this.painter.context.gl.getExtension("WEBGL_lose_context");
              s5 && s5.loseContext(), this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, false), this._canvas.removeEventListener("webglcontextlost", this._contextLost, false), i4.remove(this._canvasContainer), i4.remove(this._controlContainer), this._cooperativeGestures && this._destroyCooperativeGestures(), this._container.classList.remove("maplibregl-map"), t3.PerformanceUtils.clearMetrics(), this._removed = true, this.fire(new t3.Event("remove"));
            }
            triggerRepaint() {
              this.style && !this._frame && (this._frame = t3.browser.frame((e4) => {
                t3.PerformanceUtils.frame(e4), this._frame = null, this._render(e4);
              }));
            }
            get showTileBoundaries() {
              return !!this._showTileBoundaries;
            }
            set showTileBoundaries(t4) {
              this._showTileBoundaries !== t4 && (this._showTileBoundaries = t4, this._update());
            }
            get showPadding() {
              return !!this._showPadding;
            }
            set showPadding(t4) {
              this._showPadding !== t4 && (this._showPadding = t4, this._update());
            }
            get showCollisionBoxes() {
              return !!this._showCollisionBoxes;
            }
            set showCollisionBoxes(t4) {
              this._showCollisionBoxes !== t4 && (this._showCollisionBoxes = t4, t4 ? this.style._generateCollisionBoxes() : this._update());
            }
            get showOverdrawInspector() {
              return !!this._showOverdrawInspector;
            }
            set showOverdrawInspector(t4) {
              this._showOverdrawInspector !== t4 && (this._showOverdrawInspector = t4, this._update());
            }
            get repaint() {
              return !!this._repaint;
            }
            set repaint(t4) {
              this._repaint !== t4 && (this._repaint = t4, this.triggerRepaint());
            }
            get vertices() {
              return !!this._vertices;
            }
            set vertices(t4) {
              this._vertices = t4, this._update();
            }
            get version() {
              return fa;
            }
            getCameraTargetElevation() {
              return this.transform.elevation;
            }
          }, Ba.NavigationControl = class {
            constructor(e4) {
              this._updateZoomButtons = () => {
                const t4 = this._map.getZoom(), e5 = t4 === this._map.getMaxZoom(), i5 = t4 === this._map.getMinZoom();
                this._zoomInButton.disabled = e5, this._zoomOutButton.disabled = i5, this._zoomInButton.setAttribute("aria-disabled", e5.toString()), this._zoomOutButton.setAttribute("aria-disabled", i5.toString());
              }, this._rotateCompassArrow = () => {
                const t4 = this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitch * (Math.PI / 180)), 0.5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${this._map.transform.angle * (180 / Math.PI)}deg)` : `rotate(${this._map.transform.angle * (180 / Math.PI)}deg)`;
                this._compassIcon.style.transform = t4;
              }, this._setButtonTitle = (t4, e5) => {
                const i5 = this._map._getUIString(`NavigationControl.${e5}`);
                t4.title = i5, t4.setAttribute("aria-label", i5);
              }, this.options = t3.extend({}, xa, e4), this._container = i4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", (t4) => this._map.zoomIn({}, { originalEvent: t4 })), i4.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"), this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", (t4) => this._map.zoomOut({}, { originalEvent: t4 })), i4.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")), this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", (t4) => {
                this.options.visualizePitch ? this._map.resetNorthPitch({}, { originalEvent: t4 }) : this._map.resetNorth({}, { originalEvent: t4 });
              }), this._compassIcon = i4.create("span", "maplibregl-ctrl-icon", this._compass), this._compassIcon.setAttribute("aria-hidden", "true"));
            }
            onAdd(t4) {
              return this._map = t4, this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"), this._setButtonTitle(this._zoomOutButton, "ZoomOut"), this._map.on("zoom", this._updateZoomButtons), this._updateZoomButtons()), this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"), this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow), this._map.on("rotate", this._rotateCompassArrow), this._rotateCompassArrow(), this._handler = new ya(this._map, this._compass, this.options.visualizePitch)), this._container;
            }
            onRemove() {
              i4.remove(this._container), this.options.showZoom && this._map.off("zoom", this._updateZoomButtons), this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow), this._map.off("rotate", this._rotateCompassArrow), this._handler.off(), delete this._handler), delete this._map;
            }
            _createButton(t4, e4) {
              const s5 = i4.create("button", t4, this._container);
              return s5.type = "button", s5.addEventListener("click", e4), s5;
            }
          }, Ba.GeolocateControl = class extends t3.Evented {
            constructor(e4) {
              super(), this._onSuccess = (e5) => {
                if (this._map) {
                  if (this._isOutOfMapMaxBounds(e5))
                    return this._setErrorState(), this.fire(new t3.Event("outofmaxbounds", e5)), this._updateMarker(), void this._finish();
                  if (this.options.trackUserLocation)
                    switch (this._lastKnownPosition = e5, this._watchState) {
                      case "WAITING_ACTIVE":
                      case "ACTIVE_LOCK":
                      case "ACTIVE_ERROR":
                        this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                        break;
                      case "BACKGROUND":
                      case "BACKGROUND_ERROR":
                        this._watchState = "BACKGROUND", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                        break;
                      default:
                        throw new Error(`Unexpected watchState ${this._watchState}`);
                    }
                  this.options.showUserLocation && "OFF" !== this._watchState && this._updateMarker(e5), this.options.trackUserLocation && "ACTIVE_LOCK" !== this._watchState || this._updateCamera(e5), this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"), this.fire(new t3.Event("geolocate", e5)), this._finish();
                }
              }, this._updateCamera = (e5) => {
                const i5 = new t3.LngLat(e5.coords.longitude, e5.coords.latitude), s5 = e5.coords.accuracy, a5 = this._map.getBearing(), o5 = t3.extend({ bearing: a5 }, this.options.fitBoundsOptions), r5 = A2.fromLngLat(i5, s5);
                this._map.fitBounds(r5, o5, { geolocateSource: true });
              }, this._updateMarker = (e5) => {
                if (e5) {
                  const i5 = new t3.LngLat(e5.coords.longitude, e5.coords.latitude);
                  this._accuracyCircleMarker.setLngLat(i5).addTo(this._map), this._userLocationDotMarker.setLngLat(i5).addTo(this._map), this._accuracy = e5.coords.accuracy, this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
                } else
                  this._userLocationDotMarker.remove(), this._accuracyCircleMarker.remove();
              }, this._onZoom = () => {
                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius();
              }, this._onError = (e5) => {
                if (this._map) {
                  if (this.options.trackUserLocation)
                    if (1 === e5.code) {
                      this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.disabled = true;
                      const t4 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                      this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4), void 0 !== this._geolocationWatchID && this._clearWatch();
                    } else {
                      if (3 === e5.code && Pa)
                        return;
                      this._setErrorState();
                    }
                  "OFF" !== this._watchState && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"), this.fire(new t3.Event("error", e5)), this._finish();
                }
              }, this._finish = () => {
                this._timeoutId && clearTimeout(this._timeoutId), this._timeoutId = void 0;
              }, this._setupUI = (e5) => {
                if (this._map) {
                  if (this._container.addEventListener("contextmenu", (t4) => t4.preventDefault()), this._geolocateButton = i4.create("button", "maplibregl-ctrl-geolocate", this._container), i4.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"), this._geolocateButton.type = "button", false === e5) {
                    t3.warnOnce("Geolocation support is not available so the GeolocateControl will be disabled.");
                    const e6 = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                    this._geolocateButton.disabled = true, this._geolocateButton.title = e6, this._geolocateButton.setAttribute("aria-label", e6);
                  } else {
                    const t4 = this._map._getUIString("GeolocateControl.FindMyLocation");
                    this._geolocateButton.title = t4, this._geolocateButton.setAttribute("aria-label", t4);
                  }
                  this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"), this._watchState = "OFF"), this.options.showUserLocation && (this._dotElement = i4.create("div", "maplibregl-user-location-dot"), this._userLocationDotMarker = new Ia({ element: this._dotElement }), this._circleElement = i4.create("div", "maplibregl-user-location-accuracy-circle"), this._accuracyCircleMarker = new Ia({ element: this._circleElement, pitchAlignment: "map" }), this.options.trackUserLocation && (this._watchState = "OFF"), this._map.on("zoom", this._onZoom)), this._geolocateButton.addEventListener("click", this.trigger.bind(this)), this._setup = true, this.options.trackUserLocation && this._map.on("movestart", (e6) => {
                    e6.geolocateSource || "ACTIVE_LOCK" !== this._watchState || e6.originalEvent && "resize" === e6.originalEvent.type || (this._watchState = "BACKGROUND", this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this.fire(new t3.Event("trackuserlocationend")));
                  });
                }
              }, this.options = t3.extend({}, Sa, e4);
            }
            onAdd(t4) {
              return this._map = t4, this._container = i4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), function(t5, e4 = false) {
                void 0 === ba || e4 ? void 0 !== window.navigator.permissions ? window.navigator.permissions.query({ name: "geolocation" }).then((e5) => {
                  ba = "denied" !== e5.state, t5(ba);
                }).catch(() => {
                  ba = !!window.navigator.geolocation, t5(ba);
                }) : (ba = !!window.navigator.geolocation, t5(ba)) : t5(ba);
              }(this._setupUI), this._container;
            }
            onRemove() {
              void 0 !== this._geolocationWatchID && (window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0), this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(), this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(), i4.remove(this._container), this._map.off("zoom", this._onZoom), this._map = void 0, Ca = 0, Pa = false;
            }
            _isOutOfMapMaxBounds(t4) {
              const e4 = this._map.getMaxBounds(), i5 = t4.coords;
              return e4 && (i5.longitude < e4.getWest() || i5.longitude > e4.getEast() || i5.latitude < e4.getSouth() || i5.latitude > e4.getNorth());
            }
            _setErrorState() {
              switch (this._watchState) {
                case "WAITING_ACTIVE":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                  break;
                case "ACTIVE_LOCK":
                  this._watchState = "ACTIVE_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "BACKGROUND":
                  this._watchState = "BACKGROUND_ERROR", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                  break;
                case "ACTIVE_ERROR":
                  break;
                default:
                  throw new Error(`Unexpected watchState ${this._watchState}`);
              }
            }
            _updateCircleRadius() {
              const t4 = this._map.getBounds(), e4 = t4.getSouthEast(), i5 = t4.getNorthEast(), s5 = e4.distanceTo(i5), a5 = Math.ceil(this._accuracy / (s5 / this._map._container.clientHeight) * 2);
              this._circleElement.style.width = `${a5}px`, this._circleElement.style.height = `${a5}px`;
            }
            trigger() {
              if (!this._setup)
                return t3.warnOnce("Geolocate control triggered before added to a map"), false;
              if (this.options.trackUserLocation) {
                switch (this._watchState) {
                  case "OFF":
                    this._watchState = "WAITING_ACTIVE", this.fire(new t3.Event("trackuserlocationstart"));
                    break;
                  case "WAITING_ACTIVE":
                  case "ACTIVE_LOCK":
                  case "ACTIVE_ERROR":
                  case "BACKGROUND_ERROR":
                    Ca--, Pa = false, this._watchState = "OFF", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"), this.fire(new t3.Event("trackuserlocationend"));
                    break;
                  case "BACKGROUND":
                    this._watchState = "ACTIVE_LOCK", this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"), this._lastKnownPosition && this._updateCamera(this._lastKnownPosition), this.fire(new t3.Event("trackuserlocationstart"));
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                switch (this._watchState) {
                  case "WAITING_ACTIVE":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "ACTIVE_LOCK":
                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                    break;
                  case "OFF":
                    break;
                  default:
                    throw new Error(`Unexpected watchState ${this._watchState}`);
                }
                if ("OFF" === this._watchState && void 0 !== this._geolocationWatchID)
                  this._clearWatch();
                else if (void 0 === this._geolocationWatchID) {
                  let t4;
                  this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "true"), Ca++, Ca > 1 ? (t4 = { maximumAge: 6e5, timeout: 0 }, Pa = true) : (t4 = this.options.positionOptions, Pa = false), this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, t4);
                }
              } else
                window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions), this._timeoutId = setTimeout(this._finish, 1e4);
              return true;
            }
            _clearWatch() {
              window.navigator.geolocation.clearWatch(this._geolocationWatchID), this._geolocationWatchID = void 0, this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"), this._geolocateButton.setAttribute("aria-pressed", "false"), this.options.showUserLocation && this._updateMarker(null);
            }
          }, Ba.AttributionControl = ra, Ba.LogoControl = na, Ba.ScaleControl = class {
            constructor(e4) {
              this._onMove = () => {
                Ma(this._map, this._container, this.options);
              }, this.setUnit = (t4) => {
                this.options.unit = t4, Ma(this._map, this._container, this.options);
              }, this.options = t3.extend({}, Da, e4);
            }
            getDefaultPosition() {
              return "bottom-left";
            }
            onAdd(t4) {
              return this._map = t4, this._container = i4.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", t4.getContainer()), this._map.on("move", this._onMove), this._onMove(), this._container;
            }
            onRemove() {
              i4.remove(this._container), this._map.off("move", this._onMove), this._map = void 0;
            }
          }, Ba.FullscreenControl = class extends t3.Evented {
            constructor(e4 = {}) {
              super(), this._onFullscreenChange = () => {
                (window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement) === this._container !== this._fullscreen && this._handleFullscreenChange();
              }, this._onClickFullscreen = () => {
                this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen();
              }, this._fullscreen = false, e4 && e4.container && (e4.container instanceof HTMLElement ? this._container = e4.container : t3.warnOnce("Full screen control 'container' must be a DOM element.")), "onfullscreenchange" in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange" in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange" in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange" in document && (this._fullscreenchange = "MSFullscreenChange");
            }
            onAdd(t4) {
              return this._map = t4, this._container || (this._container = this._map.getContainer()), this._controlContainer = i4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._setupUI(), this._controlContainer;
            }
            onRemove() {
              i4.remove(this._controlContainer), this._map = null, window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _setupUI() {
              const t4 = this._fullscreenButton = i4.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
              i4.create("span", "maplibregl-ctrl-icon", t4).setAttribute("aria-hidden", "true"), t4.type = "button", this._updateTitle(), this._fullscreenButton.addEventListener("click", this._onClickFullscreen), window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange);
            }
            _updateTitle() {
              const t4 = this._getTitle();
              this._fullscreenButton.setAttribute("aria-label", t4), this._fullscreenButton.title = t4;
            }
            _getTitle() {
              return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter");
            }
            _isFullscreen() {
              return this._fullscreen;
            }
            _handleFullscreenChange() {
              this._fullscreen = !this._fullscreen, this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"), this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"), this._updateTitle(), this._fullscreen ? (this.fire(new t3.Event("fullscreenstart")), this._map._cooperativeGestures && (this._prevCooperativeGestures = this._map._cooperativeGestures, this._map.setCooperativeGestures())) : (this.fire(new t3.Event("fullscreenend")), this._prevCooperativeGestures && (this._map.setCooperativeGestures(this._prevCooperativeGestures), delete this._prevCooperativeGestures));
            }
            _exitFullscreen() {
              window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen();
            }
            _requestFullscreen() {
              this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen();
            }
            _togglePseudoFullScreen() {
              this._container.classList.toggle("maplibregl-pseudo-fullscreen"), this._handleFullscreenChange(), this._map.resize();
            }
          }, Ba.TerrainControl = class {
            constructor(t4) {
              this._toggleTerrain = () => {
                this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options), this._updateTerrainIcon();
              }, this._updateTerrainIcon = () => {
                this._terrainButton.classList.remove("maplibregl-ctrl-terrain"), this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"), this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"), this._terrainButton.title = this._map._getUIString("TerrainControl.disableTerrain")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"), this._terrainButton.title = this._map._getUIString("TerrainControl.enableTerrain"));
              }, this.options = t4;
            }
            onAdd(t4) {
              return this._map = t4, this._container = i4.create("div", "maplibregl-ctrl maplibregl-ctrl-group"), this._terrainButton = i4.create("button", "maplibregl-ctrl-terrain", this._container), i4.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"), this._terrainButton.type = "button", this._terrainButton.addEventListener("click", this._toggleTerrain), this._updateTerrainIcon(), this._map.on("terrain", this._updateTerrainIcon), this._container;
            }
            onRemove() {
              i4.remove(this._container), this._map.off("terrain", this._updateTerrainIcon), this._map = void 0;
            }
          }, Ba.Popup = class extends t3.Evented {
            constructor(e4) {
              super(), this.remove = () => (this._content && i4.remove(this._content), this._container && (i4.remove(this._container), delete this._container), this._map && (this._map.off("move", this._update), this._map.off("move", this._onClose), this._map.off("click", this._onClose), this._map.off("remove", this.remove), this._map.off("mousemove", this._onMouseMove), this._map.off("mouseup", this._onMouseUp), this._map.off("drag", this._onDrag), delete this._map), this.fire(new t3.Event("close")), this), this._onMouseUp = (t4) => {
                this._update(t4.point);
              }, this._onMouseMove = (t4) => {
                this._update(t4.point);
              }, this._onDrag = (t4) => {
                this._update(t4.point);
              }, this._update = (t4) => {
                if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                  return;
                if (!this._container) {
                  if (this._container = i4.create("div", "maplibregl-popup", this._map.getContainer()), this._tip = i4.create("div", "maplibregl-popup-tip", this._container), this._container.appendChild(this._content), this.options.className)
                    for (const t5 of this.options.className.split(" "))
                      this._container.classList.add(t5);
                  this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer");
                }
                if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth), this._map.transform.renderWorldCopies && !this._trackPointer && (this._lngLat = wa(this._lngLat, this._pos, this._map.transform)), this._trackPointer && !t4)
                  return;
                const e5 = this._pos = this._trackPointer && t4 ? t4 : this._map.project(this._lngLat);
                let s5 = this.options.anchor;
                const a5 = Ra(this.options.offset);
                if (!s5) {
                  const t5 = this._container.offsetWidth, i5 = this._container.offsetHeight;
                  let o6;
                  o6 = e5.y + a5.bottom.y < i5 ? ["top"] : e5.y > this._map.transform.height - i5 ? ["bottom"] : [], e5.x < t5 / 2 ? o6.push("left") : e5.x > this._map.transform.width - t5 / 2 && o6.push("right"), s5 = 0 === o6.length ? "bottom" : o6.join("-");
                }
                const o5 = e5.add(a5[s5]).round();
                i4.setTransform(this._container, `${Ta[s5]} translate(${o5.x}px,${o5.y}px)`), Ea(this._container, s5, "popup");
              }, this._onClose = () => {
                this.remove();
              }, this.options = t3.extend(Object.create(Aa), e4);
            }
            addTo(e4) {
              return this._map && this.remove(), this._map = e4, this.options.closeOnClick && this._map.on("click", this._onClose), this.options.closeOnMove && this._map.on("move", this._onClose), this._map.on("remove", this.remove), this._update(), this._focusFirstElement(), this._trackPointer ? (this._map.on("mousemove", this._onMouseMove), this._map.on("mouseup", this._onMouseUp), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update), this.fire(new t3.Event("open")), this;
            }
            isOpen() {
              return !!this._map;
            }
            getLngLat() {
              return this._lngLat;
            }
            setLngLat(e4) {
              return this._lngLat = t3.LngLat.convert(e4), this._pos = null, this._trackPointer = false, this._update(), this._map && (this._map.on("move", this._update), this._map.off("mousemove", this._onMouseMove), this._container && this._container.classList.remove("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.remove("maplibregl-track-pointer")), this;
            }
            trackPointer() {
              return this._trackPointer = true, this._pos = null, this._update(), this._map && (this._map.off("move", this._update), this._map.on("mousemove", this._onMouseMove), this._map.on("drag", this._onDrag), this._container && this._container.classList.add("maplibregl-popup-track-pointer"), this._map._canvasContainer.classList.add("maplibregl-track-pointer")), this;
            }
            getElement() {
              return this._container;
            }
            setText(t4) {
              return this.setDOMContent(document.createTextNode(t4));
            }
            setHTML(t4) {
              const e4 = document.createDocumentFragment(), i5 = document.createElement("body");
              let s5;
              for (i5.innerHTML = t4; s5 = i5.firstChild, s5; )
                e4.appendChild(s5);
              return this.setDOMContent(e4);
            }
            getMaxWidth() {
              var t4;
              return null === (t4 = this._container) || void 0 === t4 ? void 0 : t4.style.maxWidth;
            }
            setMaxWidth(t4) {
              return this.options.maxWidth = t4, this._update(), this;
            }
            setDOMContent(t4) {
              if (this._content)
                for (; this._content.hasChildNodes(); )
                  this._content.firstChild && this._content.removeChild(this._content.firstChild);
              else
                this._content = i4.create("div", "maplibregl-popup-content", this._container);
              return this._content.appendChild(t4), this._createCloseButton(), this._update(), this._focusFirstElement(), this;
            }
            addClassName(t4) {
              this._container && this._container.classList.add(t4);
            }
            removeClassName(t4) {
              this._container && this._container.classList.remove(t4);
            }
            setOffset(t4) {
              return this.options.offset = t4, this._update(), this;
            }
            toggleClassName(t4) {
              if (this._container)
                return this._container.classList.toggle(t4);
            }
            _createCloseButton() {
              this.options.closeButton && (this._closeButton = i4.create("button", "maplibregl-popup-close-button", this._content), this._closeButton.type = "button", this._closeButton.setAttribute("aria-label", "Close popup"), this._closeButton.innerHTML = "&#215;", this._closeButton.addEventListener("click", this._onClose));
            }
            _focusFirstElement() {
              if (!this.options.focusAfterOpen || !this._container)
                return;
              const t4 = this._container.querySelector(La);
              t4 && t4.focus();
            }
          }, Ba.Marker = Ia, Ba.Style = se, Ba.LngLat = t3.LngLat, Ba.LngLatBounds = A2, Ba.Point = t3.Point, Ba.MercatorCoordinate = t3.MercatorCoordinate, Ba.Evented = t3.Evented, Ba.AJAXError = t3.AJAXError, Ba.config = t3.config, Ba.CanvasSource = Z, Ba.GeoJSONSource = B3, Ba.ImageSource = O2, Ba.RasterDEMTileSource = F3, Ba.RasterTileSource = k3, Ba.VectorTileSource = R, Ba.VideoSource = N2, Ba.setRTLTextPlugin = t3.setRTLTextPlugin, Ba.getRTLTextPluginStatus = t3.getRTLTextPluginStatus, Ba.prewarm = function() {
            st().acquire(Q);
          }, Ba.clearPrewarmedResources = function() {
            const t4 = it;
            t4 && (t4.isPreloaded() && 1 === t4.numActive() ? (t4.release(Q), it = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"));
          }, ka.extend(Ba, { isSafari: t3.isSafari, getPerformanceMetrics: t3.PerformanceUtils.getPerformanceMetrics }), Ba;
        });
        var maplibregl$1 = maplibregl;
        return maplibregl$1;
      });
    }
  });

  // node_modules/lodash.debounce/index.js
  var require_lodash = __commonJS({
    "node_modules/lodash.debounce/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now = function() {
        return root.Date.now();
      };
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = debounce2;
    }
  });

  // node_modules/lodash.throttle/index.js
  var require_lodash2 = __commonJS({
    "node_modules/lodash.throttle/index.js"(exports, module) {
      var FUNC_ERROR_TEXT = "Expected a function";
      var NAN = 0 / 0;
      var symbolTag = "[object Symbol]";
      var reTrim = /^\s+|\s+$/g;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsOctal = /^0o[0-7]+$/i;
      var freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var objectProto = Object.prototype;
      var objectToString = objectProto.toString;
      var nativeMax = Math.max;
      var nativeMin = Math.min;
      var now = function() {
        return root.Date.now();
      };
      function debounce2(func, wait, options) {
        var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        wait = toNumber(wait) || 0;
        if (isObject(options)) {
          leading = !!options.leading;
          maxing = "maxWait" in options;
          maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        function invokeFunc(time) {
          var args = lastArgs, thisArg = lastThis;
          lastArgs = lastThis = void 0;
          lastInvokeTime = time;
          result = func.apply(thisArg, args);
          return result;
        }
        function leadingEdge(time) {
          lastInvokeTime = time;
          timerId = setTimeout(timerExpired, wait);
          return leading ? invokeFunc(time) : result;
        }
        function remainingWait(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
          return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
        }
        function shouldInvoke(time) {
          var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
          return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
        }
        function timerExpired() {
          var time = now();
          if (shouldInvoke(time)) {
            return trailingEdge(time);
          }
          timerId = setTimeout(timerExpired, remainingWait(time));
        }
        function trailingEdge(time) {
          timerId = void 0;
          if (trailing && lastArgs) {
            return invokeFunc(time);
          }
          lastArgs = lastThis = void 0;
          return result;
        }
        function cancel() {
          if (timerId !== void 0) {
            clearTimeout(timerId);
          }
          lastInvokeTime = 0;
          lastArgs = lastCallTime = lastThis = timerId = void 0;
        }
        function flush() {
          return timerId === void 0 ? result : trailingEdge(now());
        }
        function debounced() {
          var time = now(), isInvoking = shouldInvoke(time);
          lastArgs = arguments;
          lastThis = this;
          lastCallTime = time;
          if (isInvoking) {
            if (timerId === void 0) {
              return leadingEdge(lastCallTime);
            }
            if (maxing) {
              timerId = setTimeout(timerExpired, wait);
              return invokeFunc(lastCallTime);
            }
          }
          if (timerId === void 0) {
            timerId = setTimeout(timerExpired, wait);
          }
          return result;
        }
        debounced.cancel = cancel;
        debounced.flush = flush;
        return debounced;
      }
      function throttle2(func, wait, options) {
        var leading = true, trailing = true;
        if (typeof func != "function") {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        if (isObject(options)) {
          leading = "leading" in options ? !!options.leading : leading;
          trailing = "trailing" in options ? !!options.trailing : trailing;
        }
        return debounce2(func, wait, {
          "leading": leading,
          "maxWait": wait,
          "trailing": trailing
        });
      }
      function isObject(value) {
        var type = typeof value;
        return !!value && (type == "object" || type == "function");
      }
      function isObjectLike(value) {
        return !!value && typeof value == "object";
      }
      function isSymbol(value) {
        return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
      }
      function toNumber(value) {
        if (typeof value == "number") {
          return value;
        }
        if (isSymbol(value)) {
          return NAN;
        }
        if (isObject(value)) {
          var other = typeof value.valueOf == "function" ? value.valueOf() : value;
          value = isObject(other) ? other + "" : other;
        }
        if (typeof value != "string") {
          return value === 0 ? value : +value;
        }
        value = value.replace(reTrim, "");
        var isBinary = reIsBinary.test(value);
        return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
      }
      module.exports = throttle2;
    }
  });

  // node_modules/dlv/dist/dlv.umd.js
  var require_dlv_umd = __commonJS({
    "node_modules/dlv/dist/dlv.umd.js"(exports, module) {
      !function(t3, n2) {
        "object" == typeof exports && "undefined" != typeof module ? module.exports = function(t4, n3, e3, i4, o4) {
          for (n3 = n3.split ? n3.split(".") : n3, i4 = 0; i4 < n3.length; i4++)
            t4 = t4 ? t4[n3[i4]] : o4;
          return t4 === o4 ? e3 : t4;
        } : "function" == typeof define && define.amd ? define(function() {
          return function(t4, n3, e3, i4, o4) {
            for (n3 = n3.split ? n3.split(".") : n3, i4 = 0; i4 < n3.length; i4++)
              t4 = t4 ? t4[n3[i4]] : o4;
            return t4 === o4 ? e3 : t4;
          };
        }) : t3.dlv = function(t4, n3, e3, i4, o4) {
          for (n3 = n3.split ? n3.split(".") : n3, i4 = 0; i4 < n3.length; i4++)
            t4 = t4 ? t4[n3[i4]] : o4;
          return t4 === o4 ? e3 : t4;
        };
      }(exports);
    }
  });

  // node_modules/preact/dist/preact.module.js
  var n;
  var l;
  var u;
  var t;
  var i;
  var o;
  var r;
  var f;
  var e;
  var c = {};
  var s = [];
  var a = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
  var v = Array.isArray;
  function h(n2, l4) {
    for (var u4 in l4)
      n2[u4] = l4[u4];
    return n2;
  }
  function p(n2) {
    var l4 = n2.parentNode;
    l4 && l4.removeChild(n2);
  }
  function y(l4, u4, t3) {
    var i4, o4, r4, f3 = {};
    for (r4 in u4)
      "key" == r4 ? i4 = u4[r4] : "ref" == r4 ? o4 = u4[r4] : f3[r4] = u4[r4];
    if (arguments.length > 2 && (f3.children = arguments.length > 3 ? n.call(arguments, 2) : t3), "function" == typeof l4 && null != l4.defaultProps)
      for (r4 in l4.defaultProps)
        void 0 === f3[r4] && (f3[r4] = l4.defaultProps[r4]);
    return d(l4, f3, i4, o4, null);
  }
  function d(n2, t3, i4, o4, r4) {
    var f3 = { type: n2, props: t3, key: i4, ref: o4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: null == r4 ? ++u : r4 };
    return null == r4 && null != l.vnode && l.vnode(f3), f3;
  }
  function k(n2) {
    return n2.children;
  }
  function b(n2, l4) {
    this.props = n2, this.context = l4;
  }
  function g(n2, l4) {
    if (null == l4)
      return n2.__ ? g(n2.__, n2.__.__k.indexOf(n2) + 1) : null;
    for (var u4; l4 < n2.__k.length; l4++)
      if (null != (u4 = n2.__k[l4]) && null != u4.__e)
        return u4.__d || u4.__e;
    return "function" == typeof n2.type ? g(n2) : null;
  }
  function m(n2) {
    var l4, u4;
    if (null != (n2 = n2.__) && null != n2.__c) {
      for (n2.__e = n2.__c.base = null, l4 = 0; l4 < n2.__k.length; l4++)
        if (null != (u4 = n2.__k[l4]) && null != u4.__e) {
          n2.__e = n2.__c.base = u4.__e;
          break;
        }
      return m(n2);
    }
  }
  function w(n2) {
    (!n2.__d && (n2.__d = true) && i.push(n2) && !x.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(x);
  }
  function x() {
    var n2, l4, u4, t3, o4, r4, e3, c4, s4;
    for (i.sort(f); n2 = i.shift(); )
      n2.__d && (l4 = i.length, t3 = void 0, o4 = void 0, r4 = void 0, c4 = (e3 = (u4 = n2).__v).__e, (s4 = u4.__P) && (t3 = [], o4 = [], (r4 = h({}, e3)).__v = e3.__v + 1, z(s4, e3, r4, u4.__n, void 0 !== s4.ownerSVGElement, null != e3.__h ? [c4] : null, t3, null == c4 ? g(e3) : c4, e3.__h, o4), L(t3, e3, o4), e3.__e != c4 && m(e3)), i.length > l4 && i.sort(f));
    x.__r = 0;
  }
  function P(n2, l4, u4, t3, i4, o4, r4, f3, e3, a4, h3) {
    var p6, y2, _3, b3, m3, w3, x2, P2, C, D2 = 0, H2 = t3 && t3.__k || s, I2 = H2.length, T2 = I2, j3 = l4.length;
    for (u4.__k = [], p6 = 0; p6 < j3; p6++)
      null != (b3 = u4.__k[p6] = null == (b3 = l4[p6]) || "boolean" == typeof b3 || "function" == typeof b3 ? null : "string" == typeof b3 || "number" == typeof b3 || "bigint" == typeof b3 ? d(null, b3, null, null, b3) : v(b3) ? d(k, { children: b3 }, null, null, null) : b3.__b > 0 ? d(b3.type, b3.props, b3.key, b3.ref ? b3.ref : null, b3.__v) : b3) ? (b3.__ = u4, b3.__b = u4.__b + 1, -1 === (P2 = A(b3, H2, x2 = p6 + D2, T2)) ? _3 = c : (_3 = H2[P2] || c, H2[P2] = void 0, T2--), z(n2, b3, _3, i4, o4, r4, f3, e3, a4, h3), m3 = b3.__e, (y2 = b3.ref) && _3.ref != y2 && (_3.ref && N(_3.ref, null, b3), h3.push(y2, b3.__c || m3, b3)), null != m3 && (null == w3 && (w3 = m3), (C = _3 === c || null === _3.__v) ? -1 == P2 && D2-- : P2 !== x2 && (P2 === x2 + 1 ? D2++ : P2 > x2 ? T2 > j3 - x2 ? D2 += P2 - x2 : D2-- : D2 = P2 < x2 && P2 == x2 - 1 ? P2 - x2 : 0), x2 = p6 + D2, "function" != typeof b3.type || P2 === x2 && _3.__k !== b3.__k ? "function" == typeof b3.type || P2 === x2 && !C ? void 0 !== b3.__d ? (e3 = b3.__d, b3.__d = void 0) : e3 = m3.nextSibling : e3 = S(n2, m3, e3) : e3 = $(b3, e3, n2), "function" == typeof u4.type && (u4.__d = e3))) : (_3 = H2[p6]) && null == _3.key && _3.__e && (_3.__e == e3 && (_3.__ = t3, e3 = g(_3)), O(_3, _3, false), H2[p6] = null);
    for (u4.__e = w3, p6 = I2; p6--; )
      null != H2[p6] && ("function" == typeof u4.type && null != H2[p6].__e && H2[p6].__e == u4.__d && (u4.__d = H2[p6].__e.nextSibling), O(H2[p6], H2[p6]));
  }
  function $(n2, l4, u4) {
    for (var t3, i4 = n2.__k, o4 = 0; i4 && o4 < i4.length; o4++)
      (t3 = i4[o4]) && (t3.__ = n2, l4 = "function" == typeof t3.type ? $(t3, l4, u4) : S(u4, t3.__e, l4));
    return l4;
  }
  function S(n2, l4, u4) {
    return null == u4 || u4.parentNode !== n2 ? n2.insertBefore(l4, null) : l4 == u4 && null != l4.parentNode || n2.insertBefore(l4, u4), l4.nextSibling;
  }
  function A(n2, l4, u4, t3) {
    var i4 = n2.key, o4 = n2.type, r4 = u4 - 1, f3 = u4 + 1, e3 = l4[u4];
    if (null === e3 || e3 && i4 == e3.key && o4 === e3.type)
      return u4;
    if (t3 > (null != e3 ? 1 : 0))
      for (; r4 >= 0 || f3 < l4.length; ) {
        if (r4 >= 0) {
          if ((e3 = l4[r4]) && i4 == e3.key && o4 === e3.type)
            return r4;
          r4--;
        }
        if (f3 < l4.length) {
          if ((e3 = l4[f3]) && i4 == e3.key && o4 === e3.type)
            return f3;
          f3++;
        }
      }
    return -1;
  }
  function D(n2, l4, u4, t3, i4) {
    var o4;
    for (o4 in u4)
      "children" === o4 || "key" === o4 || o4 in l4 || I(n2, o4, null, u4[o4], t3);
    for (o4 in l4)
      i4 && "function" != typeof l4[o4] || "children" === o4 || "key" === o4 || "value" === o4 || "checked" === o4 || u4[o4] === l4[o4] || I(n2, o4, l4[o4], u4[o4], t3);
  }
  function H(n2, l4, u4) {
    "-" === l4[0] ? n2.setProperty(l4, null == u4 ? "" : u4) : n2[l4] = null == u4 ? "" : "number" != typeof u4 || a.test(l4) ? u4 : u4 + "px";
  }
  function I(n2, l4, u4, t3, i4) {
    var o4;
    n:
      if ("style" === l4)
        if ("string" == typeof u4)
          n2.style.cssText = u4;
        else {
          if ("string" == typeof t3 && (n2.style.cssText = t3 = ""), t3)
            for (l4 in t3)
              u4 && l4 in u4 || H(n2.style, l4, "");
          if (u4)
            for (l4 in u4)
              t3 && u4[l4] === t3[l4] || H(n2.style, l4, u4[l4]);
        }
      else if ("o" === l4[0] && "n" === l4[1])
        o4 = l4 !== (l4 = l4.replace(/(PointerCapture)$|Capture$/, "$1")), l4 = l4.toLowerCase() in n2 ? l4.toLowerCase().slice(2) : l4.slice(2), n2.l || (n2.l = {}), n2.l[l4 + o4] = u4, u4 ? t3 ? u4.u = t3.u : (u4.u = Date.now(), n2.addEventListener(l4, o4 ? j : T, o4)) : n2.removeEventListener(l4, o4 ? j : T, o4);
      else if ("dangerouslySetInnerHTML" !== l4) {
        if (i4)
          l4 = l4.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l4 && "height" !== l4 && "href" !== l4 && "list" !== l4 && "form" !== l4 && "tabIndex" !== l4 && "download" !== l4 && "rowSpan" !== l4 && "colSpan" !== l4 && "role" !== l4 && l4 in n2)
          try {
            n2[l4] = null == u4 ? "" : u4;
            break n;
          } catch (n3) {
          }
        "function" == typeof u4 || (null == u4 || false === u4 && "-" !== l4[4] ? n2.removeAttribute(l4) : n2.setAttribute(l4, u4));
      }
  }
  function T(n2) {
    var u4 = this.l[n2.type + false];
    if (n2.t) {
      if (n2.t <= u4.u)
        return;
    } else
      n2.t = Date.now();
    return u4(l.event ? l.event(n2) : n2);
  }
  function j(n2) {
    return this.l[n2.type + true](l.event ? l.event(n2) : n2);
  }
  function z(n2, u4, t3, i4, o4, r4, f3, e3, c4, s4) {
    var a4, p6, y2, d3, _3, g3, m3, w3, x2, $2, C, S2, A2, D2, H2, I2 = u4.type;
    if (void 0 !== u4.constructor)
      return null;
    null != t3.__h && (c4 = t3.__h, e3 = u4.__e = t3.__e, u4.__h = null, r4 = [e3]), (a4 = l.__b) && a4(u4);
    n:
      if ("function" == typeof I2)
        try {
          if (w3 = u4.props, x2 = (a4 = I2.contextType) && i4[a4.__c], $2 = a4 ? x2 ? x2.props.value : a4.__ : i4, t3.__c ? m3 = (p6 = u4.__c = t3.__c).__ = p6.__E : ("prototype" in I2 && I2.prototype.render ? u4.__c = p6 = new I2(w3, $2) : (u4.__c = p6 = new b(w3, $2), p6.constructor = I2, p6.render = q), x2 && x2.sub(p6), p6.props = w3, p6.state || (p6.state = {}), p6.context = $2, p6.__n = i4, y2 = p6.__d = true, p6.__h = [], p6._sb = []), null == p6.__s && (p6.__s = p6.state), null != I2.getDerivedStateFromProps && (p6.__s == p6.state && (p6.__s = h({}, p6.__s)), h(p6.__s, I2.getDerivedStateFromProps(w3, p6.__s))), d3 = p6.props, _3 = p6.state, p6.__v = u4, y2)
            null == I2.getDerivedStateFromProps && null != p6.componentWillMount && p6.componentWillMount(), null != p6.componentDidMount && p6.__h.push(p6.componentDidMount);
          else {
            if (null == I2.getDerivedStateFromProps && w3 !== d3 && null != p6.componentWillReceiveProps && p6.componentWillReceiveProps(w3, $2), !p6.__e && (null != p6.shouldComponentUpdate && false === p6.shouldComponentUpdate(w3, p6.__s, $2) || u4.__v === t3.__v)) {
              for (u4.__v !== t3.__v && (p6.props = w3, p6.state = p6.__s, p6.__d = false), u4.__e = t3.__e, u4.__k = t3.__k, u4.__k.forEach(function(n3) {
                n3 && (n3.__ = u4);
              }), C = 0; C < p6._sb.length; C++)
                p6.__h.push(p6._sb[C]);
              p6._sb = [], p6.__h.length && f3.push(p6);
              break n;
            }
            null != p6.componentWillUpdate && p6.componentWillUpdate(w3, p6.__s, $2), null != p6.componentDidUpdate && p6.__h.push(function() {
              p6.componentDidUpdate(d3, _3, g3);
            });
          }
          if (p6.context = $2, p6.props = w3, p6.__P = n2, p6.__e = false, S2 = l.__r, A2 = 0, "prototype" in I2 && I2.prototype.render) {
            for (p6.state = p6.__s, p6.__d = false, S2 && S2(u4), a4 = p6.render(p6.props, p6.state, p6.context), D2 = 0; D2 < p6._sb.length; D2++)
              p6.__h.push(p6._sb[D2]);
            p6._sb = [];
          } else
            do {
              p6.__d = false, S2 && S2(u4), a4 = p6.render(p6.props, p6.state, p6.context), p6.state = p6.__s;
            } while (p6.__d && ++A2 < 25);
          p6.state = p6.__s, null != p6.getChildContext && (i4 = h(h({}, i4), p6.getChildContext())), y2 || null == p6.getSnapshotBeforeUpdate || (g3 = p6.getSnapshotBeforeUpdate(d3, _3)), P(n2, v(H2 = null != a4 && a4.type === k && null == a4.key ? a4.props.children : a4) ? H2 : [H2], u4, t3, i4, o4, r4, f3, e3, c4, s4), p6.base = u4.__e, u4.__h = null, p6.__h.length && f3.push(p6), m3 && (p6.__E = p6.__ = null);
        } catch (n3) {
          u4.__v = null, (c4 || null != r4) && (u4.__e = e3, u4.__h = !!c4, r4[r4.indexOf(e3)] = null), l.__e(n3, u4, t3);
        }
      else
        null == r4 && u4.__v === t3.__v ? (u4.__k = t3.__k, u4.__e = t3.__e) : u4.__e = M(t3.__e, u4, t3, i4, o4, r4, f3, c4, s4);
    (a4 = l.diffed) && a4(u4);
  }
  function L(n2, u4, t3) {
    for (var i4 = 0; i4 < t3.length; i4++)
      N(t3[i4], t3[++i4], t3[++i4]);
    l.__c && l.__c(u4, n2), n2.some(function(u5) {
      try {
        n2 = u5.__h, u5.__h = [], n2.some(function(n3) {
          n3.call(u5);
        });
      } catch (n3) {
        l.__e(n3, u5.__v);
      }
    });
  }
  function M(l4, u4, t3, i4, o4, r4, f3, e3, s4) {
    var a4, h3, y2, d3 = t3.props, _3 = u4.props, k3 = u4.type, b3 = 0;
    if ("svg" === k3 && (o4 = true), null != r4) {
      for (; b3 < r4.length; b3++)
        if ((a4 = r4[b3]) && "setAttribute" in a4 == !!k3 && (k3 ? a4.localName === k3 : 3 === a4.nodeType)) {
          l4 = a4, r4[b3] = null;
          break;
        }
    }
    if (null == l4) {
      if (null === k3)
        return document.createTextNode(_3);
      l4 = o4 ? document.createElementNS("http://www.w3.org/2000/svg", k3) : document.createElement(k3, _3.is && _3), r4 = null, e3 = false;
    }
    if (null === k3)
      d3 === _3 || e3 && l4.data === _3 || (l4.data = _3);
    else {
      if (r4 = r4 && n.call(l4.childNodes), h3 = (d3 = t3.props || c).dangerouslySetInnerHTML, y2 = _3.dangerouslySetInnerHTML, !e3) {
        if (null != r4)
          for (d3 = {}, b3 = 0; b3 < l4.attributes.length; b3++)
            d3[l4.attributes[b3].name] = l4.attributes[b3].value;
        (y2 || h3) && (y2 && (h3 && y2.__html == h3.__html || y2.__html === l4.innerHTML) || (l4.innerHTML = y2 && y2.__html || ""));
      }
      if (D(l4, _3, d3, o4, e3), y2)
        u4.__k = [];
      else if (P(l4, v(b3 = u4.props.children) ? b3 : [b3], u4, t3, i4, o4 && "foreignObject" !== k3, r4, f3, r4 ? r4[0] : t3.__k && g(t3, 0), e3, s4), null != r4)
        for (b3 = r4.length; b3--; )
          null != r4[b3] && p(r4[b3]);
      e3 || ("value" in _3 && void 0 !== (b3 = _3.value) && (b3 !== l4.value || "progress" === k3 && !b3 || "option" === k3 && b3 !== d3.value) && I(l4, "value", b3, d3.value, false), "checked" in _3 && void 0 !== (b3 = _3.checked) && b3 !== l4.checked && I(l4, "checked", b3, d3.checked, false));
    }
    return l4;
  }
  function N(n2, u4, t3) {
    try {
      "function" == typeof n2 ? n2(u4) : n2.current = u4;
    } catch (n3) {
      l.__e(n3, t3);
    }
  }
  function O(n2, u4, t3) {
    var i4, o4;
    if (l.unmount && l.unmount(n2), (i4 = n2.ref) && (i4.current && i4.current !== n2.__e || N(i4, null, u4)), null != (i4 = n2.__c)) {
      if (i4.componentWillUnmount)
        try {
          i4.componentWillUnmount();
        } catch (n3) {
          l.__e(n3, u4);
        }
      i4.base = i4.__P = null, n2.__c = void 0;
    }
    if (i4 = n2.__k)
      for (o4 = 0; o4 < i4.length; o4++)
        i4[o4] && O(i4[o4], u4, t3 || "function" != typeof n2.type);
    t3 || null == n2.__e || p(n2.__e), n2.__ = n2.__e = n2.__d = void 0;
  }
  function q(n2, l4, u4) {
    return this.constructor(n2, u4);
  }
  function B(u4, t3, i4) {
    var o4, r4, f3, e3;
    l.__ && l.__(u4, t3), r4 = (o4 = "function" == typeof i4) ? null : i4 && i4.__k || t3.__k, f3 = [], e3 = [], z(t3, u4 = (!o4 && i4 || t3).__k = y(k, null, [u4]), r4 || c, c, void 0 !== t3.ownerSVGElement, !o4 && i4 ? [i4] : r4 ? null : t3.firstChild ? n.call(t3.childNodes) : null, f3, !o4 && i4 ? i4 : r4 ? r4.__e : t3.firstChild, o4, e3), L(f3, u4, e3);
  }
  function E(n2, l4) {
    B(n2, l4, E);
  }
  function F(l4, u4, t3) {
    var i4, o4, r4, f3, e3 = h({}, l4.props);
    for (r4 in l4.type && l4.type.defaultProps && (f3 = l4.type.defaultProps), u4)
      "key" == r4 ? i4 = u4[r4] : "ref" == r4 ? o4 = u4[r4] : e3[r4] = void 0 === u4[r4] && void 0 !== f3 ? f3[r4] : u4[r4];
    return arguments.length > 2 && (e3.children = arguments.length > 3 ? n.call(arguments, 2) : t3), d(l4.type, e3, i4 || l4.key, o4 || l4.ref, null);
  }
  function G(n2, l4) {
    var u4 = { __c: l4 = "__cC" + e++, __: n2, Consumer: function(n3, l5) {
      return n3.children(l5);
    }, Provider: function(n3) {
      var u5, t3;
      return this.getChildContext || (u5 = [], (t3 = {})[l4] = this, this.getChildContext = function() {
        return t3;
      }, this.shouldComponentUpdate = function(n4) {
        this.props.value !== n4.value && u5.some(function(n5) {
          n5.__e = true, w(n5);
        });
      }, this.sub = function(n4) {
        u5.push(n4);
        var l5 = n4.componentWillUnmount;
        n4.componentWillUnmount = function() {
          u5.splice(u5.indexOf(n4), 1), l5 && l5.call(n4);
        };
      }), n3.children;
    } };
    return u4.Provider.__ = u4.Consumer.contextType = u4;
  }
  n = s.slice, l = { __e: function(n2, l4, u4, t3) {
    for (var i4, o4, r4; l4 = l4.__; )
      if ((i4 = l4.__c) && !i4.__)
        try {
          if ((o4 = i4.constructor) && null != o4.getDerivedStateFromError && (i4.setState(o4.getDerivedStateFromError(n2)), r4 = i4.__d), null != i4.componentDidCatch && (i4.componentDidCatch(n2, t3 || {}), r4 = i4.__d), r4)
            return i4.__E = i4;
        } catch (l5) {
          n2 = l5;
        }
    throw n2;
  } }, u = 0, t = function(n2) {
    return null != n2 && void 0 === n2.constructor;
  }, b.prototype.setState = function(n2, l4) {
    var u4;
    u4 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = h({}, this.state), "function" == typeof n2 && (n2 = n2(h({}, u4), this.props)), n2 && h(u4, n2), null != n2 && this.__v && (l4 && this._sb.push(l4), w(this));
  }, b.prototype.forceUpdate = function(n2) {
    this.__v && (this.__e = true, n2 && this.__h.push(n2), w(this));
  }, b.prototype.render = k, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n2, l4) {
    return n2.__v.__b - l4.__v.__b;
  }, x.__r = 0, e = 0;

  // node_modules/preact-custom-element/dist/preact-custom-element.esm.js
  function r2() {
    return (r2 = Object.assign ? Object.assign.bind() : function(t3) {
      for (var e3 = 1; e3 < arguments.length; e3++) {
        var n2 = arguments[e3];
        for (var o4 in n2)
          Object.prototype.hasOwnProperty.call(n2, o4) && (t3[o4] = n2[o4]);
      }
      return t3;
    }).apply(this, arguments);
  }
  var i2 = ["context", "children"];
  function a2(t3) {
    this.getChildContext = function() {
      return t3.context;
    };
    var e3 = t3.children, n2 = function(t4, e4) {
      if (null == t4)
        return {};
      var n3, o4, r4 = {}, i4 = Object.keys(t4);
      for (o4 = 0; o4 < i4.length; o4++)
        e4.indexOf(n3 = i4[o4]) >= 0 || (r4[n3] = t4[n3]);
      return r4;
    }(t3, i2);
    return F(e3, n2);
  }
  function s2() {
    var o4 = new CustomEvent("_preact", { detail: {}, bubbles: true, cancelable: true });
    this.dispatchEvent(o4), this._vdom = y(a2, r2({}, this._props, { context: o4.detail.context }), function e3(n2, o5) {
      if (3 === n2.nodeType)
        return n2.data;
      if (1 !== n2.nodeType)
        return null;
      var r4 = [], i4 = {}, a4 = 0, s4 = n2.attributes, l4 = n2.childNodes;
      for (a4 = s4.length; a4--; )
        "slot" !== s4[a4].name && (i4[s4[a4].name] = s4[a4].value, i4[c2(s4[a4].name)] = s4[a4].value);
      for (a4 = l4.length; a4--; ) {
        var u4 = e3(l4[a4], null), d3 = l4[a4].slot;
        d3 ? i4[d3] = y(p2, { name: d3 }, u4) : r4[a4] = u4;
      }
      var h3 = o5 ? y(p2, null, r4) : r4;
      return y(o5 || n2.nodeName.toLowerCase(), i4, h3);
    }(this, this._vdomComponent)), (this.hasAttribute("hydrate") ? E : B)(this._vdom, this._root);
  }
  function c2(t3) {
    return t3.replace(/-(\w)/g, function(t4, e3) {
      return e3 ? e3.toUpperCase() : "";
    });
  }
  function l2(t3, e3, r4) {
    if (this._vdom) {
      var i4 = {};
      i4[t3] = r4 = null == r4 ? void 0 : r4, i4[c2(t3)] = r4, this._vdom = F(this._vdom, i4), B(this._vdom, this._root);
    }
  }
  function u2() {
    B(this._vdom = null, this._root);
  }
  function p2(e3, n2) {
    var o4 = this;
    return y("slot", r2({}, e3, { ref: function(t3) {
      t3 ? (o4.ref = t3, o4._listener || (o4._listener = function(t4) {
        t4.stopPropagation(), t4.detail.context = n2;
      }, t3.addEventListener("_preact", o4._listener))) : o4.ref.removeEventListener("_preact", o4._listener);
    } }));
  }
  function preact_custom_element_esm_default(t3, e3, n2, o4) {
    function r4() {
      var e4 = Reflect.construct(HTMLElement, [], r4);
      return e4._vdomComponent = t3, e4._root = o4 && o4.shadow ? e4.attachShadow({ mode: o4.mode || "open" }) : e4, e4;
    }
    return (r4.prototype = Object.create(HTMLElement.prototype)).constructor = r4, r4.prototype.connectedCallback = s2, r4.prototype.attributeChangedCallback = l2, r4.prototype.disconnectedCallback = u2, n2 = n2 || t3.observedAttributes || Object.keys(t3.propTypes || {}), r4.observedAttributes = n2, n2.forEach(function(t4) {
      Object.defineProperty(r4.prototype, t4, { get: function() {
        return this._vdom.props[t4];
      }, set: function(e4) {
        this._vdom ? this.attributeChangedCallback(t4, null, e4) : (this._props || (this._props = {}), this._props[t4] = e4, this.connectedCallback());
        var n3 = typeof e4;
        null != e4 && "string" !== n3 && "boolean" !== n3 && "number" !== n3 || this.setAttribute(t4, e4);
      } });
    }), customElements.define(e3 || t3.tagName || t3.displayName || t3.name, r4);
  }

  // node_modules/ol/events/Event.js
  var BaseEvent = class {
    /**
     * @param {string} type Type.
     */
    constructor(type) {
      this.propagationStopped;
      this.defaultPrevented;
      this.type = type;
      this.target = null;
    }
    /**
     * Prevent default. This means that no emulated `click`, `singleclick` or `doubleclick` events
     * will be fired.
     * @api
     */
    preventDefault() {
      this.defaultPrevented = true;
    }
    /**
     * Stop event propagation.
     * @api
     */
    stopPropagation() {
      this.propagationStopped = true;
    }
  };
  var Event_default = BaseEvent;

  // node_modules/ol/ObjectEventType.js
  var ObjectEventType_default = {
    /**
     * Triggered when a property is changed.
     * @event module:ol/Object.ObjectEvent#propertychange
     * @api
     */
    PROPERTYCHANGE: "propertychange"
  };

  // node_modules/ol/Disposable.js
  var Disposable = class {
    constructor() {
      this.disposed = false;
    }
    /**
     * Clean up.
     */
    dispose() {
      if (!this.disposed) {
        this.disposed = true;
        this.disposeInternal();
      }
    }
    /**
     * Extension point for disposable objects.
     * @protected
     */
    disposeInternal() {
    }
  };
  var Disposable_default = Disposable;

  // node_modules/ol/array.js
  function binarySearch(haystack, needle, comparator) {
    let mid, cmp;
    comparator = comparator || ascending;
    let low = 0;
    let high = haystack.length;
    let found = false;
    while (low < high) {
      mid = low + (high - low >> 1);
      cmp = +comparator(haystack[mid], needle);
      if (cmp < 0) {
        low = mid + 1;
      } else {
        high = mid;
        found = !cmp;
      }
    }
    return found ? low : ~low;
  }
  function ascending(a4, b3) {
    return a4 > b3 ? 1 : a4 < b3 ? -1 : 0;
  }
  function linearFindNearest(arr, target, direction) {
    if (arr[0] <= target) {
      return 0;
    }
    const n2 = arr.length;
    if (target <= arr[n2 - 1]) {
      return n2 - 1;
    }
    if (typeof direction === "function") {
      for (let i4 = 1; i4 < n2; ++i4) {
        const candidate = arr[i4];
        if (candidate === target) {
          return i4;
        }
        if (candidate < target) {
          if (direction(target, arr[i4 - 1], candidate) > 0) {
            return i4 - 1;
          }
          return i4;
        }
      }
      return n2 - 1;
    }
    if (direction > 0) {
      for (let i4 = 1; i4 < n2; ++i4) {
        if (arr[i4] < target) {
          return i4 - 1;
        }
      }
      return n2 - 1;
    }
    if (direction < 0) {
      for (let i4 = 1; i4 < n2; ++i4) {
        if (arr[i4] <= target) {
          return i4;
        }
      }
      return n2 - 1;
    }
    for (let i4 = 1; i4 < n2; ++i4) {
      if (arr[i4] == target) {
        return i4;
      }
      if (arr[i4] < target) {
        if (arr[i4 - 1] - target < target - arr[i4]) {
          return i4 - 1;
        }
        return i4;
      }
    }
    return n2 - 1;
  }
  function reverseSubArray(arr, begin, end) {
    while (begin < end) {
      const tmp = arr[begin];
      arr[begin] = arr[end];
      arr[end] = tmp;
      ++begin;
      --end;
    }
  }
  function extend(arr, data) {
    const extension = Array.isArray(data) ? data : [data];
    const length = extension.length;
    for (let i4 = 0; i4 < length; i4++) {
      arr[arr.length] = extension[i4];
    }
  }
  function equals(arr1, arr2) {
    const len1 = arr1.length;
    if (len1 !== arr2.length) {
      return false;
    }
    for (let i4 = 0; i4 < len1; i4++) {
      if (arr1[i4] !== arr2[i4]) {
        return false;
      }
    }
    return true;
  }

  // node_modules/ol/functions.js
  function TRUE() {
    return true;
  }
  function FALSE() {
    return false;
  }
  function VOID() {
  }
  function memoizeOne(fn) {
    let called = false;
    let lastResult;
    let lastArgs;
    let lastThis;
    return function() {
      const nextArgs = Array.prototype.slice.call(arguments);
      if (!called || this !== lastThis || !equals(nextArgs, lastArgs)) {
        called = true;
        lastThis = this;
        lastArgs = nextArgs;
        lastResult = fn.apply(this, arguments);
      }
      return lastResult;
    };
  }

  // node_modules/ol/obj.js
  function clear(object) {
    for (const property in object) {
      delete object[property];
    }
  }
  function isEmpty(object) {
    let property;
    for (property in object) {
      return false;
    }
    return !property;
  }

  // node_modules/ol/events/Target.js
  var Target = class extends Disposable_default {
    /**
     * @param {*} [target] Default event target for dispatched events.
     */
    constructor(target) {
      super();
      this.eventTarget_ = target;
      this.pendingRemovals_ = null;
      this.dispatching_ = null;
      this.listeners_ = null;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    addEventListener(type, listener) {
      if (!type || !listener) {
        return;
      }
      const listeners = this.listeners_ || (this.listeners_ = {});
      const listenersForType = listeners[type] || (listeners[type] = []);
      if (!listenersForType.includes(listener)) {
        listenersForType.push(listener);
      }
    }
    /**
     * Dispatches an event and calls all listeners listening for events
     * of this type. The event parameter can either be a string or an
     * Object with a `type` property.
     *
     * @param {import("./Event.js").default|string} event Event object.
     * @return {boolean|undefined} `false` if anyone called preventDefault on the
     *     event object or if any of the listeners returned false.
     * @api
     */
    dispatchEvent(event) {
      const isString = typeof event === "string";
      const type = isString ? event : event.type;
      const listeners = this.listeners_ && this.listeners_[type];
      if (!listeners) {
        return;
      }
      const evt = isString ? new Event_default(event) : (
        /** @type {Event} */
        event
      );
      if (!evt.target) {
        evt.target = this.eventTarget_ || this;
      }
      const dispatching = this.dispatching_ || (this.dispatching_ = {});
      const pendingRemovals = this.pendingRemovals_ || (this.pendingRemovals_ = {});
      if (!(type in dispatching)) {
        dispatching[type] = 0;
        pendingRemovals[type] = 0;
      }
      ++dispatching[type];
      let propagate;
      for (let i4 = 0, ii = listeners.length; i4 < ii; ++i4) {
        if ("handleEvent" in listeners[i4]) {
          propagate = /** @type {import("../events.js").ListenerObject} */
          listeners[i4].handleEvent(evt);
        } else {
          propagate = /** @type {import("../events.js").ListenerFunction} */
          listeners[i4].call(this, evt);
        }
        if (propagate === false || evt.propagationStopped) {
          propagate = false;
          break;
        }
      }
      if (--dispatching[type] === 0) {
        let pr = pendingRemovals[type];
        delete pendingRemovals[type];
        while (pr--) {
          this.removeEventListener(type, VOID);
        }
        delete dispatching[type];
      }
      return propagate;
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      this.listeners_ && clear(this.listeners_);
    }
    /**
     * Get the listeners for a specified event type. Listeners are returned in the
     * order that they will be called in.
     *
     * @param {string} type Type.
     * @return {Array<import("../events.js").Listener>|undefined} Listeners.
     */
    getListeners(type) {
      return this.listeners_ && this.listeners_[type] || void 0;
    }
    /**
     * @param {string} [type] Type. If not provided,
     *     `true` will be returned if this event target has any listeners.
     * @return {boolean} Has listeners.
     */
    hasListener(type) {
      if (!this.listeners_) {
        return false;
      }
      return type ? type in this.listeners_ : Object.keys(this.listeners_).length > 0;
    }
    /**
     * @param {string} type Type.
     * @param {import("../events.js").Listener} listener Listener.
     */
    removeEventListener(type, listener) {
      const listeners = this.listeners_ && this.listeners_[type];
      if (listeners) {
        const index = listeners.indexOf(listener);
        if (index !== -1) {
          if (this.pendingRemovals_ && type in this.pendingRemovals_) {
            listeners[index] = VOID;
            ++this.pendingRemovals_[type];
          } else {
            listeners.splice(index, 1);
            if (listeners.length === 0) {
              delete this.listeners_[type];
            }
          }
        }
      }
    }
  };
  var Target_default = Target;

  // node_modules/ol/events/EventType.js
  var EventType_default = {
    /**
     * Generic change event. Triggered when the revision counter is increased.
     * @event module:ol/events/Event~BaseEvent#change
     * @api
     */
    CHANGE: "change",
    /**
     * Generic error event. Triggered when an error occurs.
     * @event module:ol/events/Event~BaseEvent#error
     * @api
     */
    ERROR: "error",
    BLUR: "blur",
    CLEAR: "clear",
    CONTEXTMENU: "contextmenu",
    CLICK: "click",
    DBLCLICK: "dblclick",
    DRAGENTER: "dragenter",
    DRAGOVER: "dragover",
    DROP: "drop",
    FOCUS: "focus",
    KEYDOWN: "keydown",
    KEYPRESS: "keypress",
    LOAD: "load",
    RESIZE: "resize",
    TOUCHMOVE: "touchmove",
    WHEEL: "wheel"
  };

  // node_modules/ol/events.js
  function listen(target, type, listener, thisArg, once) {
    if (thisArg && thisArg !== target) {
      listener = listener.bind(thisArg);
    }
    if (once) {
      const originalListener = listener;
      listener = function() {
        target.removeEventListener(type, listener);
        originalListener.apply(this, arguments);
      };
    }
    const eventsKey = {
      target,
      type,
      listener
    };
    target.addEventListener(type, listener);
    return eventsKey;
  }
  function listenOnce(target, type, listener, thisArg) {
    return listen(target, type, listener, thisArg, true);
  }
  function unlistenByKey(key) {
    if (key && key.target) {
      key.target.removeEventListener(key.type, key.listener);
      clear(key);
    }
  }

  // node_modules/ol/Observable.js
  var Observable = class extends Target_default {
    constructor() {
      super();
      this.on = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onInternal;
      this.once = /** @type {ObservableOnSignature<import("./events").EventsKey>} */
      this.onceInternal;
      this.un = /** @type {ObservableOnSignature<void>} */
      this.unInternal;
      this.revision_ = 0;
    }
    /**
     * Increases the revision counter and dispatches a 'change' event.
     * @api
     */
    changed() {
      ++this.revision_;
      this.dispatchEvent(EventType_default.CHANGE);
    }
    /**
     * Get the version number for this object.  Each time the object is modified,
     * its version number will be incremented.
     * @return {number} Revision.
     * @api
     */
    getRevision() {
      return this.revision_;
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onInternal(type, listener) {
      if (Array.isArray(type)) {
        const len = type.length;
        const keys = new Array(len);
        for (let i4 = 0; i4 < len; ++i4) {
          keys[i4] = listen(this, type[i4], listener);
        }
        return keys;
      }
      return listen(
        this,
        /** @type {string} */
        type,
        listener
      );
    }
    /**
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @return {import("./events.js").EventsKey|Array<import("./events.js").EventsKey>} Event key.
     * @protected
     */
    onceInternal(type, listener) {
      let key;
      if (Array.isArray(type)) {
        const len = type.length;
        key = new Array(len);
        for (let i4 = 0; i4 < len; ++i4) {
          key[i4] = listenOnce(this, type[i4], listener);
        }
      } else {
        key = listenOnce(
          this,
          /** @type {string} */
          type,
          listener
        );
      }
      listener.ol_key = key;
      return key;
    }
    /**
     * Unlisten for a certain type of event.
     * @param {string|Array<string>} type Type.
     * @param {function((Event|import("./events/Event").default)): ?} listener Listener.
     * @protected
     */
    unInternal(type, listener) {
      const key = (
        /** @type {Object} */
        listener.ol_key
      );
      if (key) {
        unByKey(key);
      } else if (Array.isArray(type)) {
        for (let i4 = 0, ii = type.length; i4 < ii; ++i4) {
          this.removeEventListener(type[i4], listener);
        }
      } else {
        this.removeEventListener(type, listener);
      }
    }
  };
  Observable.prototype.on;
  Observable.prototype.once;
  Observable.prototype.un;
  function unByKey(key) {
    if (Array.isArray(key)) {
      for (let i4 = 0, ii = key.length; i4 < ii; ++i4) {
        unlistenByKey(key[i4]);
      }
    } else {
      unlistenByKey(
        /** @type {import("./events.js").EventsKey} */
        key
      );
    }
  }
  var Observable_default = Observable;

  // node_modules/ol/util.js
  function abstract() {
    throw new Error("Unimplemented abstract method.");
  }
  var uidCounter_ = 0;
  function getUid(obj) {
    return obj.ol_uid || (obj.ol_uid = String(++uidCounter_));
  }

  // node_modules/ol/Object.js
  var ObjectEvent = class extends Event_default {
    /**
     * @param {string} type The event type.
     * @param {string} key The property name.
     * @param {*} oldValue The old value for `key`.
     */
    constructor(type, key, oldValue) {
      super(type);
      this.key = key;
      this.oldValue = oldValue;
    }
  };
  var BaseObject = class extends Observable_default {
    /**
     * @param {Object<string, *>} [values] An object with key-value pairs.
     */
    constructor(values) {
      super();
      this.on;
      this.once;
      this.un;
      getUid(this);
      this.values_ = null;
      if (values !== void 0) {
        this.setProperties(values);
      }
    }
    /**
     * Gets a value.
     * @param {string} key Key name.
     * @return {*} Value.
     * @api
     */
    get(key) {
      let value;
      if (this.values_ && this.values_.hasOwnProperty(key)) {
        value = this.values_[key];
      }
      return value;
    }
    /**
     * Get a list of object property names.
     * @return {Array<string>} List of property names.
     * @api
     */
    getKeys() {
      return this.values_ && Object.keys(this.values_) || [];
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>} Object.
     * @api
     */
    getProperties() {
      return this.values_ && Object.assign({}, this.values_) || {};
    }
    /**
     * Get an object of all property names and values.
     * @return {Object<string, *>?} Object.
     */
    getPropertiesInternal() {
      return this.values_;
    }
    /**
     * @return {boolean} The object has properties.
     */
    hasProperties() {
      return !!this.values_;
    }
    /**
     * @param {string} key Key name.
     * @param {*} oldValue Old value.
     */
    notify(key, oldValue) {
      let eventType;
      eventType = `change:${key}`;
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
      eventType = ObjectEventType_default.PROPERTYCHANGE;
      if (this.hasListener(eventType)) {
        this.dispatchEvent(new ObjectEvent(eventType, key, oldValue));
      }
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    addChangeListener(key, listener) {
      this.addEventListener(`change:${key}`, listener);
    }
    /**
     * @param {string} key Key name.
     * @param {import("./events.js").Listener} listener Listener.
     */
    removeChangeListener(key, listener) {
      this.removeEventListener(`change:${key}`, listener);
    }
    /**
     * Sets a value.
     * @param {string} key Key name.
     * @param {*} value Value.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    set(key, value, silent) {
      const values = this.values_ || (this.values_ = {});
      if (silent) {
        values[key] = value;
      } else {
        const oldValue = values[key];
        values[key] = value;
        if (oldValue !== value) {
          this.notify(key, oldValue);
        }
      }
    }
    /**
     * Sets a collection of key-value pairs.  Note that this changes any existing
     * properties and adds new ones (it does not remove any existing properties).
     * @param {Object<string, *>} values Values.
     * @param {boolean} [silent] Update without triggering an event.
     * @api
     */
    setProperties(values, silent) {
      for (const key in values) {
        this.set(key, values[key], silent);
      }
    }
    /**
     * Apply any properties from another object without triggering events.
     * @param {BaseObject} source The source object.
     * @protected
     */
    applyProperties(source) {
      if (!source.values_) {
        return;
      }
      Object.assign(this.values_ || (this.values_ = {}), source.values_);
    }
    /**
     * Unsets a property.
     * @param {string} key Key name.
     * @param {boolean} [silent] Unset without triggering an event.
     * @api
     */
    unset(key, silent) {
      if (this.values_ && key in this.values_) {
        const oldValue = this.values_[key];
        delete this.values_[key];
        if (isEmpty(this.values_)) {
          this.values_ = null;
        }
        if (!silent) {
          this.notify(key, oldValue);
        }
      }
    }
  };
  var Object_default = BaseObject;

  // node_modules/mobility-toolbox-js/common/utils/getUrlWithParams.js
  var getUrlWithParams = (url, params) => {
    const newUrl = new URL(url);
    const searchParams = params || {};
    Object.entries(searchParams).forEach(([key, value]) => {
      if (value !== void 0 && value !== null) {
        newUrl.searchParams.set(key, value);
      }
    });
    return newUrl;
  };
  var getUrlWithParams_default = getUrlWithParams;

  // node_modules/mobility-toolbox-js/common/api/WebSocketAPI.js
  var WebSocketAPI = class _WebSocketAPI {
    constructor() {
      this.defineProperties();
    }
    defineProperties() {
      Object.defineProperties(this, {
        closed: {
          get: () => !!(!this.websocket || this.websocket.readyState === this.websocket.CLOSED)
        },
        closing: {
          get: () => !!(this.websocket && this.websocket.readyState === this.websocket.CLOSING)
        },
        connecting: {
          get: () => !!(this.websocket && this.websocket.readyState === this.websocket.CONNECTING)
        },
        open: {
          get: () => !!(this.websocket && this.websocket.readyState === this.websocket.OPEN)
        },
        /**
         * Array of message to send on open.
         * @type {Array<string>}
         * @private
         */
        messagesOnOpen: {
          value: [],
          writable: true
        },
        /**
         * Array of subscriptions.
         * @type {Array<WebSocketSubscription>}
         * @private
         */
        subscriptions: {
          value: [],
          writable: true
        },
        /**
         * List of channels subscribed.
         * @type {WebSocketSubscribed}
         * @private
         */
        subscribed: {
          value: {},
          writable: true
        }
      });
    }
    /**
     * Get the websocket request string.
     *
     * @param {string} method Request mehtod {GET, SUB}.
     * @param {WebSocketParameters} params Request parameters.
     * @param {string} params.channel Channel name
     * @param {string} [params.args] Request arguments
     * @param {Number|string} [params.id] Request identifier
     * @return {string} request string
     * @private
     */
    static getRequestString(method, params = {}) {
      let reqStr = `${method} ${params.channel}`;
      reqStr += params.args ? ` ${params.args}` : "";
      reqStr += params.id ? ` ${params.id}` : "";
      return reqStr.trim();
    }
    /**
     * (Re)connect the websocket.
     *
     * @param {string} url Websocket url.
     * @param {function} onOpen Callback called when the websocket connection is opened and before subscriptions of previous subscriptions.
     * @private
     */
    connect(url, onOpen = () => {
    }) {
      var _a;
      if (!url) {
        (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.close();
        return;
      }
      if (this.websocket) {
        if (this.websocket.url === url && (this.open || this.connecting)) {
          return;
        }
        if (this.websocket.url !== url && (this.open || this.connecting)) {
          this.websocket.close();
        }
      }
      this.websocket = new WebSocket(url);
      if (!this.open) {
        this.websocket.addEventListener("open", () => {
          onOpen();
          this.subscribePreviousSubscriptions();
        });
      } else {
        onOpen();
        this.subscribePreviousSubscriptions();
      }
    }
    /**
     * Close the websocket definitively.
     *
     * @private
     */
    close() {
      if (this.websocket && (this.open || this.connecting)) {
        this.websocket.onclose = () => {
        };
        this.websocket.close();
        this.messagesOnOpen = [];
      }
    }
    /**
     * Sends a message to the websocket.
     *
     * @param {message} message Message to send.
     * @private
     */
    send(message) {
      if (!this.websocket || this.closed || this.closing) {
        return;
      }
      const send = () => {
        var _a;
        (_a = this.websocket) === null || _a === void 0 ? void 0 : _a.send(message);
      };
      if (!this.open) {
        if (!this.messagesOnOpen.includes(message)) {
          this.messagesOnOpen.push(message);
          this.websocket.addEventListener("open", () => {
            this.messagesOnOpen = [];
            send();
          });
          this.websocket.addEventListener("close", () => {
            this.messagesOnOpen = [];
          });
        }
      } else if (!this.messagesOnOpen.includes(message)) {
        send();
      }
    }
    addEvents(onMessage, onError) {
      if (this.websocket) {
        this.websocket.addEventListener("message", onMessage);
        if (onError) {
          this.websocket.addEventListener("error", onError);
          this.websocket.addEventListener("close", onError);
        }
      }
    }
    removeEvents(onMessage, onError) {
      if (this.websocket) {
        this.websocket.removeEventListener("message", onMessage);
        if (onError) {
          this.websocket.removeEventListener("error", onError);
          this.websocket.removeEventListener("close", onError);
        }
      }
    }
    /**
     * Listen to websocket messages.
     *
     * @param {WebSocketParameters} params Parameters for the websocket get request
     * @param {function} cb callback on listen
     * @param {function} errorCb Callback on error
     * @return {{onMessage: function, errorCb: function}} Object with onMessage and error callbacks
     * @private
     */
    listen(params, cb, errorCb) {
      this.unlisten(params, cb);
      const onMessage = (evt) => {
        let data;
        try {
          data = JSON.parse(evt.data);
        } catch (err) {
          console.error("WebSocket: unable to parse JSON data", err, evt.data);
          return;
        }
        let source = params.channel;
        source += params.args ? ` ${params.args}` : "";
        let contents;
        if (data.source === "buffer") {
          contents = data.content;
        } else {
          contents = [data];
        }
        contents.forEach((content) => {
          if ((content === null || content === void 0 ? void 0 : content.source) === source && (!params.id || params.id === data.client_reference)) {
            cb(content);
          }
        });
      };
      this.addEvents(onMessage, errorCb);
      return { onMessageCb: onMessage, onErrorCb: errorCb };
    }
    /**
     * Unlisten websocket messages.
     *
     * @param {Object} params Parameters for the websocket get request.
     * @param {function} cb Callback used when listen.
     * @private
     */
    unlisten(params, cb) {
      [...this.subscriptions || [], ...this.requests || []].filter((s4) => s4.params.channel === params.channel && (!cb || s4.cb === cb)).forEach(({ onMessageCb, onErrorCb }) => {
        this.removeEvents(onMessageCb, onErrorCb);
      });
    }
    /**
     * Sends a get request to the websocket.
     * The callback is called only once, when the response is received or when the call returns an error.
     *
     * @param {Object} params Parameters for the websocket get request
     * @param {function} onMessage callback on message event
     * @param {function} onError Callback on error and close event
     * @private
     */
    get(params, cb, errorCb) {
      const requestString = _WebSocketAPI.getRequestString("GET", params);
      this.send(requestString);
      const once = (callback) => (
        // @ts-ignore: Spread error
        (...args) => {
          callback(...args);
          const index2 = this.requests.findIndex((request) => requestString === request.requestString && cb === request.cb);
          const { onMessageCb: onMessageCb2, onErrorCb: onErrorCb2 } = this.requests[index2];
          this.removeEvents(onMessageCb2, onErrorCb2);
          this.requests.splice(index2, 1);
        }
      );
      const { onMessageCb, onErrorCb } = this.listen(params, once(cb), errorCb && once(errorCb));
      if (!this.requests) {
        this.requests = [];
      }
      const index = this.requests.findIndex((request) => requestString === request.requestString && cb === request.cb);
      const newReq = {
        params,
        requestString,
        cb,
        errorCb,
        onMessageCb,
        onErrorCb
      };
      if (index > -1) {
        this.requests[index] = newReq;
      } else {
        this.requests.push(newReq);
      }
    }
    /**
     * Subscribe to a given channel.
     *
     * @param {Object} params Parameters for the websocket get request
     * @param {function} cb callback on listen
     * @param {function} errorCb Callback on error
     * @param {boolean} quiet if false, no GET or SUB requests are send, only the callback is registered.
     * @private
     */
    subscribe(params, cb, errorCb, quiet = false) {
      const { onMessageCb, onErrorCb } = this.listen(params, cb, errorCb);
      const reqStr = _WebSocketAPI.getRequestString("", params);
      const index = this.subscriptions.findIndex((subcr) => params.channel === subcr.params.channel && cb === subcr.cb);
      const newSubscr = { params, cb, errorCb, onMessageCb, onErrorCb, quiet };
      if (index > -1) {
        this.subscriptions[index] = newSubscr;
      } else {
        this.subscriptions.push(newSubscr);
      }
      if (!this.subscribed[reqStr]) {
        if (!newSubscr.quiet) {
          this.send(`GET ${reqStr}`);
          this.send(`SUB ${reqStr}`);
        }
        this.subscribed[reqStr] = true;
      }
    }
    /**
     * Unsubscribe from a channel.
     * @param {string} source source to unsubscribe from
     * @param {function} cb Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     * @private
     */
    unsubscribe(source, cb) {
      const toRemove = this.subscriptions.filter((s4) => s4.params.channel === source && (!cb || s4.cb === cb));
      toRemove.forEach(({ onMessageCb, onErrorCb }) => {
        this.removeEvents(onMessageCb, onErrorCb);
      });
      this.subscriptions = this.subscriptions.filter((s4) => s4.params.channel !== source || cb && s4.cb !== cb);
      if (source && this.subscribed[source] && !this.subscriptions.find((s4) => s4.params.channel === source) && toRemove.find((subscr) => !subscr.quiet)) {
        this.send(`DEL ${source}`);
        this.subscribed[source] = false;
      }
    }
    /**
     * After an auto reconnection we need to re-subscribe to the channels.
     */
    subscribePreviousSubscriptions() {
      Object.keys(this.subscribed).forEach((key) => {
        this.subscribed[key] = false;
      });
      [...this.subscriptions].forEach((s4) => {
        this.subscribe(s4.params, s4.cb, s4.errorCb, s4.quiet);
      });
    }
  };
  var WebSocketAPI_default = WebSocketAPI;

  // node_modules/mobility-toolbox-js/common/utils/debounceWebsocketMessages.js
  var debounceWebsocketMessages = (onUpdate, getObjectId, timeout = 100) => {
    const updateTimeout = {};
    const objectsById = {};
    const objects = [];
    return (data) => {
      const { source, content } = data;
      if (updateTimeout[source]) {
        window.clearTimeout(updateTimeout[source]);
      }
      if (getObjectId) {
        objectsById[getObjectId(content)] = content;
      } else {
        objects.push(content);
      }
      updateTimeout[source] = window.setTimeout(() => {
        const objectToReturn = getObjectId ? Object.values(objectsById) : objects;
        onUpdate(objectToReturn);
      }, timeout);
    };
  };
  var debounceWebsocketMessages_default = debounceWebsocketMessages;

  // node_modules/mobility-toolbox-js/common/utils/getRealtimeModeSuffix.js
  var getModeSuffix = (mode, modes) => mode === modes.SCHEMATIC ? "_schematic" : "";
  var getRealtimeModeSuffix_default = getModeSuffix;

  // node_modules/mobility-toolbox-js/api/RealtimeAPI.js
  var RealtimeModes = {
    RAW: "raw",
    TOPOGRAPHIC: "topographic",
    SCHEMATIC: "schematic"
  };
  var RealtimeAPI = class {
    /**
     * Constructor
     *
     * @param {Object|string} options A string representing the url of the service or an object containing the url and the apiKey.
     * @param {string} options.url Url to the [geOps realtime api](https://developer.geops.io/apis/realtime/).
     * @param {string} options.apiKey Access key for [geOps apis](https://developer.geops.io/).
     * @param {string} [options.prefix=''] Service prefix to specify tenant.
     * @param {string} [options.projection] The epsg code of the projection for features. Default to EPSG:3857.
     * @param {number[4]} [options.bbox=[minX, minY, maxX, maxY, zoom, tenant] The bounding box to receive data from.
     */
    constructor(options = {}) {
      this.defineProperties(options);
      this.prefix = options.prefix || "";
      this.onOpen = this.onOpen.bind(this);
    }
    /* @private */
    defineProperties(options) {
      let opt = options;
      if (typeof options === "string") {
        opt = { url: options };
      }
      const { apiKey } = opt;
      let { url, projection, bbox, buffer: buffer2 = [100, 100] } = opt;
      const wsApi = new WebSocketAPI_default();
      if (!url) {
        url = "wss://api.geops.io/tracker-ws/v1/";
      }
      if (apiKey) {
        url = `${url}?key=${apiKey}`;
      }
      Object.defineProperties(this, {
        url: {
          get: () => url,
          set: (newUrl) => {
            if (url !== newUrl) {
              url = newUrl;
              if (this.wsApi.open || this.wsApi.connecting) {
                this.open();
              }
            }
          }
        },
        projection: {
          get: () => projection,
          set: (newProjection) => {
            if (newProjection !== projection) {
              projection = newProjection;
              if (this.wsApi) {
                this.wsApi.send(`PROJECTION ${projection}`);
              }
            }
          }
        },
        bbox: {
          get: () => bbox,
          set: (newBbox) => {
            if (JSON.stringify(newBbox) !== JSON.stringify(bbox)) {
              bbox = newBbox;
              if (this.wsApi && bbox) {
                this.wsApi.send(`BBOX ${bbox.join(" ")}`);
              }
            }
          }
        },
        buffer: {
          get: () => buffer2,
          set: (newBuffer) => {
            if (JSON.stringify(newBuffer) !== JSON.stringify(buffer2)) {
              buffer2 = newBuffer;
              if (this.wsApi) {
                this.wsApi.send(`BUFFER ${buffer2.join(" ")}`);
              }
            }
          }
        },
        /**
         * The websocket helper class to connect the websocket.
         *
         * @private
         */
        wsApi: {
          value: wsApi,
          writable: true
        },
        /**
         * Interval between PING request in ms.
         * If equal to 0,  no PING request are sent.
         * @type {number}
         * @private
         */
        pingIntervalMs: {
          value: options.pingIntervalMs || 1e4,
          writable: true
        },
        /**
         * Timeout in ms after an automatic reconnection when the websoscket has been closed by the server.
         * @type {number}
         */
        reconnectTimeoutMs: {
          value: options.pingIntervalMs || 100,
          writable: true
        }
      });
    }
    open() {
      this.wsApi.connect(this.url, this.onOpen);
      if (this.wsApi.websocket) {
        this.wsApi.websocket.onclose = () => {
          this.onClose();
        };
      }
    }
    /**
     * Close the websocket connection without reconnection.
     */
    close() {
      this.wsApi.close();
    }
    /**
     * Unsubscribe trajectory and deleted_vehicles channels. To resubscribe you have to set a new BBOX.
     */
    // eslint-disable-next-line class-methods-use-this
    reset() {
      this.wsApi.send("RESET");
    }
    /**
     * Callback when the websocket is opened and ready.
     * It applies the bbox and the projection.
     */
    onOpen() {
      if (this.projection) {
        this.wsApi.send(`PROJECTION ${this.projection}`);
      }
      if (this.bbox) {
        this.wsApi.send(`BBOX ${this.bbox.join(" ")}`);
      }
      if (this.buffer) {
        this.wsApi.send(`BUFFER ${this.buffer.join(" ")}`);
      }
      if (this.pingIntervalMs) {
        window.clearInterval(this.pingInterval);
        this.pingInterval = window.setInterval(() => {
          this.wsApi.send("PING");
        }, this.pingIntervalMs);
      }
    }
    /**
     * Callback when the websocket is closed by the server.
     * It auto reconnects after a timeout.
     */
    onClose() {
      window.clearTimeout(this.pingInterval);
      window.clearTimeout(this.reconnectTimeout);
      if (this.reconnectTimeoutMs) {
        this.reconnectTimeout = window.setTimeout(() => this.open(), this.reconnectTimeoutMs);
      }
    }
    /**
     * Send GET to a channel.
     *
     * @param {string | WebSocketAPIParameters} channelOrParams Name of the websocket channel to send GET or an object representing parameters to send
     * @return {Promise<WebSocketAPIMessageEventData<?>>} A websocket response.
     */
    get(channelOrParams) {
      let params = channelOrParams;
      if (typeof channelOrParams === "string") {
        params = { channel: channelOrParams };
      }
      return new Promise((resolve, reject) => {
        this.wsApi.get(params, resolve, reject);
      });
    }
    /**
     * Subscribe to a channel.
     *
     * @param {string} channel Name of the websocket channel to subscribe.
     * @param {function} onSuccess Callback when the subscription succeeds.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     * @private
     */
    subscribe(channel, onSuccess, onError = () => {
    }, quiet = false) {
      if (!channel || !onSuccess) {
        return;
      }
      this.wsApi.subscribe({ channel }, onSuccess, onError, quiet);
    }
    /**
     * Unsubscribe both modes of a channel.
     *
     * @param {string} channel Name of the websocket channel to unsubscribe.
     * @param {string} suffix Suffix to add to the channel name.
     * @param {function} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     * @private
     */
    unsubscribe(channel, suffix = "", onMessage) {
      const suffixSchenatic = getRealtimeModeSuffix_default(RealtimeModes.SCHEMATIC, RealtimeModes);
      const suffixTopographic = getRealtimeModeSuffix_default(RealtimeModes.TOPOGRAPHIC, RealtimeModes);
      this.wsApi.unsubscribe(`${channel}${suffixSchenatic}${suffix || ""}`, onMessage);
      this.wsApi.unsubscribe(`${channel}${suffixTopographic}${suffix || ""}`, onMessage);
    }
    /**
     * Subscribe to departures channel of a given station.
     *
     * @param {number} stationId UIC of the station.
     * @param {Boolean} sortByMinArrivalTime Sort by minimum arrival time
     * @param {function(departures:Departure[])} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeDepartures(stationId, onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe(`timetable_${stationId}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe from current departures channel.
     * @param {RealtimeStationId} id Station's id
     * @param {function(data: { content: RealtimeDeparture[] })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeDepartures(id, onMessage) {
      this.unsubscribe(`timetable_${id}`, "", onMessage);
    }
    /**
     * Subscribe to the disruptions channel for tenant.
     *
     * @param {function(data: { content: RealtimeNews[] })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeDisruptions(onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe(`${this.prefix}newsticker`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe disruptions.
     *
     * @param {function(data: { content: RealtimeNews[] })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeDisruptions(onMessage) {
      this.unsubscribe(`${this.prefix}newsticker`, "", onMessage);
    }
    /**
     * Return a station with a given uic number and a mode.
     *
     * @param {number} uic UIC of the station.
     * @param {RealtimeMode} mode Realtime mode.
     * @return {Promise<{data: { content: RealtimeStation }}>} A station.
     */
    getStation(uic, mode) {
      const params = {
        channel: `station${getRealtimeModeSuffix_default(mode, RealtimeModes)}`,
        args: uic
      };
      return this.get(params);
    }
    /**
     * Get the list of ststions available for a specifc mode. The promise is resolved every 100ms
     * @param {RealtimeMode} mode Realtime mode.
     * @param {number} timeout = 100 Duration in ms between each promise resolve calls.
     * @return {Promise<RealtimeStation[]>} An array of stations.
     */
    getStations(mode, timeout = 100) {
      return new Promise((resolve) => {
        this.get(`station${getRealtimeModeSuffix_default(mode, RealtimeModes)}`).then(debounceWebsocketMessages_default(resolve, void 0, timeout));
      });
    }
    /**
     * Subscribe to stations channel.
     * One message pro station.
     *
     * @param {RealtimeMode} mode Realtime mode.
     * @param {function(data: { content: RealtimeStation })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeStations(mode, onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe(`station${getRealtimeModeSuffix_default(mode, RealtimeModes)}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe to stations channel.
     * @param {function(data: { content: RealtimeStation })} onMessage The listener callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribe.
     */
    unsubscribeStations(onMessage) {
      this.unsubscribe("station", "", onMessage);
    }
    /**
     * Subscribe to extra_geoms channel.
     *
     * @param {function(data: { content: RealtimeExtraGeom })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeExtraGeoms(onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe("extra_geoms", onMessage, onError, quiet);
    }
    /**
     * Unsubscribe to extra_geoms channel.
     * @param {function(data: { content: RealtimeExtraGeom })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeExtraGeoms(onMessage) {
      this.unsubscribe("extra_geoms", "", onMessage);
    }
    /**
     * Return a partial trajectory with a given id and a mode.
     *
     * @param {number} trainId The identifier of a trajectory.
     * @param {RealtimeMode} mode Realtime mode.
     * @return {Promise<{data: { content: RealtimeTrajectory }}>} A trajectory.
     */
    getTrajectory(id, mode) {
      return this.get(`partial_trajectory${getRealtimeModeSuffix_default(mode, RealtimeModes)}_${id}`);
    }
    /**
     * Subscribe to trajectory channel.
     *
     * @param {RealtimeMode} mode Realtime mode.
     * @param {function(data: { content: RealtimeTrajectoryResponse[] })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeTrajectory(mode, onMessage, onError = () => {
    }, quiet = false) {
      this.unsubscribeTrajectory(onMessage);
      this.subscribe(`trajectory${getRealtimeModeSuffix_default(mode, RealtimeModes)}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe to trajectory channels.
     * @param {function(data: { content: RealtimeTrajectoryResponse[] })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeTrajectory(onMessage) {
      this.unsubscribe(`trajectory`, "", onMessage);
    }
    /**
     * Subscribe to deleted_vhicles channel.
     *
     * @param {RealtimeMode} mode Realtime mode.
     * @param {function(data: { content: RealtimeTrainId })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeDeletedVehicles(mode, onMessage, onError = () => {
    }, quiet = false) {
      this.unsubscribeDeletedVehicles(onMessage);
      this.subscribe(`deleted_vehicles${getRealtimeModeSuffix_default(mode, RealtimeModes)}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe to deleted_vhicles channels.
     * @param {function(data: { content: RealtimeTrainId })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeDeletedVehicles(onMessage) {
      this.unsubscribe("deleted_vehicles", "", onMessage);
    }
    /**
     * Get a full trajectory of a vehicule .
     *
     * @param {string} id A vehicle id.
     * @param {RealtimeMode} mode Realtime mode.
     * @param {string} generalizationLevel The generalization level to request. Can be one of 5 (more generalized), 10, 30, 100, undefined (less generalized).
     * @return {Promise<{ data: { content: RealtimeFullTrajectory } }>} Return a full trajectory.
     */
    getFullTrajectory(id, mode, generalizationLevel) {
      const channel = [`full_trajectory${getRealtimeModeSuffix_default(mode, RealtimeModes)}`];
      if (id) {
        channel.push(id);
      }
      if ((!mode || mode === RealtimeModes.TOPOGRAPHIC) && generalizationLevel) {
        channel.push(`gen${generalizationLevel}`);
      }
      return this.get(channel.join("_"));
    }
    /**
     * Subscribe to full_trajectory channel of a given vehicle.
     *
     * @param {string} id A vehicle id.
     * @param {RealtimeMode} mode Realtime mode.
     * @param {function(data: { content: RealtimeFullTrajectory })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeFullTrajectory(id, mode, onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe(`full_trajectory${getRealtimeModeSuffix_default(mode, RealtimeModes)}_${id}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe from full_trajectory channel
     *
     * @param {string} id A vehicle id.
     * @param {function(data: { content: RealtimeFullTrajectory })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeFullTrajectory(id, onMessage) {
      this.unsubscribe("full_trajectory", `_${id}`, onMessage);
    }
    /**
     * Get the list of stops for this vehicle.
     *
     * @param {string} id A vehicle id.
     * @return {Promise<{ data: { content: StopSequence[] } }>} Returns a stop sequence object.
     */
    getStopSequence(id) {
      return this.get(`stopsequence_${id}`);
    }
    /**
     * Subscribe to stopsequence channel of a given vehicle.
     *
     * @param {string} id A vehicle id.
     * @param {function(data: { content: StopSequence[] })} onMessage Function called on each message of the channel.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeStopSequence(id, onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe(`stopsequence_${id}`, onMessage, onError, quiet);
    }
    /**
     * Unsubscribe from stopsequence channel
     *
     * @param {string} id A vehicle id.
     * @param {function(data: { content: StopSequence[] })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeStopSequence(id, onMessage) {
      this.unsubscribe(`stopsequence`, `_${id}`, onMessage);
    }
    /**
     * Subscribe to healthcheck channel.
     * @param {function(data: { content: string })} onMessage Callback when the subscribe to healthcheck channel succeeds.
     * @param {function} onError Callback when the subscription fails.
     * @param {boolean} [quiet=false] If true avoid to store the subscription in the subscriptions list.
     */
    subscribeHealthCheck(onMessage, onError = () => {
    }, quiet = false) {
      this.subscribe("healthcheck", onMessage, onError, quiet);
    }
    /**
     * Unsubscribe to healthcheck channel.
     * @param {function(data: { content: string })} onMessage Callback function to unsubscribe. If null all subscriptions for the channel will be unsubscribed.
     */
    unsubscribeHealthCheck(onMessage) {
      this.unsubscribe("healthcheck", "", onMessage);
    }
  };
  var RealtimeAPI_default = RealtimeAPI;

  // node_modules/mobility-toolbox-js/common/utils/removeDuplicate.js
  var removeDuplicate = (array) => {
    const arrWithoutEmptyValues = array.filter((val) => val !== void 0 && val !== null && val.trim && val.trim());
    const lowerCasesValues = arrWithoutEmptyValues.map((str) => str.toLowerCase());
    const uniqueLowerCaseValues = [...new Set(lowerCasesValues)];
    const uniqueValues = uniqueLowerCaseValues.map((uniqueStr) => arrWithoutEmptyValues.find((str) => str.toLowerCase() === uniqueStr));
    return uniqueValues;
  };
  var removeDuplicate_default = removeDuplicate;

  // node_modules/mobility-toolbox-js/common/utils/getMapboxMapCopyrights.js
  var getMapboxMapCopyrights = (map2) => {
    if (!map2) {
      return [];
    }
    const { style } = map2;
    if (!style) {
      return [];
    }
    const { sourceCaches } = style;
    let copyrights = [];
    Object.values(sourceCaches).forEach((sourceCache) => {
      if (sourceCache.used) {
        const source = sourceCache.getSource();
        const attribution = (
          // @ts-ignore
          source.attribution || source.options && source.options.attribution
        );
        if (attribution) {
          copyrights = copyrights.concat(attribution.replace(/&copy;/g, "\xA9").split(/(<a.*?<\/a>)/));
        }
      }
    });
    return removeDuplicate_default(copyrights);
  };
  var getMapboxMapCopyrights_default = getMapboxMapCopyrights;

  // node_modules/mobility-toolbox-js/common/utils/getLayersAsFlatArray.js
  var getLayersAsFlatArray = (layersOrLayer) => {
    let layers = layersOrLayer;
    if (!Array.isArray(layers)) {
      layers = [layersOrLayer];
    }
    let flatLayers = [];
    layers.forEach((layer) => {
      flatLayers.push(layer);
      const { children } = layer;
      flatLayers = flatLayers.concat(getLayersAsFlatArray(children || []));
    });
    return flatLayers;
  };
  var getLayersAsFlatArray_default = getLayersAsFlatArray;

  // node_modules/ol/has.js
  var ua = typeof navigator !== "undefined" && typeof navigator.userAgent !== "undefined" ? navigator.userAgent.toLowerCase() : "";
  var FIREFOX = ua.includes("firefox");
  var SAFARI = ua.includes("safari") && !ua.includes("chrom");
  var SAFARI_BUG_237906 = SAFARI && (ua.includes("version/15.4") || /cpu (os|iphone os) 15_4 like mac os x/.test(ua));
  var WEBKIT = ua.includes("webkit") && !ua.includes("edge");
  var MAC = ua.includes("macintosh");
  var DEVICE_PIXEL_RATIO = typeof devicePixelRatio !== "undefined" ? devicePixelRatio : 1;
  var WORKER_OFFSCREEN_CANVAS = typeof WorkerGlobalScope !== "undefined" && typeof OffscreenCanvas !== "undefined" && self instanceof WorkerGlobalScope;
  var IMAGE_DECODE = typeof Image !== "undefined" && Image.prototype.decode;
  var PASSIVE_EVENT_LISTENERS = function() {
    let passive = false;
    try {
      const options = Object.defineProperty({}, "passive", {
        get: function() {
          passive = true;
        }
      });
      window.addEventListener("_", null, options);
      window.removeEventListener("_", null, options);
    } catch (error) {
    }
    return passive;
  }();

  // node_modules/ol/asserts.js
  function assert(assertion, errorMessage) {
    if (!assertion) {
      throw new Error(errorMessage);
    }
  }

  // node_modules/ol/transform.js
  var tmp_ = new Array(6);
  function create() {
    return [1, 0, 0, 1, 0, 0];
  }
  function set(transform2, a4, b3, c4, d3, e3, f3) {
    transform2[0] = a4;
    transform2[1] = b3;
    transform2[2] = c4;
    transform2[3] = d3;
    transform2[4] = e3;
    transform2[5] = f3;
    return transform2;
  }
  function setFromArray(transform1, transform2) {
    transform1[0] = transform2[0];
    transform1[1] = transform2[1];
    transform1[2] = transform2[2];
    transform1[3] = transform2[3];
    transform1[4] = transform2[4];
    transform1[5] = transform2[5];
    return transform1;
  }
  function apply(transform2, coordinate) {
    const x2 = coordinate[0];
    const y2 = coordinate[1];
    coordinate[0] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
    coordinate[1] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
    return coordinate;
  }
  function makeScale(target, x2, y2) {
    return set(target, x2, 0, 0, y2, 0, 0);
  }
  function compose(transform2, dx1, dy1, sx, sy, angle, dx2, dy2) {
    const sin = Math.sin(angle);
    const cos = Math.cos(angle);
    transform2[0] = sx * cos;
    transform2[1] = sy * sin;
    transform2[2] = -sx * sin;
    transform2[3] = sy * cos;
    transform2[4] = dx2 * sx * cos - dy2 * sx * sin + dx1;
    transform2[5] = dx2 * sy * sin + dy2 * sy * cos + dy1;
    return transform2;
  }
  function composeCssTransform(dx1, dy1, sx, sy, angle, dx2, dy2) {
    return toString(compose(create(), dx1, dy1, sx, sy, angle, dx2, dy2));
  }
  function makeInverse(target, source) {
    const det = determinant(source);
    assert(det !== 0, "Transformation matrix cannot be inverted");
    const a4 = source[0];
    const b3 = source[1];
    const c4 = source[2];
    const d3 = source[3];
    const e3 = source[4];
    const f3 = source[5];
    target[0] = d3 / det;
    target[1] = -b3 / det;
    target[2] = -c4 / det;
    target[3] = a4 / det;
    target[4] = (c4 * f3 - d3 * e3) / det;
    target[5] = -(a4 * f3 - b3 * e3) / det;
    return target;
  }
  function determinant(mat) {
    return mat[0] * mat[3] - mat[1] * mat[2];
  }
  var transformStringDiv;
  function toString(mat) {
    const transformString = "matrix(" + mat.join(", ") + ")";
    if (WORKER_OFFSCREEN_CANVAS) {
      return transformString;
    }
    const node = transformStringDiv || (transformStringDiv = document.createElement("div"));
    node.style.transform = transformString;
    return node.style.transform;
  }

  // node_modules/ol/extent/Relationship.js
  var Relationship_default = {
    UNKNOWN: 0,
    INTERSECTING: 1,
    ABOVE: 2,
    RIGHT: 4,
    BELOW: 8,
    LEFT: 16
  };

  // node_modules/ol/extent.js
  function _boundingExtentXYs(xs, ys, dest) {
    const minX = Math.min.apply(null, xs);
    const minY = Math.min.apply(null, ys);
    const maxX = Math.max.apply(null, xs);
    const maxY = Math.max.apply(null, ys);
    return createOrUpdate(minX, minY, maxX, maxY, dest);
  }
  function buffer(extent, value, dest) {
    if (dest) {
      dest[0] = extent[0] - value;
      dest[1] = extent[1] - value;
      dest[2] = extent[2] + value;
      dest[3] = extent[3] + value;
      return dest;
    }
    return [
      extent[0] - value,
      extent[1] - value,
      extent[2] + value,
      extent[3] + value
    ];
  }
  function clone(extent, dest) {
    if (dest) {
      dest[0] = extent[0];
      dest[1] = extent[1];
      dest[2] = extent[2];
      dest[3] = extent[3];
      return dest;
    }
    return extent.slice();
  }
  function closestSquaredDistanceXY(extent, x2, y2) {
    let dx, dy;
    if (x2 < extent[0]) {
      dx = extent[0] - x2;
    } else if (extent[2] < x2) {
      dx = x2 - extent[2];
    } else {
      dx = 0;
    }
    if (y2 < extent[1]) {
      dy = extent[1] - y2;
    } else if (extent[3] < y2) {
      dy = y2 - extent[3];
    } else {
      dy = 0;
    }
    return dx * dx + dy * dy;
  }
  function containsCoordinate(extent, coordinate) {
    return containsXY(extent, coordinate[0], coordinate[1]);
  }
  function containsExtent(extent1, extent2) {
    return extent1[0] <= extent2[0] && extent2[2] <= extent1[2] && extent1[1] <= extent2[1] && extent2[3] <= extent1[3];
  }
  function containsXY(extent, x2, y2) {
    return extent[0] <= x2 && x2 <= extent[2] && extent[1] <= y2 && y2 <= extent[3];
  }
  function coordinateRelationship(extent, coordinate) {
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const x2 = coordinate[0];
    const y2 = coordinate[1];
    let relationship = Relationship_default.UNKNOWN;
    if (x2 < minX) {
      relationship = relationship | Relationship_default.LEFT;
    } else if (x2 > maxX) {
      relationship = relationship | Relationship_default.RIGHT;
    }
    if (y2 < minY) {
      relationship = relationship | Relationship_default.BELOW;
    } else if (y2 > maxY) {
      relationship = relationship | Relationship_default.ABOVE;
    }
    if (relationship === Relationship_default.UNKNOWN) {
      relationship = Relationship_default.INTERSECTING;
    }
    return relationship;
  }
  function createEmpty() {
    return [Infinity, Infinity, -Infinity, -Infinity];
  }
  function createOrUpdate(minX, minY, maxX, maxY, dest) {
    if (dest) {
      dest[0] = minX;
      dest[1] = minY;
      dest[2] = maxX;
      dest[3] = maxY;
      return dest;
    }
    return [minX, minY, maxX, maxY];
  }
  function createOrUpdateEmpty(dest) {
    return createOrUpdate(Infinity, Infinity, -Infinity, -Infinity, dest);
  }
  function createOrUpdateFromCoordinate(coordinate, dest) {
    const x2 = coordinate[0];
    const y2 = coordinate[1];
    return createOrUpdate(x2, y2, x2, y2, dest);
  }
  function createOrUpdateFromFlatCoordinates(flatCoordinates, offset2, end, stride, dest) {
    const extent = createOrUpdateEmpty(dest);
    return extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride);
  }
  function equals2(extent1, extent2) {
    return extent1[0] == extent2[0] && extent1[2] == extent2[2] && extent1[1] == extent2[1] && extent1[3] == extent2[3];
  }
  function extend2(extent1, extent2) {
    if (extent2[0] < extent1[0]) {
      extent1[0] = extent2[0];
    }
    if (extent2[2] > extent1[2]) {
      extent1[2] = extent2[2];
    }
    if (extent2[1] < extent1[1]) {
      extent1[1] = extent2[1];
    }
    if (extent2[3] > extent1[3]) {
      extent1[3] = extent2[3];
    }
    return extent1;
  }
  function extendCoordinate(extent, coordinate) {
    if (coordinate[0] < extent[0]) {
      extent[0] = coordinate[0];
    }
    if (coordinate[0] > extent[2]) {
      extent[2] = coordinate[0];
    }
    if (coordinate[1] < extent[1]) {
      extent[1] = coordinate[1];
    }
    if (coordinate[1] > extent[3]) {
      extent[3] = coordinate[1];
    }
  }
  function extendFlatCoordinates(extent, flatCoordinates, offset2, end, stride) {
    for (; offset2 < end; offset2 += stride) {
      extendXY(extent, flatCoordinates[offset2], flatCoordinates[offset2 + 1]);
    }
    return extent;
  }
  function extendXY(extent, x2, y2) {
    extent[0] = Math.min(extent[0], x2);
    extent[1] = Math.min(extent[1], y2);
    extent[2] = Math.max(extent[2], x2);
    extent[3] = Math.max(extent[3], y2);
  }
  function forEachCorner(extent, callback) {
    let val;
    val = callback(getBottomLeft(extent));
    if (val) {
      return val;
    }
    val = callback(getBottomRight(extent));
    if (val) {
      return val;
    }
    val = callback(getTopRight(extent));
    if (val) {
      return val;
    }
    val = callback(getTopLeft(extent));
    if (val) {
      return val;
    }
    return false;
  }
  function getBottomLeft(extent) {
    return [extent[0], extent[1]];
  }
  function getBottomRight(extent) {
    return [extent[2], extent[1]];
  }
  function getCenter(extent) {
    return [(extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2];
  }
  function getForViewAndSize(center, resolution, rotation, size, dest) {
    const [x0, y0, x1, y1, x2, y2, x3, y3] = getRotatedViewport(
      center,
      resolution,
      rotation,
      size
    );
    return createOrUpdate(
      Math.min(x0, x1, x2, x3),
      Math.min(y0, y1, y2, y3),
      Math.max(x0, x1, x2, x3),
      Math.max(y0, y1, y2, y3),
      dest
    );
  }
  function getRotatedViewport(center, resolution, rotation, size) {
    const dx = resolution * size[0] / 2;
    const dy = resolution * size[1] / 2;
    const cosRotation = Math.cos(rotation);
    const sinRotation = Math.sin(rotation);
    const xCos = dx * cosRotation;
    const xSin = dx * sinRotation;
    const yCos = dy * cosRotation;
    const ySin = dy * sinRotation;
    const x2 = center[0];
    const y2 = center[1];
    return [
      x2 - xCos + ySin,
      y2 - xSin - yCos,
      x2 - xCos - ySin,
      y2 - xSin + yCos,
      x2 + xCos - ySin,
      y2 + xSin + yCos,
      x2 + xCos + ySin,
      y2 + xSin - yCos,
      x2 - xCos + ySin,
      y2 - xSin - yCos
    ];
  }
  function getHeight(extent) {
    return extent[3] - extent[1];
  }
  function getIntersection(extent1, extent2, dest) {
    const intersection = dest ? dest : createEmpty();
    if (intersects(extent1, extent2)) {
      if (extent1[0] > extent2[0]) {
        intersection[0] = extent1[0];
      } else {
        intersection[0] = extent2[0];
      }
      if (extent1[1] > extent2[1]) {
        intersection[1] = extent1[1];
      } else {
        intersection[1] = extent2[1];
      }
      if (extent1[2] < extent2[2]) {
        intersection[2] = extent1[2];
      } else {
        intersection[2] = extent2[2];
      }
      if (extent1[3] < extent2[3]) {
        intersection[3] = extent1[3];
      } else {
        intersection[3] = extent2[3];
      }
    } else {
      createOrUpdateEmpty(intersection);
    }
    return intersection;
  }
  function getTopLeft(extent) {
    return [extent[0], extent[3]];
  }
  function getTopRight(extent) {
    return [extent[2], extent[3]];
  }
  function getWidth(extent) {
    return extent[2] - extent[0];
  }
  function intersects(extent1, extent2) {
    return extent1[0] <= extent2[2] && extent1[2] >= extent2[0] && extent1[1] <= extent2[3] && extent1[3] >= extent2[1];
  }
  function isEmpty2(extent) {
    return extent[2] < extent[0] || extent[3] < extent[1];
  }
  function returnOrUpdate(extent, dest) {
    if (dest) {
      dest[0] = extent[0];
      dest[1] = extent[1];
      dest[2] = extent[2];
      dest[3] = extent[3];
      return dest;
    }
    return extent;
  }
  function intersectsSegment(extent, start, end) {
    let intersects2 = false;
    const startRel = coordinateRelationship(extent, start);
    const endRel = coordinateRelationship(extent, end);
    if (startRel === Relationship_default.INTERSECTING || endRel === Relationship_default.INTERSECTING) {
      intersects2 = true;
    } else {
      const minX = extent[0];
      const minY = extent[1];
      const maxX = extent[2];
      const maxY = extent[3];
      const startX = start[0];
      const startY = start[1];
      const endX = end[0];
      const endY = end[1];
      const slope = (endY - startY) / (endX - startX);
      let x2, y2;
      if (!!(endRel & Relationship_default.ABOVE) && !(startRel & Relationship_default.ABOVE)) {
        x2 = endX - (endY - maxY) / slope;
        intersects2 = x2 >= minX && x2 <= maxX;
      }
      if (!intersects2 && !!(endRel & Relationship_default.RIGHT) && !(startRel & Relationship_default.RIGHT)) {
        y2 = endY - (endX - maxX) * slope;
        intersects2 = y2 >= minY && y2 <= maxY;
      }
      if (!intersects2 && !!(endRel & Relationship_default.BELOW) && !(startRel & Relationship_default.BELOW)) {
        x2 = endX - (endY - minY) / slope;
        intersects2 = x2 >= minX && x2 <= maxX;
      }
      if (!intersects2 && !!(endRel & Relationship_default.LEFT) && !(startRel & Relationship_default.LEFT)) {
        y2 = endY - (endX - minX) * slope;
        intersects2 = y2 >= minY && y2 <= maxY;
      }
    }
    return intersects2;
  }
  function applyTransform(extent, transformFn, dest, stops) {
    if (isEmpty2(extent)) {
      return createOrUpdateEmpty(dest);
    }
    let coordinates2 = [];
    if (stops > 1) {
      const width = extent[2] - extent[0];
      const height = extent[3] - extent[1];
      for (let i4 = 0; i4 < stops; ++i4) {
        coordinates2.push(
          extent[0] + width * i4 / stops,
          extent[1],
          extent[2],
          extent[1] + height * i4 / stops,
          extent[2] - width * i4 / stops,
          extent[3],
          extent[0],
          extent[3] - height * i4 / stops
        );
      }
    } else {
      coordinates2 = [
        extent[0],
        extent[1],
        extent[2],
        extent[1],
        extent[2],
        extent[3],
        extent[0],
        extent[3]
      ];
    }
    transformFn(coordinates2, coordinates2, 2);
    const xs = [];
    const ys = [];
    for (let i4 = 0, l4 = coordinates2.length; i4 < l4; i4 += 2) {
      xs.push(coordinates2[i4]);
      ys.push(coordinates2[i4 + 1]);
    }
    return _boundingExtentXYs(xs, ys, dest);
  }
  function wrapX(extent, projection) {
    const projectionExtent = projection.getExtent();
    const center = getCenter(extent);
    if (projection.canWrapX() && (center[0] < projectionExtent[0] || center[0] >= projectionExtent[2])) {
      const worldWidth = getWidth(projectionExtent);
      const worldsAway = Math.floor(
        (center[0] - projectionExtent[0]) / worldWidth
      );
      const offset2 = worldsAway * worldWidth;
      extent[0] -= offset2;
      extent[2] -= offset2;
    }
    return extent;
  }
  function wrapAndSliceX(extent, projection) {
    if (projection.canWrapX()) {
      const projectionExtent = projection.getExtent();
      if (!isFinite(extent[0]) || !isFinite(extent[2])) {
        return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
      }
      wrapX(extent, projection);
      const worldWidth = getWidth(projectionExtent);
      if (getWidth(extent) > worldWidth) {
        return [[projectionExtent[0], extent[1], projectionExtent[2], extent[3]]];
      }
      if (extent[0] < projectionExtent[0]) {
        return [
          [extent[0] + worldWidth, extent[1], projectionExtent[2], extent[3]],
          [projectionExtent[0], extent[1], extent[2], extent[3]]
        ];
      }
      if (extent[2] > projectionExtent[2]) {
        return [
          [extent[0], extent[1], projectionExtent[2], extent[3]],
          [projectionExtent[0], extent[1], extent[2] - worldWidth, extent[3]]
        ];
      }
    }
    return [extent];
  }

  // node_modules/ol/proj/Units.js
  var METERS_PER_UNIT = {
    // use the radius of the Normal sphere
    "radians": 6370997 / (2 * Math.PI),
    "degrees": 2 * Math.PI * 6370997 / 360,
    "ft": 0.3048,
    "m": 1,
    "us-ft": 1200 / 3937
  };

  // node_modules/ol/proj/Projection.js
  var Projection = class {
    /**
     * @param {Options} options Projection options.
     */
    constructor(options) {
      this.code_ = options.code;
      this.units_ = /** @type {import("./Units.js").Units} */
      options.units;
      this.extent_ = options.extent !== void 0 ? options.extent : null;
      this.worldExtent_ = options.worldExtent !== void 0 ? options.worldExtent : null;
      this.axisOrientation_ = options.axisOrientation !== void 0 ? options.axisOrientation : "enu";
      this.global_ = options.global !== void 0 ? options.global : false;
      this.canWrapX_ = !!(this.global_ && this.extent_);
      this.getPointResolutionFunc_ = options.getPointResolution;
      this.defaultTileGrid_ = null;
      this.metersPerUnit_ = options.metersPerUnit;
    }
    /**
     * @return {boolean} The projection is suitable for wrapping the x-axis
     */
    canWrapX() {
      return this.canWrapX_;
    }
    /**
     * Get the code for this projection, e.g. 'EPSG:4326'.
     * @return {string} Code.
     * @api
     */
    getCode() {
      return this.code_;
    }
    /**
     * Get the validity extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent() {
      return this.extent_;
    }
    /**
     * Get the units of this projection.
     * @return {import("./Units.js").Units} Units.
     * @api
     */
    getUnits() {
      return this.units_;
    }
    /**
     * Get the amount of meters per unit of this projection.  If the projection is
     * not configured with `metersPerUnit` or a units identifier, the return is
     * `undefined`.
     * @return {number|undefined} Meters.
     * @api
     */
    getMetersPerUnit() {
      return this.metersPerUnit_ || METERS_PER_UNIT[this.units_];
    }
    /**
     * Get the world extent for this projection.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getWorldExtent() {
      return this.worldExtent_;
    }
    /**
     * Get the axis orientation of this projection.
     * Example values are:
     * enu - the default easting, northing, elevation.
     * neu - northing, easting, up - useful for "lat/long" geographic coordinates,
     *     or south orientated transverse mercator.
     * wnu - westing, northing, up - some planetary coordinate systems have
     *     "west positive" coordinate systems
     * @return {string} Axis orientation.
     * @api
     */
    getAxisOrientation() {
      return this.axisOrientation_;
    }
    /**
     * Is this projection a global projection which spans the whole world?
     * @return {boolean} Whether the projection is global.
     * @api
     */
    isGlobal() {
      return this.global_;
    }
    /**
     * Set if the projection is a global projection which spans the whole world
     * @param {boolean} global Whether the projection is global.
     * @api
     */
    setGlobal(global2) {
      this.global_ = global2;
      this.canWrapX_ = !!(global2 && this.extent_);
    }
    /**
     * @return {import("../tilegrid/TileGrid.js").default} The default tile grid.
     */
    getDefaultTileGrid() {
      return this.defaultTileGrid_;
    }
    /**
     * @param {import("../tilegrid/TileGrid.js").default} tileGrid The default tile grid.
     */
    setDefaultTileGrid(tileGrid) {
      this.defaultTileGrid_ = tileGrid;
    }
    /**
     * Set the validity extent for this projection.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    setExtent(extent) {
      this.extent_ = extent;
      this.canWrapX_ = !!(this.global_ && extent);
    }
    /**
     * Set the world extent for this projection.
     * @param {import("../extent.js").Extent} worldExtent World extent
     *     [minlon, minlat, maxlon, maxlat].
     * @api
     */
    setWorldExtent(worldExtent) {
      this.worldExtent_ = worldExtent;
    }
    /**
     * Set the getPointResolution function (see {@link module:ol/proj.getPointResolution}
     * for this projection.
     * @param {function(number, import("../coordinate.js").Coordinate):number} func Function
     * @api
     */
    setGetPointResolution(func) {
      this.getPointResolutionFunc_ = func;
    }
    /**
     * Get the custom point resolution function for this projection (if set).
     * @return {function(number, import("../coordinate.js").Coordinate):number|undefined} The custom point
     * resolution function (if set).
     */
    getPointResolutionFunc() {
      return this.getPointResolutionFunc_;
    }
  };
  var Projection_default = Projection;

  // node_modules/ol/proj/epsg3857.js
  var RADIUS = 6378137;
  var HALF_SIZE = Math.PI * RADIUS;
  var EXTENT = [-HALF_SIZE, -HALF_SIZE, HALF_SIZE, HALF_SIZE];
  var WORLD_EXTENT = [-180, -85, 180, 85];
  var MAX_SAFE_Y = RADIUS * Math.log(Math.tan(Math.PI / 2));
  var EPSG3857Projection = class extends Projection_default {
    /**
     * @param {string} code Code.
     */
    constructor(code) {
      super({
        code,
        units: "m",
        extent: EXTENT,
        global: true,
        worldExtent: WORLD_EXTENT,
        getPointResolution: function(resolution, point) {
          return resolution / Math.cosh(point[1] / RADIUS);
        }
      });
    }
  };
  var PROJECTIONS = [
    new EPSG3857Projection("EPSG:3857"),
    new EPSG3857Projection("EPSG:102100"),
    new EPSG3857Projection("EPSG:102113"),
    new EPSG3857Projection("EPSG:900913"),
    new EPSG3857Projection("http://www.opengis.net/def/crs/EPSG/0/3857"),
    new EPSG3857Projection("http://www.opengis.net/gml/srs/epsg.xml#3857")
  ];
  function fromEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === void 0) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i4 = 0; i4 < length; i4 += dimension) {
      output[i4] = HALF_SIZE * input[i4] / 180;
      let y2 = RADIUS * Math.log(Math.tan(Math.PI * (+input[i4 + 1] + 90) / 360));
      if (y2 > MAX_SAFE_Y) {
        y2 = MAX_SAFE_Y;
      } else if (y2 < -MAX_SAFE_Y) {
        y2 = -MAX_SAFE_Y;
      }
      output[i4 + 1] = y2;
    }
    return output;
  }
  function toEPSG4326(input, output, dimension) {
    const length = input.length;
    dimension = dimension > 1 ? dimension : 2;
    if (output === void 0) {
      if (dimension > 2) {
        output = input.slice();
      } else {
        output = new Array(length);
      }
    }
    for (let i4 = 0; i4 < length; i4 += dimension) {
      output[i4] = 180 * input[i4] / HALF_SIZE;
      output[i4 + 1] = 360 * Math.atan(Math.exp(input[i4 + 1] / RADIUS)) / Math.PI - 90;
    }
    return output;
  }

  // node_modules/ol/proj/epsg4326.js
  var RADIUS2 = 6378137;
  var EXTENT2 = [-180, -90, 180, 90];
  var METERS_PER_UNIT2 = Math.PI * RADIUS2 / 180;
  var EPSG4326Projection = class extends Projection_default {
    /**
     * @param {string} code Code.
     * @param {string} [axisOrientation] Axis orientation.
     */
    constructor(code, axisOrientation) {
      super({
        code,
        units: "degrees",
        extent: EXTENT2,
        axisOrientation,
        global: true,
        metersPerUnit: METERS_PER_UNIT2,
        worldExtent: EXTENT2
      });
    }
  };
  var PROJECTIONS2 = [
    new EPSG4326Projection("CRS:84"),
    new EPSG4326Projection("EPSG:4326", "neu"),
    new EPSG4326Projection("urn:ogc:def:crs:OGC:1.3:CRS84"),
    new EPSG4326Projection("urn:ogc:def:crs:OGC:2:84"),
    new EPSG4326Projection("http://www.opengis.net/def/crs/OGC/1.3/CRS84"),
    new EPSG4326Projection("http://www.opengis.net/gml/srs/epsg.xml#4326", "neu"),
    new EPSG4326Projection("http://www.opengis.net/def/crs/EPSG/0/4326", "neu")
  ];

  // node_modules/ol/proj/projections.js
  var cache = {};
  function get(code) {
    return cache[code] || cache[code.replace(/urn:(x-)?ogc:def:crs:EPSG:(.*:)?(\w+)$/, "EPSG:$3")] || null;
  }
  function add(code, projection) {
    cache[code] = projection;
  }

  // node_modules/ol/proj/transforms.js
  var transforms = {};
  function add2(source, destination, transformFn) {
    const sourceCode = source.getCode();
    const destinationCode = destination.getCode();
    if (!(sourceCode in transforms)) {
      transforms[sourceCode] = {};
    }
    transforms[sourceCode][destinationCode] = transformFn;
  }
  function get2(sourceCode, destinationCode) {
    let transform2;
    if (sourceCode in transforms && destinationCode in transforms[sourceCode]) {
      transform2 = transforms[sourceCode][destinationCode];
    }
    return transform2;
  }

  // node_modules/ol/math.js
  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }
  function squaredSegmentDistance(x2, y2, x1, y1, x22, y22) {
    const dx = x22 - x1;
    const dy = y22 - y1;
    if (dx !== 0 || dy !== 0) {
      const t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
      if (t3 > 1) {
        x1 = x22;
        y1 = y22;
      } else if (t3 > 0) {
        x1 += dx * t3;
        y1 += dy * t3;
      }
    }
    return squaredDistance(x2, y2, x1, y1);
  }
  function squaredDistance(x1, y1, x2, y2) {
    const dx = x2 - x1;
    const dy = y2 - y1;
    return dx * dx + dy * dy;
  }
  function toDegrees(angleInRadians) {
    return angleInRadians * 180 / Math.PI;
  }
  function toRadians(angleInDegrees) {
    return angleInDegrees * Math.PI / 180;
  }
  function modulo(a4, b3) {
    const r4 = a4 % b3;
    return r4 * b3 < 0 ? r4 + b3 : r4;
  }
  function lerp(a4, b3, x2) {
    return a4 + x2 * (b3 - a4);
  }
  function toFixed(n2, decimals) {
    const factor = Math.pow(10, decimals);
    return Math.round(n2 * factor) / factor;
  }

  // node_modules/ol/coordinate.js
  function add3(coordinate, delta) {
    coordinate[0] += +delta[0];
    coordinate[1] += +delta[1];
    return coordinate;
  }
  function equals3(coordinate1, coordinate2) {
    let equals4 = true;
    for (let i4 = coordinate1.length - 1; i4 >= 0; --i4) {
      if (coordinate1[i4] != coordinate2[i4]) {
        equals4 = false;
        break;
      }
    }
    return equals4;
  }
  function rotate(coordinate, angle) {
    const cosAngle = Math.cos(angle);
    const sinAngle = Math.sin(angle);
    const x2 = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    const y2 = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    coordinate[0] = x2;
    coordinate[1] = y2;
    return coordinate;
  }
  function scale(coordinate, scale3) {
    coordinate[0] *= scale3;
    coordinate[1] *= scale3;
    return coordinate;
  }
  function wrapX2(coordinate, projection) {
    if (projection.canWrapX()) {
      const worldWidth = getWidth(projection.getExtent());
      const worldsAway = getWorldsAway(coordinate, projection, worldWidth);
      if (worldsAway) {
        coordinate[0] -= worldsAway * worldWidth;
      }
    }
    return coordinate;
  }
  function getWorldsAway(coordinate, projection, sourceExtentWidth) {
    const projectionExtent = projection.getExtent();
    let worldsAway = 0;
    if (projection.canWrapX() && (coordinate[0] < projectionExtent[0] || coordinate[0] > projectionExtent[2])) {
      sourceExtentWidth = sourceExtentWidth || getWidth(projectionExtent);
      worldsAway = Math.floor(
        (coordinate[0] - projectionExtent[0]) / sourceExtentWidth
      );
    }
    return worldsAway;
  }

  // node_modules/ol/sphere.js
  var DEFAULT_RADIUS = 63710088e-1;
  function getDistance(c1, c22, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = toRadians(c1[1]);
    const lat2 = toRadians(c22[1]);
    const deltaLatBy2 = (lat2 - lat1) / 2;
    const deltaLonBy2 = toRadians(c22[0] - c1[0]) / 2;
    const a4 = Math.sin(deltaLatBy2) * Math.sin(deltaLatBy2) + Math.sin(deltaLonBy2) * Math.sin(deltaLonBy2) * Math.cos(lat1) * Math.cos(lat2);
    return 2 * radius * Math.atan2(Math.sqrt(a4), Math.sqrt(1 - a4));
  }
  function offset(c1, distance, bearing, radius) {
    radius = radius || DEFAULT_RADIUS;
    const lat1 = toRadians(c1[1]);
    const lon1 = toRadians(c1[0]);
    const dByR = distance / radius;
    const lat = Math.asin(
      Math.sin(lat1) * Math.cos(dByR) + Math.cos(lat1) * Math.sin(dByR) * Math.cos(bearing)
    );
    const lon = lon1 + Math.atan2(
      Math.sin(bearing) * Math.sin(dByR) * Math.cos(lat1),
      Math.cos(dByR) - Math.sin(lat1) * Math.sin(lat)
    );
    return [toDegrees(lon), toDegrees(lat)];
  }

  // node_modules/ol/console.js
  var levels = {
    info: 1,
    warn: 2,
    error: 3,
    none: 4
  };
  var level = levels.info;
  function warn(...args) {
    if (level > levels.warn) {
      return;
    }
    console.warn(...args);
  }

  // node_modules/ol/proj.js
  var showCoordinateWarning = true;
  function disableCoordinateWarning(disable2) {
    const hide = disable2 === void 0 ? true : disable2;
    showCoordinateWarning = !hide;
  }
  function cloneTransform(input, output) {
    if (output !== void 0) {
      for (let i4 = 0, ii = input.length; i4 < ii; ++i4) {
        output[i4] = input[i4];
      }
      output = output;
    } else {
      output = input.slice();
    }
    return output;
  }
  function identityTransform(input, output) {
    if (output !== void 0 && input !== output) {
      for (let i4 = 0, ii = input.length; i4 < ii; ++i4) {
        output[i4] = input[i4];
      }
      input = output;
    }
    return input;
  }
  function addProjection(projection) {
    add(projection.getCode(), projection);
    add2(projection, projection, cloneTransform);
  }
  function addProjections(projections) {
    projections.forEach(addProjection);
  }
  function get3(projectionLike) {
    return typeof projectionLike === "string" ? get(
      /** @type {string} */
      projectionLike
    ) : (
      /** @type {Projection} */
      projectionLike || null
    );
  }
  function getPointResolution(projection, resolution, point, units) {
    projection = get3(projection);
    let pointResolution;
    const getter = projection.getPointResolutionFunc();
    if (getter) {
      pointResolution = getter(resolution, point);
      if (units && units !== projection.getUnits()) {
        const metersPerUnit = projection.getMetersPerUnit();
        if (metersPerUnit) {
          pointResolution = pointResolution * metersPerUnit / METERS_PER_UNIT[units];
        }
      }
    } else {
      const projUnits = projection.getUnits();
      if (projUnits == "degrees" && !units || units == "degrees") {
        pointResolution = resolution;
      } else {
        const toEPSG43262 = getTransformFromProjections(
          projection,
          get3("EPSG:4326")
        );
        if (toEPSG43262 === identityTransform && projUnits !== "degrees") {
          pointResolution = resolution * projection.getMetersPerUnit();
        } else {
          let vertices = [
            point[0] - resolution / 2,
            point[1],
            point[0] + resolution / 2,
            point[1],
            point[0],
            point[1] - resolution / 2,
            point[0],
            point[1] + resolution / 2
          ];
          vertices = toEPSG43262(vertices, vertices, 2);
          const width = getDistance(vertices.slice(0, 2), vertices.slice(2, 4));
          const height = getDistance(vertices.slice(4, 6), vertices.slice(6, 8));
          pointResolution = (width + height) / 2;
        }
        const metersPerUnit = units ? METERS_PER_UNIT[units] : projection.getMetersPerUnit();
        if (metersPerUnit !== void 0) {
          pointResolution /= metersPerUnit;
        }
      }
    }
    return pointResolution;
  }
  function addEquivalentProjections(projections) {
    addProjections(projections);
    projections.forEach(function(source) {
      projections.forEach(function(destination) {
        if (source !== destination) {
          add2(source, destination, cloneTransform);
        }
      });
    });
  }
  function addEquivalentTransforms(projections1, projections2, forwardTransform, inverseTransform) {
    projections1.forEach(function(projection1) {
      projections2.forEach(function(projection2) {
        add2(projection1, projection2, forwardTransform);
        add2(projection2, projection1, inverseTransform);
      });
    });
  }
  function createProjection(projection, defaultCode) {
    if (!projection) {
      return get3(defaultCode);
    }
    if (typeof projection === "string") {
      return get3(projection);
    }
    return (
      /** @type {Projection} */
      projection
    );
  }
  function fromLonLat(coordinate, projection) {
    disableCoordinateWarning();
    return transform(
      coordinate,
      "EPSG:4326",
      projection !== void 0 ? projection : "EPSG:3857"
    );
  }
  function toLonLat(coordinate, projection) {
    const lonLat = transform(
      coordinate,
      projection !== void 0 ? projection : "EPSG:3857",
      "EPSG:4326"
    );
    const lon = lonLat[0];
    if (lon < -180 || lon > 180) {
      lonLat[0] = modulo(lon + 180, 360) - 180;
    }
    return lonLat;
  }
  function equivalent(projection1, projection2) {
    if (projection1 === projection2) {
      return true;
    }
    const equalUnits = projection1.getUnits() === projection2.getUnits();
    if (projection1.getCode() === projection2.getCode()) {
      return equalUnits;
    }
    const transformFunc = getTransformFromProjections(projection1, projection2);
    return transformFunc === cloneTransform && equalUnits;
  }
  function getTransformFromProjections(sourceProjection, destinationProjection) {
    const sourceCode = sourceProjection.getCode();
    const destinationCode = destinationProjection.getCode();
    let transformFunc = get2(sourceCode, destinationCode);
    if (!transformFunc) {
      transformFunc = identityTransform;
    }
    return transformFunc;
  }
  function getTransform(source, destination) {
    const sourceProjection = get3(source);
    const destinationProjection = get3(destination);
    return getTransformFromProjections(sourceProjection, destinationProjection);
  }
  function transform(coordinate, source, destination) {
    const transformFunc = getTransform(source, destination);
    return transformFunc(coordinate, void 0, coordinate.length);
  }
  function transformExtent(extent, source, destination, stops) {
    const transformFunc = getTransform(source, destination);
    return applyTransform(extent, transformFunc, void 0, stops);
  }
  var userProjection = null;
  function getUserProjection() {
    return userProjection;
  }
  function toUserCoordinate(coordinate, sourceProjection) {
    if (!userProjection) {
      return coordinate;
    }
    return transform(coordinate, sourceProjection, userProjection);
  }
  function fromUserCoordinate(coordinate, destProjection) {
    if (!userProjection) {
      if (showCoordinateWarning && !equals3(coordinate, [0, 0]) && coordinate[0] >= -180 && coordinate[0] <= 180 && coordinate[1] >= -90 && coordinate[1] <= 90) {
        showCoordinateWarning = false;
        warn(
          "Call useGeographic() from ol/proj once to work with [longitude, latitude] coordinates."
        );
      }
      return coordinate;
    }
    return transform(coordinate, userProjection, destProjection);
  }
  function toUserExtent(extent, sourceProjection) {
    if (!userProjection) {
      return extent;
    }
    return transformExtent(extent, sourceProjection, userProjection);
  }
  function fromUserExtent(extent, destProjection) {
    if (!userProjection) {
      return extent;
    }
    return transformExtent(extent, userProjection, destProjection);
  }
  function toUserResolution(resolution, sourceProjection) {
    if (!userProjection) {
      return resolution;
    }
    const sourceUnits = get3(sourceProjection).getUnits();
    const userUnits = userProjection.getUnits();
    return sourceUnits && userUnits ? resolution * METERS_PER_UNIT[sourceUnits] / METERS_PER_UNIT[userUnits] : resolution;
  }
  function addCommon() {
    addEquivalentProjections(PROJECTIONS);
    addEquivalentProjections(PROJECTIONS2);
    addEquivalentTransforms(
      PROJECTIONS2,
      PROJECTIONS,
      fromEPSG4326,
      toEPSG4326
    );
  }
  addCommon();

  // node_modules/ol/geom/flat/transform.js
  function transform2D(flatCoordinates, offset2, end, stride, transform2, dest) {
    dest = dest ? dest : [];
    let i4 = 0;
    for (let j3 = offset2; j3 < end; j3 += stride) {
      const x2 = flatCoordinates[j3];
      const y2 = flatCoordinates[j3 + 1];
      dest[i4++] = transform2[0] * x2 + transform2[2] * y2 + transform2[4];
      dest[i4++] = transform2[1] * x2 + transform2[3] * y2 + transform2[5];
    }
    if (dest && dest.length != i4) {
      dest.length = i4;
    }
    return dest;
  }
  function rotate2(flatCoordinates, offset2, end, stride, angle, anchor, dest) {
    dest = dest ? dest : [];
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i4 = 0;
    for (let j3 = offset2; j3 < end; j3 += stride) {
      const deltaX = flatCoordinates[j3] - anchorX;
      const deltaY = flatCoordinates[j3 + 1] - anchorY;
      dest[i4++] = anchorX + deltaX * cos - deltaY * sin;
      dest[i4++] = anchorY + deltaX * sin + deltaY * cos;
      for (let k3 = j3 + 2; k3 < j3 + stride; ++k3) {
        dest[i4++] = flatCoordinates[k3];
      }
    }
    if (dest && dest.length != i4) {
      dest.length = i4;
    }
    return dest;
  }
  function scale2(flatCoordinates, offset2, end, stride, sx, sy, anchor, dest) {
    dest = dest ? dest : [];
    const anchorX = anchor[0];
    const anchorY = anchor[1];
    let i4 = 0;
    for (let j3 = offset2; j3 < end; j3 += stride) {
      const deltaX = flatCoordinates[j3] - anchorX;
      const deltaY = flatCoordinates[j3 + 1] - anchorY;
      dest[i4++] = anchorX + sx * deltaX;
      dest[i4++] = anchorY + sy * deltaY;
      for (let k3 = j3 + 2; k3 < j3 + stride; ++k3) {
        dest[i4++] = flatCoordinates[k3];
      }
    }
    if (dest && dest.length != i4) {
      dest.length = i4;
    }
    return dest;
  }
  function translate(flatCoordinates, offset2, end, stride, deltaX, deltaY, dest) {
    dest = dest ? dest : [];
    let i4 = 0;
    for (let j3 = offset2; j3 < end; j3 += stride) {
      dest[i4++] = flatCoordinates[j3] + deltaX;
      dest[i4++] = flatCoordinates[j3 + 1] + deltaY;
      for (let k3 = j3 + 2; k3 < j3 + stride; ++k3) {
        dest[i4++] = flatCoordinates[k3];
      }
    }
    if (dest && dest.length != i4) {
      dest.length = i4;
    }
    return dest;
  }

  // node_modules/ol/geom/Geometry.js
  var tmpTransform = create();
  var Geometry = class extends Object_default {
    constructor() {
      super();
      this.extent_ = createEmpty();
      this.extentRevision_ = -1;
      this.simplifiedGeometryMaxMinSquaredTolerance = 0;
      this.simplifiedGeometryRevision = 0;
      this.simplifyTransformedInternal = memoizeOne(function(revision, squaredTolerance, transform2) {
        if (!transform2) {
          return this.getSimplifiedGeometry(squaredTolerance);
        }
        const clone2 = this.clone();
        clone2.applyTransform(transform2);
        return clone2.getSimplifiedGeometry(squaredTolerance);
      });
    }
    /**
     * Get a transformed and simplified version of the geometry.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @param {import("../proj.js").TransformFunction} [transform] Optional transform function.
     * @return {Geometry} Simplified geometry.
     */
    simplifyTransformed(squaredTolerance, transform2) {
      return this.simplifyTransformedInternal(
        this.getRevision(),
        squaredTolerance,
        transform2
      );
    }
    /**
     * Make a complete copy of the geometry.
     * @abstract
     * @return {!Geometry} Clone.
     */
    clone() {
      return abstract();
    }
    /**
     * @abstract
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      return abstract();
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(x2, y2) {
      const coord = this.getClosestPoint([x2, y2]);
      return coord[0] === x2 && coord[1] === y2;
    }
    /**
     * Return the closest point of the geometry to the passed point as
     * {@link module:ol/coordinate~Coordinate coordinate}.
     * @param {import("../coordinate.js").Coordinate} point Point.
     * @param {import("../coordinate.js").Coordinate} [closestPoint] Closest point.
     * @return {import("../coordinate.js").Coordinate} Closest point.
     * @api
     */
    getClosestPoint(point, closestPoint) {
      closestPoint = closestPoint ? closestPoint : [NaN, NaN];
      this.closestPointXY(point[0], point[1], closestPoint, Infinity);
      return closestPoint;
    }
    /**
     * Returns true if this geometry includes the specified coordinate. If the
     * coordinate is on the boundary of the geometry, returns false.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {boolean} Contains coordinate.
     * @api
     */
    intersectsCoordinate(coordinate) {
      return this.containsXY(coordinate[0], coordinate[1]);
    }
    /**
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(extent) {
      return abstract();
    }
    /**
     * Get the extent of the geometry.
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} extent Extent.
     * @api
     */
    getExtent(extent) {
      if (this.extentRevision_ != this.getRevision()) {
        const extent2 = this.computeExtent(this.extent_);
        if (isNaN(extent2[0]) || isNaN(extent2[1])) {
          createOrUpdateEmpty(extent2);
        }
        this.extentRevision_ = this.getRevision();
      }
      return returnOrUpdate(this.extent_, extent);
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(angle, anchor) {
      abstract();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(sx, sy, anchor) {
      abstract();
    }
    /**
     * Create a simplified version of this geometry.  For linestrings, this uses
     * the [Douglas Peucker](https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm)
     * algorithm.  For polygons, a quantization-based
     * simplification is used to preserve topology.
     * @param {number} tolerance The tolerance distance for simplification.
     * @return {Geometry} A new, simplified version of the original geometry.
     * @api
     */
    simplify(tolerance) {
      return this.getSimplifiedGeometry(tolerance * tolerance);
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker
     * algorithm.
     * See https://en.wikipedia.org/wiki/Ramer-Douglas-Peucker_algorithm.
     * @abstract
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Geometry} Simplified geometry.
     */
    getSimplifiedGeometry(squaredTolerance) {
      return abstract();
    }
    /**
     * Get the type of this geometry.
     * @abstract
     * @return {Type} Geometry type.
     */
    getType() {
      return abstract();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @abstract
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     */
    applyTransform(transformFn) {
      abstract();
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @abstract
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     */
    intersectsExtent(extent) {
      return abstract();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @abstract
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(deltaX, deltaY) {
      abstract();
    }
    /**
     * Transform each coordinate of the geometry from one coordinate reference
     * system to another. The geometry is modified in place.
     * For example, a line will be transformed to a line and a circle to a circle.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     *
     * @param {import("../proj.js").ProjectionLike} source The current projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @param {import("../proj.js").ProjectionLike} destination The desired projection.  Can be a
     *     string identifier or a {@link module:ol/proj/Projection~Projection} object.
     * @return {Geometry} This geometry.  Note that original geometry is
     *     modified in place.
     * @api
     */
    transform(source, destination) {
      const sourceProj = get3(source);
      const transformFn = sourceProj.getUnits() == "tile-pixels" ? function(inCoordinates, outCoordinates, stride) {
        const pixelExtent = sourceProj.getExtent();
        const projectedExtent = sourceProj.getWorldExtent();
        const scale3 = getHeight(projectedExtent) / getHeight(pixelExtent);
        compose(
          tmpTransform,
          projectedExtent[0],
          projectedExtent[3],
          scale3,
          -scale3,
          0,
          0,
          0
        );
        transform2D(
          inCoordinates,
          0,
          inCoordinates.length,
          stride,
          tmpTransform,
          outCoordinates
        );
        return getTransform(sourceProj, destination)(
          inCoordinates,
          outCoordinates,
          stride
        );
      } : getTransform(sourceProj, destination);
      this.applyTransform(transformFn);
      return this;
    }
  };
  var Geometry_default = Geometry;

  // node_modules/ol/geom/SimpleGeometry.js
  var SimpleGeometry = class extends Geometry_default {
    constructor() {
      super();
      this.layout = "XY";
      this.stride = 2;
      this.flatCoordinates = null;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(extent) {
      return createOrUpdateFromFlatCoordinates(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        extent
      );
    }
    /**
     * @abstract
     * @return {Array<*> | null} Coordinates.
     */
    getCoordinates() {
      return abstract();
    }
    /**
     * Return the first coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} First coordinate.
     * @api
     */
    getFirstCoordinate() {
      return this.flatCoordinates.slice(0, this.stride);
    }
    /**
     * @return {Array<number>} Flat coordinates.
     */
    getFlatCoordinates() {
      return this.flatCoordinates;
    }
    /**
     * Return the last coordinate of the geometry.
     * @return {import("../coordinate.js").Coordinate} Last point.
     * @api
     */
    getLastCoordinate() {
      return this.flatCoordinates.slice(
        this.flatCoordinates.length - this.stride
      );
    }
    /**
     * Return the {@link import("./Geometry.js").GeometryLayout layout} of the geometry.
     * @return {import("./Geometry.js").GeometryLayout} Layout.
     * @api
     */
    getLayout() {
      return this.layout;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     */
    getSimplifiedGeometry(squaredTolerance) {
      if (this.simplifiedGeometryRevision !== this.getRevision()) {
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = this.getRevision();
      }
      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance <= this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }
      const simplifiedGeometry = this.getSimplifiedGeometryInternal(squaredTolerance);
      const simplifiedFlatCoordinates = simplifiedGeometry.getFlatCoordinates();
      if (simplifiedFlatCoordinates.length < this.flatCoordinates.length) {
        return simplifiedGeometry;
      }
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {SimpleGeometry} Simplified geometry.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      return this;
    }
    /**
     * @return {number} Stride.
     */
    getStride() {
      return this.stride;
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout} layout Layout.
     * @param {Array<number>} flatCoordinates Flat coordinates.
     */
    setFlatCoordinates(layout, flatCoordinates) {
      this.stride = getStrideForLayout(layout);
      this.layout = layout;
      this.flatCoordinates = flatCoordinates;
    }
    /**
     * @abstract
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    setCoordinates(coordinates2, layout) {
      abstract();
    }
    /**
     * @param {import("./Geometry.js").GeometryLayout|undefined} layout Layout.
     * @param {Array<*>} coordinates Coordinates.
     * @param {number} nesting Nesting.
     * @protected
     */
    setLayout(layout, coordinates2, nesting) {
      let stride;
      if (layout) {
        stride = getStrideForLayout(layout);
      } else {
        for (let i4 = 0; i4 < nesting; ++i4) {
          if (coordinates2.length === 0) {
            this.layout = "XY";
            this.stride = 2;
            return;
          }
          coordinates2 = /** @type {Array} */
          coordinates2[0];
        }
        stride = coordinates2.length;
        layout = getLayoutForStride(stride);
      }
      this.layout = layout;
      this.stride = stride;
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
    applyTransform(transformFn) {
      if (this.flatCoordinates) {
        transformFn(this.flatCoordinates, this.flatCoordinates, this.stride);
        this.changed();
      }
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in counter-clockwise radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(angle, anchor) {
      const flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        const stride = this.getStride();
        rotate2(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          angle,
          anchor,
          flatCoordinates
        );
        this.changed();
      }
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(sx, sy, anchor) {
      if (sy === void 0) {
        sy = sx;
      }
      if (!anchor) {
        anchor = getCenter(this.getExtent());
      }
      const flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        const stride = this.getStride();
        scale2(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          sx,
          sy,
          anchor,
          flatCoordinates
        );
        this.changed();
      }
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(deltaX, deltaY) {
      const flatCoordinates = this.getFlatCoordinates();
      if (flatCoordinates) {
        const stride = this.getStride();
        translate(
          flatCoordinates,
          0,
          flatCoordinates.length,
          stride,
          deltaX,
          deltaY,
          flatCoordinates
        );
        this.changed();
      }
    }
  };
  function getLayoutForStride(stride) {
    let layout;
    if (stride == 2) {
      layout = "XY";
    } else if (stride == 3) {
      layout = "XYZ";
    } else if (stride == 4) {
      layout = "XYZM";
    }
    return (
      /** @type {import("./Geometry.js").GeometryLayout} */
      layout
    );
  }
  function getStrideForLayout(layout) {
    let stride;
    if (layout == "XY") {
      stride = 2;
    } else if (layout == "XYZ" || layout == "XYM") {
      stride = 3;
    } else if (layout == "XYZM") {
      stride = 4;
    }
    return (
      /** @type {number} */
      stride
    );
  }
  function transformGeom2D(simpleGeometry, transform2, dest) {
    const flatCoordinates = simpleGeometry.getFlatCoordinates();
    if (!flatCoordinates) {
      return null;
    }
    const stride = simpleGeometry.getStride();
    return transform2D(
      flatCoordinates,
      0,
      flatCoordinates.length,
      stride,
      transform2,
      dest
    );
  }
  var SimpleGeometry_default = SimpleGeometry;

  // node_modules/ol/geom/flat/deflate.js
  function deflateCoordinate(flatCoordinates, offset2, coordinate, stride) {
    for (let i4 = 0, ii = coordinate.length; i4 < ii; ++i4) {
      flatCoordinates[offset2++] = coordinate[i4];
    }
    return offset2;
  }
  function deflateCoordinates(flatCoordinates, offset2, coordinates2, stride) {
    for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
      const coordinate = coordinates2[i4];
      for (let j3 = 0; j3 < stride; ++j3) {
        flatCoordinates[offset2++] = coordinate[j3];
      }
    }
    return offset2;
  }
  function deflateCoordinatesArray(flatCoordinates, offset2, coordinatess, stride, ends) {
    ends = ends ? ends : [];
    let i4 = 0;
    for (let j3 = 0, jj = coordinatess.length; j3 < jj; ++j3) {
      const end = deflateCoordinates(
        flatCoordinates,
        offset2,
        coordinatess[j3],
        stride
      );
      ends[i4++] = end;
      offset2 = end;
    }
    ends.length = i4;
    return ends;
  }
  function deflateMultiCoordinatesArray(flatCoordinates, offset2, coordinatesss, stride, endss) {
    endss = endss ? endss : [];
    let i4 = 0;
    for (let j3 = 0, jj = coordinatesss.length; j3 < jj; ++j3) {
      const ends = deflateCoordinatesArray(
        flatCoordinates,
        offset2,
        coordinatesss[j3],
        stride,
        endss[i4]
      );
      if (ends.length === 0) {
        ends[0] = offset2;
      }
      endss[i4++] = ends;
      offset2 = ends[ends.length - 1];
    }
    endss.length = i4;
    return endss;
  }

  // node_modules/ol/geom/GeometryCollection.js
  var GeometryCollection = class _GeometryCollection extends Geometry_default {
    /**
     * @param {Array<Geometry>} [geometries] Geometries.
     */
    constructor(geometries) {
      super();
      this.geometries_ = geometries ? geometries : null;
      this.changeEventsKeys_ = [];
      this.listenGeometriesChange_();
    }
    /**
     * @private
     */
    unlistenGeometriesChange_() {
      this.changeEventsKeys_.forEach(unlistenByKey);
      this.changeEventsKeys_.length = 0;
    }
    /**
     * @private
     */
    listenGeometriesChange_() {
      if (!this.geometries_) {
        return;
      }
      for (let i4 = 0, ii = this.geometries_.length; i4 < ii; ++i4) {
        this.changeEventsKeys_.push(
          listen(this.geometries_[i4], EventType_default.CHANGE, this.changed, this)
        );
      }
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!GeometryCollection} Clone.
     * @api
     */
    clone() {
      const geometryCollection = new _GeometryCollection(null);
      geometryCollection.setGeometries(this.geometries_);
      geometryCollection.applyProperties(this);
      return geometryCollection;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        minSquaredDistance = geometries[i4].closestPointXY(
          x2,
          y2,
          closestPoint,
          minSquaredDistance
        );
      }
      return minSquaredDistance;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(x2, y2) {
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        if (geometries[i4].containsXY(x2, y2)) {
          return true;
        }
      }
      return false;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(extent) {
      createOrUpdateEmpty(extent);
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        extend2(extent, geometries[i4].getExtent());
      }
      return extent;
    }
    /**
     * Return the geometries that make up this geometry collection.
     * @return {Array<Geometry>} Geometries.
     * @api
     */
    getGeometries() {
      return cloneGeometries(this.geometries_);
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArray() {
      return this.geometries_;
    }
    /**
     * @return {Array<Geometry>} Geometries.
     */
    getGeometriesArrayRecursive() {
      let geometriesArray = [];
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        if (geometries[i4].getType() === this.getType()) {
          geometriesArray = geometriesArray.concat(
            /** @type {GeometryCollection} */
            geometries[i4].getGeometriesArrayRecursive()
          );
        } else {
          geometriesArray.push(geometries[i4]);
        }
      }
      return geometriesArray;
    }
    /**
     * Create a simplified version of this geometry using the Douglas Peucker algorithm.
     * @param {number} squaredTolerance Squared tolerance.
     * @return {GeometryCollection} Simplified GeometryCollection.
     */
    getSimplifiedGeometry(squaredTolerance) {
      if (this.simplifiedGeometryRevision !== this.getRevision()) {
        this.simplifiedGeometryMaxMinSquaredTolerance = 0;
        this.simplifiedGeometryRevision = this.getRevision();
      }
      if (squaredTolerance < 0 || this.simplifiedGeometryMaxMinSquaredTolerance !== 0 && squaredTolerance < this.simplifiedGeometryMaxMinSquaredTolerance) {
        return this;
      }
      const simplifiedGeometries = [];
      const geometries = this.geometries_;
      let simplified = false;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        const geometry = geometries[i4];
        const simplifiedGeometry = geometry.getSimplifiedGeometry(squaredTolerance);
        simplifiedGeometries.push(simplifiedGeometry);
        if (simplifiedGeometry !== geometry) {
          simplified = true;
        }
      }
      if (simplified) {
        const simplifiedGeometryCollection = new _GeometryCollection(null);
        simplifiedGeometryCollection.setGeometriesArray(simplifiedGeometries);
        return simplifiedGeometryCollection;
      }
      this.simplifiedGeometryMaxMinSquaredTolerance = squaredTolerance;
      return this;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "GeometryCollection";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        if (geometries[i4].intersectsExtent(extent)) {
          return true;
        }
      }
      return false;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.geometries_.length === 0;
    }
    /**
     * Rotate the geometry around a given coordinate. This modifies the geometry
     * coordinates in place.
     * @param {number} angle Rotation angle in radians.
     * @param {import("../coordinate.js").Coordinate} anchor The rotation center.
     * @api
     */
    rotate(angle, anchor) {
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        geometries[i4].rotate(angle, anchor);
      }
      this.changed();
    }
    /**
     * Scale the geometry (with an optional origin).  This modifies the geometry
     * coordinates in place.
     * @abstract
     * @param {number} sx The scaling factor in the x-direction.
     * @param {number} [sy] The scaling factor in the y-direction (defaults to sx).
     * @param {import("../coordinate.js").Coordinate} [anchor] The scale origin (defaults to the center
     *     of the geometry extent).
     * @api
     */
    scale(sx, sy, anchor) {
      if (!anchor) {
        anchor = getCenter(this.getExtent());
      }
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        geometries[i4].scale(sx, sy, anchor);
      }
      this.changed();
    }
    /**
     * Set the geometries that make up this geometry collection.
     * @param {Array<Geometry>} geometries Geometries.
     * @api
     */
    setGeometries(geometries) {
      this.setGeometriesArray(cloneGeometries(geometries));
    }
    /**
     * @param {Array<Geometry>} geometries Geometries.
     */
    setGeometriesArray(geometries) {
      this.unlistenGeometriesChange_();
      this.geometries_ = geometries;
      this.listenGeometriesChange_();
      this.changed();
    }
    /**
     * Apply a transform function to the coordinates of the geometry.
     * The geometry is modified in place.
     * If you do not want the geometry modified in place, first `clone()` it and
     * then use this function on the clone.
     * @param {import("../proj.js").TransformFunction} transformFn Transform function.
     * Called with a flat array of geometry coordinates.
     * @api
     */
    applyTransform(transformFn) {
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        geometries[i4].applyTransform(transformFn);
      }
      this.changed();
    }
    /**
     * Translate the geometry.  This modifies the geometry coordinates in place.  If
     * instead you want a new geometry, first `clone()` this geometry.
     * @param {number} deltaX Delta X.
     * @param {number} deltaY Delta Y.
     * @api
     */
    translate(deltaX, deltaY) {
      const geometries = this.geometries_;
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        geometries[i4].translate(deltaX, deltaY);
      }
      this.changed();
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      this.unlistenGeometriesChange_();
      super.disposeInternal();
    }
  };
  function cloneGeometries(geometries) {
    const clonedGeometries = [];
    for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
      clonedGeometries.push(geometries[i4].clone());
    }
    return clonedGeometries;
  }
  var GeometryCollection_default = GeometryCollection;

  // node_modules/ol/geom/flat/closest.js
  function assignClosest(flatCoordinates, offset1, offset2, stride, x2, y2, closestPoint) {
    const x1 = flatCoordinates[offset1];
    const y1 = flatCoordinates[offset1 + 1];
    const dx = flatCoordinates[offset2] - x1;
    const dy = flatCoordinates[offset2 + 1] - y1;
    let offset3;
    if (dx === 0 && dy === 0) {
      offset3 = offset1;
    } else {
      const t3 = ((x2 - x1) * dx + (y2 - y1) * dy) / (dx * dx + dy * dy);
      if (t3 > 1) {
        offset3 = offset2;
      } else if (t3 > 0) {
        for (let i4 = 0; i4 < stride; ++i4) {
          closestPoint[i4] = lerp(
            flatCoordinates[offset1 + i4],
            flatCoordinates[offset2 + i4],
            t3
          );
        }
        closestPoint.length = stride;
        return;
      } else {
        offset3 = offset1;
      }
    }
    for (let i4 = 0; i4 < stride; ++i4) {
      closestPoint[i4] = flatCoordinates[offset3 + i4];
    }
    closestPoint.length = stride;
  }
  function maxSquaredDelta(flatCoordinates, offset2, end, stride, max) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    for (offset2 += stride; offset2 < end; offset2 += stride) {
      const x2 = flatCoordinates[offset2];
      const y2 = flatCoordinates[offset2 + 1];
      const squaredDelta = squaredDistance(x1, y1, x2, y2);
      if (squaredDelta > max) {
        max = squaredDelta;
      }
      x1 = x2;
      y1 = y2;
    }
    return max;
  }
  function arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max) {
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      max = maxSquaredDelta(flatCoordinates, offset2, end, stride, max);
      offset2 = end;
    }
    return max;
  }
  function multiArrayMaxSquaredDelta(flatCoordinates, offset2, endss, stride, max) {
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      max = arrayMaxSquaredDelta(flatCoordinates, offset2, ends, stride, max);
      offset2 = ends[ends.length - 1];
    }
    return max;
  }
  function assignClosestPoint(flatCoordinates, offset2, end, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
    if (offset2 == end) {
      return minSquaredDistance;
    }
    let i4, squaredDistance2;
    if (maxDelta === 0) {
      squaredDistance2 = squaredDistance(
        x2,
        y2,
        flatCoordinates[offset2],
        flatCoordinates[offset2 + 1]
      );
      if (squaredDistance2 < minSquaredDistance) {
        for (i4 = 0; i4 < stride; ++i4) {
          closestPoint[i4] = flatCoordinates[offset2 + i4];
        }
        closestPoint.length = stride;
        return squaredDistance2;
      }
      return minSquaredDistance;
    }
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    let index = offset2 + stride;
    while (index < end) {
      assignClosest(
        flatCoordinates,
        index - stride,
        index,
        stride,
        x2,
        y2,
        tmpPoint
      );
      squaredDistance2 = squaredDistance(x2, y2, tmpPoint[0], tmpPoint[1]);
      if (squaredDistance2 < minSquaredDistance) {
        minSquaredDistance = squaredDistance2;
        for (i4 = 0; i4 < stride; ++i4) {
          closestPoint[i4] = tmpPoint[i4];
        }
        closestPoint.length = stride;
        index += stride;
      } else {
        index += stride * Math.max(
          (Math.sqrt(squaredDistance2) - Math.sqrt(minSquaredDistance)) / maxDelta | 0,
          1
        );
      }
    }
    if (isRing) {
      assignClosest(
        flatCoordinates,
        end - stride,
        offset2,
        stride,
        x2,
        y2,
        tmpPoint
      );
      squaredDistance2 = squaredDistance(x2, y2, tmpPoint[0], tmpPoint[1]);
      if (squaredDistance2 < minSquaredDistance) {
        minSquaredDistance = squaredDistance2;
        for (i4 = 0; i4 < stride; ++i4) {
          closestPoint[i4] = tmpPoint[i4];
        }
        closestPoint.length = stride;
      }
    }
    return minSquaredDistance;
  }
  function assignClosestArrayPoint(flatCoordinates, offset2, ends, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      minSquaredDistance = assignClosestPoint(
        flatCoordinates,
        offset2,
        end,
        stride,
        maxDelta,
        isRing,
        x2,
        y2,
        closestPoint,
        minSquaredDistance,
        tmpPoint
      );
      offset2 = end;
    }
    return minSquaredDistance;
  }
  function assignClosestMultiArrayPoint(flatCoordinates, offset2, endss, stride, maxDelta, isRing, x2, y2, closestPoint, minSquaredDistance, tmpPoint) {
    tmpPoint = tmpPoint ? tmpPoint : [NaN, NaN];
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      minSquaredDistance = assignClosestArrayPoint(
        flatCoordinates,
        offset2,
        ends,
        stride,
        maxDelta,
        isRing,
        x2,
        y2,
        closestPoint,
        minSquaredDistance,
        tmpPoint
      );
      offset2 = ends[ends.length - 1];
    }
    return minSquaredDistance;
  }

  // node_modules/ol/geom/flat/simplify.js
  function douglasPeucker(flatCoordinates, offset2, end, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    const n2 = (end - offset2) / stride;
    if (n2 < 3) {
      for (; offset2 < end; offset2 += stride) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + 1];
      }
      return simplifiedOffset;
    }
    const markers = new Array(n2);
    markers[0] = 1;
    markers[n2 - 1] = 1;
    const stack = [offset2, end - stride];
    let index = 0;
    while (stack.length > 0) {
      const last = stack.pop();
      const first = stack.pop();
      let maxSquaredDistance = 0;
      const x1 = flatCoordinates[first];
      const y1 = flatCoordinates[first + 1];
      const x2 = flatCoordinates[last];
      const y2 = flatCoordinates[last + 1];
      for (let i4 = first + stride; i4 < last; i4 += stride) {
        const x3 = flatCoordinates[i4];
        const y3 = flatCoordinates[i4 + 1];
        const squaredDistance2 = squaredSegmentDistance(x3, y3, x1, y1, x2, y2);
        if (squaredDistance2 > maxSquaredDistance) {
          index = i4;
          maxSquaredDistance = squaredDistance2;
        }
      }
      if (maxSquaredDistance > squaredTolerance) {
        markers[(index - offset2) / stride] = 1;
        if (first + stride < index) {
          stack.push(first, index);
        }
        if (index + stride < last) {
          stack.push(index, last);
        }
      }
    }
    for (let i4 = 0; i4 < n2; ++i4) {
      if (markers[i4]) {
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i4 * stride];
        simplifiedFlatCoordinates[simplifiedOffset++] = flatCoordinates[offset2 + i4 * stride + 1];
      }
    }
    return simplifiedOffset;
  }
  function douglasPeuckerArray(flatCoordinates, offset2, ends, stride, squaredTolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      simplifiedOffset = douglasPeucker(
        flatCoordinates,
        offset2,
        end,
        stride,
        squaredTolerance,
        simplifiedFlatCoordinates,
        simplifiedOffset
      );
      simplifiedEnds.push(simplifiedOffset);
      offset2 = end;
    }
    return simplifiedOffset;
  }
  function snap(value, tolerance) {
    return tolerance * Math.round(value / tolerance);
  }
  function quantize(flatCoordinates, offset2, end, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset) {
    if (offset2 == end) {
      return simplifiedOffset;
    }
    let x1 = snap(flatCoordinates[offset2], tolerance);
    let y1 = snap(flatCoordinates[offset2 + 1], tolerance);
    offset2 += stride;
    simplifiedFlatCoordinates[simplifiedOffset++] = x1;
    simplifiedFlatCoordinates[simplifiedOffset++] = y1;
    let x2, y2;
    do {
      x2 = snap(flatCoordinates[offset2], tolerance);
      y2 = snap(flatCoordinates[offset2 + 1], tolerance);
      offset2 += stride;
      if (offset2 == end) {
        simplifiedFlatCoordinates[simplifiedOffset++] = x2;
        simplifiedFlatCoordinates[simplifiedOffset++] = y2;
        return simplifiedOffset;
      }
    } while (x2 == x1 && y2 == y1);
    while (offset2 < end) {
      const x3 = snap(flatCoordinates[offset2], tolerance);
      const y3 = snap(flatCoordinates[offset2 + 1], tolerance);
      offset2 += stride;
      if (x3 == x2 && y3 == y2) {
        continue;
      }
      const dx1 = x2 - x1;
      const dy1 = y2 - y1;
      const dx2 = x3 - x1;
      const dy2 = y3 - y1;
      if (dx1 * dy2 == dy1 * dx2 && (dx1 < 0 && dx2 < dx1 || dx1 == dx2 || dx1 > 0 && dx2 > dx1) && (dy1 < 0 && dy2 < dy1 || dy1 == dy2 || dy1 > 0 && dy2 > dy1)) {
        x2 = x3;
        y2 = y3;
        continue;
      }
      simplifiedFlatCoordinates[simplifiedOffset++] = x2;
      simplifiedFlatCoordinates[simplifiedOffset++] = y2;
      x1 = x2;
      y1 = y2;
      x2 = x3;
      y2 = y3;
    }
    simplifiedFlatCoordinates[simplifiedOffset++] = x2;
    simplifiedFlatCoordinates[simplifiedOffset++] = y2;
    return simplifiedOffset;
  }
  function quantizeArray(flatCoordinates, offset2, ends, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEnds) {
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      simplifiedOffset = quantize(
        flatCoordinates,
        offset2,
        end,
        stride,
        tolerance,
        simplifiedFlatCoordinates,
        simplifiedOffset
      );
      simplifiedEnds.push(simplifiedOffset);
      offset2 = end;
    }
    return simplifiedOffset;
  }
  function quantizeMultiArray(flatCoordinates, offset2, endss, stride, tolerance, simplifiedFlatCoordinates, simplifiedOffset, simplifiedEndss) {
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      const simplifiedEnds = [];
      simplifiedOffset = quantizeArray(
        flatCoordinates,
        offset2,
        ends,
        stride,
        tolerance,
        simplifiedFlatCoordinates,
        simplifiedOffset,
        simplifiedEnds
      );
      simplifiedEndss.push(simplifiedEnds);
      offset2 = ends[ends.length - 1];
    }
    return simplifiedOffset;
  }

  // node_modules/ol/geom/flat/inflate.js
  function inflateCoordinates(flatCoordinates, offset2, end, stride, coordinates2) {
    coordinates2 = coordinates2 !== void 0 ? coordinates2 : [];
    let i4 = 0;
    for (let j3 = offset2; j3 < end; j3 += stride) {
      coordinates2[i4++] = flatCoordinates.slice(j3, j3 + stride);
    }
    coordinates2.length = i4;
    return coordinates2;
  }
  function inflateCoordinatesArray(flatCoordinates, offset2, ends, stride, coordinatess) {
    coordinatess = coordinatess !== void 0 ? coordinatess : [];
    let i4 = 0;
    for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
      const end = ends[j3];
      coordinatess[i4++] = inflateCoordinates(
        flatCoordinates,
        offset2,
        end,
        stride,
        coordinatess[i4]
      );
      offset2 = end;
    }
    coordinatess.length = i4;
    return coordinatess;
  }
  function inflateMultiCoordinatesArray(flatCoordinates, offset2, endss, stride, coordinatesss) {
    coordinatesss = coordinatesss !== void 0 ? coordinatesss : [];
    let i4 = 0;
    for (let j3 = 0, jj = endss.length; j3 < jj; ++j3) {
      const ends = endss[j3];
      coordinatesss[i4++] = ends.length === 1 && ends[0] === offset2 ? [] : inflateCoordinatesArray(
        flatCoordinates,
        offset2,
        ends,
        stride,
        coordinatesss[i4]
      );
      offset2 = ends[ends.length - 1];
    }
    coordinatesss.length = i4;
    return coordinatesss;
  }

  // node_modules/ol/geom/flat/area.js
  function linearRing(flatCoordinates, offset2, end, stride) {
    let twiceArea = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for (; offset2 < end; offset2 += stride) {
      const x2 = flatCoordinates[offset2];
      const y2 = flatCoordinates[offset2 + 1];
      twiceArea += y1 * x2 - x1 * y2;
      x1 = x2;
      y1 = y2;
    }
    return twiceArea / 2;
  }
  function linearRings(flatCoordinates, offset2, ends, stride) {
    let area = 0;
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      area += linearRing(flatCoordinates, offset2, end, stride);
      offset2 = end;
    }
    return area;
  }
  function linearRingss(flatCoordinates, offset2, endss, stride) {
    let area = 0;
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      area += linearRings(flatCoordinates, offset2, ends, stride);
      offset2 = ends[ends.length - 1];
    }
    return area;
  }

  // node_modules/ol/geom/LinearRing.js
  var LinearRing = class _LinearRing extends SimpleGeometry_default {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates2, layout) {
      super();
      this.maxDelta_ = -1;
      this.maxDeltaRevision_ = -1;
      if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
      } else {
        this.setCoordinates(
          /** @type {Array<import("../coordinate.js").Coordinate>} */
          coordinates2,
          layout
        );
      }
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LinearRing} Clone.
     * @api
     */
    clone() {
      return new _LinearRing(this.flatCoordinates.slice(), this.layout);
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(
          maxSquaredDelta(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            0
          )
        );
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestPoint(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        true,
        x2,
        y2,
        closestPoint,
        minSquaredDistance
      );
    }
    /**
     * Return the area of the linear ring on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return linearRing(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinates of the linear ring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    getCoordinates() {
      return inflateCoordinates(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LinearRing} Simplified LinearRing.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = douglasPeucker(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        squaredTolerance,
        simplifiedFlatCoordinates,
        0
      );
      return new _LinearRing(simplifiedFlatCoordinates, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "LinearRing";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return false;
    }
    /**
     * Set the coordinates of the linear ring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = deflateCoordinates(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride
      );
      this.changed();
    }
  };
  var LinearRing_default = LinearRing;

  // node_modules/ol/geom/flat/segments.js
  function forEach(flatCoordinates, offset2, end, stride, callback) {
    let ret;
    offset2 += stride;
    for (; offset2 < end; offset2 += stride) {
      ret = callback(
        flatCoordinates.slice(offset2 - stride, offset2),
        flatCoordinates.slice(offset2, offset2 + stride)
      );
      if (ret) {
        return ret;
      }
    }
    return false;
  }

  // node_modules/ol/geom/flat/interpolate.js
  function interpolatePoint(flatCoordinates, offset2, end, stride, fraction, dest, dimension) {
    let o4, t3;
    const n2 = (end - offset2) / stride;
    if (n2 === 1) {
      o4 = offset2;
    } else if (n2 === 2) {
      o4 = offset2;
      t3 = fraction;
    } else if (n2 !== 0) {
      let x1 = flatCoordinates[offset2];
      let y1 = flatCoordinates[offset2 + 1];
      let length = 0;
      const cumulativeLengths = [0];
      for (let i4 = offset2 + stride; i4 < end; i4 += stride) {
        const x2 = flatCoordinates[i4];
        const y2 = flatCoordinates[i4 + 1];
        length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
        cumulativeLengths.push(length);
        x1 = x2;
        y1 = y2;
      }
      const target = fraction * length;
      const index = binarySearch(cumulativeLengths, target);
      if (index < 0) {
        t3 = (target - cumulativeLengths[-index - 2]) / (cumulativeLengths[-index - 1] - cumulativeLengths[-index - 2]);
        o4 = offset2 + (-index - 2) * stride;
      } else {
        o4 = offset2 + index * stride;
      }
    }
    dimension = dimension > 1 ? dimension : 2;
    dest = dest ? dest : new Array(dimension);
    for (let i4 = 0; i4 < dimension; ++i4) {
      dest[i4] = o4 === void 0 ? NaN : t3 === void 0 ? flatCoordinates[o4 + i4] : lerp(flatCoordinates[o4 + i4], flatCoordinates[o4 + stride + i4], t3);
    }
    return dest;
  }
  function lineStringCoordinateAtM(flatCoordinates, offset2, end, stride, m3, extrapolate) {
    if (end == offset2) {
      return null;
    }
    let coordinate;
    if (m3 < flatCoordinates[offset2 + stride - 1]) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(offset2, offset2 + stride);
        coordinate[stride - 1] = m3;
        return coordinate;
      }
      return null;
    }
    if (flatCoordinates[end - 1] < m3) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(end - stride, end);
        coordinate[stride - 1] = m3;
        return coordinate;
      }
      return null;
    }
    if (m3 == flatCoordinates[offset2 + stride - 1]) {
      return flatCoordinates.slice(offset2, offset2 + stride);
    }
    let lo = offset2 / stride;
    let hi = end / stride;
    while (lo < hi) {
      const mid = lo + hi >> 1;
      if (m3 < flatCoordinates[(mid + 1) * stride - 1]) {
        hi = mid;
      } else {
        lo = mid + 1;
      }
    }
    const m0 = flatCoordinates[lo * stride - 1];
    if (m3 == m0) {
      return flatCoordinates.slice((lo - 1) * stride, (lo - 1) * stride + stride);
    }
    const m1 = flatCoordinates[(lo + 1) * stride - 1];
    const t3 = (m3 - m0) / (m1 - m0);
    coordinate = [];
    for (let i4 = 0; i4 < stride - 1; ++i4) {
      coordinate.push(
        lerp(
          flatCoordinates[(lo - 1) * stride + i4],
          flatCoordinates[lo * stride + i4],
          t3
        )
      );
    }
    coordinate.push(m3);
    return coordinate;
  }
  function lineStringsCoordinateAtM(flatCoordinates, offset2, ends, stride, m3, extrapolate, interpolate) {
    if (interpolate) {
      return lineStringCoordinateAtM(
        flatCoordinates,
        offset2,
        ends[ends.length - 1],
        stride,
        m3,
        extrapolate
      );
    }
    let coordinate;
    if (m3 < flatCoordinates[stride - 1]) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(0, stride);
        coordinate[stride - 1] = m3;
        return coordinate;
      }
      return null;
    }
    if (flatCoordinates[flatCoordinates.length - 1] < m3) {
      if (extrapolate) {
        coordinate = flatCoordinates.slice(flatCoordinates.length - stride);
        coordinate[stride - 1] = m3;
        return coordinate;
      }
      return null;
    }
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      if (offset2 == end) {
        continue;
      }
      if (m3 < flatCoordinates[offset2 + stride - 1]) {
        return null;
      }
      if (m3 <= flatCoordinates[end - 1]) {
        return lineStringCoordinateAtM(
          flatCoordinates,
          offset2,
          end,
          stride,
          m3,
          false
        );
      }
      offset2 = end;
    }
    return null;
  }

  // node_modules/ol/geom/flat/contains.js
  function linearRingContainsExtent(flatCoordinates, offset2, end, stride, extent) {
    const outside = forEachCorner(
      extent,
      /**
       * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
       * @return {boolean} Contains (x, y).
       */
      function(coordinate) {
        return !linearRingContainsXY(
          flatCoordinates,
          offset2,
          end,
          stride,
          coordinate[0],
          coordinate[1]
        );
      }
    );
    return !outside;
  }
  function linearRingContainsXY(flatCoordinates, offset2, end, stride, x2, y2) {
    let wn = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for (; offset2 < end; offset2 += stride) {
      const x22 = flatCoordinates[offset2];
      const y22 = flatCoordinates[offset2 + 1];
      if (y1 <= y2) {
        if (y22 > y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) > 0) {
          wn++;
        }
      } else if (y22 <= y2 && (x22 - x1) * (y2 - y1) - (x2 - x1) * (y22 - y1) < 0) {
        wn--;
      }
      x1 = x22;
      y1 = y22;
    }
    return wn !== 0;
  }
  function linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2) {
    if (ends.length === 0) {
      return false;
    }
    if (!linearRingContainsXY(flatCoordinates, offset2, ends[0], stride, x2, y2)) {
      return false;
    }
    for (let i4 = 1, ii = ends.length; i4 < ii; ++i4) {
      if (linearRingContainsXY(flatCoordinates, ends[i4 - 1], ends[i4], stride, x2, y2)) {
        return false;
      }
    }
    return true;
  }
  function linearRingssContainsXY(flatCoordinates, offset2, endss, stride, x2, y2) {
    if (endss.length === 0) {
      return false;
    }
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y2)) {
        return true;
      }
      offset2 = ends[ends.length - 1];
    }
    return false;
  }

  // node_modules/ol/geom/flat/intersectsextent.js
  function intersectsLineString(flatCoordinates, offset2, end, stride, extent) {
    const coordinatesExtent = extendFlatCoordinates(
      createEmpty(),
      flatCoordinates,
      offset2,
      end,
      stride
    );
    if (!intersects(extent, coordinatesExtent)) {
      return false;
    }
    if (containsExtent(extent, coordinatesExtent)) {
      return true;
    }
    if (coordinatesExtent[0] >= extent[0] && coordinatesExtent[2] <= extent[2]) {
      return true;
    }
    if (coordinatesExtent[1] >= extent[1] && coordinatesExtent[3] <= extent[3]) {
      return true;
    }
    return forEach(
      flatCoordinates,
      offset2,
      end,
      stride,
      /**
       * @param {import("../../coordinate.js").Coordinate} point1 Start point.
       * @param {import("../../coordinate.js").Coordinate} point2 End point.
       * @return {boolean} `true` if the segment and the extent intersect,
       *     `false` otherwise.
       */
      function(point1, point2) {
        return intersectsSegment(extent, point1, point2);
      }
    );
  }
  function intersectsLineStringArray(flatCoordinates, offset2, ends, stride, extent) {
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      if (intersectsLineString(flatCoordinates, offset2, ends[i4], stride, extent)) {
        return true;
      }
      offset2 = ends[i4];
    }
    return false;
  }
  function intersectsLinearRing(flatCoordinates, offset2, end, stride, extent) {
    if (intersectsLineString(flatCoordinates, offset2, end, stride, extent)) {
      return true;
    }
    if (linearRingContainsXY(
      flatCoordinates,
      offset2,
      end,
      stride,
      extent[0],
      extent[1]
    )) {
      return true;
    }
    if (linearRingContainsXY(
      flatCoordinates,
      offset2,
      end,
      stride,
      extent[0],
      extent[3]
    )) {
      return true;
    }
    if (linearRingContainsXY(
      flatCoordinates,
      offset2,
      end,
      stride,
      extent[2],
      extent[1]
    )) {
      return true;
    }
    if (linearRingContainsXY(
      flatCoordinates,
      offset2,
      end,
      stride,
      extent[2],
      extent[3]
    )) {
      return true;
    }
    return false;
  }
  function intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent) {
    if (!intersectsLinearRing(flatCoordinates, offset2, ends[0], stride, extent)) {
      return false;
    }
    if (ends.length === 1) {
      return true;
    }
    for (let i4 = 1, ii = ends.length; i4 < ii; ++i4) {
      if (linearRingContainsExtent(
        flatCoordinates,
        ends[i4 - 1],
        ends[i4],
        stride,
        extent
      )) {
        if (!intersectsLineString(
          flatCoordinates,
          ends[i4 - 1],
          ends[i4],
          stride,
          extent
        )) {
          return false;
        }
      }
    }
    return true;
  }
  function intersectsLinearRingMultiArray(flatCoordinates, offset2, endss, stride, extent) {
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      if (intersectsLinearRingArray(flatCoordinates, offset2, ends, stride, extent)) {
        return true;
      }
      offset2 = ends[ends.length - 1];
    }
    return false;
  }

  // node_modules/ol/geom/flat/length.js
  function lineStringLength(flatCoordinates, offset2, end, stride) {
    let x1 = flatCoordinates[offset2];
    let y1 = flatCoordinates[offset2 + 1];
    let length = 0;
    for (let i4 = offset2 + stride; i4 < end; i4 += stride) {
      const x2 = flatCoordinates[i4];
      const y2 = flatCoordinates[i4 + 1];
      length += Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
      x1 = x2;
      y1 = y2;
    }
    return length;
  }

  // node_modules/ol/geom/LineString.js
  var LineString = class _LineString extends SimpleGeometry_default {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates2, layout) {
      super();
      this.flatMidpoint_ = null;
      this.flatMidpointRevision_ = -1;
      this.maxDelta_ = -1;
      this.maxDeltaRevision_ = -1;
      if (layout !== void 0 && !Array.isArray(coordinates2[0])) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
      } else {
        this.setCoordinates(
          /** @type {Array<import("../coordinate.js").Coordinate>} */
          coordinates2,
          layout
        );
      }
    }
    /**
     * Append the passed coordinate to the coordinates of the linestring.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @api
     */
    appendCoordinate(coordinate) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = coordinate.slice();
      } else {
        extend(this.flatCoordinates, coordinate);
      }
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!LineString} Clone.
     * @api
     */
    clone() {
      const lineString = new _LineString(
        this.flatCoordinates.slice(),
        this.layout
      );
      lineString.applyProperties(this);
      return lineString;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(
          maxSquaredDelta(
            this.flatCoordinates,
            0,
            this.flatCoordinates.length,
            this.stride,
            0
          )
        );
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestPoint(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        this.maxDelta_,
        false,
        x2,
        y2,
        closestPoint,
        minSquaredDistance
      );
    }
    /**
     * Iterate over each segment, calling the provided callback.
     * If the callback returns a truthy value the function returns that
     * value immediately. Otherwise the function returns `false`.
     *
     * @param {function(this: S, import("../coordinate.js").Coordinate, import("../coordinate.js").Coordinate): T} callback Function
     *     called for each segment. The function will receive two arguments, the start and end coordinates of the segment.
     * @return {T|boolean} Value.
     * @template T,S
     * @api
     */
    forEachSegment(callback) {
      return forEach(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        callback
      );
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(m3, extrapolate) {
      if (this.layout != "XYM" && this.layout != "XYZM") {
        return null;
      }
      extrapolate = extrapolate !== void 0 ? extrapolate : false;
      return lineStringCoordinateAtM(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        m3,
        extrapolate
      );
    }
    /**
     * Return the coordinates of the linestring.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    getCoordinates() {
      return inflateCoordinates(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the coordinate at the provided fraction along the linestring.
     * The `fraction` is a number between 0 and 1, where 0 is the start of the
     * linestring and 1 is the end.
     * @param {number} fraction Fraction.
     * @param {import("../coordinate.js").Coordinate} [dest] Optional coordinate whose values will
     *     be modified. If not provided, a new coordinate will be returned.
     * @return {import("../coordinate.js").Coordinate} Coordinate of the interpolated point.
     * @api
     */
    getCoordinateAt(fraction, dest) {
      return interpolatePoint(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        fraction,
        dest,
        this.stride
      );
    }
    /**
     * Return the length of the linestring on projected plane.
     * @return {number} Length (on projected plane).
     * @api
     */
    getLength() {
      return lineStringLength(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Flat midpoint.
     */
    getFlatMidpoint() {
      if (this.flatMidpointRevision_ != this.getRevision()) {
        this.flatMidpoint_ = this.getCoordinateAt(0.5, this.flatMidpoint_);
        this.flatMidpointRevision_ = this.getRevision();
      }
      return this.flatMidpoint_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {LineString} Simplified LineString.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [];
      simplifiedFlatCoordinates.length = douglasPeucker(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        squaredTolerance,
        simplifiedFlatCoordinates,
        0
      );
      return new _LineString(simplifiedFlatCoordinates, "XY");
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "LineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return intersectsLineString(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride,
        extent
      );
    }
    /**
     * Set the coordinates of the linestring.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = deflateCoordinates(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride
      );
      this.changed();
    }
  };
  var LineString_default = LineString;

  // node_modules/ol/geom/MultiLineString.js
  var MultiLineString = class _MultiLineString extends SimpleGeometry_default {
    /**
     * @param {Array<Array<import("../coordinate.js").Coordinate>|LineString>|Array<number>} coordinates
     *     Coordinates or LineString geometries. (For internal use, flat coordinates in
     *     combination with `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Flat coordinate ends for internal use.
     */
    constructor(coordinates2, layout, ends) {
      super();
      this.ends_ = [];
      this.maxDelta_ = -1;
      this.maxDeltaRevision_ = -1;
      if (Array.isArray(coordinates2[0])) {
        this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          coordinates2,
          layout
        );
      } else if (layout !== void 0 && ends) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
        this.ends_ = ends;
      } else {
        let layout2 = this.getLayout();
        const lineStrings = (
          /** @type {Array<LineString>} */
          coordinates2
        );
        const flatCoordinates = [];
        const ends2 = [];
        for (let i4 = 0, ii = lineStrings.length; i4 < ii; ++i4) {
          const lineString = lineStrings[i4];
          if (i4 === 0) {
            layout2 = lineString.getLayout();
          }
          extend(flatCoordinates, lineString.getFlatCoordinates());
          ends2.push(flatCoordinates.length);
        }
        this.setFlatCoordinates(layout2, flatCoordinates);
        this.ends_ = ends2;
      }
    }
    /**
     * Append the passed linestring to the multilinestring.
     * @param {LineString} lineString LineString.
     * @api
     */
    appendLineString(lineString) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = lineString.getFlatCoordinates().slice();
      } else {
        extend(this.flatCoordinates, lineString.getFlatCoordinates().slice());
      }
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiLineString} Clone.
     * @api
     */
    clone() {
      const multiLineString = new _MultiLineString(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      multiLineString.applyProperties(this);
      return multiLineString;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(
          arrayMaxSquaredDelta(
            this.flatCoordinates,
            0,
            this.ends_,
            this.stride,
            0
          )
        );
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestArrayPoint(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        false,
        x2,
        y2,
        closestPoint,
        minSquaredDistance
      );
    }
    /**
     * Returns the coordinate at `m` using linear interpolation, or `null` if no
     * such coordinate exists.
     *
     * `extrapolate` controls extrapolation beyond the range of Ms in the
     * MultiLineString. If `extrapolate` is `true` then Ms less than the first
     * M will return the first coordinate and Ms greater than the last M will
     * return the last coordinate.
     *
     * `interpolate` controls interpolation between consecutive LineStrings
     * within the MultiLineString. If `interpolate` is `true` the coordinates
     * will be linearly interpolated between the last coordinate of one LineString
     * and the first coordinate of the next LineString.  If `interpolate` is
     * `false` then the function will return `null` for Ms falling between
     * LineStrings.
     *
     * @param {number} m M.
     * @param {boolean} [extrapolate] Extrapolate. Default is `false`.
     * @param {boolean} [interpolate] Interpolate. Default is `false`.
     * @return {import("../coordinate.js").Coordinate|null} Coordinate.
     * @api
     */
    getCoordinateAtM(m3, extrapolate, interpolate) {
      if (this.layout != "XYM" && this.layout != "XYZM" || this.flatCoordinates.length === 0) {
        return null;
      }
      extrapolate = extrapolate !== void 0 ? extrapolate : false;
      interpolate = interpolate !== void 0 ? interpolate : false;
      return lineStringsCoordinateAtM(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        m3,
        extrapolate,
        interpolate
      );
    }
    /**
     * Return the coordinates of the multilinestring.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
    getCoordinates() {
      return inflateCoordinatesArray(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * Return the linestring at the specified index.
     * @param {number} index Index.
     * @return {LineString} LineString.
     * @api
     */
    getLineString(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }
      return new LineString_default(
        this.flatCoordinates.slice(
          index === 0 ? 0 : this.ends_[index - 1],
          this.ends_[index]
        ),
        this.layout
      );
    }
    /**
     * Return the linestrings of this multilinestring.
     * @return {Array<LineString>} LineStrings.
     * @api
     */
    getLineStrings() {
      const flatCoordinates = this.flatCoordinates;
      const ends = this.ends_;
      const layout = this.layout;
      const lineStrings = [];
      let offset2 = 0;
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        const end = ends[i4];
        const lineString = new LineString_default(
          flatCoordinates.slice(offset2, end),
          layout
        );
        lineStrings.push(lineString);
        offset2 = end;
      }
      return lineStrings;
    }
    /**
     * @return {Array<number>} Flat midpoints.
     */
    getFlatMidpoints() {
      const midpoints = [];
      const flatCoordinates = this.flatCoordinates;
      let offset2 = 0;
      const ends = this.ends_;
      const stride = this.stride;
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        const end = ends[i4];
        const midpoint = interpolatePoint(
          flatCoordinates,
          offset2,
          end,
          stride,
          0.5
        );
        extend(midpoints, midpoint);
        offset2 = end;
      }
      return midpoints;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiLineString} Simplified MultiLineString.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [];
      const simplifiedEnds = [];
      simplifiedFlatCoordinates.length = douglasPeuckerArray(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        squaredTolerance,
        simplifiedFlatCoordinates,
        0,
        simplifiedEnds
      );
      return new _MultiLineString(simplifiedFlatCoordinates, "XY", simplifiedEnds);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "MultiLineString";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return intersectsLineStringArray(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        extent
      );
    }
    /**
     * Set the coordinates of the multilinestring.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 2);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      const ends = deflateCoordinatesArray(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    }
  };
  var MultiLineString_default = MultiLineString;

  // node_modules/ol/geom/Point.js
  var Point = class _Point extends SimpleGeometry_default {
    /**
     * @param {import("../coordinate.js").Coordinate} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates2, layout) {
      super();
      this.setCoordinates(coordinates2, layout);
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Point} Clone.
     * @api
     */
    clone() {
      const point = new _Point(this.flatCoordinates.slice(), this.layout);
      point.applyProperties(this);
      return point;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      const flatCoordinates = this.flatCoordinates;
      const squaredDistance2 = squaredDistance(
        x2,
        y2,
        flatCoordinates[0],
        flatCoordinates[1]
      );
      if (squaredDistance2 < minSquaredDistance) {
        const stride = this.stride;
        for (let i4 = 0; i4 < stride; ++i4) {
          closestPoint[i4] = flatCoordinates[i4];
        }
        closestPoint.length = stride;
        return squaredDistance2;
      }
      return minSquaredDistance;
    }
    /**
     * Return the coordinate of the point.
     * @return {import("../coordinate.js").Coordinate} Coordinates.
     * @api
     */
    getCoordinates() {
      return !this.flatCoordinates ? [] : this.flatCoordinates.slice();
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @protected
     * @return {import("../extent.js").Extent} extent Extent.
     */
    computeExtent(extent) {
      return createOrUpdateFromCoordinate(this.flatCoordinates, extent);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "Point";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return containsXY(extent, this.flatCoordinates[0], this.flatCoordinates[1]);
    }
    /**
     * @param {!Array<*>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 0);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = deflateCoordinate(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride
      );
      this.changed();
    }
  };
  var Point_default = Point;

  // node_modules/ol/geom/MultiPoint.js
  var MultiPoint = class _MultiPoint extends SimpleGeometry_default {
    /**
     * @param {Array<import("../coordinate.js").Coordinate>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     */
    constructor(coordinates2, layout) {
      super();
      if (layout && !Array.isArray(coordinates2[0])) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
      } else {
        this.setCoordinates(
          /** @type {Array<import("../coordinate.js").Coordinate>} */
          coordinates2,
          layout
        );
      }
    }
    /**
     * Append the passed point to this multipoint.
     * @param {Point} point Point.
     * @api
     */
    appendPoint(point) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = point.getFlatCoordinates().slice();
      } else {
        extend(this.flatCoordinates, point.getFlatCoordinates());
      }
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPoint} Clone.
     * @api
     */
    clone() {
      const multiPoint = new _MultiPoint(
        this.flatCoordinates.slice(),
        this.layout
      );
      multiPoint.applyProperties(this);
      return multiPoint;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      const flatCoordinates = this.flatCoordinates;
      const stride = this.stride;
      for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
        const squaredDistance2 = squaredDistance(
          x2,
          y2,
          flatCoordinates[i4],
          flatCoordinates[i4 + 1]
        );
        if (squaredDistance2 < minSquaredDistance) {
          minSquaredDistance = squaredDistance2;
          for (let j3 = 0; j3 < stride; ++j3) {
            closestPoint[j3] = flatCoordinates[i4 + j3];
          }
          closestPoint.length = stride;
        }
      }
      return minSquaredDistance;
    }
    /**
     * Return the coordinates of the multipoint.
     * @return {Array<import("../coordinate.js").Coordinate>} Coordinates.
     * @api
     */
    getCoordinates() {
      return inflateCoordinates(
        this.flatCoordinates,
        0,
        this.flatCoordinates.length,
        this.stride
      );
    }
    /**
     * Return the point at the specified index.
     * @param {number} index Index.
     * @return {Point} Point.
     * @api
     */
    getPoint(index) {
      const n2 = !this.flatCoordinates ? 0 : this.flatCoordinates.length / this.stride;
      if (index < 0 || n2 <= index) {
        return null;
      }
      return new Point_default(
        this.flatCoordinates.slice(
          index * this.stride,
          (index + 1) * this.stride
        ),
        this.layout
      );
    }
    /**
     * Return the points of this multipoint.
     * @return {Array<Point>} Points.
     * @api
     */
    getPoints() {
      const flatCoordinates = this.flatCoordinates;
      const layout = this.layout;
      const stride = this.stride;
      const points = [];
      for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
        const point = new Point_default(flatCoordinates.slice(i4, i4 + stride), layout);
        points.push(point);
      }
      return points;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "MultiPoint";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      const flatCoordinates = this.flatCoordinates;
      const stride = this.stride;
      for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
        const x2 = flatCoordinates[i4];
        const y2 = flatCoordinates[i4 + 1];
        if (containsXY(extent, x2, y2)) {
          return true;
        }
      }
      return false;
    }
    /**
     * Set the coordinates of the multipoint.
     * @param {!Array<import("../coordinate.js").Coordinate>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 1);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      this.flatCoordinates.length = deflateCoordinates(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride
      );
      this.changed();
    }
  };
  var MultiPoint_default = MultiPoint;

  // node_modules/ol/geom/flat/interiorpoint.js
  function getInteriorPointOfArray(flatCoordinates, offset2, ends, stride, flatCenters, flatCentersOffset, dest) {
    let i4, ii, x2, x1, x22, y1, y2;
    const y3 = flatCenters[flatCentersOffset + 1];
    const intersections = [];
    for (let r4 = 0, rr = ends.length; r4 < rr; ++r4) {
      const end = ends[r4];
      x1 = flatCoordinates[end - stride];
      y1 = flatCoordinates[end - stride + 1];
      for (i4 = offset2; i4 < end; i4 += stride) {
        x22 = flatCoordinates[i4];
        y2 = flatCoordinates[i4 + 1];
        if (y3 <= y1 && y2 <= y3 || y1 <= y3 && y3 <= y2) {
          x2 = (y3 - y1) / (y2 - y1) * (x22 - x1) + x1;
          intersections.push(x2);
        }
        x1 = x22;
        y1 = y2;
      }
    }
    let pointX = NaN;
    let maxSegmentLength = -Infinity;
    intersections.sort(ascending);
    x1 = intersections[0];
    for (i4 = 1, ii = intersections.length; i4 < ii; ++i4) {
      x22 = intersections[i4];
      const segmentLength = Math.abs(x22 - x1);
      if (segmentLength > maxSegmentLength) {
        x2 = (x1 + x22) / 2;
        if (linearRingsContainsXY(flatCoordinates, offset2, ends, stride, x2, y3)) {
          pointX = x2;
          maxSegmentLength = segmentLength;
        }
      }
      x1 = x22;
    }
    if (isNaN(pointX)) {
      pointX = flatCenters[flatCentersOffset];
    }
    if (dest) {
      dest.push(pointX, y3, maxSegmentLength);
      return dest;
    }
    return [pointX, y3, maxSegmentLength];
  }
  function getInteriorPointsOfMultiArray(flatCoordinates, offset2, endss, stride, flatCenters) {
    let interiorPoints = [];
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      interiorPoints = getInteriorPointOfArray(
        flatCoordinates,
        offset2,
        ends,
        stride,
        flatCenters,
        2 * i4,
        interiorPoints
      );
      offset2 = ends[ends.length - 1];
    }
    return interiorPoints;
  }

  // node_modules/ol/geom/flat/reverse.js
  function coordinates(flatCoordinates, offset2, end, stride) {
    while (offset2 < end - stride) {
      for (let i4 = 0; i4 < stride; ++i4) {
        const tmp = flatCoordinates[offset2 + i4];
        flatCoordinates[offset2 + i4] = flatCoordinates[end - stride + i4];
        flatCoordinates[end - stride + i4] = tmp;
      }
      offset2 += stride;
      end -= stride;
    }
  }

  // node_modules/ol/geom/flat/orient.js
  function linearRingIsClockwise(flatCoordinates, offset2, end, stride) {
    let edge = 0;
    let x1 = flatCoordinates[end - stride];
    let y1 = flatCoordinates[end - stride + 1];
    for (; offset2 < end; offset2 += stride) {
      const x2 = flatCoordinates[offset2];
      const y2 = flatCoordinates[offset2 + 1];
      edge += (x2 - x1) * (y2 + y1);
      x1 = x2;
      y1 = y2;
    }
    return edge === 0 ? void 0 : edge > 0;
  }
  function linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right) {
    right = right !== void 0 ? right : false;
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      const isClockwise = linearRingIsClockwise(
        flatCoordinates,
        offset2,
        end,
        stride
      );
      if (i4 === 0) {
        if (right && isClockwise || !right && !isClockwise) {
          return false;
        }
      } else {
        if (right && !isClockwise || !right && isClockwise) {
          return false;
        }
      }
      offset2 = end;
    }
    return true;
  }
  function linearRingssAreOriented(flatCoordinates, offset2, endss, stride, right) {
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      if (!linearRingsAreOriented(flatCoordinates, offset2, ends, stride, right)) {
        return false;
      }
      if (ends.length) {
        offset2 = ends[ends.length - 1];
      }
    }
    return true;
  }
  function orientLinearRings(flatCoordinates, offset2, ends, stride, right) {
    right = right !== void 0 ? right : false;
    for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
      const end = ends[i4];
      const isClockwise = linearRingIsClockwise(
        flatCoordinates,
        offset2,
        end,
        stride
      );
      const reverse = i4 === 0 ? right && isClockwise || !right && !isClockwise : right && !isClockwise || !right && isClockwise;
      if (reverse) {
        coordinates(flatCoordinates, offset2, end, stride);
      }
      offset2 = end;
    }
    return offset2;
  }
  function orientLinearRingsArray(flatCoordinates, offset2, endss, stride, right) {
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      offset2 = orientLinearRings(
        flatCoordinates,
        offset2,
        endss[i4],
        stride,
        right
      );
    }
    return offset2;
  }

  // node_modules/ol/geom/Polygon.js
  var Polygon = class _Polygon extends SimpleGeometry_default {
    /**
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>|!Array<number>} coordinates
     *     Array of linear rings that define the polygon. The first linear ring of the
     *     array defines the outer-boundary or surface of the polygon. Each subsequent
     *     linear ring defines a hole in the surface of the polygon. A linear ring is
     *     an array of vertices' coordinates where the first coordinate and the last are
     *     equivalent. (For internal use, flat coordinates in combination with
     *     `layout` and `ends` are also accepted.)
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<number>} [ends] Ends (for internal use with flat coordinates).
     */
    constructor(coordinates2, layout, ends) {
      super();
      this.ends_ = [];
      this.flatInteriorPointRevision_ = -1;
      this.flatInteriorPoint_ = null;
      this.maxDelta_ = -1;
      this.maxDeltaRevision_ = -1;
      this.orientedRevision_ = -1;
      this.orientedFlatCoordinates_ = null;
      if (layout !== void 0 && ends) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
        this.ends_ = ends;
      } else {
        this.setCoordinates(
          /** @type {Array<Array<import("../coordinate.js").Coordinate>>} */
          coordinates2,
          layout
        );
      }
    }
    /**
     * Append the passed linear ring to this polygon.
     * @param {LinearRing} linearRing Linear ring.
     * @api
     */
    appendLinearRing(linearRing2) {
      if (!this.flatCoordinates) {
        this.flatCoordinates = linearRing2.getFlatCoordinates().slice();
      } else {
        extend(this.flatCoordinates, linearRing2.getFlatCoordinates());
      }
      this.ends_.push(this.flatCoordinates.length);
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!Polygon} Clone.
     * @api
     */
    clone() {
      const polygon = new _Polygon(
        this.flatCoordinates.slice(),
        this.layout,
        this.ends_.slice()
      );
      polygon.applyProperties(this);
      return polygon;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(
          arrayMaxSquaredDelta(
            this.flatCoordinates,
            0,
            this.ends_,
            this.stride,
            0
          )
        );
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestArrayPoint(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        this.maxDelta_,
        true,
        x2,
        y2,
        closestPoint,
        minSquaredDistance
      );
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(x2, y2) {
      return linearRingsContainsXY(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        x2,
        y2
      );
    }
    /**
     * Return the area of the polygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return linearRings(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<import("../coordinate.js").Coordinate>>} Coordinates.
     * @api
     */
    getCoordinates(right) {
      let flatCoordinates;
      if (right !== void 0) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        orientLinearRings(flatCoordinates, 0, this.ends_, this.stride, right);
      } else {
        flatCoordinates = this.flatCoordinates;
      }
      return inflateCoordinatesArray(flatCoordinates, 0, this.ends_, this.stride);
    }
    /**
     * @return {Array<number>} Ends.
     */
    getEnds() {
      return this.ends_;
    }
    /**
     * @return {Array<number>} Interior point.
     */
    getFlatInteriorPoint() {
      if (this.flatInteriorPointRevision_ != this.getRevision()) {
        const flatCenter = getCenter(this.getExtent());
        this.flatInteriorPoint_ = getInteriorPointOfArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.ends_,
          this.stride,
          flatCenter,
          0
        );
        this.flatInteriorPointRevision_ = this.getRevision();
      }
      return this.flatInteriorPoint_;
    }
    /**
     * Return an interior point of the polygon.
     * @return {Point} Interior point as XYM coordinate, where M is the
     * length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoint() {
      return new Point_default(this.getFlatInteriorPoint(), "XYM");
    }
    /**
     * Return the number of rings of the polygon,  this includes the exterior
     * ring and any interior rings.
     *
     * @return {number} Number of rings.
     * @api
     */
    getLinearRingCount() {
      return this.ends_.length;
    }
    /**
     * Return the Nth linear ring of the polygon geometry. Return `null` if the
     * given index is out of range.
     * The exterior linear ring is available at index `0` and the interior rings
     * at index `1` and beyond.
     *
     * @param {number} index Index.
     * @return {LinearRing|null} Linear ring.
     * @api
     */
    getLinearRing(index) {
      if (index < 0 || this.ends_.length <= index) {
        return null;
      }
      return new LinearRing_default(
        this.flatCoordinates.slice(
          index === 0 ? 0 : this.ends_[index - 1],
          this.ends_[index]
        ),
        this.layout
      );
    }
    /**
     * Return the linear rings of the polygon.
     * @return {Array<LinearRing>} Linear rings.
     * @api
     */
    getLinearRings() {
      const layout = this.layout;
      const flatCoordinates = this.flatCoordinates;
      const ends = this.ends_;
      const linearRings2 = [];
      let offset2 = 0;
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        const end = ends[i4];
        const linearRing2 = new LinearRing_default(
          flatCoordinates.slice(offset2, end),
          layout
        );
        linearRings2.push(linearRing2);
        offset2 = end;
      }
      return linearRings2;
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const flatCoordinates = this.flatCoordinates;
        if (linearRingsAreOriented(flatCoordinates, 0, this.ends_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = orientLinearRings(
            this.orientedFlatCoordinates_,
            0,
            this.ends_,
            this.stride
          );
        }
        this.orientedRevision_ = this.getRevision();
      }
      return this.orientedFlatCoordinates_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {Polygon} Simplified Polygon.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [];
      const simplifiedEnds = [];
      simplifiedFlatCoordinates.length = quantizeArray(
        this.flatCoordinates,
        0,
        this.ends_,
        this.stride,
        Math.sqrt(squaredTolerance),
        simplifiedFlatCoordinates,
        0,
        simplifiedEnds
      );
      return new _Polygon(simplifiedFlatCoordinates, "XY", simplifiedEnds);
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "Polygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return intersectsLinearRingArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.ends_,
        this.stride,
        extent
      );
    }
    /**
     * Set the coordinates of the polygon.
     * @param {!Array<Array<import("../coordinate.js").Coordinate>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 2);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      const ends = deflateCoordinatesArray(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride,
        this.ends_
      );
      this.flatCoordinates.length = ends.length === 0 ? 0 : ends[ends.length - 1];
      this.changed();
    }
  };
  var Polygon_default = Polygon;
  function circular(center, radius, n2, sphereRadius) {
    n2 = n2 ? n2 : 32;
    const flatCoordinates = [];
    for (let i4 = 0; i4 < n2; ++i4) {
      extend(
        flatCoordinates,
        offset(center, radius, 2 * Math.PI * i4 / n2, sphereRadius)
      );
    }
    flatCoordinates.push(flatCoordinates[0], flatCoordinates[1]);
    return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
  }
  function fromExtent(extent) {
    if (isEmpty2(extent)) {
      throw new Error("Cannot create polygon from empty extent");
    }
    const minX = extent[0];
    const minY = extent[1];
    const maxX = extent[2];
    const maxY = extent[3];
    const flatCoordinates = [
      minX,
      minY,
      minX,
      maxY,
      maxX,
      maxY,
      maxX,
      minY,
      minX,
      minY
    ];
    return new Polygon(flatCoordinates, "XY", [flatCoordinates.length]);
  }

  // node_modules/ol/geom/flat/center.js
  function linearRingss2(flatCoordinates, offset2, endss, stride) {
    const flatCenters = [];
    let extent = createEmpty();
    for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
      const ends = endss[i4];
      extent = createOrUpdateFromFlatCoordinates(
        flatCoordinates,
        offset2,
        ends[0],
        stride
      );
      flatCenters.push((extent[0] + extent[2]) / 2, (extent[1] + extent[3]) / 2);
      offset2 = ends[ends.length - 1];
    }
    return flatCenters;
  }

  // node_modules/ol/geom/MultiPolygon.js
  var MultiPolygon = class _MultiPolygon extends SimpleGeometry_default {
    /**
     * @param {Array<Array<Array<import("../coordinate.js").Coordinate>>|Polygon>|Array<number>} coordinates Coordinates.
     *     For internal use, flat coordinates in combination with `layout` and `endss` are also accepted.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @param {Array<Array<number>>} [endss] Array of ends for internal use with flat coordinates.
     */
    constructor(coordinates2, layout, endss) {
      super();
      this.endss_ = [];
      this.flatInteriorPointsRevision_ = -1;
      this.flatInteriorPoints_ = null;
      this.maxDelta_ = -1;
      this.maxDeltaRevision_ = -1;
      this.orientedRevision_ = -1;
      this.orientedFlatCoordinates_ = null;
      if (!endss && !Array.isArray(coordinates2[0])) {
        let thisLayout = this.getLayout();
        const polygons = (
          /** @type {Array<Polygon>} */
          coordinates2
        );
        const flatCoordinates = [];
        const thisEndss = [];
        for (let i4 = 0, ii = polygons.length; i4 < ii; ++i4) {
          const polygon = polygons[i4];
          if (i4 === 0) {
            thisLayout = polygon.getLayout();
          }
          const offset2 = flatCoordinates.length;
          const ends = polygon.getEnds();
          for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
            ends[j3] += offset2;
          }
          extend(flatCoordinates, polygon.getFlatCoordinates());
          thisEndss.push(ends);
        }
        layout = thisLayout;
        coordinates2 = flatCoordinates;
        endss = thisEndss;
      }
      if (layout !== void 0 && endss) {
        this.setFlatCoordinates(
          layout,
          /** @type {Array<number>} */
          coordinates2
        );
        this.endss_ = endss;
      } else {
        this.setCoordinates(
          /** @type {Array<Array<Array<import("../coordinate.js").Coordinate>>>} */
          coordinates2,
          layout
        );
      }
    }
    /**
     * Append the passed polygon to this multipolygon.
     * @param {Polygon} polygon Polygon.
     * @api
     */
    appendPolygon(polygon) {
      let ends;
      if (!this.flatCoordinates) {
        this.flatCoordinates = polygon.getFlatCoordinates().slice();
        ends = polygon.getEnds().slice();
        this.endss_.push();
      } else {
        const offset2 = this.flatCoordinates.length;
        extend(this.flatCoordinates, polygon.getFlatCoordinates());
        ends = polygon.getEnds().slice();
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          ends[i4] += offset2;
        }
      }
      this.endss_.push(ends);
      this.changed();
    }
    /**
     * Make a complete copy of the geometry.
     * @return {!MultiPolygon} Clone.
     * @api
     */
    clone() {
      const len = this.endss_.length;
      const newEndss = new Array(len);
      for (let i4 = 0; i4 < len; ++i4) {
        newEndss[i4] = this.endss_[i4].slice();
      }
      const multiPolygon = new _MultiPolygon(
        this.flatCoordinates.slice(),
        this.layout,
        newEndss
      );
      multiPolygon.applyProperties(this);
      return multiPolygon;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @param {import("../coordinate.js").Coordinate} closestPoint Closest point.
     * @param {number} minSquaredDistance Minimum squared distance.
     * @return {number} Minimum squared distance.
     */
    closestPointXY(x2, y2, closestPoint, minSquaredDistance) {
      if (minSquaredDistance < closestSquaredDistanceXY(this.getExtent(), x2, y2)) {
        return minSquaredDistance;
      }
      if (this.maxDeltaRevision_ != this.getRevision()) {
        this.maxDelta_ = Math.sqrt(
          multiArrayMaxSquaredDelta(
            this.flatCoordinates,
            0,
            this.endss_,
            this.stride,
            0
          )
        );
        this.maxDeltaRevision_ = this.getRevision();
      }
      return assignClosestMultiArrayPoint(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        this.maxDelta_,
        true,
        x2,
        y2,
        closestPoint,
        minSquaredDistance
      );
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     * @return {boolean} Contains (x, y).
     */
    containsXY(x2, y2) {
      return linearRingssContainsXY(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        x2,
        y2
      );
    }
    /**
     * Return the area of the multipolygon on projected plane.
     * @return {number} Area (on projected plane).
     * @api
     */
    getArea() {
      return linearRingss(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * Get the coordinate array for this geometry.  This array has the structure
     * of a GeoJSON coordinate array for multi-polygons.
     *
     * @param {boolean} [right] Orient coordinates according to the right-hand
     *     rule (counter-clockwise for exterior and clockwise for interior rings).
     *     If `false`, coordinates will be oriented according to the left-hand rule
     *     (clockwise for exterior and counter-clockwise for interior rings).
     *     By default, coordinate orientation will depend on how the geometry was
     *     constructed.
     * @return {Array<Array<Array<import("../coordinate.js").Coordinate>>>} Coordinates.
     * @api
     */
    getCoordinates(right) {
      let flatCoordinates;
      if (right !== void 0) {
        flatCoordinates = this.getOrientedFlatCoordinates().slice();
        orientLinearRingsArray(
          flatCoordinates,
          0,
          this.endss_,
          this.stride,
          right
        );
      } else {
        flatCoordinates = this.flatCoordinates;
      }
      return inflateMultiCoordinatesArray(
        flatCoordinates,
        0,
        this.endss_,
        this.stride
      );
    }
    /**
     * @return {Array<Array<number>>} Endss.
     */
    getEndss() {
      return this.endss_;
    }
    /**
     * @return {Array<number>} Flat interior points.
     */
    getFlatInteriorPoints() {
      if (this.flatInteriorPointsRevision_ != this.getRevision()) {
        const flatCenters = linearRingss2(
          this.flatCoordinates,
          0,
          this.endss_,
          this.stride
        );
        this.flatInteriorPoints_ = getInteriorPointsOfMultiArray(
          this.getOrientedFlatCoordinates(),
          0,
          this.endss_,
          this.stride,
          flatCenters
        );
        this.flatInteriorPointsRevision_ = this.getRevision();
      }
      return this.flatInteriorPoints_;
    }
    /**
     * Return the interior points as {@link module:ol/geom/MultiPoint~MultiPoint multipoint}.
     * @return {MultiPoint} Interior points as XYM coordinates, where M is
     * the length of the horizontal intersection that the point belongs to.
     * @api
     */
    getInteriorPoints() {
      return new MultiPoint_default(this.getFlatInteriorPoints().slice(), "XYM");
    }
    /**
     * @return {Array<number>} Oriented flat coordinates.
     */
    getOrientedFlatCoordinates() {
      if (this.orientedRevision_ != this.getRevision()) {
        const flatCoordinates = this.flatCoordinates;
        if (linearRingssAreOriented(flatCoordinates, 0, this.endss_, this.stride)) {
          this.orientedFlatCoordinates_ = flatCoordinates;
        } else {
          this.orientedFlatCoordinates_ = flatCoordinates.slice();
          this.orientedFlatCoordinates_.length = orientLinearRingsArray(
            this.orientedFlatCoordinates_,
            0,
            this.endss_,
            this.stride
          );
        }
        this.orientedRevision_ = this.getRevision();
      }
      return this.orientedFlatCoordinates_;
    }
    /**
     * @param {number} squaredTolerance Squared tolerance.
     * @return {MultiPolygon} Simplified MultiPolygon.
     * @protected
     */
    getSimplifiedGeometryInternal(squaredTolerance) {
      const simplifiedFlatCoordinates = [];
      const simplifiedEndss = [];
      simplifiedFlatCoordinates.length = quantizeMultiArray(
        this.flatCoordinates,
        0,
        this.endss_,
        this.stride,
        Math.sqrt(squaredTolerance),
        simplifiedFlatCoordinates,
        0,
        simplifiedEndss
      );
      return new _MultiPolygon(simplifiedFlatCoordinates, "XY", simplifiedEndss);
    }
    /**
     * Return the polygon at the specified index.
     * @param {number} index Index.
     * @return {Polygon} Polygon.
     * @api
     */
    getPolygon(index) {
      if (index < 0 || this.endss_.length <= index) {
        return null;
      }
      let offset2;
      if (index === 0) {
        offset2 = 0;
      } else {
        const prevEnds = this.endss_[index - 1];
        offset2 = prevEnds[prevEnds.length - 1];
      }
      const ends = this.endss_[index].slice();
      const end = ends[ends.length - 1];
      if (offset2 !== 0) {
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          ends[i4] -= offset2;
        }
      }
      return new Polygon_default(
        this.flatCoordinates.slice(offset2, end),
        this.layout,
        ends
      );
    }
    /**
     * Return the polygons of this multipolygon.
     * @return {Array<Polygon>} Polygons.
     * @api
     */
    getPolygons() {
      const layout = this.layout;
      const flatCoordinates = this.flatCoordinates;
      const endss = this.endss_;
      const polygons = [];
      let offset2 = 0;
      for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
        const ends = endss[i4].slice();
        const end = ends[ends.length - 1];
        if (offset2 !== 0) {
          for (let j3 = 0, jj = ends.length; j3 < jj; ++j3) {
            ends[j3] -= offset2;
          }
        }
        const polygon = new Polygon_default(
          flatCoordinates.slice(offset2, end),
          layout,
          ends
        );
        polygons.push(polygon);
        offset2 = end;
      }
      return polygons;
    }
    /**
     * Get the type of this geometry.
     * @return {import("./Geometry.js").Type} Geometry type.
     * @api
     */
    getType() {
      return "MultiPolygon";
    }
    /**
     * Test if the geometry and the passed extent intersect.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {boolean} `true` if the geometry and the extent intersect.
     * @api
     */
    intersectsExtent(extent) {
      return intersectsLinearRingMultiArray(
        this.getOrientedFlatCoordinates(),
        0,
        this.endss_,
        this.stride,
        extent
      );
    }
    /**
     * Set the coordinates of the multipolygon.
     * @param {!Array<Array<Array<import("../coordinate.js").Coordinate>>>} coordinates Coordinates.
     * @param {import("./Geometry.js").GeometryLayout} [layout] Layout.
     * @api
     */
    setCoordinates(coordinates2, layout) {
      this.setLayout(layout, coordinates2, 3);
      if (!this.flatCoordinates) {
        this.flatCoordinates = [];
      }
      const endss = deflateMultiCoordinatesArray(
        this.flatCoordinates,
        0,
        coordinates2,
        this.stride,
        this.endss_
      );
      if (endss.length === 0) {
        this.flatCoordinates.length = 0;
      } else {
        const lastEnds = endss[endss.length - 1];
        this.flatCoordinates.length = lastEnds.length === 0 ? 0 : lastEnds[lastEnds.length - 1];
      }
      this.changed();
    }
  };
  var MultiPolygon_default = MultiPolygon;

  // node_modules/mobility-toolbox-js/common/utils/getVehiclePosition.js
  var getVehiclePosition = (now, trajectory, noInterpolate) => {
    const { time_intervals: timeIntervals, olGeometry, coordinate } = trajectory.properties;
    const { coordinates: coordinates2 } = trajectory.geometry;
    let { type } = trajectory.geometry;
    let geometry = olGeometry;
    let coord;
    let rotation;
    if (olGeometry) {
      type = geometry.getType();
    }
    if (noInterpolate && coordinate) {
      coord = coordinate;
    } else if (type === "Point") {
      coord = coordinates2;
    } else if (type === "LineString") {
      if (!geometry) {
        geometry = new LineString_default(coordinates2);
      }
      const intervals = timeIntervals || [[]];
      const firstInterval = intervals[0];
      const lastInterval = intervals[intervals.length - 1];
      if (now < firstInterval[0]) {
        [, , rotation] = firstInterval;
        coord = geometry.getFirstCoordinate();
      } else if (now > lastInterval[0]) {
        [, , rotation] = lastInterval;
        coord = geometry.getLastCoordinate();
      } else {
        for (let j3 = 0; j3 < intervals.length - 1; j3 += 1) {
          const [start, startFrac] = intervals[j3];
          const [end, endFrac] = intervals[j3 + 1];
          if (start <= now && now <= end) {
            const timeFrac = Math.min((now - start) / (end - start), 1);
            const geomFrac = timeFrac * (endFrac - startFrac) + startFrac;
            coord = geometry.getCoordinateAt(geomFrac);
            [, , rotation] = intervals[j3];
            break;
          }
        }
      }
    } else {
      console.error("This geometry type is not supported. Only Point or LineString are. Current geometry: ", geometry);
    }
    return { coord, rotation };
  };
  var getVehiclePosition_default = getVehiclePosition;

  // node_modules/mobility-toolbox-js/common/utils/renderTrajectories.js
  var renderTrajectories = (canvas, trajectories, style, viewState, options) => {
    if (!canvas) {
      return { renderedTrajectories: [] };
    }
    const { time = Date.now(), size = [], center, resolution, rotation = 0, pixelRatio = 1 } = viewState;
    if (!resolution || !center) {
      return { renderedTrajectories: [] };
    }
    const { noInterpolate = false, hoverVehicleId, selectedVehicleId, filter, getScreenPixel = (pixel, viewStat) => (viewStat.zoom || 0) < 12 ? pixel.map((coord) => Math.floor(coord)) : pixel } = options;
    const context = canvas.getContext("2d");
    context === null || context === void 0 ? void 0 : context.clearRect(0, 0, canvas.width, canvas.height);
    const [width, height] = size;
    if (width && height && (canvas.width !== width || canvas.height !== height)) {
      [canvas.width, canvas.height] = [width * pixelRatio, height * pixelRatio];
    }
    const coordinateToPixelTransform = compose(create(), size[0] / 2, size[1] / 2, 1 / resolution, -1 / resolution, -rotation, -center[0], -center[1]);
    if (canvas.style) {
      canvas.style.width = `${canvas.width / pixelRatio}px`;
      canvas.style.height = `${canvas.height / pixelRatio}px`;
    }
    let hoverVehicleImg;
    let hoverVehiclePx;
    let selectedVehicleImg;
    let selectedVehiclePx;
    const renderedTrajectories = [];
    for (let i4 = trajectories.length - 1; i4 >= 0; i4 -= 1) {
      const trajectory = trajectories[i4];
      if (filter && !filter(trajectory)) {
        continue;
      }
      const { train_id: id, timeOffset } = trajectory.properties;
      const { coord, rotation: rotationIcon } = getVehiclePosition_default(time - (timeOffset || 0), trajectory, noInterpolate);
      trajectories[i4].properties.coordinate = coord;
      trajectories[i4].properties.rotation = rotationIcon;
      if (!coord) {
        continue;
      }
      let px = apply(coordinateToPixelTransform, [...coord]);
      if (!px) {
        continue;
      }
      px = px.map((p6) => p6 * pixelRatio);
      if (px[0] < 0 || px[0] > canvas.width || px[1] < 0 || px[1] > canvas.height) {
        continue;
      }
      const vehicleImg = style(trajectory, viewState, options);
      if (!vehicleImg) {
        continue;
      }
      if (hoverVehicleId !== id && selectedVehicleId !== id) {
        const [x2, y2] = getScreenPixel([px[0] - vehicleImg.width / 2, px[1] - vehicleImg.height / 2], viewState);
        context === null || context === void 0 ? void 0 : context.drawImage(vehicleImg, x2, y2);
      }
      if (hoverVehicleId && hoverVehicleId === id) {
        hoverVehicleImg = vehicleImg;
        hoverVehiclePx = px;
      }
      if (selectedVehicleId && selectedVehicleId === id) {
        selectedVehicleImg = vehicleImg;
        selectedVehiclePx = px;
      }
      renderedTrajectories.push(trajectory);
    }
    if (selectedVehicleImg && selectedVehiclePx) {
      context === null || context === void 0 ? void 0 : context.drawImage(selectedVehicleImg, Math.floor(selectedVehiclePx[0] - selectedVehicleImg.width / 2), Math.floor(selectedVehiclePx[1] - selectedVehicleImg.height / 2));
    }
    if (hoverVehicleImg && hoverVehiclePx) {
      context === null || context === void 0 ? void 0 : context.drawImage(hoverVehicleImg, Math.floor(hoverVehiclePx[0] - hoverVehicleImg.width / 2), Math.floor(hoverVehiclePx[1] - hoverVehicleImg.height / 2));
    }
    return {
      renderedTrajectories
    };
  };
  var renderTrajectories_default = renderTrajectories;

  // node_modules/mobility-toolbox-js/common/utils/getMaplibreRender.js
  function getMaplibreRender(maplibreLayer) {
    let emptyDiv;
    return (frameState) => {
      const { map: map2, mbMap, olLayer } = maplibreLayer;
      if (!map2 || !mbMap) {
        if (!emptyDiv) {
          emptyDiv = document.createElement("div");
        }
        return emptyDiv;
      }
      const canvas = mbMap.getCanvas();
      const { viewState } = frameState;
      const opacity = (olLayer === null || olLayer === void 0 ? void 0 : olLayer.getOpacity()) || 1;
      canvas.style.opacity = `${opacity}`;
      mbMap.jumpTo({
        center: toLonLat(viewState.center),
        zoom: viewState.zoom - 1,
        bearing: toDegrees(-viewState.rotation)
      });
      if (!canvas.isConnected) {
        map2.render();
      } else if (canvas.width !== frameState.size[0] || canvas.height !== frameState.size[1]) {
        mbMap.resize();
      }
      mbMap.redraw();
      return mbMap.getContainer();
    };
  }

  // node_modules/mobility-toolbox-js/common/utils/createCanvas.js
  var createCanvas = (width, height) => {
    let canvas = null;
    if (typeof window === "undefined") {
      return null;
    }
    if (typeof document !== "undefined" && (document === null || document === void 0 ? void 0 : document.createElement)) {
      canvas = document.createElement("canvas");
      canvas.width = width;
      canvas.height = height;
    } else if (OffscreenCanvas) {
      canvas = new OffscreenCanvas(width, height);
    } else {
      console.error("We didn't find a way to create a canvas element, document.createElement('canvas') and new OffscrenCanvas() are not supported");
    }
    return canvas;
  };
  var createCanvas_default = createCanvas;

  // node_modules/mobility-toolbox-js/common/utils/realtimeConfig.js
  var realtimeConfig_exports = {};
  __export(realtimeConfig_exports, {
    bgColors: () => bgColors,
    getBgColor: () => getBgColor,
    getDelayColor: () => getDelayColor,
    getDelayText: () => getDelayText,
    getRadius: () => getRadius,
    getTextColor: () => getTextColor,
    getTextSize: () => getTextSize,
    getTypeIndex: () => getTypeIndex,
    textColors: () => textColors,
    types: () => types
  });
  var radiusMapping = [
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 2, 2, 3, 7, 7, 7, 12, 15, 15, 15, 15, 15],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7],
    [0, 0, 0, 0, 0, 2, 2, 3, 7, 7, 7, 12, 15, 15, 15, 15, 15]
  ];
  var types = [
    /^Tram/i,
    /^Subway( \/ Metro \/ S-Bahn)?/i,
    /^Train/i,
    /^Bus/i,
    /^Ferry/i,
    /^Cable ?Car/i,
    /^Gondola/i,
    /^Funicular/i,
    /^(Long distance bus|coach)/i,
    /^Rail/i
    // New endpoint use Rail instead of Train.
  ];
  var bgColors = [
    "#ffb400",
    "#ff5400",
    "#ff8080",
    "#ea0000",
    "#3000ff",
    "#ffb400",
    "#41a27b",
    "#00d237",
    "#b5b5b5",
    "#ff8080"
  ];
  var textColors = [
    "#000000",
    "#ffffff",
    "#000000",
    "#ffffff",
    "#ffffff",
    "#000000",
    "#ffffff",
    "#000000",
    "#000000",
    "#000000"
  ];
  var getTypeIndex = (type) => {
    if (typeof type === "string") {
      return types.findIndex((t3) => t3.test(type));
    }
    return type;
  };
  var getRadius = (type, zoom) => {
    try {
      const typeIdx = getTypeIndex(type || 0);
      return radiusMapping[typeIdx][zoom];
    } catch (e3) {
      return 1;
    }
  };
  var getBgColor = (type) => {
    try {
      const typeIdx = getTypeIndex(type);
      return bgColors[typeIdx];
    } catch (e3) {
      return "#ffffff";
    }
  };
  var getTextColor = (type) => {
    try {
      const typeIdx = getTypeIndex(type);
      return textColors[typeIdx];
    } catch (e3) {
      return "#ffffff";
    }
  };
  var getTextSize = (ctx, markerSize, text, fontSize) => {
    if (!ctx) {
      return 0;
    }
    ctx.font = `bold ${fontSize}px Arial`;
    let newText = ctx.measureText(text);
    const maxiter = 25;
    let i4 = 0;
    while (newText.width > markerSize - 6 && i4 < maxiter) {
      fontSize -= 0.5;
      ctx.font = `bold ${fontSize}px arial, sans-serif`;
      newText = ctx.measureText(text);
      i4 += 1;
    }
    return fontSize;
  };
  var getDelayColor = (delayInMs, cancelled, isDelayText) => {
    if (cancelled) {
      return isDelayText ? "#ff0000" : "#a0a0a0";
    }
    if (delayInMs === null) {
      return "#a0a0a0";
    }
    if (delayInMs >= 36e5) {
      return "#ed004c";
    }
    if (delayInMs >= 5e5) {
      return "#e80000";
    }
    if (delayInMs >= 3e5) {
      return "#ff4a00";
    }
    if (delayInMs >= 18e4) {
      return "#f7bf00";
    }
    return "#00a00c";
  };
  var getDelayText = (delayInMs, cancelled) => {
    if (cancelled) {
      return String.fromCodePoint(215);
    }
    if (delayInMs > 36e5) {
      const rounded = Math.round(delayInMs / 36e5);
      return `+${rounded}h`;
    }
    if (delayInMs > 59e3) {
      const rounded = Math.round(delayInMs / 6e4);
      return `+${rounded}m`;
    }
    if (delayInMs > 0) {
      return `+${delayInMs}s`;
    }
    return "";
  };

  // node_modules/mobility-toolbox-js/common/styles/realtimeDefaultStyle.js
  var cacheDelayBg = {};
  var getDelayBgCanvas = (origin, radius, color) => {
    const key = `${origin}, ${radius}, ${color}`;
    if (!cacheDelayBg[key]) {
      const canvas = createCanvas_default(origin * 2, origin * 2);
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        ctx.beginPath();
        ctx.arc(origin, origin, radius, 0, 2 * Math.PI, false);
        ctx.fillStyle = color;
        ctx.filter = "blur(1px)";
        ctx.fill();
        cacheDelayBg[key] = canvas;
      }
    }
    return cacheDelayBg[key];
  };
  var cacheDelayText = {};
  var getDelayTextCanvas = (text, fontSize, font, delayColor, delayOutlineColor = "#000", pixelRatio = 1) => {
    const key = `${text}, ${font}, ${delayColor}, ${delayOutlineColor}, ${pixelRatio}`;
    if (!cacheDelayText[key]) {
      const canvas = createCanvas_default(Math.ceil(text.length * fontSize), Math.ceil(fontSize + 8 * pixelRatio));
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        ctx.font = font;
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.font = font;
        ctx.fillStyle = delayColor;
        ctx.strokeStyle = delayOutlineColor;
        ctx.lineWidth = 1.5 * pixelRatio;
        ctx.strokeText(text, 0, fontSize);
        ctx.fillText(text, 0, fontSize);
        cacheDelayText[key] = canvas;
      }
    }
    return cacheDelayText[key];
  };
  var cacheCircle = {};
  var getCircleCanvas = (origin, radius, color, hasStroke, hasDash, pixelRatio) => {
    const key = `${origin}, ${radius}, ${color}, ${hasStroke},  ${hasDash}, ${pixelRatio}`;
    if (!cacheCircle[key]) {
      const canvas = createCanvas_default(origin * 2, origin * 2);
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        ctx.fillStyle = color;
        if (hasStroke) {
          ctx.lineWidth = 1 * pixelRatio;
          ctx.strokeStyle = "#000000";
        }
        ctx.beginPath();
        ctx.arc(origin, origin, radius, 0, 2 * Math.PI, false);
        ctx.fill();
        if (hasDash) {
          ctx.setLineDash([5, 3]);
        }
        if (hasStroke) {
          ctx.stroke();
        }
        cacheCircle[key] = canvas;
      }
    }
    return cacheCircle[key];
  };
  var cacheText = {};
  var getTextCanvas = (text, origin, textSize, fillColor, strokeColor, hasStroke, pixelRatio) => {
    const key = `${text}, ${origin}, ${textSize}, ${fillColor},${strokeColor}, ${hasStroke}, ${pixelRatio}`;
    if (!cacheText[key]) {
      const canvas = createCanvas_default(origin * 2, origin * 2);
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        if (hasStroke) {
          ctx.save();
          ctx.textBaseline = "middle";
          ctx.textAlign = "center";
          ctx.font = `bold ${textSize + 2}px Arial`;
          ctx.strokeStyle = strokeColor;
          ctx.strokeText(text, origin, origin);
          ctx.restore();
        }
        ctx.textBaseline = "middle";
        ctx.textAlign = "center";
        ctx.fillStyle = fillColor;
        ctx.font = `bold ${textSize}px Arial`;
        ctx.strokeStyle = strokeColor;
        ctx.strokeText(text, origin, origin);
        ctx.fillText(text, origin, origin);
        cacheText[key] = canvas;
      }
    }
    return cacheText[key];
  };
  var cache2 = {};
  var realtimeDefaultStyle = (trajectory, viewState, options) => {
    const { hoverVehicleId, selectedVehicleId, useDelayStyle, delayOutlineColor = "#000", delayDisplay = 3e5, getRadius: getRadius2 = () => 0, getBgColor: getBgColor3 = () => "#000", getDelayColor: getDelayColor3 = () => "#000", getDelayText: getDelayText2 = () => null, getTextColor: getTextColor2 = () => "#000", getTextSize: getTextSize2 = () => 0, getMaxRadiusForText = () => 10, getMaxRadiusForStrokeAndDelay = () => 7 } = options;
    const { zoom, pixelRatio = 1 } = viewState;
    let { type } = trajectory.properties;
    const { train_id: id, line, delay, state, operator_provides_realtime_journey: operatorProvidesRealtime } = trajectory.properties;
    let { name, text_color: textColor, color } = line || {};
    const cancelled = state === "JOURNEY_CANCELLED";
    if (!type) {
      type = "Rail";
    }
    if (!name) {
      name = "I";
    }
    if (!textColor) {
      textColor = "#000000";
    }
    if (color && color[0] !== "#") {
      color = `#${color}`;
    }
    if (textColor[0] !== "#") {
      textColor = `#${textColor}`;
    }
    const z3 = Math.min(Math.floor(zoom || 1), 16);
    const hover = !!(hoverVehicleId && hoverVehicleId === id);
    const selected = !!(selectedVehicleId && selectedVehicleId === id);
    let radius = getRadius2(type, z3) * pixelRatio;
    const isDisplayStrokeAndDelay = radius >= getMaxRadiusForStrokeAndDelay() * pixelRatio;
    if (hover || selected) {
      radius = isDisplayStrokeAndDelay ? radius + 5 * pixelRatio : 14 * pixelRatio;
    }
    const isDisplayText = radius > getMaxRadiusForText() * pixelRatio;
    let key = `${radius}${hover || selected}`;
    if (useDelayStyle) {
      key += `${operatorProvidesRealtime}${delay}`;
      if (isDisplayStrokeAndDelay) {
        key += `${cancelled}`;
      }
    } else {
      key += `${color || type}`;
      if (isDisplayStrokeAndDelay) {
        key += `${cancelled}${delay}`;
      }
    }
    if (isDisplayText) {
      key += `${name}${textColor}`;
    }
    if (!cache2[key]) {
      if (radius === 0) {
        return null;
      }
      const margin = 1 * pixelRatio;
      const radiusDelay = radius + 2 * pixelRatio;
      const markerSize = radius * 2;
      const size = radiusDelay * 2 + margin * 2;
      const origin = size / 2;
      let delayBg = null;
      if (isDisplayStrokeAndDelay && delay !== null) {
        delayBg = getDelayBgCanvas(origin, radiusDelay, getDelayColor3(delay, cancelled));
      }
      let delayText = null;
      let fontSize = 0;
      if (isDisplayStrokeAndDelay && (hover || (delay || 0) >= delayDisplay || cancelled)) {
        fontSize = Math.max(cancelled ? 19 : 14, Math.min(cancelled ? 19 : 17, radius * 1.2)) * pixelRatio;
        const text = getDelayText2(delay, cancelled);
        if (text) {
          delayText = getDelayTextCanvas(text, fontSize, `bold ${fontSize}px arial, sans-serif`, getDelayColor3(delay, cancelled, true), delayOutlineColor, pixelRatio);
        }
      }
      let circleFillColor;
      if (useDelayStyle) {
        circleFillColor = getDelayColor3(delay, cancelled);
      } else {
        circleFillColor = color || getBgColor3(type);
      }
      const hasStroke = isDisplayStrokeAndDelay || hover || selected;
      const hasDash = !!isDisplayStrokeAndDelay && !!useDelayStyle && delay === null && operatorProvidesRealtime === "yes";
      const circle = getCircleCanvas(origin, radius, circleFillColor, hasStroke, hasDash, pixelRatio);
      const width = size + ((delayText === null || delayText === void 0 ? void 0 : delayText.width) || 0) * 2;
      const height = size;
      const canvas = createCanvas_default(width, height);
      if (canvas) {
        const ctx = canvas.getContext("2d");
        if (!ctx) {
          return null;
        }
        const originX = (delayText === null || delayText === void 0 ? void 0 : delayText.width) || 0;
        if (delayBg) {
          ctx.drawImage(delayBg, originX, 0);
        }
        if (circle) {
          ctx.drawImage(circle, originX, 0);
        }
        let circleText = null;
        if (isDisplayText) {
          const fontSize2 = Math.max(radius, 10);
          const textSize = getTextSize2(ctx, markerSize, name, fontSize2);
          const textColor2 = !useDelayStyle ? textColor || getTextColor2(type) : "#000000";
          const hasStroke2 = !!useDelayStyle && delay === null && operatorProvidesRealtime === "yes";
          circleText = getTextCanvas(name, origin, textSize, textColor2, circleFillColor, hasStroke2, pixelRatio);
        }
        if (circleText) {
          ctx.drawImage(circleText, originX, 0);
        }
        if (delayText) {
          ctx.drawImage(delayText, originX + Math.ceil(origin + radiusDelay) + margin, Math.ceil(origin - fontSize));
        }
        cache2[key] = canvas;
      }
    }
    return cache2[key];
  };
  var realtimeDefaultStyle_default = realtimeDefaultStyle;

  // node_modules/ol/layer/Property.js
  var Property_default = {
    OPACITY: "opacity",
    VISIBLE: "visible",
    EXTENT: "extent",
    Z_INDEX: "zIndex",
    MAX_RESOLUTION: "maxResolution",
    MIN_RESOLUTION: "minResolution",
    MAX_ZOOM: "maxZoom",
    MIN_ZOOM: "minZoom",
    SOURCE: "source",
    MAP: "map"
  };

  // node_modules/ol/layer/Base.js
  var BaseLayer = class extends Object_default {
    /**
     * @param {Options} options Layer options.
     */
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      this.background_ = options.background;
      const properties = Object.assign({}, options);
      if (typeof options.properties === "object") {
        delete properties.properties;
        Object.assign(properties, options.properties);
      }
      properties[Property_default.OPACITY] = options.opacity !== void 0 ? options.opacity : 1;
      assert(
        typeof properties[Property_default.OPACITY] === "number",
        "Layer opacity must be a number"
      );
      properties[Property_default.VISIBLE] = options.visible !== void 0 ? options.visible : true;
      properties[Property_default.Z_INDEX] = options.zIndex;
      properties[Property_default.MAX_RESOLUTION] = options.maxResolution !== void 0 ? options.maxResolution : Infinity;
      properties[Property_default.MIN_RESOLUTION] = options.minResolution !== void 0 ? options.minResolution : 0;
      properties[Property_default.MIN_ZOOM] = options.minZoom !== void 0 ? options.minZoom : -Infinity;
      properties[Property_default.MAX_ZOOM] = options.maxZoom !== void 0 ? options.maxZoom : Infinity;
      this.className_ = properties.className !== void 0 ? properties.className : "ol-layer";
      delete properties.className;
      this.setProperties(properties);
      this.state_ = null;
    }
    /**
     * Get the background for this layer.
     * @return {BackgroundColor|false} Layer background.
     */
    getBackground() {
      return this.background_;
    }
    /**
     * @return {string} CSS class name.
     */
    getClassName() {
      return this.className_;
    }
    /**
     * This method is not meant to be called by layers or layer renderers because the state
     * is incorrect if the layer is included in a layer group.
     *
     * @param {boolean} [managed] Layer is managed.
     * @return {import("./Layer.js").State} Layer state.
     */
    getLayerState(managed) {
      const state = this.state_ || /** @type {?} */
      {
        layer: this,
        managed: managed === void 0 ? true : managed
      };
      const zIndex = this.getZIndex();
      state.opacity = clamp(Math.round(this.getOpacity() * 100) / 100, 0, 1);
      state.visible = this.getVisible();
      state.extent = this.getExtent();
      state.zIndex = zIndex === void 0 && !state.managed ? Infinity : zIndex;
      state.maxResolution = this.getMaxResolution();
      state.minResolution = Math.max(this.getMinResolution(), 0);
      state.minZoom = this.getMinZoom();
      state.maxZoom = this.getMaxZoom();
      this.state_ = state;
      return state;
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be
     *     modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(array) {
      return abstract();
    }
    /**
     * @abstract
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer
     *     states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(states) {
      return abstract();
    }
    /**
     * Return the {@link module:ol/extent~Extent extent} of the layer or `undefined` if it
     * will be visible regardless of extent.
     * @return {import("../extent.js").Extent|undefined} The layer extent.
     * @observable
     * @api
     */
    getExtent() {
      return (
        /** @type {import("../extent.js").Extent|undefined} */
        this.get(Property_default.EXTENT)
      );
    }
    /**
     * Return the maximum resolution of the layer. Returns Infinity if
     * the layer has no maximum resolution set.
     * @return {number} The maximum resolution of the layer.
     * @observable
     * @api
     */
    getMaxResolution() {
      return (
        /** @type {number} */
        this.get(Property_default.MAX_RESOLUTION)
      );
    }
    /**
     * Return the minimum resolution of the layer. Returns 0 if
     * the layer has no minimum resolution set.
     * @return {number} The minimum resolution of the layer.
     * @observable
     * @api
     */
    getMinResolution() {
      return (
        /** @type {number} */
        this.get(Property_default.MIN_RESOLUTION)
      );
    }
    /**
     * Return the minimum zoom level of the layer. Returns -Infinity if
     * the layer has no minimum zoom set.
     * @return {number} The minimum zoom level of the layer.
     * @observable
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.get(Property_default.MIN_ZOOM)
      );
    }
    /**
     * Return the maximum zoom level of the layer. Returns Infinity if
     * the layer has no maximum zoom set.
     * @return {number} The maximum zoom level of the layer.
     * @observable
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.get(Property_default.MAX_ZOOM)
      );
    }
    /**
     * Return the opacity of the layer (between 0 and 1).
     * @return {number} The opacity of the layer.
     * @observable
     * @api
     */
    getOpacity() {
      return (
        /** @type {number} */
        this.get(Property_default.OPACITY)
      );
    }
    /**
     * @abstract
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      return abstract();
    }
    /**
     * Return the value of this layer's `visible` property. To find out whether the layer
     * is visible on a map, use `isVisible()` instead.
     * @return {boolean} The value of the `visible` property of the layer.
     * @observable
     * @api
     */
    getVisible() {
      return (
        /** @type {boolean} */
        this.get(Property_default.VISIBLE)
      );
    }
    /**
     * Return the Z-index of the layer, which is used to order layers before
     * rendering. Returns undefined if the layer is unmanaged.
     * @return {number|undefined} The Z-index of the layer.
     * @observable
     * @api
     */
    getZIndex() {
      return (
        /** @type {number|undefined} */
        this.get(Property_default.Z_INDEX)
      );
    }
    /**
     * Sets the background color.
     * @param {BackgroundColor} [background] Background color.
     */
    setBackground(background) {
      this.background_ = background;
      this.changed();
    }
    /**
     * Set the extent at which the layer is visible.  If `undefined`, the layer
     * will be visible at all extents.
     * @param {import("../extent.js").Extent|undefined} extent The extent of the layer.
     * @observable
     * @api
     */
    setExtent(extent) {
      this.set(Property_default.EXTENT, extent);
    }
    /**
     * Set the maximum resolution at which the layer is visible.
     * @param {number} maxResolution The maximum resolution of the layer.
     * @observable
     * @api
     */
    setMaxResolution(maxResolution) {
      this.set(Property_default.MAX_RESOLUTION, maxResolution);
    }
    /**
     * Set the minimum resolution at which the layer is visible.
     * @param {number} minResolution The minimum resolution of the layer.
     * @observable
     * @api
     */
    setMinResolution(minResolution) {
      this.set(Property_default.MIN_RESOLUTION, minResolution);
    }
    /**
     * Set the maximum zoom (exclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} maxZoom The maximum zoom of the layer.
     * @observable
     * @api
     */
    setMaxZoom(maxZoom) {
      this.set(Property_default.MAX_ZOOM, maxZoom);
    }
    /**
     * Set the minimum zoom (inclusive) at which the layer is visible.
     * Note that the zoom levels for layer visibility are based on the
     * view zoom level, which may be different from a tile source zoom level.
     * @param {number} minZoom The minimum zoom of the layer.
     * @observable
     * @api
     */
    setMinZoom(minZoom) {
      this.set(Property_default.MIN_ZOOM, minZoom);
    }
    /**
     * Set the opacity of the layer, allowed values range from 0 to 1.
     * @param {number} opacity The opacity of the layer.
     * @observable
     * @api
     */
    setOpacity(opacity) {
      assert(typeof opacity === "number", "Layer opacity must be a number");
      this.set(Property_default.OPACITY, opacity);
    }
    /**
     * Set the visibility of the layer (`true` or `false`).
     * @param {boolean} visible The visibility of the layer.
     * @observable
     * @api
     */
    setVisible(visible) {
      this.set(Property_default.VISIBLE, visible);
    }
    /**
     * Set Z-index of the layer, which is used to order layers before rendering.
     * The default Z-index is 0.
     * @param {number} zindex The z-index of the layer.
     * @observable
     * @api
     */
    setZIndex(zindex) {
      this.set(Property_default.Z_INDEX, zindex);
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      if (this.state_) {
        this.state_.layer = null;
        this.state_ = null;
      }
      super.disposeInternal();
    }
  };
  var Base_default = BaseLayer;

  // node_modules/ol/render/EventType.js
  var EventType_default2 = {
    /**
     * Triggered before a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#prerender
     * @api
     */
    PRERENDER: "prerender",
    /**
     * Triggered after a layer is rendered.
     * @event module:ol/render/Event~RenderEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered before layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#precompose
     * @api
     */
    PRECOMPOSE: "precompose",
    /**
     * Triggered after layers are composed.  When dispatched by the map, the event object will not have
     * a `context` set.  When dispatched by a layer, the event object will have a `context` set.  Only
     * WebGL layers currently dispatch this event.
     * @event module:ol/render/Event~RenderEvent#postcompose
     * @api
     */
    POSTCOMPOSE: "postcompose",
    /**
     * Triggered when rendering is complete, i.e. all sources and tiles have
     * finished loading for the current viewport, and all tiles are faded in.
     * The event object will not have a `context` set.
     * @event module:ol/render/Event~RenderEvent#rendercomplete
     * @api
     */
    RENDERCOMPLETE: "rendercomplete"
  };

  // node_modules/ol/ViewHint.js
  var ViewHint_default = {
    ANIMATING: 0,
    INTERACTING: 1
  };

  // node_modules/ol/ViewProperty.js
  var ViewProperty_default = {
    CENTER: "center",
    RESOLUTION: "resolution",
    ROTATION: "rotation"
  };

  // node_modules/ol/tilegrid/common.js
  var DEFAULT_TILE_SIZE = 256;

  // node_modules/ol/centerconstraint.js
  function createExtent(extent, onlyCenter, smooth) {
    return (
      /**
       * @param {import("./coordinate.js").Coordinate|undefined} center Center.
       * @param {number|undefined} resolution Resolution.
       * @param {import("./size.js").Size} size Viewport size; unused if `onlyCenter` was specified.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @param {Array<number>} [centerShift] Shift between map center and viewport center.
       * @return {import("./coordinate.js").Coordinate|undefined} Center.
       */
      function(center, resolution, size, isMoving, centerShift) {
        if (!center) {
          return void 0;
        }
        if (!resolution && !onlyCenter) {
          return center;
        }
        const viewWidth = onlyCenter ? 0 : size[0] * resolution;
        const viewHeight = onlyCenter ? 0 : size[1] * resolution;
        const shiftX = centerShift ? centerShift[0] : 0;
        const shiftY = centerShift ? centerShift[1] : 0;
        let minX = extent[0] + viewWidth / 2 + shiftX;
        let maxX = extent[2] - viewWidth / 2 + shiftX;
        let minY = extent[1] + viewHeight / 2 + shiftY;
        let maxY = extent[3] - viewHeight / 2 + shiftY;
        if (minX > maxX) {
          minX = (maxX + minX) / 2;
          maxX = minX;
        }
        if (minY > maxY) {
          minY = (maxY + minY) / 2;
          maxY = minY;
        }
        let x2 = clamp(center[0], minX, maxX);
        let y2 = clamp(center[1], minY, maxY);
        if (isMoving && smooth && resolution) {
          const ratio = 30 * resolution;
          x2 += -ratio * Math.log(1 + Math.max(0, minX - center[0]) / ratio) + ratio * Math.log(1 + Math.max(0, center[0] - maxX) / ratio);
          y2 += -ratio * Math.log(1 + Math.max(0, minY - center[1]) / ratio) + ratio * Math.log(1 + Math.max(0, center[1] - maxY) / ratio);
        }
        return [x2, y2];
      }
    );
  }
  function none(center) {
    return center;
  }

  // node_modules/ol/resolutionconstraint.js
  function getViewportClampedResolution(resolution, maxExtent, viewportSize, showFullExtent) {
    const xResolution = getWidth(maxExtent) / viewportSize[0];
    const yResolution = getHeight(maxExtent) / viewportSize[1];
    if (showFullExtent) {
      return Math.min(resolution, Math.max(xResolution, yResolution));
    }
    return Math.min(resolution, Math.min(xResolution, yResolution));
  }
  function getSmoothClampedResolution(resolution, maxResolution, minResolution) {
    let result = Math.min(resolution, maxResolution);
    const ratio = 50;
    result *= Math.log(1 + ratio * Math.max(0, resolution / maxResolution - 1)) / ratio + 1;
    if (minResolution) {
      result = Math.max(result, minResolution);
      result /= Math.log(1 + ratio * Math.max(0, minResolution / resolution - 1)) / ratio + 1;
    }
    return clamp(result, minResolution / 2, maxResolution * 2);
  }
  function createSnapToResolutions(resolutions, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== void 0 ? smooth : true;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function(resolution, direction, size, isMoving) {
        if (resolution !== void 0) {
          const maxResolution = resolutions[0];
          const minResolution = resolutions[resolutions.length - 1];
          const cappedMaxRes = maxExtent ? getViewportClampedResolution(
            maxResolution,
            maxExtent,
            size,
            showFullExtent
          ) : maxResolution;
          if (isMoving) {
            if (!smooth) {
              return clamp(resolution, minResolution, cappedMaxRes);
            }
            return getSmoothClampedResolution(
              resolution,
              cappedMaxRes,
              minResolution
            );
          }
          const capped = Math.min(cappedMaxRes, resolution);
          const z3 = Math.floor(linearFindNearest(resolutions, capped, direction));
          if (resolutions[z3] > cappedMaxRes && z3 < resolutions.length - 1) {
            return resolutions[z3 + 1];
          }
          return resolutions[z3];
        }
        return void 0;
      }
    );
  }
  function createSnapToPower(power, maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== void 0 ? smooth : true;
    minResolution = minResolution !== void 0 ? minResolution : 0;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function(resolution, direction, size, isMoving) {
        if (resolution !== void 0) {
          const cappedMaxRes = maxExtent ? getViewportClampedResolution(
            maxResolution,
            maxExtent,
            size,
            showFullExtent
          ) : maxResolution;
          if (isMoving) {
            if (!smooth) {
              return clamp(resolution, minResolution, cappedMaxRes);
            }
            return getSmoothClampedResolution(
              resolution,
              cappedMaxRes,
              minResolution
            );
          }
          const tolerance = 1e-9;
          const minZoomLevel = Math.ceil(
            Math.log(maxResolution / cappedMaxRes) / Math.log(power) - tolerance
          );
          const offset2 = -direction * (0.5 - tolerance) + 0.5;
          const capped = Math.min(cappedMaxRes, resolution);
          const cappedZoomLevel = Math.floor(
            Math.log(maxResolution / capped) / Math.log(power) + offset2
          );
          const zoomLevel = Math.max(minZoomLevel, cappedZoomLevel);
          const newResolution = maxResolution / Math.pow(power, zoomLevel);
          return clamp(newResolution, minResolution, cappedMaxRes);
        }
        return void 0;
      }
    );
  }
  function createMinMaxResolution(maxResolution, minResolution, smooth, maxExtent, showFullExtent) {
    smooth = smooth !== void 0 ? smooth : true;
    return (
      /**
       * @param {number|undefined} resolution Resolution.
       * @param {number} direction Direction.
       * @param {import("./size.js").Size} size Viewport size.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Resolution.
       */
      function(resolution, direction, size, isMoving) {
        if (resolution !== void 0) {
          const cappedMaxRes = maxExtent ? getViewportClampedResolution(
            maxResolution,
            maxExtent,
            size,
            showFullExtent
          ) : maxResolution;
          if (!smooth || !isMoving) {
            return clamp(resolution, minResolution, cappedMaxRes);
          }
          return getSmoothClampedResolution(
            resolution,
            cappedMaxRes,
            minResolution
          );
        }
        return void 0;
      }
    );
  }

  // node_modules/ol/rotationconstraint.js
  function disable(rotation) {
    if (rotation !== void 0) {
      return 0;
    }
    return void 0;
  }
  function none2(rotation) {
    if (rotation !== void 0) {
      return rotation;
    }
    return void 0;
  }
  function createSnapToN(n2) {
    const theta = 2 * Math.PI / n2;
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(rotation, isMoving) {
        if (isMoving) {
          return rotation;
        }
        if (rotation !== void 0) {
          rotation = Math.floor(rotation / theta + 0.5) * theta;
          return rotation;
        }
        return void 0;
      }
    );
  }
  function createSnapToZero(tolerance) {
    tolerance = tolerance || toRadians(5);
    return (
      /**
       * @param {number|undefined} rotation Rotation.
       * @param {boolean} [isMoving] True if an interaction or animation is in progress.
       * @return {number|undefined} Rotation.
       */
      function(rotation, isMoving) {
        if (isMoving) {
          return rotation;
        }
        if (rotation !== void 0) {
          if (Math.abs(rotation) <= tolerance) {
            return 0;
          }
          return rotation;
        }
        return void 0;
      }
    );
  }

  // node_modules/ol/easing.js
  function easeIn(t3) {
    return Math.pow(t3, 3);
  }
  function easeOut(t3) {
    return 1 - easeIn(1 - t3);
  }
  function inAndOut(t3) {
    return 3 * t3 * t3 - 2 * t3 * t3 * t3;
  }
  function linear(t3) {
    return t3;
  }

  // node_modules/ol/View.js
  var DEFAULT_MIN_ZOOM = 0;
  var View = class extends Object_default {
    /**
     * @param {ViewOptions} [options] View options.
     */
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      options = Object.assign({}, options);
      this.hints_ = [0, 0];
      this.animations_ = [];
      this.updateAnimationKey_;
      this.projection_ = createProjection(options.projection, "EPSG:3857");
      this.viewportSize_ = [100, 100];
      this.targetCenter_ = null;
      this.targetResolution_;
      this.targetRotation_;
      this.nextCenter_ = null;
      this.nextResolution_;
      this.nextRotation_;
      this.cancelAnchor_ = void 0;
      if (options.projection) {
        disableCoordinateWarning();
      }
      if (options.center) {
        options.center = fromUserCoordinate(options.center, this.projection_);
      }
      if (options.extent) {
        options.extent = fromUserExtent(options.extent, this.projection_);
      }
      this.applyOptions_(options);
    }
    /**
     * Set up the view with the given options.
     * @param {ViewOptions} options View options.
     */
    applyOptions_(options) {
      const properties = Object.assign({}, options);
      for (const key in ViewProperty_default) {
        delete properties[key];
      }
      this.setProperties(properties, true);
      const resolutionConstraintInfo = createResolutionConstraint(options);
      this.maxResolution_ = resolutionConstraintInfo.maxResolution;
      this.minResolution_ = resolutionConstraintInfo.minResolution;
      this.zoomFactor_ = resolutionConstraintInfo.zoomFactor;
      this.resolutions_ = options.resolutions;
      this.padding_ = options.padding;
      this.minZoom_ = resolutionConstraintInfo.minZoom;
      const centerConstraint = createCenterConstraint(options);
      const resolutionConstraint = resolutionConstraintInfo.constraint;
      const rotationConstraint = createRotationConstraint(options);
      this.constraints_ = {
        center: centerConstraint,
        resolution: resolutionConstraint,
        rotation: rotationConstraint
      };
      this.setRotation(options.rotation !== void 0 ? options.rotation : 0);
      this.setCenterInternal(
        options.center !== void 0 ? options.center : null
      );
      if (options.resolution !== void 0) {
        this.setResolution(options.resolution);
      } else if (options.zoom !== void 0) {
        this.setZoom(options.zoom);
      }
    }
    /**
     * Padding (in css pixels).
     * If the map viewport is partially covered with other content (overlays) along
     * its edges, this setting allows to shift the center of the viewport away from that
     * content. The order of the values in the array is top, right, bottom, left.
     * The default is no padding, which is equivalent to `[0, 0, 0, 0]`.
     * @type {Array<number>|undefined}
     * @api
     */
    get padding() {
      return this.padding_;
    }
    set padding(padding) {
      let oldPadding = this.padding_;
      this.padding_ = padding;
      const center = this.getCenterInternal();
      if (center) {
        const newPadding = padding || [0, 0, 0, 0];
        oldPadding = oldPadding || [0, 0, 0, 0];
        const resolution = this.getResolution();
        const offsetX = resolution / 2 * (newPadding[3] - oldPadding[3] + oldPadding[1] - newPadding[1]);
        const offsetY = resolution / 2 * (newPadding[0] - oldPadding[0] + oldPadding[2] - newPadding[2]);
        this.setCenterInternal([center[0] + offsetX, center[1] - offsetY]);
      }
    }
    /**
     * Get an updated version of the view options used to construct the view.  The
     * current resolution (or zoom), center, and rotation are applied to any stored
     * options.  The provided options can be used to apply new min/max zoom or
     * resolution limits.
     * @param {ViewOptions} newOptions New options to be applied.
     * @return {ViewOptions} New options updated with the current view state.
     */
    getUpdatedOptions_(newOptions) {
      const options = this.getProperties();
      if (options.resolution !== void 0) {
        options.resolution = this.getResolution();
      } else {
        options.zoom = this.getZoom();
      }
      options.center = this.getCenterInternal();
      options.rotation = this.getRotation();
      return Object.assign({}, options, newOptions);
    }
    /**
     * Animate the view.  The view's center, zoom (or resolution), and rotation
     * can be animated for smooth transitions between view states.  For example,
     * to animate the view to a new zoom level:
     *
     *     view.animate({zoom: view.getZoom() + 1});
     *
     * By default, the animation lasts one second and uses in-and-out easing.  You
     * can customize this behavior by including `duration` (in milliseconds) and
     * `easing` options (see {@link module:ol/easing}).
     *
     * To chain together multiple animations, call the method with multiple
     * animation objects.  For example, to first zoom and then pan:
     *
     *     view.animate({zoom: 10}, {center: [0, 0]});
     *
     * If you provide a function as the last argument to the animate method, it
     * will get called at the end of an animation series.  The callback will be
     * called with `true` if the animation series completed on its own or `false`
     * if it was cancelled.
     *
     * Animations are cancelled by user interactions (e.g. dragging the map) or by
     * calling `view.setCenter()`, `view.setResolution()`, or `view.setRotation()`
     * (or another method that calls one of these).
     *
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation
     *     options.  Multiple animations can be run in series by passing multiple
     *     options objects.  To run multiple animations in parallel, call the method
     *     multiple times.  An optional callback can be provided as a final
     *     argument.  The callback will be called with a boolean indicating whether
     *     the animation completed without being cancelled.
     * @api
     */
    animate(var_args) {
      if (this.isDef() && !this.getAnimating()) {
        this.resolveConstraints(0);
      }
      const args = new Array(arguments.length);
      for (let i4 = 0; i4 < args.length; ++i4) {
        let options = arguments[i4];
        if (options.center) {
          options = Object.assign({}, options);
          options.center = fromUserCoordinate(
            options.center,
            this.getProjection()
          );
        }
        if (options.anchor) {
          options = Object.assign({}, options);
          options.anchor = fromUserCoordinate(
            options.anchor,
            this.getProjection()
          );
        }
        args[i4] = options;
      }
      this.animateInternal.apply(this, args);
    }
    /**
     * @param {...(AnimationOptions|function(boolean): void)} var_args Animation options.
     */
    animateInternal(var_args) {
      let animationCount = arguments.length;
      let callback;
      if (animationCount > 1 && typeof arguments[animationCount - 1] === "function") {
        callback = arguments[animationCount - 1];
        --animationCount;
      }
      let i4 = 0;
      for (; i4 < animationCount && !this.isDef(); ++i4) {
        const state = arguments[i4];
        if (state.center) {
          this.setCenterInternal(state.center);
        }
        if (state.zoom !== void 0) {
          this.setZoom(state.zoom);
        } else if (state.resolution) {
          this.setResolution(state.resolution);
        }
        if (state.rotation !== void 0) {
          this.setRotation(state.rotation);
        }
      }
      if (i4 === animationCount) {
        if (callback) {
          animationCallback(callback, true);
        }
        return;
      }
      let start = Date.now();
      let center = this.targetCenter_.slice();
      let resolution = this.targetResolution_;
      let rotation = this.targetRotation_;
      const series = [];
      for (; i4 < animationCount; ++i4) {
        const options = (
          /** @type {AnimationOptions} */
          arguments[i4]
        );
        const animation = {
          start,
          complete: false,
          anchor: options.anchor,
          duration: options.duration !== void 0 ? options.duration : 1e3,
          easing: options.easing || inAndOut,
          callback
        };
        if (options.center) {
          animation.sourceCenter = center;
          animation.targetCenter = options.center.slice();
          center = animation.targetCenter;
        }
        if (options.zoom !== void 0) {
          animation.sourceResolution = resolution;
          animation.targetResolution = this.getResolutionForZoom(options.zoom);
          resolution = animation.targetResolution;
        } else if (options.resolution) {
          animation.sourceResolution = resolution;
          animation.targetResolution = options.resolution;
          resolution = animation.targetResolution;
        }
        if (options.rotation !== void 0) {
          animation.sourceRotation = rotation;
          const delta = modulo(options.rotation - rotation + Math.PI, 2 * Math.PI) - Math.PI;
          animation.targetRotation = rotation + delta;
          rotation = animation.targetRotation;
        }
        if (isNoopAnimation(animation)) {
          animation.complete = true;
        } else {
          start += animation.duration;
        }
        series.push(animation);
      }
      this.animations_.push(series);
      this.setHint(ViewHint_default.ANIMATING, 1);
      this.updateAnimations_();
    }
    /**
     * Determine if the view is being animated.
     * @return {boolean} The view is being animated.
     * @api
     */
    getAnimating() {
      return this.hints_[ViewHint_default.ANIMATING] > 0;
    }
    /**
     * Determine if the user is interacting with the view, such as panning or zooming.
     * @return {boolean} The view is being interacted with.
     * @api
     */
    getInteracting() {
      return this.hints_[ViewHint_default.INTERACTING] > 0;
    }
    /**
     * Cancel any ongoing animations.
     * @api
     */
    cancelAnimations() {
      this.setHint(ViewHint_default.ANIMATING, -this.hints_[ViewHint_default.ANIMATING]);
      let anchor;
      for (let i4 = 0, ii = this.animations_.length; i4 < ii; ++i4) {
        const series = this.animations_[i4];
        if (series[0].callback) {
          animationCallback(series[0].callback, false);
        }
        if (!anchor) {
          for (let j3 = 0, jj = series.length; j3 < jj; ++j3) {
            const animation = series[j3];
            if (!animation.complete) {
              anchor = animation.anchor;
              break;
            }
          }
        }
      }
      this.animations_.length = 0;
      this.cancelAnchor_ = anchor;
      this.nextCenter_ = null;
      this.nextResolution_ = NaN;
      this.nextRotation_ = NaN;
    }
    /**
     * Update all animations.
     */
    updateAnimations_() {
      if (this.updateAnimationKey_ !== void 0) {
        cancelAnimationFrame(this.updateAnimationKey_);
        this.updateAnimationKey_ = void 0;
      }
      if (!this.getAnimating()) {
        return;
      }
      const now = Date.now();
      let more = false;
      for (let i4 = this.animations_.length - 1; i4 >= 0; --i4) {
        const series = this.animations_[i4];
        let seriesComplete = true;
        for (let j3 = 0, jj = series.length; j3 < jj; ++j3) {
          const animation = series[j3];
          if (animation.complete) {
            continue;
          }
          const elapsed = now - animation.start;
          let fraction = animation.duration > 0 ? elapsed / animation.duration : 1;
          if (fraction >= 1) {
            animation.complete = true;
            fraction = 1;
          } else {
            seriesComplete = false;
          }
          const progress = animation.easing(fraction);
          if (animation.sourceCenter) {
            const x0 = animation.sourceCenter[0];
            const y0 = animation.sourceCenter[1];
            const x1 = animation.targetCenter[0];
            const y1 = animation.targetCenter[1];
            this.nextCenter_ = animation.targetCenter;
            const x2 = x0 + progress * (x1 - x0);
            const y2 = y0 + progress * (y1 - y0);
            this.targetCenter_ = [x2, y2];
          }
          if (animation.sourceResolution && animation.targetResolution) {
            const resolution = progress === 1 ? animation.targetResolution : animation.sourceResolution + progress * (animation.targetResolution - animation.sourceResolution);
            if (animation.anchor) {
              const size = this.getViewportSize_(this.getRotation());
              const constrainedResolution = this.constraints_.resolution(
                resolution,
                0,
                size,
                true
              );
              this.targetCenter_ = this.calculateCenterZoom(
                constrainedResolution,
                animation.anchor
              );
            }
            this.nextResolution_ = animation.targetResolution;
            this.targetResolution_ = resolution;
            this.applyTargetState_(true);
          }
          if (animation.sourceRotation !== void 0 && animation.targetRotation !== void 0) {
            const rotation = progress === 1 ? modulo(animation.targetRotation + Math.PI, 2 * Math.PI) - Math.PI : animation.sourceRotation + progress * (animation.targetRotation - animation.sourceRotation);
            if (animation.anchor) {
              const constrainedRotation = this.constraints_.rotation(
                rotation,
                true
              );
              this.targetCenter_ = this.calculateCenterRotate(
                constrainedRotation,
                animation.anchor
              );
            }
            this.nextRotation_ = animation.targetRotation;
            this.targetRotation_ = rotation;
          }
          this.applyTargetState_(true);
          more = true;
          if (!animation.complete) {
            break;
          }
        }
        if (seriesComplete) {
          this.animations_[i4] = null;
          this.setHint(ViewHint_default.ANIMATING, -1);
          this.nextCenter_ = null;
          this.nextResolution_ = NaN;
          this.nextRotation_ = NaN;
          const callback = series[0].callback;
          if (callback) {
            animationCallback(callback, true);
          }
        }
      }
      this.animations_ = this.animations_.filter(Boolean);
      if (more && this.updateAnimationKey_ === void 0) {
        this.updateAnimationKey_ = requestAnimationFrame(
          this.updateAnimations_.bind(this)
        );
      }
    }
    /**
     * @param {number} rotation Target rotation.
     * @param {import("./coordinate.js").Coordinate} anchor Rotation anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for rotation and anchor.
     */
    calculateCenterRotate(rotation, anchor) {
      let center;
      const currentCenter = this.getCenterInternal();
      if (currentCenter !== void 0) {
        center = [currentCenter[0] - anchor[0], currentCenter[1] - anchor[1]];
        rotate(center, rotation - this.getRotation());
        add3(center, anchor);
      }
      return center;
    }
    /**
     * @param {number} resolution Target resolution.
     * @param {import("./coordinate.js").Coordinate} anchor Zoom anchor.
     * @return {import("./coordinate.js").Coordinate|undefined} Center for resolution and anchor.
     */
    calculateCenterZoom(resolution, anchor) {
      let center;
      const currentCenter = this.getCenterInternal();
      const currentResolution = this.getResolution();
      if (currentCenter !== void 0 && currentResolution !== void 0) {
        const x2 = anchor[0] - resolution * (anchor[0] - currentCenter[0]) / currentResolution;
        const y2 = anchor[1] - resolution * (anchor[1] - currentCenter[1]) / currentResolution;
        center = [x2, y2];
      }
      return center;
    }
    /**
     * Returns the current viewport size.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size or `[100, 100]` when no viewport is found.
     */
    getViewportSize_(rotation) {
      const size = this.viewportSize_;
      if (rotation) {
        const w3 = size[0];
        const h3 = size[1];
        return [
          Math.abs(w3 * Math.cos(rotation)) + Math.abs(h3 * Math.sin(rotation)),
          Math.abs(w3 * Math.sin(rotation)) + Math.abs(h3 * Math.cos(rotation))
        ];
      }
      return size;
    }
    /**
     * Stores the viewport size on the view. The viewport size is not read every time from the DOM
     * to avoid performance hit and layout reflow.
     * This should be done on map size change.
     * Note: the constraints are not resolved during an animation to avoid stopping it
     * @param {import("./size.js").Size} [size] Viewport size; if undefined, [100, 100] is assumed
     */
    setViewportSize(size) {
      this.viewportSize_ = Array.isArray(size) ? size.slice() : [100, 100];
      if (!this.getAnimating()) {
        this.resolveConstraints(0);
      }
    }
    /**
     * Get the view center.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     * @observable
     * @api
     */
    getCenter() {
      const center = this.getCenterInternal();
      if (!center) {
        return center;
      }
      return toUserCoordinate(center, this.getProjection());
    }
    /**
     * Get the view center without transforming to user projection.
     * @return {import("./coordinate.js").Coordinate|undefined} The center of the view.
     */
    getCenterInternal() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(ViewProperty_default.CENTER)
      );
    }
    /**
     * @return {Constraints} Constraints.
     */
    getConstraints() {
      return this.constraints_;
    }
    /**
     * @return {boolean} Resolution constraint is set
     */
    getConstrainResolution() {
      return this.get("constrainResolution");
    }
    /**
     * @param {Array<number>} [hints] Destination array.
     * @return {Array<number>} Hint.
     */
    getHints(hints) {
      if (hints !== void 0) {
        hints[0] = this.hints_[0];
        hints[1] = this.hints_[1];
        return hints;
      }
      return this.hints_.slice();
    }
    /**
     * Calculate the extent for the current view state and the passed size.
     * The size is the pixel dimensions of the box into which the calculated extent
     * should fit. In most cases you want to get the extent of the entire map,
     * that is `map.getSize()`.
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided, the size
     * of the map that uses this view will be used.
     * @return {import("./extent.js").Extent} Extent.
     * @api
     */
    calculateExtent(size) {
      const extent = this.calculateExtentInternal(size);
      return toUserExtent(extent, this.getProjection());
    }
    /**
     * @param {import("./size.js").Size} [size] Box pixel size. If not provided,
     * the map's last known viewport size will be used.
     * @return {import("./extent.js").Extent} Extent.
     */
    calculateExtentInternal(size) {
      size = size || this.getViewportSizeMinusPadding_();
      const center = (
        /** @type {!import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      assert(center, "The view center is not defined");
      const resolution = (
        /** @type {!number} */
        this.getResolution()
      );
      assert(resolution !== void 0, "The view resolution is not defined");
      const rotation = (
        /** @type {!number} */
        this.getRotation()
      );
      assert(rotation !== void 0, "The view rotation is not defined");
      return getForViewAndSize(center, resolution, rotation, size);
    }
    /**
     * Get the maximum resolution of the view.
     * @return {number} The maximum resolution of the view.
     * @api
     */
    getMaxResolution() {
      return this.maxResolution_;
    }
    /**
     * Get the minimum resolution of the view.
     * @return {number} The minimum resolution of the view.
     * @api
     */
    getMinResolution() {
      return this.minResolution_;
    }
    /**
     * Get the maximum zoom level for the view.
     * @return {number} The maximum zoom level.
     * @api
     */
    getMaxZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.minResolution_)
      );
    }
    /**
     * Set a new maximum zoom level for the view.
     * @param {number} zoom The maximum zoom level.
     * @api
     */
    setMaxZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({ maxZoom: zoom }));
    }
    /**
     * Get the minimum zoom level for the view.
     * @return {number} The minimum zoom level.
     * @api
     */
    getMinZoom() {
      return (
        /** @type {number} */
        this.getZoomForResolution(this.maxResolution_)
      );
    }
    /**
     * Set a new minimum zoom level for the view.
     * @param {number} zoom The minimum zoom level.
     * @api
     */
    setMinZoom(zoom) {
      this.applyOptions_(this.getUpdatedOptions_({ minZoom: zoom }));
    }
    /**
     * Set whether the view should allow intermediary zoom levels.
     * @param {boolean} enabled Whether the resolution is constrained.
     * @api
     */
    setConstrainResolution(enabled) {
      this.applyOptions_(this.getUpdatedOptions_({ constrainResolution: enabled }));
    }
    /**
     * Get the view projection.
     * @return {import("./proj/Projection.js").default} The projection of the view.
     * @api
     */
    getProjection() {
      return this.projection_;
    }
    /**
     * Get the view resolution.
     * @return {number|undefined} The resolution of the view.
     * @observable
     * @api
     */
    getResolution() {
      return (
        /** @type {number|undefined} */
        this.get(ViewProperty_default.RESOLUTION)
      );
    }
    /**
     * Get the resolutions for the view. This returns the array of resolutions
     * passed to the constructor of the View, or undefined if none were given.
     * @return {Array<number>|undefined} The resolutions of the view.
     * @api
     */
    getResolutions() {
      return this.resolutions_;
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     * @api
     */
    getResolutionForExtent(extent, size) {
      return this.getResolutionForExtentInternal(
        fromUserExtent(extent, this.getProjection()),
        size
      );
    }
    /**
     * Get the resolution for a provided extent (in map units) and size (in pixels).
     * @param {import("./extent.js").Extent} extent Extent.
     * @param {import("./size.js").Size} [size] Box pixel size.
     * @return {number} The resolution at which the provided extent will render at
     *     the given size.
     */
    getResolutionForExtentInternal(extent, size) {
      size = size || this.getViewportSizeMinusPadding_();
      const xResolution = getWidth(extent) / size[0];
      const yResolution = getHeight(extent) / size[1];
      return Math.max(xResolution, yResolution);
    }
    /**
     * Return a function that returns a value between 0 and 1 for a
     * resolution. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Resolution for value function.
     */
    getResolutionForValueFunction(power) {
      power = power || 2;
      const maxResolution = this.getConstrainedResolution(this.maxResolution_);
      const minResolution = this.minResolution_;
      const max = Math.log(maxResolution / minResolution) / Math.log(power);
      return (
        /**
         * @param {number} value Value.
         * @return {number} Resolution.
         */
        function(value) {
          const resolution = maxResolution / Math.pow(power, value * max);
          return resolution;
        }
      );
    }
    /**
     * Get the view rotation.
     * @return {number} The rotation of the view in radians.
     * @observable
     * @api
     */
    getRotation() {
      return (
        /** @type {number} */
        this.get(ViewProperty_default.ROTATION)
      );
    }
    /**
     * Return a function that returns a resolution for a value between
     * 0 and 1. Exponential scaling is assumed.
     * @param {number} [power] Power.
     * @return {function(number): number} Value for resolution function.
     */
    getValueForResolutionFunction(power) {
      const logPower = Math.log(power || 2);
      const maxResolution = this.getConstrainedResolution(this.maxResolution_);
      const minResolution = this.minResolution_;
      const max = Math.log(maxResolution / minResolution) / logPower;
      return (
        /**
         * @param {number} resolution Resolution.
         * @return {number} Value.
         */
        function(resolution) {
          const value = Math.log(maxResolution / resolution) / logPower / max;
          return value;
        }
      );
    }
    /**
     * Returns the size of the viewport minus padding.
     * @private
     * @param {number} [rotation] Take into account the rotation of the viewport when giving the size
     * @return {import("./size.js").Size} Viewport size reduced by the padding.
     */
    getViewportSizeMinusPadding_(rotation) {
      let size = this.getViewportSize_(rotation);
      const padding = this.padding_;
      if (padding) {
        size = [
          size[0] - padding[1] - padding[3],
          size[1] - padding[0] - padding[2]
        ];
      }
      return size;
    }
    /**
     * @return {State} View state.
     */
    getState() {
      const projection = this.getProjection();
      const resolution = this.getResolution();
      const rotation = this.getRotation();
      let center = (
        /** @type {import("./coordinate.js").Coordinate} */
        this.getCenterInternal()
      );
      const padding = this.padding_;
      if (padding) {
        const reducedSize = this.getViewportSizeMinusPadding_();
        center = calculateCenterOn(
          center,
          this.getViewportSize_(),
          [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
          resolution,
          rotation
        );
      }
      return {
        center: center.slice(0),
        projection: projection !== void 0 ? projection : null,
        resolution,
        nextCenter: this.nextCenter_,
        nextResolution: this.nextResolution_,
        nextRotation: this.nextRotation_,
        rotation,
        zoom: this.getZoom()
      };
    }
    /**
     * @return {ViewStateLayerStateExtent} Like `FrameState`, but just `viewState` and `extent`.
     */
    getViewStateAndExtent() {
      return {
        viewState: this.getState(),
        extent: this.calculateExtent()
      };
    }
    /**
     * Get the current zoom level. This method may return non-integer zoom levels
     * if the view does not constrain the resolution, or if an interaction or
     * animation is underway.
     * @return {number|undefined} Zoom.
     * @api
     */
    getZoom() {
      let zoom;
      const resolution = this.getResolution();
      if (resolution !== void 0) {
        zoom = this.getZoomForResolution(resolution);
      }
      return zoom;
    }
    /**
     * Get the zoom level for a resolution.
     * @param {number} resolution The resolution.
     * @return {number|undefined} The zoom level for the provided resolution.
     * @api
     */
    getZoomForResolution(resolution) {
      let offset2 = this.minZoom_ || 0;
      let max, zoomFactor;
      if (this.resolutions_) {
        const nearest = linearFindNearest(this.resolutions_, resolution, 1);
        offset2 = nearest;
        max = this.resolutions_[nearest];
        if (nearest == this.resolutions_.length - 1) {
          zoomFactor = 2;
        } else {
          zoomFactor = max / this.resolutions_[nearest + 1];
        }
      } else {
        max = this.maxResolution_;
        zoomFactor = this.zoomFactor_;
      }
      return offset2 + Math.log(max / resolution) / Math.log(zoomFactor);
    }
    /**
     * Get the resolution for a zoom level.
     * @param {number} zoom Zoom level.
     * @return {number} The view resolution for the provided zoom level.
     * @api
     */
    getResolutionForZoom(zoom) {
      if (this.resolutions_) {
        if (this.resolutions_.length <= 1) {
          return 0;
        }
        const baseLevel = clamp(
          Math.floor(zoom),
          0,
          this.resolutions_.length - 2
        );
        const zoomFactor = this.resolutions_[baseLevel] / this.resolutions_[baseLevel + 1];
        return this.resolutions_[baseLevel] / Math.pow(zoomFactor, clamp(zoom - baseLevel, 0, 1));
      }
      return this.maxResolution_ / Math.pow(this.zoomFactor_, zoom - this.minZoom_);
    }
    /**
     * Fit the given geometry or extent based on the given map size and border.
     * The size is pixel dimensions of the box to fit the extent into.
     * In most cases you will want to use the map size, that is `map.getSize()`.
     * Takes care of the map angle.
     * @param {import("./geom/SimpleGeometry.js").default|import("./extent.js").Extent} geometryOrExtent The geometry or
     *     extent to fit the view to.
     * @param {FitOptions} [options] Options.
     * @api
     */
    fit(geometryOrExtent, options) {
      let geometry;
      assert(
        Array.isArray(geometryOrExtent) || typeof /** @type {?} */
        geometryOrExtent.getSimplifiedGeometry === "function",
        "Invalid extent or geometry provided as `geometry`"
      );
      if (Array.isArray(geometryOrExtent)) {
        assert(
          !isEmpty2(geometryOrExtent),
          "Cannot fit empty extent provided as `geometry`"
        );
        const extent = fromUserExtent(geometryOrExtent, this.getProjection());
        geometry = fromExtent(extent);
      } else if (geometryOrExtent.getType() === "Circle") {
        const extent = fromUserExtent(
          geometryOrExtent.getExtent(),
          this.getProjection()
        );
        geometry = fromExtent(extent);
        geometry.rotate(this.getRotation(), getCenter(extent));
      } else {
        const userProjection2 = getUserProjection();
        if (userProjection2) {
          geometry = /** @type {import("./geom/SimpleGeometry.js").default} */
          geometryOrExtent.clone().transform(userProjection2, this.getProjection());
        } else {
          geometry = geometryOrExtent;
        }
      }
      this.fitInternal(geometry, options);
    }
    /**
     * Calculate rotated extent
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @return {import("./extent").Extent} The rotated extent for the geometry.
     */
    rotatedExtentForGeometry(geometry) {
      const rotation = this.getRotation();
      const cosAngle = Math.cos(rotation);
      const sinAngle = Math.sin(-rotation);
      const coords = geometry.getFlatCoordinates();
      const stride = geometry.getStride();
      let minRotX = Infinity;
      let minRotY = Infinity;
      let maxRotX = -Infinity;
      let maxRotY = -Infinity;
      for (let i4 = 0, ii = coords.length; i4 < ii; i4 += stride) {
        const rotX = coords[i4] * cosAngle - coords[i4 + 1] * sinAngle;
        const rotY = coords[i4] * sinAngle + coords[i4 + 1] * cosAngle;
        minRotX = Math.min(minRotX, rotX);
        minRotY = Math.min(minRotY, rotY);
        maxRotX = Math.max(maxRotX, rotX);
        maxRotY = Math.max(maxRotY, rotY);
      }
      return [minRotX, minRotY, maxRotX, maxRotY];
    }
    /**
     * @param {import("./geom/SimpleGeometry.js").default} geometry The geometry.
     * @param {FitOptions} [options] Options.
     */
    fitInternal(geometry, options) {
      options = options || {};
      let size = options.size;
      if (!size) {
        size = this.getViewportSizeMinusPadding_();
      }
      const padding = options.padding !== void 0 ? options.padding : [0, 0, 0, 0];
      const nearest = options.nearest !== void 0 ? options.nearest : false;
      let minResolution;
      if (options.minResolution !== void 0) {
        minResolution = options.minResolution;
      } else if (options.maxZoom !== void 0) {
        minResolution = this.getResolutionForZoom(options.maxZoom);
      } else {
        minResolution = 0;
      }
      const rotatedExtent = this.rotatedExtentForGeometry(geometry);
      let resolution = this.getResolutionForExtentInternal(rotatedExtent, [
        size[0] - padding[1] - padding[3],
        size[1] - padding[0] - padding[2]
      ]);
      resolution = isNaN(resolution) ? minResolution : Math.max(resolution, minResolution);
      resolution = this.getConstrainedResolution(resolution, nearest ? 0 : 1);
      const rotation = this.getRotation();
      const sinAngle = Math.sin(rotation);
      const cosAngle = Math.cos(rotation);
      const centerRot = getCenter(rotatedExtent);
      centerRot[0] += (padding[1] - padding[3]) / 2 * resolution;
      centerRot[1] += (padding[0] - padding[2]) / 2 * resolution;
      const centerX = centerRot[0] * cosAngle - centerRot[1] * sinAngle;
      const centerY = centerRot[1] * cosAngle + centerRot[0] * sinAngle;
      const center = this.getConstrainedCenter([centerX, centerY], resolution);
      const callback = options.callback ? options.callback : VOID;
      if (options.duration !== void 0) {
        this.animateInternal(
          {
            resolution,
            center,
            duration: options.duration,
            easing: options.easing
          },
          callback
        );
      } else {
        this.targetResolution_ = resolution;
        this.targetCenter_ = center;
        this.applyTargetState_(false, true);
        animationCallback(callback, true);
      }
    }
    /**
     * Center on coordinate and view position.
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     * @api
     */
    centerOn(coordinate, size, position) {
      this.centerOnInternal(
        fromUserCoordinate(coordinate, this.getProjection()),
        size,
        position
      );
    }
    /**
     * @param {import("./coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("./size.js").Size} size Box pixel size.
     * @param {import("./pixel.js").Pixel} position Position on the view to center on.
     */
    centerOnInternal(coordinate, size, position) {
      this.setCenterInternal(
        calculateCenterOn(
          coordinate,
          size,
          position,
          this.getResolution(),
          this.getRotation()
        )
      );
    }
    /**
     * Calculates the shift between map and viewport center.
     * @param {import("./coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {import("./size.js").Size} size Size.
     * @return {Array<number>|undefined} Center shift.
     */
    calculateCenterShift(center, resolution, rotation, size) {
      let centerShift;
      const padding = this.padding_;
      if (padding && center) {
        const reducedSize = this.getViewportSizeMinusPadding_(-rotation);
        const shiftedCenter = calculateCenterOn(
          center,
          size,
          [reducedSize[0] / 2 + padding[3], reducedSize[1] / 2 + padding[0]],
          resolution,
          rotation
        );
        centerShift = [
          center[0] - shiftedCenter[0],
          center[1] - shiftedCenter[1]
        ];
      }
      return centerShift;
    }
    /**
     * @return {boolean} Is defined.
     */
    isDef() {
      return !!this.getCenterInternal() && this.getResolution() !== void 0;
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     * @api
     */
    adjustCenter(deltaCoordinates) {
      const center = toUserCoordinate(this.targetCenter_, this.getProjection());
      this.setCenter([
        center[0] + deltaCoordinates[0],
        center[1] + deltaCoordinates[1]
      ]);
    }
    /**
     * Adds relative coordinates to the center of the view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate} deltaCoordinates Relative value to add.
     */
    adjustCenterInternal(deltaCoordinates) {
      const center = this.targetCenter_;
      this.setCenterInternal([
        center[0] + deltaCoordinates[0],
        center[1] + deltaCoordinates[1]
      ]);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustResolution(ratio, anchor) {
      anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
      this.adjustResolutionInternal(ratio, anchor);
    }
    /**
     * Multiply the view resolution by a ratio, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} ratio The ratio to apply on the view resolution.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    adjustResolutionInternal(ratio, anchor) {
      const isMoving = this.getAnimating() || this.getInteracting();
      const size = this.getViewportSize_(this.getRotation());
      const newResolution = this.constraints_.resolution(
        this.targetResolution_ * ratio,
        0,
        size,
        isMoving
      );
      if (anchor) {
        this.targetCenter_ = this.calculateCenterZoom(newResolution, anchor);
      }
      this.targetResolution_ *= ratio;
      this.applyTargetState_();
    }
    /**
     * Adds a value to the view zoom level, optionally using an anchor. Any resolution
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom level.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    adjustZoom(delta, anchor) {
      this.adjustResolution(Math.pow(this.zoomFactor_, -delta), anchor);
    }
    /**
     * Adds a value to the view rotation, optionally using an anchor. Any rotation
     * constraint will apply.
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     * @api
     */
    adjustRotation(delta, anchor) {
      if (anchor) {
        anchor = fromUserCoordinate(anchor, this.getProjection());
      }
      this.adjustRotationInternal(delta, anchor);
    }
    /**
     * @param {number} delta Relative value to add to the zoom rotation, in radians.
     * @param {import("./coordinate.js").Coordinate} [anchor] The rotation center.
     */
    adjustRotationInternal(delta, anchor) {
      const isMoving = this.getAnimating() || this.getInteracting();
      const newRotation = this.constraints_.rotation(
        this.targetRotation_ + delta,
        isMoving
      );
      if (anchor) {
        this.targetCenter_ = this.calculateCenterRotate(newRotation, anchor);
      }
      this.targetRotation_ += delta;
      this.applyTargetState_();
    }
    /**
     * Set the center of the current view. Any extent constraint will apply.
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     * @observable
     * @api
     */
    setCenter(center) {
      this.setCenterInternal(
        center ? fromUserCoordinate(center, this.getProjection()) : center
      );
    }
    /**
     * Set the center using the view projection (not the user projection).
     * @param {import("./coordinate.js").Coordinate|undefined} center The center of the view.
     */
    setCenterInternal(center) {
      this.targetCenter_ = center;
      this.applyTargetState_();
    }
    /**
     * @param {import("./ViewHint.js").default} hint Hint.
     * @param {number} delta Delta.
     * @return {number} New value.
     */
    setHint(hint, delta) {
      this.hints_[hint] += delta;
      this.changed();
      return this.hints_[hint];
    }
    /**
     * Set the resolution for this view. Any resolution constraint will apply.
     * @param {number|undefined} resolution The resolution of the view.
     * @observable
     * @api
     */
    setResolution(resolution) {
      this.targetResolution_ = resolution;
      this.applyTargetState_();
    }
    /**
     * Set the rotation for this view. Any rotation constraint will apply.
     * @param {number} rotation The rotation of the view in radians.
     * @observable
     * @api
     */
    setRotation(rotation) {
      this.targetRotation_ = rotation;
      this.applyTargetState_();
    }
    /**
     * Zoom to a specific zoom level. Any resolution constrain will apply.
     * @param {number} zoom Zoom level.
     * @api
     */
    setZoom(zoom) {
      this.setResolution(this.getResolutionForZoom(zoom));
    }
    /**
     * Recompute rotation/resolution/center based on target values.
     * Note: we have to compute rotation first, then resolution and center considering that
     * parameters can influence one another in case a view extent constraint is present.
     * @param {boolean} [doNotCancelAnims] Do not cancel animations.
     * @param {boolean} [forceMoving] Apply constraints as if the view is moving.
     * @private
     */
    applyTargetState_(doNotCancelAnims, forceMoving) {
      const isMoving = this.getAnimating() || this.getInteracting() || forceMoving;
      const newRotation = this.constraints_.rotation(
        this.targetRotation_,
        isMoving
      );
      const size = this.getViewportSize_(newRotation);
      const newResolution = this.constraints_.resolution(
        this.targetResolution_,
        0,
        size,
        isMoving
      );
      const newCenter = this.constraints_.center(
        this.targetCenter_,
        newResolution,
        size,
        isMoving,
        this.calculateCenterShift(
          this.targetCenter_,
          newResolution,
          newRotation,
          size
        )
      );
      if (this.get(ViewProperty_default.ROTATION) !== newRotation) {
        this.set(ViewProperty_default.ROTATION, newRotation);
      }
      if (this.get(ViewProperty_default.RESOLUTION) !== newResolution) {
        this.set(ViewProperty_default.RESOLUTION, newResolution);
        this.set("zoom", this.getZoom(), true);
      }
      if (!newCenter || !this.get(ViewProperty_default.CENTER) || !equals3(this.get(ViewProperty_default.CENTER), newCenter)) {
        this.set(ViewProperty_default.CENTER, newCenter);
      }
      if (this.getAnimating() && !doNotCancelAnims) {
        this.cancelAnimations();
      }
      this.cancelAnchor_ = void 0;
    }
    /**
     * If any constraints need to be applied, an animation will be triggered.
     * This is typically done on interaction end.
     * Note: calling this with a duration of 0 will apply the constrained values straight away,
     * without animation.
     * @param {number} [duration] The animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    resolveConstraints(duration, resolutionDirection, anchor) {
      duration = duration !== void 0 ? duration : 200;
      const direction = resolutionDirection || 0;
      const newRotation = this.constraints_.rotation(this.targetRotation_);
      const size = this.getViewportSize_(newRotation);
      const newResolution = this.constraints_.resolution(
        this.targetResolution_,
        direction,
        size
      );
      const newCenter = this.constraints_.center(
        this.targetCenter_,
        newResolution,
        size,
        false,
        this.calculateCenterShift(
          this.targetCenter_,
          newResolution,
          newRotation,
          size
        )
      );
      if (duration === 0 && !this.cancelAnchor_) {
        this.targetResolution_ = newResolution;
        this.targetRotation_ = newRotation;
        this.targetCenter_ = newCenter;
        this.applyTargetState_();
        return;
      }
      anchor = anchor || (duration === 0 ? this.cancelAnchor_ : void 0);
      this.cancelAnchor_ = void 0;
      if (this.getResolution() !== newResolution || this.getRotation() !== newRotation || !this.getCenterInternal() || !equals3(this.getCenterInternal(), newCenter)) {
        if (this.getAnimating()) {
          this.cancelAnimations();
        }
        this.animateInternal({
          rotation: newRotation,
          center: newCenter,
          resolution: newResolution,
          duration,
          easing: easeOut,
          anchor
        });
      }
    }
    /**
     * Notify the View that an interaction has started.
     * The view state will be resolved to a stable one if needed
     * (depending on its constraints).
     * @api
     */
    beginInteraction() {
      this.resolveConstraints(0);
      this.setHint(ViewHint_default.INTERACTING, 1);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     * @api
     */
    endInteraction(duration, resolutionDirection, anchor) {
      anchor = anchor && fromUserCoordinate(anchor, this.getProjection());
      this.endInteractionInternal(duration, resolutionDirection, anchor);
    }
    /**
     * Notify the View that an interaction has ended. The view state will be resolved
     * to a stable one if needed (depending on its constraints).
     * @param {number} [duration] Animation duration in ms.
     * @param {number} [resolutionDirection] Which direction to zoom.
     * @param {import("./coordinate.js").Coordinate} [anchor] The origin of the transformation.
     */
    endInteractionInternal(duration, resolutionDirection, anchor) {
      if (!this.getInteracting()) {
        return;
      }
      this.setHint(ViewHint_default.INTERACTING, -1);
      this.resolveConstraints(duration, resolutionDirection, anchor);
    }
    /**
     * Get a valid position for the view center according to the current constraints.
     * @param {import("./coordinate.js").Coordinate|undefined} targetCenter Target center position.
     * @param {number} [targetResolution] Target resolution. If not supplied, the current one will be used.
     * This is useful to guess a valid center position at a different zoom level.
     * @return {import("./coordinate.js").Coordinate|undefined} Valid center position.
     */
    getConstrainedCenter(targetCenter, targetResolution) {
      const size = this.getViewportSize_(this.getRotation());
      return this.constraints_.center(
        targetCenter,
        targetResolution || this.getResolution(),
        size
      );
    }
    /**
     * Get a valid zoom level according to the current view constraints.
     * @param {number|undefined} targetZoom Target zoom.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid zoom level.
     */
    getConstrainedZoom(targetZoom, direction) {
      const targetRes = this.getResolutionForZoom(targetZoom);
      return this.getZoomForResolution(
        this.getConstrainedResolution(targetRes, direction)
      );
    }
    /**
     * Get a valid resolution according to the current view constraints.
     * @param {number|undefined} targetResolution Target resolution.
     * @param {number} [direction=0] Indicate which resolution should be used
     * by a renderer if the view resolution does not match any resolution of the tile source.
     * If 0, the nearest resolution will be used. If 1, the nearest lower resolution
     * will be used. If -1, the nearest higher resolution will be used.
     * @return {number|undefined} Valid resolution.
     */
    getConstrainedResolution(targetResolution, direction) {
      direction = direction || 0;
      const size = this.getViewportSize_(this.getRotation());
      return this.constraints_.resolution(targetResolution, direction, size);
    }
  };
  function animationCallback(callback, returnValue) {
    setTimeout(function() {
      callback(returnValue);
    }, 0);
  }
  function createCenterConstraint(options) {
    if (options.extent !== void 0) {
      const smooth = options.smoothExtentConstraint !== void 0 ? options.smoothExtentConstraint : true;
      return createExtent(options.extent, options.constrainOnlyCenter, smooth);
    }
    const projection = createProjection(options.projection, "EPSG:3857");
    if (options.multiWorld !== true && projection.isGlobal()) {
      const extent = projection.getExtent().slice();
      extent[0] = -Infinity;
      extent[2] = Infinity;
      return createExtent(extent, false, false);
    }
    return none;
  }
  function createResolutionConstraint(options) {
    let resolutionConstraint;
    let maxResolution;
    let minResolution;
    const defaultMaxZoom = 28;
    const defaultZoomFactor = 2;
    let minZoom = options.minZoom !== void 0 ? options.minZoom : DEFAULT_MIN_ZOOM;
    let maxZoom = options.maxZoom !== void 0 ? options.maxZoom : defaultMaxZoom;
    const zoomFactor = options.zoomFactor !== void 0 ? options.zoomFactor : defaultZoomFactor;
    const multiWorld = options.multiWorld !== void 0 ? options.multiWorld : false;
    const smooth = options.smoothResolutionConstraint !== void 0 ? options.smoothResolutionConstraint : true;
    const showFullExtent = options.showFullExtent !== void 0 ? options.showFullExtent : false;
    const projection = createProjection(options.projection, "EPSG:3857");
    const projExtent = projection.getExtent();
    let constrainOnlyCenter = options.constrainOnlyCenter;
    let extent = options.extent;
    if (!multiWorld && !extent && projection.isGlobal()) {
      constrainOnlyCenter = false;
      extent = projExtent;
    }
    if (options.resolutions !== void 0) {
      const resolutions = options.resolutions;
      maxResolution = resolutions[minZoom];
      minResolution = resolutions[maxZoom] !== void 0 ? resolutions[maxZoom] : resolutions[resolutions.length - 1];
      if (options.constrainResolution) {
        resolutionConstraint = createSnapToResolutions(
          resolutions,
          smooth,
          !constrainOnlyCenter && extent,
          showFullExtent
        );
      } else {
        resolutionConstraint = createMinMaxResolution(
          maxResolution,
          minResolution,
          smooth,
          !constrainOnlyCenter && extent,
          showFullExtent
        );
      }
    } else {
      const size = !projExtent ? (
        // use an extent that can fit the whole world if need be
        360 * METERS_PER_UNIT.degrees / projection.getMetersPerUnit()
      ) : Math.max(getWidth(projExtent), getHeight(projExtent));
      const defaultMaxResolution = size / DEFAULT_TILE_SIZE / Math.pow(defaultZoomFactor, DEFAULT_MIN_ZOOM);
      const defaultMinResolution = defaultMaxResolution / Math.pow(defaultZoomFactor, defaultMaxZoom - DEFAULT_MIN_ZOOM);
      maxResolution = options.maxResolution;
      if (maxResolution !== void 0) {
        minZoom = 0;
      } else {
        maxResolution = defaultMaxResolution / Math.pow(zoomFactor, minZoom);
      }
      minResolution = options.minResolution;
      if (minResolution === void 0) {
        if (options.maxZoom !== void 0) {
          if (options.maxResolution !== void 0) {
            minResolution = maxResolution / Math.pow(zoomFactor, maxZoom);
          } else {
            minResolution = defaultMaxResolution / Math.pow(zoomFactor, maxZoom);
          }
        } else {
          minResolution = defaultMinResolution;
        }
      }
      maxZoom = minZoom + Math.floor(
        Math.log(maxResolution / minResolution) / Math.log(zoomFactor)
      );
      minResolution = maxResolution / Math.pow(zoomFactor, maxZoom - minZoom);
      if (options.constrainResolution) {
        resolutionConstraint = createSnapToPower(
          zoomFactor,
          maxResolution,
          minResolution,
          smooth,
          !constrainOnlyCenter && extent,
          showFullExtent
        );
      } else {
        resolutionConstraint = createMinMaxResolution(
          maxResolution,
          minResolution,
          smooth,
          !constrainOnlyCenter && extent,
          showFullExtent
        );
      }
    }
    return {
      constraint: resolutionConstraint,
      maxResolution,
      minResolution,
      minZoom,
      zoomFactor
    };
  }
  function createRotationConstraint(options) {
    const enableRotation = options.enableRotation !== void 0 ? options.enableRotation : true;
    if (enableRotation) {
      const constrainRotation = options.constrainRotation;
      if (constrainRotation === void 0 || constrainRotation === true) {
        return createSnapToZero();
      }
      if (constrainRotation === false) {
        return none2;
      }
      if (typeof constrainRotation === "number") {
        return createSnapToN(constrainRotation);
      }
      return none2;
    }
    return disable;
  }
  function isNoopAnimation(animation) {
    if (animation.sourceCenter && animation.targetCenter) {
      if (!equals3(animation.sourceCenter, animation.targetCenter)) {
        return false;
      }
    }
    if (animation.sourceResolution !== animation.targetResolution) {
      return false;
    }
    if (animation.sourceRotation !== animation.targetRotation) {
      return false;
    }
    return true;
  }
  function calculateCenterOn(coordinate, size, position, resolution, rotation) {
    const cosAngle = Math.cos(-rotation);
    let sinAngle = Math.sin(-rotation);
    let rotX = coordinate[0] * cosAngle - coordinate[1] * sinAngle;
    let rotY = coordinate[1] * cosAngle + coordinate[0] * sinAngle;
    rotX += (size[0] / 2 - position[0]) * resolution;
    rotY += (position[1] - size[1] / 2) * resolution;
    sinAngle = -sinAngle;
    const centerX = rotX * cosAngle - rotY * sinAngle;
    const centerY = rotY * cosAngle + rotX * sinAngle;
    return [centerX, centerY];
  }
  var View_default = View;

  // node_modules/ol/layer/Layer.js
  var Layer = class extends Base_default {
    /**
     * @param {Options<SourceType>} options Layer options.
     */
    constructor(options) {
      const baseOptions = Object.assign({}, options);
      delete baseOptions.source;
      super(baseOptions);
      this.on;
      this.once;
      this.un;
      this.mapPrecomposeKey_ = null;
      this.mapRenderKey_ = null;
      this.sourceChangeKey_ = null;
      this.renderer_ = null;
      this.sourceReady_ = false;
      this.rendered = false;
      if (options.render) {
        this.render = options.render;
      }
      if (options.map) {
        this.setMap(options.map);
      }
      this.addChangeListener(
        Property_default.SOURCE,
        this.handleSourcePropertyChange_
      );
      const source = options.source ? (
        /** @type {SourceType} */
        options.source
      ) : null;
      this.setSource(source);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(array) {
      array = array ? array : [];
      array.push(this);
      return array;
    }
    /**
     * @param {Array<import("./Layer.js").State>} [states] Optional list of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(states) {
      states = states ? states : [];
      states.push(this.getLayerState());
      return states;
    }
    /**
     * Get the layer source.
     * @return {SourceType|null} The layer source (or `null` if not yet set).
     * @observable
     * @api
     */
    getSource() {
      return (
        /** @type {SourceType} */
        this.get(Property_default.SOURCE) || null
      );
    }
    /**
     * @return {SourceType|null} The source being rendered.
     */
    getRenderSource() {
      return this.getSource();
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      const source = this.getSource();
      return !source ? "undefined" : source.getState();
    }
    /**
     * @private
     */
    handleSourceChange_() {
      this.changed();
      if (this.sourceReady_ || this.getSource().getState() !== "ready") {
        return;
      }
      this.sourceReady_ = true;
      this.dispatchEvent("sourceready");
    }
    /**
     * @private
     */
    handleSourcePropertyChange_() {
      if (this.sourceChangeKey_) {
        unlistenByKey(this.sourceChangeKey_);
        this.sourceChangeKey_ = null;
      }
      this.sourceReady_ = false;
      const source = this.getSource();
      if (source) {
        this.sourceChangeKey_ = listen(
          source,
          EventType_default.CHANGE,
          this.handleSourceChange_,
          this
        );
        if (source.getState() === "ready") {
          this.sourceReady_ = true;
          setTimeout(() => {
            this.dispatchEvent("sourceready");
          }, 0);
        }
      }
      this.changed();
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(pixel) {
      if (!this.renderer_) {
        return Promise.resolve([]);
      }
      return this.renderer_.getFeatures(pixel);
    }
    /**
     * @param {import("../pixel").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(pixel) {
      if (!this.renderer_ || !this.rendered) {
        return null;
      }
      return this.renderer_.getData(pixel);
    }
    /**
     * The layer is visible on the map view, i.e. within its min/max resolution or zoom and
     * extent, not set to `visible: false`, and not inside a layer group that is set
     * to `visible: false`.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {boolean} The layer is visible in the map view.
     * @api
     */
    isVisible(view) {
      let frameState;
      const map2 = this.getMapInternal();
      if (!view && map2) {
        view = map2.getView();
      }
      if (view instanceof View_default) {
        frameState = {
          viewState: view.getState(),
          extent: view.calculateExtent()
        };
      } else {
        frameState = view;
      }
      if (!frameState.layerStatesArray && map2) {
        frameState.layerStatesArray = map2.getLayerGroup().getLayerStatesArray();
      }
      let layerState;
      if (frameState.layerStatesArray) {
        layerState = frameState.layerStatesArray.find(
          (layerState2) => layerState2.layer === this
        );
      } else {
        layerState = this.getLayerState();
      }
      const layerExtent = this.getExtent();
      return inView(layerState, frameState.viewState) && (!layerExtent || intersects(layerExtent, frameState.extent));
    }
    /**
     * Get the attributions of the source of this layer for the given view.
     * @param {View|import("../View.js").ViewStateLayerStateExtent} [view] View or {@link import("../Map.js").FrameState}.
     * Only required when the layer is not added to a map.
     * @return {Array<string>} Attributions for this layer at the given view.
     * @api
     */
    getAttributions(view) {
      if (!this.isVisible(view)) {
        return [];
      }
      let getAttributions;
      const source = this.getSource();
      if (source) {
        getAttributions = source.getAttributions();
      }
      if (!getAttributions) {
        return [];
      }
      const frameState = view instanceof View_default ? view.getViewStateAndExtent() : view;
      let attributions = getAttributions(frameState);
      if (!Array.isArray(attributions)) {
        attributions = [attributions];
      }
      return attributions;
    }
    /**
     * In charge to manage the rendering of the layer. One layer type is
     * bounded with one layer renderer.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement} target Target which the renderer may (but need not) use
     * for rendering its content.
     * @return {HTMLElement|null} The rendered element.
     */
    render(frameState, target) {
      const layerRenderer = this.getRenderer();
      if (layerRenderer.prepareFrame(frameState)) {
        this.rendered = true;
        return layerRenderer.renderFrame(frameState, target);
      }
      return null;
    }
    /**
     * Called when a layer is not visible during a map render.
     */
    unrender() {
      this.rendered = false;
    }
    /**
     * For use inside the library only.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMapInternal(map2) {
      if (!map2) {
        this.unrender();
      }
      this.set(Property_default.MAP, map2);
    }
    /**
     * For use inside the library only.
     * @return {import("../Map.js").default|null} Map.
     */
    getMapInternal() {
      return this.get(Property_default.MAP);
    }
    /**
     * Sets the layer to be rendered on top of other layers on a map. The map will
     * not manage this layer in its layers collection. This
     * is useful for temporary layers. To remove an unmanaged layer from the map,
     * use `#setMap(null)`.
     *
     * To add the layer to a map and have it managed by the map, use
     * {@link module:ol/Map~Map#addLayer} instead.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(map2) {
      if (this.mapPrecomposeKey_) {
        unlistenByKey(this.mapPrecomposeKey_);
        this.mapPrecomposeKey_ = null;
      }
      if (!map2) {
        this.changed();
      }
      if (this.mapRenderKey_) {
        unlistenByKey(this.mapRenderKey_);
        this.mapRenderKey_ = null;
      }
      if (map2) {
        this.mapPrecomposeKey_ = listen(
          map2,
          EventType_default2.PRECOMPOSE,
          function(evt) {
            const renderEvent = (
              /** @type {import("../render/Event.js").default} */
              evt
            );
            const layerStatesArray = renderEvent.frameState.layerStatesArray;
            const layerState = this.getLayerState(false);
            assert(
              !layerStatesArray.some(function(arrayLayerState) {
                return arrayLayerState.layer === layerState.layer;
              }),
              "A layer can only be added to the map once. Use either `layer.setMap()` or `map.addLayer()`, not both."
            );
            layerStatesArray.push(layerState);
          },
          this
        );
        this.mapRenderKey_ = listen(this, EventType_default.CHANGE, map2.render, map2);
        this.changed();
      }
    }
    /**
     * Set the layer source.
     * @param {SourceType|null} source The layer source.
     * @observable
     * @api
     */
    setSource(source) {
      this.set(Property_default.SOURCE, source);
    }
    /**
     * Get the renderer for this layer.
     * @return {RendererType|null} The layer renderer.
     */
    getRenderer() {
      if (!this.renderer_) {
        this.renderer_ = this.createRenderer();
      }
      return this.renderer_;
    }
    /**
     * @return {boolean} The layer has a renderer.
     */
    hasRenderer() {
      return !!this.renderer_;
    }
    /**
     * Create a renderer for this layer.
     * @return {RendererType} A layer renderer.
     * @protected
     */
    createRenderer() {
      return null;
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      if (this.renderer_) {
        this.renderer_.dispose();
        delete this.renderer_;
      }
      this.setSource(null);
      super.disposeInternal();
    }
  };
  function inView(layerState, viewState) {
    if (!layerState.visible) {
      return false;
    }
    const resolution = viewState.resolution;
    if (resolution < layerState.minResolution || resolution >= layerState.maxResolution) {
      return false;
    }
    const zoom = viewState.zoom;
    return zoom > layerState.minZoom && zoom <= layerState.maxZoom;
  }
  var Layer_default = Layer;

  // node_modules/mobility-toolbox-js/common/controls/ControlCommon.js
  var ControlCommon = class extends Object_default {
    /**
     * Constructor
     *
     * @param {Object} [options] Control options.
     * @param {boolean} [options.active = true] Whether the control is active or not.
     * @param {HTMLElement} [options.element] The HTML element used to render the control.
     * @param {HTMLElement} [options.target] The HTML element where to render the element property. Default is the map's element.
     * @param {function} [options.render] Render function called whenever the control needs to be rerendered.
     */
    constructor(options = {}) {
      super(options);
      this.defineProperties(options);
      const { active } = Object.assign({ active: options.active !== false }, options);
      this.active = active;
    }
    /**
     * Define control's properties.
     *
     * @private
     * @ignore
     */
    defineProperties(options) {
      const { target, element, render } = Object.assign({}, options);
      Object.defineProperties(this, {
        active: {
          get: () => this.get("active"),
          set: (newActive) => {
            this.set("active", newActive);
            if (newActive) {
              this.activate();
            } else {
              this.deactivate();
            }
            this.render();
          }
        },
        map: {
          get: () => this.get("map"),
          set: (map2) => {
            if (this.map && this.element && this.element.parentNode) {
              this.element.parentNode.removeChild(this.element);
            }
            this.deactivate();
            this.set("map", map2);
            if (this.map) {
              const targett = this.target || this.map.getTargetElement && this.map.getTargetElement() || this.map.getContainer && this.map.getContainer();
              if (!this.element) {
                this.createDefaultElement();
              }
              if (this.element) {
                targett.appendChild(this.element);
              }
              if (this.active) {
                this.activate();
              }
            }
            this.render();
          }
        },
        target: {
          value: target
        },
        element: {
          value: element,
          writable: true
        },
        render: {
          /** @ignore */
          value: render || this.render,
          writable: true
        }
      });
    }
    /**
     * Attach the control to the map. Add events, html element ...
     */
    attachToMap(map2) {
      this.map = map2;
    }
    /**
     * Detach the control From the map. Remove events, html element ..
     */
    detachFromMap() {
      this.map = void 0;
    }
    /**
     * Add listeners then renders the control.
     * To be defined in inherited classes.
     */
    activate() {
      this.deactivate();
    }
    /**
     * Remove listeners added by activate() function then renders the control.
     * To be defined in inherited classes.
     */
    // eslint-disable-next-line class-methods-use-this
    deactivate() {
      console.error("The function deactivate() must be implemented in subclasses");
    }
    /**
     * The default render function. It renders content in the HTML element.
     * To be defined in inherited classes.
     *
     * @private
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    render(options) {
      console.error("The function render() must be implemented in subclasses");
    }
    /**
     * The default element to display if this.element is not defined.
     * To be defined in inherited classes.
     *
     * @private
     */
    // eslint-disable-next-line class-methods-use-this
    createDefaultElement() {
      console.error("The function createDefaultElement() must be implemented in subclasses");
    }
  };
  var ControlCommon_default = ControlCommon;

  // node_modules/mobility-toolbox-js/common/controls/CopyrightControlCommon.js
  var CopyrightControlCommon = class extends ControlCommon_default {
    render() {
      if (!this.element) {
        return;
      }
      this.element.innerHTML = this.active ? this.getCopyrights().join(" | ") : "";
    }
    createDefaultElement() {
      this.element = document.createElement("div");
      this.element.id = "mbt-copyright";
      Object.assign(this.element.style, {
        position: "absolute",
        bottom: 0,
        right: 0,
        fontSize: ".8rem",
        padding: "0 10px"
      });
    }
    getCopyrights() {
      console.error("The getCopyrights() function must be implemented in subclasses.", this);
      return [];
    }
  };
  var CopyrightControlCommon_default = CopyrightControlCommon;

  // node_modules/mobility-toolbox-js/ol/controls/CopyrightControl.js
  var CopyrightControl = class extends CopyrightControlCommon_default {
    constructor(options) {
      super(options);
      this.onPostRender = this.onPostRender.bind(this);
    }
    getCopyrights() {
      var _a;
      if (!this.frameState) {
        return [];
      }
      let copyrights = [];
      (_a = this.frameState) === null || _a === void 0 ? void 0 : _a.layerStatesArray.forEach((layerState) => {
        const { layer } = layerState;
        if (this.frameState && inView(layerState, this.frameState.viewState) && layer && layer.getSource && layer.getSource() && layer.getSource().getAttributions()) {
          copyrights = copyrights.concat(layer.getSource().getAttributions()(this.frameState));
        }
      });
      return removeDuplicate_default(copyrights);
    }
    activate() {
      super.activate();
      if (this.map) {
        this.map.on("postrender", this.onPostRender);
      }
    }
    deactivate() {
      if (this.map) {
        this.map.un("postrender", this.onPostRender);
      }
    }
    onPostRender(evt) {
      if (this.map && this.element) {
        this.frameState = evt.frameState || void 0;
        this.render();
      }
    }
  };
  var CopyrightControl_default = CopyrightControl;

  // node_modules/ol/CollectionEventType.js
  var CollectionEventType_default = {
    /**
     * Triggered when an item is added to the collection.
     * @event module:ol/Collection.CollectionEvent#add
     * @api
     */
    ADD: "add",
    /**
     * Triggered when an item is removed from the collection.
     * @event module:ol/Collection.CollectionEvent#remove
     * @api
     */
    REMOVE: "remove"
  };

  // node_modules/ol/Collection.js
  var Property = {
    LENGTH: "length"
  };
  var CollectionEvent = class extends Event_default {
    /**
     * @param {import("./CollectionEventType.js").default} type Type.
     * @param {T} element Element.
     * @param {number} index The index of the added or removed element.
     */
    constructor(type, element, index) {
      super(type);
      this.element = element;
      this.index = index;
    }
  };
  var Collection = class extends Object_default {
    /**
     * @param {Array<T>} [array] Array.
     * @param {Options} [options] Collection options.
     */
    constructor(array, options) {
      super();
      this.on;
      this.once;
      this.un;
      options = options || {};
      this.unique_ = !!options.unique;
      this.array_ = array ? array : [];
      if (this.unique_) {
        for (let i4 = 0, ii = this.array_.length; i4 < ii; ++i4) {
          this.assertUnique_(this.array_[i4], i4);
        }
      }
      this.updateLength_();
    }
    /**
     * Remove all elements from the collection.
     * @api
     */
    clear() {
      while (this.getLength() > 0) {
        this.pop();
      }
    }
    /**
     * Add elements to the collection.  This pushes each item in the provided array
     * to the end of the collection.
     * @param {!Array<T>} arr Array.
     * @return {Collection<T>} This collection.
     * @api
     */
    extend(arr) {
      for (let i4 = 0, ii = arr.length; i4 < ii; ++i4) {
        this.push(arr[i4]);
      }
      return this;
    }
    /**
     * Iterate over each element, calling the provided callback.
     * @param {function(T, number, Array<T>): *} f The function to call
     *     for every element. This function takes 3 arguments (the element, the
     *     index and the array). The return value is ignored.
     * @api
     */
    forEach(f3) {
      const array = this.array_;
      for (let i4 = 0, ii = array.length; i4 < ii; ++i4) {
        f3(array[i4], i4, array);
      }
    }
    /**
     * Get a reference to the underlying Array object. Warning: if the array
     * is mutated, no events will be dispatched by the collection, and the
     * collection's "length" property won't be in sync with the actual length
     * of the array.
     * @return {!Array<T>} Array.
     * @api
     */
    getArray() {
      return this.array_;
    }
    /**
     * Get the element at the provided index.
     * @param {number} index Index.
     * @return {T} Element.
     * @api
     */
    item(index) {
      return this.array_[index];
    }
    /**
     * Get the length of this collection.
     * @return {number} The length of the array.
     * @observable
     * @api
     */
    getLength() {
      return this.get(Property.LENGTH);
    }
    /**
     * Insert an element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    insertAt(index, elem) {
      if (index < 0 || index > this.getLength()) {
        throw new Error("Index out of bounds: " + index);
      }
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      this.array_.splice(index, 0, elem);
      this.updateLength_();
      this.dispatchEvent(
        new CollectionEvent(CollectionEventType_default.ADD, elem, index)
      );
    }
    /**
     * Remove the last element of the collection and return it.
     * Return `undefined` if the collection is empty.
     * @return {T|undefined} Element.
     * @api
     */
    pop() {
      return this.removeAt(this.getLength() - 1);
    }
    /**
     * Insert the provided element at the end of the collection.
     * @param {T} elem Element.
     * @return {number} New length of the collection.
     * @api
     */
    push(elem) {
      if (this.unique_) {
        this.assertUnique_(elem);
      }
      const n2 = this.getLength();
      this.insertAt(n2, elem);
      return this.getLength();
    }
    /**
     * Remove the first occurrence of an element from the collection.
     * @param {T} elem Element.
     * @return {T|undefined} The removed element or undefined if none found.
     * @api
     */
    remove(elem) {
      const arr = this.array_;
      for (let i4 = 0, ii = arr.length; i4 < ii; ++i4) {
        if (arr[i4] === elem) {
          return this.removeAt(i4);
        }
      }
      return void 0;
    }
    /**
     * Remove the element at the provided index and return it.
     * Return `undefined` if the collection does not contain this index.
     * @param {number} index Index.
     * @return {T|undefined} Value.
     * @api
     */
    removeAt(index) {
      if (index < 0 || index >= this.getLength()) {
        return void 0;
      }
      const prev = this.array_[index];
      this.array_.splice(index, 1);
      this.updateLength_();
      this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
      );
      return prev;
    }
    /**
     * Set the element at the provided index.
     * @param {number} index Index.
     * @param {T} elem Element.
     * @api
     */
    setAt(index, elem) {
      const n2 = this.getLength();
      if (index >= n2) {
        this.insertAt(index, elem);
        return;
      }
      if (index < 0) {
        throw new Error("Index out of bounds: " + index);
      }
      if (this.unique_) {
        this.assertUnique_(elem, index);
      }
      const prev = this.array_[index];
      this.array_[index] = elem;
      this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType_default.REMOVE, prev, index)
      );
      this.dispatchEvent(
        /** @type {CollectionEvent<T>} */
        new CollectionEvent(CollectionEventType_default.ADD, elem, index)
      );
    }
    /**
     * @private
     */
    updateLength_() {
      this.set(Property.LENGTH, this.array_.length);
    }
    /**
     * @private
     * @param {T} elem Element.
     * @param {number} [except] Optional index to ignore.
     */
    assertUnique_(elem, except) {
      for (let i4 = 0, ii = this.array_.length; i4 < ii; ++i4) {
        if (this.array_[i4] === elem && i4 !== except) {
          throw new Error("Duplicate item added to a unique collection");
        }
      }
    }
  };
  var Collection_default = Collection;

  // node_modules/ol/Feature.js
  var Feature = class _Feature extends Object_default {
    /**
     * @param {Geometry|ObjectWithGeometry<Geometry>} [geometryOrProperties]
     *     You may pass a Geometry object directly, or an object literal containing
     *     properties. If you pass an object literal, you may include a Geometry
     *     associated with a `geometry` key.
     */
    constructor(geometryOrProperties) {
      super();
      this.on;
      this.once;
      this.un;
      this.id_ = void 0;
      this.geometryName_ = "geometry";
      this.style_ = null;
      this.styleFunction_ = void 0;
      this.geometryChangeKey_ = null;
      this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
      if (geometryOrProperties) {
        if (typeof /** @type {?} */
        geometryOrProperties.getSimplifiedGeometry === "function") {
          const geometry = (
            /** @type {Geometry} */
            geometryOrProperties
          );
          this.setGeometry(geometry);
        } else {
          const properties = geometryOrProperties;
          this.setProperties(properties);
        }
      }
    }
    /**
     * Clone this feature. If the original feature has a geometry it
     * is also cloned. The feature id is not set in the clone.
     * @return {Feature<Geometry>} The clone.
     * @api
     */
    clone() {
      const clone2 = (
        /** @type {Feature<Geometry>} */
        new _Feature(this.hasProperties() ? this.getProperties() : null)
      );
      clone2.setGeometryName(this.getGeometryName());
      const geometry = this.getGeometry();
      if (geometry) {
        clone2.setGeometry(
          /** @type {Geometry} */
          geometry.clone()
        );
      }
      const style = this.getStyle();
      if (style) {
        clone2.setStyle(style);
      }
      return clone2;
    }
    /**
     * Get the feature's default geometry.  A feature may have any number of named
     * geometries.  The "default" geometry (the one that is rendered by default) is
     * set when calling {@link module:ol/Feature~Feature#setGeometry}.
     * @return {Geometry|undefined} The default geometry for the feature.
     * @api
     * @observable
     */
    getGeometry() {
      return (
        /** @type {Geometry|undefined} */
        this.get(this.geometryName_)
      );
    }
    /**
     * Get the feature identifier.  This is a stable identifier for the feature and
     * is either set when reading data from a remote source or set explicitly by
     * calling {@link module:ol/Feature~Feature#setId}.
     * @return {number|string|undefined} Id.
     * @api
     */
    getId() {
      return this.id_;
    }
    /**
     * Get the name of the feature's default geometry.  By default, the default
     * geometry is named `geometry`.
     * @return {string} Get the property name associated with the default geometry
     *     for this feature.
     * @api
     */
    getGeometryName() {
      return this.geometryName_;
    }
    /**
     * Get the feature's style. Will return what was provided to the
     * {@link module:ol/Feature~Feature#setStyle} method.
     * @return {import("./style/Style.js").StyleLike|undefined} The feature style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the feature's style function.
     * @return {import("./style/Style.js").StyleFunction|undefined} Return a function
     * representing the current style of this feature.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @private
     */
    handleGeometryChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleGeometryChanged_() {
      if (this.geometryChangeKey_) {
        unlistenByKey(this.geometryChangeKey_);
        this.geometryChangeKey_ = null;
      }
      const geometry = this.getGeometry();
      if (geometry) {
        this.geometryChangeKey_ = listen(
          geometry,
          EventType_default.CHANGE,
          this.handleGeometryChange_,
          this
        );
      }
      this.changed();
    }
    /**
     * Set the default geometry for the feature.  This will update the property
     * with the name returned by {@link module:ol/Feature~Feature#getGeometryName}.
     * @param {Geometry|undefined} geometry The new geometry.
     * @api
     * @observable
     */
    setGeometry(geometry) {
      this.set(this.geometryName_, geometry);
    }
    /**
     * Set the style for the feature to override the layer style.  This can be a
     * single style object, an array of styles, or a function that takes a
     * resolution and returns an array of styles. To unset the feature style, call
     * `setStyle()` without arguments or a falsey value.
     * @param {import("./style/Style.js").StyleLike} [style] Style for this feature.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setStyle(style) {
      this.style_ = style;
      this.styleFunction_ = !style ? void 0 : createStyleFunction(style);
      this.changed();
    }
    /**
     * Set the feature id.  The feature id is considered stable and may be used when
     * requesting features or comparing identifiers returned from a remote source.
     * The feature id can be used with the
     * {@link module:ol/source/Vector~VectorSource#getFeatureById} method.
     * @param {number|string|undefined} id The feature id.
     * @api
     * @fires module:ol/events/Event~BaseEvent#event:change
     */
    setId(id) {
      this.id_ = id;
      this.changed();
    }
    /**
     * Set the property name to be used when getting the feature's default geometry.
     * When calling {@link module:ol/Feature~Feature#getGeometry}, the value of the property with
     * this name will be returned.
     * @param {string} name The property name of the default geometry.
     * @api
     */
    setGeometryName(name) {
      this.removeChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.geometryName_ = name;
      this.addChangeListener(this.geometryName_, this.handleGeometryChanged_);
      this.handleGeometryChanged_();
    }
  };
  function createStyleFunction(obj) {
    if (typeof obj === "function") {
      return obj;
    }
    let styles;
    if (Array.isArray(obj)) {
      styles = obj;
    } else {
      assert(
        typeof /** @type {?} */
        obj.getZIndex === "function",
        "Expected an `ol/style/Style` or an array of `ol/style/Style.js`"
      );
      const style = (
        /** @type {import("./style/Style.js").default} */
        obj
      );
      styles = [style];
    }
    return function() {
      return styles;
    };
  }
  var Feature_default = Feature;

  // node_modules/ol/Geolocation.js
  var Property2 = {
    ACCURACY: "accuracy",
    ACCURACY_GEOMETRY: "accuracyGeometry",
    ALTITUDE: "altitude",
    ALTITUDE_ACCURACY: "altitudeAccuracy",
    HEADING: "heading",
    POSITION: "position",
    PROJECTION: "projection",
    SPEED: "speed",
    TRACKING: "tracking",
    TRACKING_OPTIONS: "trackingOptions"
  };
  var GeolocationErrorType = {
    /**
     * Triggered when a `GeolocationPositionError` occurs.
     * @event module:ol/Geolocation.GeolocationError#error
     * @api
     */
    ERROR: "error"
  };
  var GeolocationError = class extends Event_default {
    /**
     * @param {GeolocationPositionError} error error object.
     */
    constructor(error) {
      super(GeolocationErrorType.ERROR);
      this.code = error.code;
      this.message = error.message;
    }
  };
  var Geolocation = class extends Object_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      options = options || {};
      this.position_ = null;
      this.transform_ = identityTransform;
      this.watchId_ = void 0;
      this.addChangeListener(Property2.PROJECTION, this.handleProjectionChanged_);
      this.addChangeListener(Property2.TRACKING, this.handleTrackingChanged_);
      if (options.projection !== void 0) {
        this.setProjection(options.projection);
      }
      if (options.trackingOptions !== void 0) {
        this.setTrackingOptions(options.trackingOptions);
      }
      this.setTracking(options.tracking !== void 0 ? options.tracking : false);
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      this.setTracking(false);
      super.disposeInternal();
    }
    /**
     * @private
     */
    handleProjectionChanged_() {
      const projection = this.getProjection();
      if (projection) {
        this.transform_ = getTransformFromProjections(
          get3("EPSG:4326"),
          projection
        );
        if (this.position_) {
          this.set(Property2.POSITION, this.transform_(this.position_));
        }
      }
    }
    /**
     * @private
     */
    handleTrackingChanged_() {
      if ("geolocation" in navigator) {
        const tracking = this.getTracking();
        if (tracking && this.watchId_ === void 0) {
          this.watchId_ = navigator.geolocation.watchPosition(
            this.positionChange_.bind(this),
            this.positionError_.bind(this),
            this.getTrackingOptions()
          );
        } else if (!tracking && this.watchId_ !== void 0) {
          navigator.geolocation.clearWatch(this.watchId_);
          this.watchId_ = void 0;
        }
      }
    }
    /**
     * @private
     * @param {GeolocationPosition} position position event.
     */
    positionChange_(position) {
      const coords = position.coords;
      this.set(Property2.ACCURACY, coords.accuracy);
      this.set(
        Property2.ALTITUDE,
        coords.altitude === null ? void 0 : coords.altitude
      );
      this.set(
        Property2.ALTITUDE_ACCURACY,
        coords.altitudeAccuracy === null ? void 0 : coords.altitudeAccuracy
      );
      this.set(
        Property2.HEADING,
        coords.heading === null ? void 0 : toRadians(coords.heading)
      );
      if (!this.position_) {
        this.position_ = [coords.longitude, coords.latitude];
      } else {
        this.position_[0] = coords.longitude;
        this.position_[1] = coords.latitude;
      }
      const projectedPosition = this.transform_(this.position_);
      this.set(Property2.POSITION, projectedPosition.slice());
      this.set(Property2.SPEED, coords.speed === null ? void 0 : coords.speed);
      const geometry = circular(this.position_, coords.accuracy);
      geometry.applyTransform(this.transform_);
      this.set(Property2.ACCURACY_GEOMETRY, geometry);
      this.changed();
    }
    /**
     * @private
     * @param {GeolocationPositionError} error error object.
     */
    positionError_(error) {
      this.dispatchEvent(new GeolocationError(error));
    }
    /**
     * Get the accuracy of the position in meters.
     * @return {number|undefined} The accuracy of the position measurement in
     *     meters.
     * @observable
     * @api
     */
    getAccuracy() {
      return (
        /** @type {number|undefined} */
        this.get(Property2.ACCURACY)
      );
    }
    /**
     * Get a geometry of the position accuracy.
     * @return {?import("./geom/Polygon.js").default} A geometry of the position accuracy.
     * @observable
     * @api
     */
    getAccuracyGeometry() {
      return (
        /** @type {?import("./geom/Polygon.js").default} */
        this.get(Property2.ACCURACY_GEOMETRY) || null
      );
    }
    /**
     * Get the altitude associated with the position.
     * @return {number|undefined} The altitude of the position in meters above mean
     *     sea level.
     * @observable
     * @api
     */
    getAltitude() {
      return (
        /** @type {number|undefined} */
        this.get(Property2.ALTITUDE)
      );
    }
    /**
     * Get the altitude accuracy of the position.
     * @return {number|undefined} The accuracy of the altitude measurement in
     *     meters.
     * @observable
     * @api
     */
    getAltitudeAccuracy() {
      return (
        /** @type {number|undefined} */
        this.get(Property2.ALTITUDE_ACCURACY)
      );
    }
    /**
     * Get the heading as radians clockwise from North.
     * Note: depending on the browser, the heading is only defined if the `enableHighAccuracy`
     * is set to `true` in the tracking options.
     * @return {number|undefined} The heading of the device in radians from north.
     * @observable
     * @api
     */
    getHeading() {
      return (
        /** @type {number|undefined} */
        this.get(Property2.HEADING)
      );
    }
    /**
     * Get the position of the device.
     * @return {import("./coordinate.js").Coordinate|undefined} The current position of the device reported
     *     in the current projection.
     * @observable
     * @api
     */
    getPosition() {
      return (
        /** @type {import("./coordinate.js").Coordinate|undefined} */
        this.get(Property2.POSITION)
      );
    }
    /**
     * Get the projection associated with the position.
     * @return {import("./proj/Projection.js").default|undefined} The projection the position is
     *     reported in.
     * @observable
     * @api
     */
    getProjection() {
      return (
        /** @type {import("./proj/Projection.js").default|undefined} */
        this.get(Property2.PROJECTION)
      );
    }
    /**
     * Get the speed in meters per second.
     * @return {number|undefined} The instantaneous speed of the device in meters
     *     per second.
     * @observable
     * @api
     */
    getSpeed() {
      return (
        /** @type {number|undefined} */
        this.get(Property2.SPEED)
      );
    }
    /**
     * Determine if the device location is being tracked.
     * @return {boolean} The device location is being tracked.
     * @observable
     * @api
     */
    getTracking() {
      return (
        /** @type {boolean} */
        this.get(Property2.TRACKING)
      );
    }
    /**
     * Get the tracking options.
     * See https://www.w3.org/TR/geolocation-API/#position-options.
     * @return {PositionOptions|undefined} PositionOptions as defined by
     *     the [HTML5 Geolocation spec
     *     ](https://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
    getTrackingOptions() {
      return (
        /** @type {PositionOptions|undefined} */
        this.get(Property2.TRACKING_OPTIONS)
      );
    }
    /**
     * Set the projection to use for transforming the coordinates.
     * @param {import("./proj.js").ProjectionLike} projection The projection the position is
     *     reported in.
     * @observable
     * @api
     */
    setProjection(projection) {
      this.set(Property2.PROJECTION, get3(projection));
    }
    /**
     * Enable or disable tracking.
     * @param {boolean} tracking Enable tracking.
     * @observable
     * @api
     */
    setTracking(tracking) {
      this.set(Property2.TRACKING, tracking);
    }
    /**
     * Set the tracking options.
     * See http://www.w3.org/TR/geolocation-API/#position-options.
     * @param {PositionOptions} options PositionOptions as defined by the
     *     [HTML5 Geolocation spec
     *     ](http://www.w3.org/TR/geolocation-API/#position_options_interface).
     * @observable
     * @api
     */
    setTrackingOptions(options) {
      this.set(Property2.TRACKING_OPTIONS, options);
    }
  };
  var Geolocation_default = Geolocation;

  // node_modules/ol/style/Fill.js
  var Fill = class _Fill {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options || {};
      this.color_ = options.color !== void 0 ? options.color : null;
    }
    /**
     * Clones the style. The color is not cloned if it is an {@link module:ol/colorlike~ColorLike}.
     * @return {Fill} The cloned style.
     * @api
     */
    clone() {
      const color = this.getColor();
      return new _Fill({
        color: Array.isArray(color) ? color.slice() : color || void 0
      });
    }
    /**
     * Get the fill color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike|null} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike|null} color Color.
     * @api
     */
    setColor(color) {
      this.color_ = color;
    }
  };
  var Fill_default = Fill;

  // node_modules/ol/style/Stroke.js
  var Stroke = class _Stroke {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options || {};
      this.color_ = options.color !== void 0 ? options.color : null;
      this.lineCap_ = options.lineCap;
      this.lineDash_ = options.lineDash !== void 0 ? options.lineDash : null;
      this.lineDashOffset_ = options.lineDashOffset;
      this.lineJoin_ = options.lineJoin;
      this.miterLimit_ = options.miterLimit;
      this.width_ = options.width;
    }
    /**
     * Clones the style.
     * @return {Stroke} The cloned style.
     * @api
     */
    clone() {
      const color = this.getColor();
      return new _Stroke({
        color: Array.isArray(color) ? color.slice() : color || void 0,
        lineCap: this.getLineCap(),
        lineDash: this.getLineDash() ? this.getLineDash().slice() : void 0,
        lineDashOffset: this.getLineDashOffset(),
        lineJoin: this.getLineJoin(),
        miterLimit: this.getMiterLimit(),
        width: this.getWidth()
      });
    }
    /**
     * Get the stroke color.
     * @return {import("../color.js").Color|import("../colorlike.js").ColorLike} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the line cap type for the stroke.
     * @return {CanvasLineCap|undefined} Line cap.
     * @api
     */
    getLineCap() {
      return this.lineCap_;
    }
    /**
     * Get the line dash style for the stroke.
     * @return {Array<number>|null} Line dash.
     * @api
     */
    getLineDash() {
      return this.lineDash_;
    }
    /**
     * Get the line dash offset for the stroke.
     * @return {number|undefined} Line dash offset.
     * @api
     */
    getLineDashOffset() {
      return this.lineDashOffset_;
    }
    /**
     * Get the line join type for the stroke.
     * @return {CanvasLineJoin|undefined} Line join.
     * @api
     */
    getLineJoin() {
      return this.lineJoin_;
    }
    /**
     * Get the miter limit for the stroke.
     * @return {number|undefined} Miter limit.
     * @api
     */
    getMiterLimit() {
      return this.miterLimit_;
    }
    /**
     * Get the stroke width.
     * @return {number|undefined} Width.
     * @api
     */
    getWidth() {
      return this.width_;
    }
    /**
     * Set the color.
     *
     * @param {import("../color.js").Color|import("../colorlike.js").ColorLike} color Color.
     * @api
     */
    setColor(color) {
      this.color_ = color;
    }
    /**
     * Set the line cap.
     *
     * @param {CanvasLineCap|undefined} lineCap Line cap.
     * @api
     */
    setLineCap(lineCap) {
      this.lineCap_ = lineCap;
    }
    /**
     * Set the line dash.
     *
     * @param {Array<number>|null} lineDash Line dash.
     * @api
     */
    setLineDash(lineDash) {
      this.lineDash_ = lineDash;
    }
    /**
     * Set the line dash offset.
     *
     * @param {number|undefined} lineDashOffset Line dash offset.
     * @api
     */
    setLineDashOffset(lineDashOffset) {
      this.lineDashOffset_ = lineDashOffset;
    }
    /**
     * Set the line join.
     *
     * @param {CanvasLineJoin|undefined} lineJoin Line join.
     * @api
     */
    setLineJoin(lineJoin) {
      this.lineJoin_ = lineJoin;
    }
    /**
     * Set the miter limit.
     *
     * @param {number|undefined} miterLimit Miter limit.
     * @api
     */
    setMiterLimit(miterLimit) {
      this.miterLimit_ = miterLimit;
    }
    /**
     * Set the width.
     *
     * @param {number|undefined} width Width.
     * @api
     */
    setWidth(width) {
      this.width_ = width;
    }
  };
  var Stroke_default = Stroke;

  // node_modules/ol/ImageState.js
  var ImageState_default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    ERROR: 3,
    EMPTY: 4
  };

  // node_modules/ol/size.js
  function hasArea(size) {
    return size[0] > 0 && size[1] > 0;
  }
  function toSize(size, dest) {
    if (Array.isArray(size)) {
      return size;
    }
    if (dest === void 0) {
      dest = [size, size];
    } else {
      dest[0] = size;
      dest[1] = size;
    }
    return dest;
  }

  // node_modules/ol/style/Image.js
  var ImageStyle = class _ImageStyle {
    /**
     * @param {Options} options Options.
     */
    constructor(options) {
      this.opacity_ = options.opacity;
      this.rotateWithView_ = options.rotateWithView;
      this.rotation_ = options.rotation;
      this.scale_ = options.scale;
      this.scaleArray_ = toSize(options.scale);
      this.displacement_ = options.displacement;
      this.declutterMode_ = options.declutterMode;
    }
    /**
     * Clones the style.
     * @return {ImageStyle} The cloned style.
     * @api
     */
    clone() {
      const scale3 = this.getScale();
      return new _ImageStyle({
        opacity: this.getOpacity(),
        scale: Array.isArray(scale3) ? scale3.slice() : scale3,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the symbolizer opacity.
     * @return {number} Opacity.
     * @api
     */
    getOpacity() {
      return this.opacity_;
    }
    /**
     * Determine whether the symbolizer rotates with the map.
     * @return {boolean} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the symoblizer rotation.
     * @return {number} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the symbolizer scale.
     * @return {number|import("../size.js").Size} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the displacement of the shape
     * @return {Array<number>} Shape's center displacement
     * @api
     */
    getDisplacement() {
      return this.displacement_;
    }
    /**
     * Get the declutter mode of the shape
     * @return {"declutter"|"obstacle"|"none"|undefined} Shape's declutter mode
     * @api
     */
    getDeclutterMode() {
      return this.declutterMode_;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @abstract
     * @return {Array<number>} Anchor.
     */
    getAnchor() {
      return abstract();
    }
    /**
     * Get the image element for the symbolizer.
     * @abstract
     * @param {number} pixelRatio Pixel ratio.
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getImage(pixelRatio) {
      return abstract();
    }
    /**
     * @abstract
     * @return {import('../DataTile.js').ImageLike} Image element.
     */
    getHitDetectionImage() {
      return abstract();
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(pixelRatio) {
      return 1;
    }
    /**
     * @abstract
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return abstract();
    }
    /**
     * @abstract
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return abstract();
    }
    /**
     * Get the origin of the symbolizer.
     * @abstract
     * @return {Array<number>} Origin.
     */
    getOrigin() {
      return abstract();
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @abstract
     * @return {import("../size.js").Size} Size.
     */
    getSize() {
      return abstract();
    }
    /**
     * Set the displacement.
     *
     * @param {Array<number>} displacement Displacement.
     * @api
     */
    setDisplacement(displacement) {
      this.displacement_ = displacement;
    }
    /**
     * Set the opacity.
     *
     * @param {number} opacity Opacity.
     * @api
     */
    setOpacity(opacity) {
      this.opacity_ = opacity;
    }
    /**
     * Set whether to rotate the style with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }
    /**
     * Set the rotation.
     *
     * @param {number} rotation Rotation.
     * @api
     */
    setRotation(rotation) {
      this.rotation_ = rotation;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(scale3) {
      this.scale_ = scale3;
      this.scaleArray_ = toSize(scale3);
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(listener) {
      abstract();
    }
    /**
     * Load not yet loaded URI.
     * @abstract
     */
    load() {
      abstract();
    }
    /**
     * @abstract
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(listener) {
      abstract();
    }
  };
  var Image_default = ImageStyle;

  // node_modules/ol/color.js
  var HEX_COLOR_RE_ = /^#([a-f0-9]{3}|[a-f0-9]{4}(?:[a-f0-9]{2}){0,2})$/i;
  var NAMED_COLOR_RE_ = /^([a-z]*)$|^hsla?\(.*\)$/i;
  function asString(color) {
    if (typeof color === "string") {
      return color;
    }
    return toString2(color);
  }
  function fromNamed(color) {
    const el = document.createElement("div");
    el.style.color = color;
    if (el.style.color !== "") {
      document.body.appendChild(el);
      const rgb = getComputedStyle(el).color;
      document.body.removeChild(el);
      return rgb;
    }
    return "";
  }
  var fromString = function() {
    const MAX_CACHE_SIZE = 1024;
    const cache3 = {};
    let cacheSize = 0;
    return (
      /**
       * @param {string} s String.
       * @return {Color} Color.
       */
      function(s4) {
        let color;
        if (cache3.hasOwnProperty(s4)) {
          color = cache3[s4];
        } else {
          if (cacheSize >= MAX_CACHE_SIZE) {
            let i4 = 0;
            for (const key in cache3) {
              if ((i4++ & 3) === 0) {
                delete cache3[key];
                --cacheSize;
              }
            }
          }
          color = fromStringInternal_(s4);
          cache3[s4] = color;
          ++cacheSize;
        }
        return color;
      }
    );
  }();
  function asArray(color) {
    if (Array.isArray(color)) {
      return color;
    }
    return fromString(color);
  }
  function fromStringInternal_(s4) {
    let r4, g3, b3, a4, color;
    if (NAMED_COLOR_RE_.exec(s4)) {
      s4 = fromNamed(s4);
    }
    if (HEX_COLOR_RE_.exec(s4)) {
      const n2 = s4.length - 1;
      let d3;
      if (n2 <= 4) {
        d3 = 1;
      } else {
        d3 = 2;
      }
      const hasAlpha = n2 === 4 || n2 === 8;
      r4 = parseInt(s4.substr(1 + 0 * d3, d3), 16);
      g3 = parseInt(s4.substr(1 + 1 * d3, d3), 16);
      b3 = parseInt(s4.substr(1 + 2 * d3, d3), 16);
      if (hasAlpha) {
        a4 = parseInt(s4.substr(1 + 3 * d3, d3), 16);
      } else {
        a4 = 255;
      }
      if (d3 == 1) {
        r4 = (r4 << 4) + r4;
        g3 = (g3 << 4) + g3;
        b3 = (b3 << 4) + b3;
        if (hasAlpha) {
          a4 = (a4 << 4) + a4;
        }
      }
      color = [r4, g3, b3, a4 / 255];
    } else if (s4.startsWith("rgba(")) {
      color = s4.slice(5, -1).split(",").map(Number);
      normalize(color);
    } else if (s4.startsWith("rgb(")) {
      color = s4.slice(4, -1).split(",").map(Number);
      color.push(1);
      normalize(color);
    } else {
      throw new Error("Invalid color");
    }
    return color;
  }
  function normalize(color) {
    color[0] = clamp(color[0] + 0.5 | 0, 0, 255);
    color[1] = clamp(color[1] + 0.5 | 0, 0, 255);
    color[2] = clamp(color[2] + 0.5 | 0, 0, 255);
    color[3] = clamp(color[3], 0, 1);
    return color;
  }
  function toString2(color) {
    let r4 = color[0];
    if (r4 != (r4 | 0)) {
      r4 = r4 + 0.5 | 0;
    }
    let g3 = color[1];
    if (g3 != (g3 | 0)) {
      g3 = g3 + 0.5 | 0;
    }
    let b3 = color[2];
    if (b3 != (b3 | 0)) {
      b3 = b3 + 0.5 | 0;
    }
    const a4 = color[3] === void 0 ? 1 : Math.round(color[3] * 100) / 100;
    return "rgba(" + r4 + "," + g3 + "," + b3 + "," + a4 + ")";
  }

  // node_modules/ol/colorlike.js
  function asColorLike(color) {
    if (Array.isArray(color)) {
      return toString2(color);
    }
    return color;
  }

  // node_modules/ol/dom.js
  function createCanvasContext2D(width, height, canvasPool2, settings) {
    let canvas;
    if (canvasPool2 && canvasPool2.length) {
      canvas = canvasPool2.shift();
    } else if (WORKER_OFFSCREEN_CANVAS) {
      canvas = new OffscreenCanvas(width || 300, height || 300);
    } else {
      canvas = document.createElement("canvas");
    }
    if (width) {
      canvas.width = width;
    }
    if (height) {
      canvas.height = height;
    }
    return (
      /** @type {CanvasRenderingContext2D} */
      canvas.getContext("2d", settings)
    );
  }
  function releaseCanvas(context) {
    const canvas = context.canvas;
    canvas.width = 1;
    canvas.height = 1;
    context.clearRect(0, 0, 1, 1);
  }
  function replaceNode(newNode, oldNode) {
    const parent = oldNode.parentNode;
    if (parent) {
      parent.replaceChild(newNode, oldNode);
    }
  }
  function removeNode(node) {
    return node && node.parentNode ? node.parentNode.removeChild(node) : null;
  }
  function removeChildren(node) {
    while (node.lastChild) {
      node.removeChild(node.lastChild);
    }
  }
  function replaceChildren(node, children) {
    const oldChildren = node.childNodes;
    for (let i4 = 0; true; ++i4) {
      const oldChild = oldChildren[i4];
      const newChild = children[i4];
      if (!oldChild && !newChild) {
        break;
      }
      if (oldChild === newChild) {
        continue;
      }
      if (!oldChild) {
        node.appendChild(newChild);
        continue;
      }
      if (!newChild) {
        node.removeChild(oldChild);
        --i4;
        continue;
      }
      node.insertBefore(newChild, oldChild);
    }
  }

  // node_modules/ol/css.js
  var CLASS_HIDDEN = "ol-hidden";
  var CLASS_UNSELECTABLE = "ol-unselectable";
  var CLASS_CONTROL = "ol-control";
  var CLASS_COLLAPSED = "ol-collapsed";
  var fontRegEx = new RegExp(
    [
      "^\\s*(?=(?:(?:[-a-z]+\\s*){0,2}(italic|oblique))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(small-caps))?)",
      "(?=(?:(?:[-a-z]+\\s*){0,2}(bold(?:er)?|lighter|[1-9]00 ))?)",
      "(?:(?:normal|\\1|\\2|\\3)\\s*){0,3}((?:xx?-)?",
      "(?:small|large)|medium|smaller|larger|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx]))",
      "(?:\\s*\\/\\s*(normal|[\\.\\d]+(?:\\%|in|[cem]m|ex|p[ctx])?))",
      `?\\s*([-,\\"\\'\\sa-z]+?)\\s*$`
    ].join(""),
    "i"
  );
  var fontRegExMatchIndex = [
    "style",
    "variant",
    "weight",
    "size",
    "lineHeight",
    "family"
  ];
  var getFontParameters = function(fontSpec) {
    const match = fontSpec.match(fontRegEx);
    if (!match) {
      return null;
    }
    const style = (
      /** @type {FontParameters} */
      {
        lineHeight: "normal",
        size: "1.2em",
        style: "normal",
        weight: "normal",
        variant: "normal"
      }
    );
    for (let i4 = 0, ii = fontRegExMatchIndex.length; i4 < ii; ++i4) {
      const value = match[i4 + 1];
      if (value !== void 0) {
        style[fontRegExMatchIndex[i4]] = value;
      }
    }
    style.families = style.family.split(/,\s?/);
    return style;
  };

  // node_modules/ol/render/canvas.js
  var defaultFont = "10px sans-serif";
  var defaultFillStyle = "#000";
  var defaultLineCap = "round";
  var defaultLineDash = [];
  var defaultLineDashOffset = 0;
  var defaultLineJoin = "round";
  var defaultMiterLimit = 10;
  var defaultStrokeStyle = "#000";
  var defaultTextAlign = "center";
  var defaultTextBaseline = "middle";
  var defaultPadding = [0, 0, 0, 0];
  var defaultLineWidth = 1;
  var checkedFonts = new Object_default();
  var measureContext = null;
  var measureFont;
  var textHeights = {};
  var registerFont = function() {
    const retries = 100;
    const size = "32px ";
    const referenceFonts = ["monospace", "serif"];
    const len = referenceFonts.length;
    const text = "wmytzilWMYTZIL@#/&?$%10\uF013";
    let interval, referenceWidth;
    function isAvailable(fontStyle, fontWeight, fontFamily) {
      let available = true;
      for (let i4 = 0; i4 < len; ++i4) {
        const referenceFont = referenceFonts[i4];
        referenceWidth = measureTextWidth(
          fontStyle + " " + fontWeight + " " + size + referenceFont,
          text
        );
        if (fontFamily != referenceFont) {
          const width = measureTextWidth(
            fontStyle + " " + fontWeight + " " + size + fontFamily + "," + referenceFont,
            text
          );
          available = available && width != referenceWidth;
        }
      }
      if (available) {
        return true;
      }
      return false;
    }
    function check() {
      let done = true;
      const fonts = checkedFonts.getKeys();
      for (let i4 = 0, ii = fonts.length; i4 < ii; ++i4) {
        const font = fonts[i4];
        if (checkedFonts.get(font) < retries) {
          if (isAvailable.apply(this, font.split("\n"))) {
            clear(textHeights);
            measureContext = null;
            measureFont = void 0;
            checkedFonts.set(font, retries);
          } else {
            checkedFonts.set(font, checkedFonts.get(font) + 1, true);
            done = false;
          }
        }
      }
      if (done) {
        clearInterval(interval);
        interval = void 0;
      }
    }
    return function(fontSpec) {
      const font = getFontParameters(fontSpec);
      if (!font) {
        return;
      }
      const families = font.families;
      for (let i4 = 0, ii = families.length; i4 < ii; ++i4) {
        const family = families[i4];
        const key = font.style + "\n" + font.weight + "\n" + family;
        if (checkedFonts.get(key) === void 0) {
          checkedFonts.set(key, retries, true);
          if (!isAvailable(font.style, font.weight, family)) {
            checkedFonts.set(key, 0, true);
            if (interval === void 0) {
              interval = setInterval(check, 32);
            }
          }
        }
      }
    };
  }();
  var measureTextHeight = function() {
    let measureElement;
    return function(fontSpec) {
      let height = textHeights[fontSpec];
      if (height == void 0) {
        if (WORKER_OFFSCREEN_CANVAS) {
          const font = getFontParameters(fontSpec);
          const metrics = measureText(fontSpec, "\u017Dg");
          const lineHeight = isNaN(Number(font.lineHeight)) ? 1.2 : Number(font.lineHeight);
          height = lineHeight * (metrics.actualBoundingBoxAscent + metrics.actualBoundingBoxDescent);
        } else {
          if (!measureElement) {
            measureElement = document.createElement("div");
            measureElement.innerHTML = "M";
            measureElement.style.minHeight = "0";
            measureElement.style.maxHeight = "none";
            measureElement.style.height = "auto";
            measureElement.style.padding = "0";
            measureElement.style.border = "none";
            measureElement.style.position = "absolute";
            measureElement.style.display = "block";
            measureElement.style.left = "-99999px";
          }
          measureElement.style.font = fontSpec;
          document.body.appendChild(measureElement);
          height = measureElement.offsetHeight;
          document.body.removeChild(measureElement);
        }
        textHeights[fontSpec] = height;
      }
      return height;
    };
  }();
  function measureText(font, text) {
    if (!measureContext) {
      measureContext = createCanvasContext2D(1, 1);
    }
    if (font != measureFont) {
      measureContext.font = font;
      measureFont = measureContext.font;
    }
    return measureContext.measureText(text);
  }
  function measureTextWidth(font, text) {
    return measureText(font, text).width;
  }
  function measureAndCacheTextWidth(font, text, cache3) {
    if (text in cache3) {
      return cache3[text];
    }
    const width = text.split("\n").reduce((prev, curr) => Math.max(prev, measureTextWidth(font, curr)), 0);
    cache3[text] = width;
    return width;
  }
  function getTextDimensions(baseStyle, chunks) {
    const widths = [];
    const heights = [];
    const lineWidths = [];
    let width = 0;
    let lineWidth = 0;
    let height = 0;
    let lineHeight = 0;
    for (let i4 = 0, ii = chunks.length; i4 <= ii; i4 += 2) {
      const text = chunks[i4];
      if (text === "\n" || i4 === ii) {
        width = Math.max(width, lineWidth);
        lineWidths.push(lineWidth);
        lineWidth = 0;
        height += lineHeight;
        continue;
      }
      const font = chunks[i4 + 1] || baseStyle.font;
      const currentWidth = measureTextWidth(font, text);
      widths.push(currentWidth);
      lineWidth += currentWidth;
      const currentHeight = measureTextHeight(font);
      heights.push(currentHeight);
      lineHeight = Math.max(lineHeight, currentHeight);
    }
    return { width, height, widths, heights, lineWidths };
  }
  function drawImageOrLabel(context, transform2, opacity, labelOrImage, originX, originY, w3, h3, x2, y2, scale3) {
    context.save();
    if (opacity !== 1) {
      context.globalAlpha *= opacity;
    }
    if (transform2) {
      context.transform.apply(context, transform2);
    }
    if (
      /** @type {*} */
      labelOrImage.contextInstructions
    ) {
      context.translate(x2, y2);
      context.scale(scale3[0], scale3[1]);
      executeLabelInstructions(
        /** @type {Label} */
        labelOrImage,
        context
      );
    } else if (scale3[0] < 0 || scale3[1] < 0) {
      context.translate(x2, y2);
      context.scale(scale3[0], scale3[1]);
      context.drawImage(
        /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
        labelOrImage,
        originX,
        originY,
        w3,
        h3,
        0,
        0,
        w3,
        h3
      );
    } else {
      context.drawImage(
        /** @type {HTMLCanvasElement|HTMLImageElement|HTMLVideoElement} */
        labelOrImage,
        originX,
        originY,
        w3,
        h3,
        x2,
        y2,
        w3 * scale3[0],
        h3 * scale3[1]
      );
    }
    context.restore();
  }
  function executeLabelInstructions(label, context) {
    const contextInstructions = label.contextInstructions;
    for (let i4 = 0, ii = contextInstructions.length; i4 < ii; i4 += 2) {
      if (Array.isArray(contextInstructions[i4 + 1])) {
        context[contextInstructions[i4]].apply(
          context,
          contextInstructions[i4 + 1]
        );
      } else {
        context[contextInstructions[i4]] = contextInstructions[i4 + 1];
      }
    }
  }

  // node_modules/ol/style/RegularShape.js
  var RegularShape = class _RegularShape extends Image_default {
    /**
     * @param {Options} options Options.
     */
    constructor(options) {
      const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
      super({
        opacity: 1,
        rotateWithView,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        scale: options.scale !== void 0 ? options.scale : 1,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        declutterMode: options.declutterMode
      });
      this.canvas_ = void 0;
      this.hitDetectionCanvas_ = null;
      this.fill_ = options.fill !== void 0 ? options.fill : null;
      this.origin_ = [0, 0];
      this.points_ = options.points;
      this.radius_ = options.radius !== void 0 ? options.radius : options.radius1;
      this.radius2_ = options.radius2;
      this.angle_ = options.angle !== void 0 ? options.angle : 0;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.size_ = null;
      this.renderOptions_ = null;
      this.render();
    }
    /**
     * Clones the style.
     * @return {RegularShape} The cloned style.
     * @api
     */
    clone() {
      const scale3 = this.getScale();
      const style = new _RegularShape({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        points: this.getPoints(),
        radius: this.getRadius(),
        radius2: this.getRadius2(),
        angle: this.getAngle(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale3) ? scale3.slice() : scale3,
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
    getAnchor() {
      const size = this.size_;
      if (!size) {
        return null;
      }
      const displacement = this.getDisplacement();
      const scale3 = this.getScaleArray();
      return [
        size[0] / 2 - displacement[0] / scale3[0],
        size[1] / 2 + displacement[1] / scale3[1]
      ];
    }
    /**
     * Get the angle used in generating the shape.
     * @return {number} Shape's rotation in radians.
     * @api
     */
    getAngle() {
      return this.angle_;
    }
    /**
     * Get the fill style for the shape.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    setFill(fill) {
      this.fill_ = fill;
      this.render();
    }
    /**
     * @return {HTMLCanvasElement} Image element.
     */
    getHitDetectionImage() {
      if (!this.hitDetectionCanvas_) {
        this.createHitDetectionCanvas_(this.renderOptions_);
      }
      return this.hitDetectionCanvas_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLCanvasElement} Image or Canvas element.
     * @api
     */
    getImage(pixelRatio) {
      let image = this.canvas_[pixelRatio];
      if (!image) {
        const renderOptions = this.renderOptions_;
        const context = createCanvasContext2D(
          renderOptions.size * pixelRatio,
          renderOptions.size * pixelRatio
        );
        this.draw_(renderOptions, context, pixelRatio);
        image = context.canvas;
        this.canvas_[pixelRatio] = image;
      }
      return image;
    }
    /**
     * Get the image pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Pixel ratio.
     */
    getPixelRatio(pixelRatio) {
      return pixelRatio;
    }
    /**
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return this.size_;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return ImageState_default.LOADED;
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
    getOrigin() {
      return this.origin_;
    }
    /**
     * Get the number of points for generating the shape.
     * @return {number} Number of points for stars and regular polygons.
     * @api
     */
    getPoints() {
      return this.points_;
    }
    /**
     * Get the (primary) radius for the shape.
     * @return {number} Radius.
     * @api
     */
    getRadius() {
      return this.radius_;
    }
    /**
     * Get the secondary radius for the shape.
     * @return {number|undefined} Radius2.
     * @api
     */
    getRadius2() {
      return this.radius2_;
    }
    /**
     * Get the size of the symbolizer (in pixels).
     * @return {import("../size.js").Size} Size.
     * @api
     */
    getSize() {
      return this.size_;
    }
    /**
     * Get the stroke style for the shape.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    setStroke(stroke) {
      this.stroke_ = stroke;
      this.render();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(listener) {
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(listener) {
    }
    /**
     * Calculate additional canvas size needed for the miter.
     * @param {string} lineJoin Line join
     * @param {number} strokeWidth Stroke width
     * @param {number} miterLimit Miter limit
     * @return {number} Additional canvas size needed
     * @private
     */
    calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit) {
      if (strokeWidth === 0 || this.points_ === Infinity || lineJoin !== "bevel" && lineJoin !== "miter") {
        return strokeWidth;
      }
      let r1 = this.radius_;
      let r22 = this.radius2_ === void 0 ? r1 : this.radius2_;
      if (r1 < r22) {
        const tmp = r1;
        r1 = r22;
        r22 = tmp;
      }
      const points = this.radius2_ === void 0 ? this.points_ : this.points_ * 2;
      const alpha = 2 * Math.PI / points;
      const a4 = r22 * Math.sin(alpha);
      const b3 = Math.sqrt(r22 * r22 - a4 * a4);
      const d3 = r1 - b3;
      const e3 = Math.sqrt(a4 * a4 + d3 * d3);
      const miterRatio = e3 / a4;
      if (lineJoin === "miter" && miterRatio <= miterLimit) {
        return miterRatio * strokeWidth;
      }
      const k3 = strokeWidth / 2 / miterRatio;
      const l4 = strokeWidth / 2 * (d3 / e3);
      const maxr = Math.sqrt((r1 + k3) * (r1 + k3) + l4 * l4);
      const bevelAdd = maxr - r1;
      if (this.radius2_ === void 0 || lineJoin === "bevel") {
        return bevelAdd * 2;
      }
      const aa = r1 * Math.sin(alpha);
      const bb = Math.sqrt(r1 * r1 - aa * aa);
      const dd = r22 - bb;
      const ee = Math.sqrt(aa * aa + dd * dd);
      const innerMiterRatio = ee / aa;
      if (innerMiterRatio <= miterLimit) {
        const innerLength = innerMiterRatio * strokeWidth / 2 - r22 - r1;
        return 2 * Math.max(bevelAdd, innerLength);
      }
      return bevelAdd * 2;
    }
    /**
     * @return {RenderOptions}  The render options
     * @protected
     */
    createRenderOptions() {
      let lineCap = defaultLineCap;
      let lineJoin = defaultLineJoin;
      let miterLimit = 0;
      let lineDash = null;
      let lineDashOffset = 0;
      let strokeStyle;
      let strokeWidth = 0;
      if (this.stroke_) {
        strokeStyle = this.stroke_.getColor();
        if (strokeStyle === null) {
          strokeStyle = defaultStrokeStyle;
        }
        strokeStyle = asColorLike(strokeStyle);
        strokeWidth = this.stroke_.getWidth();
        if (strokeWidth === void 0) {
          strokeWidth = defaultLineWidth;
        }
        lineDash = this.stroke_.getLineDash();
        lineDashOffset = this.stroke_.getLineDashOffset();
        lineJoin = this.stroke_.getLineJoin();
        if (lineJoin === void 0) {
          lineJoin = defaultLineJoin;
        }
        lineCap = this.stroke_.getLineCap();
        if (lineCap === void 0) {
          lineCap = defaultLineCap;
        }
        miterLimit = this.stroke_.getMiterLimit();
        if (miterLimit === void 0) {
          miterLimit = defaultMiterLimit;
        }
      }
      const add4 = this.calculateLineJoinSize_(lineJoin, strokeWidth, miterLimit);
      const maxRadius = Math.max(this.radius_, this.radius2_ || 0);
      const size = Math.ceil(2 * maxRadius + add4);
      return {
        strokeStyle,
        strokeWidth,
        size,
        lineCap,
        lineDash,
        lineDashOffset,
        lineJoin,
        miterLimit
      };
    }
    /**
     * @protected
     */
    render() {
      this.renderOptions_ = this.createRenderOptions();
      const size = this.renderOptions_.size;
      this.canvas_ = {};
      this.size_ = [size, size];
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The rendering context.
     * @param {number} pixelRatio The pixel ratio.
     */
    draw_(renderOptions, context, pixelRatio) {
      context.scale(pixelRatio, pixelRatio);
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      if (this.fill_) {
        let color = this.fill_.getColor();
        if (color === null) {
          color = defaultFillStyle;
        }
        context.fillStyle = asColorLike(color);
        context.fill();
      }
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineCap = renderOptions.lineCap;
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     */
    createHitDetectionCanvas_(renderOptions) {
      if (this.fill_) {
        let color = this.fill_.getColor();
        let opacity = 0;
        if (typeof color === "string") {
          color = asArray(color);
        }
        if (color === null) {
          opacity = 1;
        } else if (Array.isArray(color)) {
          opacity = color.length === 4 ? color[3] : 1;
        }
        if (opacity === 0) {
          const context = createCanvasContext2D(
            renderOptions.size,
            renderOptions.size
          );
          this.hitDetectionCanvas_ = context.canvas;
          this.drawHitDetectionCanvas_(renderOptions, context);
        }
      }
      if (!this.hitDetectionCanvas_) {
        this.hitDetectionCanvas_ = this.getImage(1);
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context The context to draw in.
     */
    createPath_(context) {
      let points = this.points_;
      const radius = this.radius_;
      if (points === Infinity) {
        context.arc(0, 0, radius, 0, 2 * Math.PI);
      } else {
        const radius2 = this.radius2_ === void 0 ? radius : this.radius2_;
        if (this.radius2_ !== void 0) {
          points *= 2;
        }
        const startAngle = this.angle_ - Math.PI / 2;
        const step = 2 * Math.PI / points;
        for (let i4 = 0; i4 < points; i4++) {
          const angle0 = startAngle + i4 * step;
          const radiusC = i4 % 2 === 0 ? radius : radius2;
          context.lineTo(radiusC * Math.cos(angle0), radiusC * Math.sin(angle0));
        }
        context.closePath();
      }
    }
    /**
     * @private
     * @param {RenderOptions} renderOptions Render options.
     * @param {CanvasRenderingContext2D} context The context.
     */
    drawHitDetectionCanvas_(renderOptions, context) {
      context.translate(renderOptions.size / 2, renderOptions.size / 2);
      this.createPath_(context);
      context.fillStyle = defaultFillStyle;
      context.fill();
      if (this.stroke_) {
        context.strokeStyle = renderOptions.strokeStyle;
        context.lineWidth = renderOptions.strokeWidth;
        if (renderOptions.lineDash) {
          context.setLineDash(renderOptions.lineDash);
          context.lineDashOffset = renderOptions.lineDashOffset;
        }
        context.lineJoin = renderOptions.lineJoin;
        context.miterLimit = renderOptions.miterLimit;
        context.stroke();
      }
    }
  };
  var RegularShape_default = RegularShape;

  // node_modules/ol/style/Circle.js
  var CircleStyle = class _CircleStyle extends RegularShape_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : { radius: 5 };
      super({
        points: Infinity,
        fill: options.fill,
        radius: options.radius,
        stroke: options.stroke,
        scale: options.scale !== void 0 ? options.scale : 1,
        rotation: options.rotation !== void 0 ? options.rotation : 0,
        rotateWithView: options.rotateWithView !== void 0 ? options.rotateWithView : false,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        declutterMode: options.declutterMode
      });
    }
    /**
     * Clones the style.
     * @return {CircleStyle} The cloned style.
     * @api
     */
    clone() {
      const scale3 = this.getScale();
      const style = new _CircleStyle({
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        radius: this.getRadius(),
        scale: Array.isArray(scale3) ? scale3.slice() : scale3,
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
      style.setOpacity(this.getOpacity());
      return style;
    }
    /**
     * Set the circle radius.
     *
     * @param {number} radius Circle radius.
     * @api
     */
    setRadius(radius) {
      this.radius_ = radius;
      this.render();
    }
  };
  var Circle_default = CircleStyle;

  // node_modules/ol/style/Style.js
  var Style = class _Style {
    /**
     * @param {Options} [options] Style options.
     */
    constructor(options) {
      options = options || {};
      this.geometry_ = null;
      this.geometryFunction_ = defaultGeometryFunction;
      if (options.geometry !== void 0) {
        this.setGeometry(options.geometry);
      }
      this.fill_ = options.fill !== void 0 ? options.fill : null;
      this.image_ = options.image !== void 0 ? options.image : null;
      this.renderer_ = options.renderer !== void 0 ? options.renderer : null;
      this.hitDetectionRenderer_ = options.hitDetectionRenderer !== void 0 ? options.hitDetectionRenderer : null;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.text_ = options.text !== void 0 ? options.text : null;
      this.zIndex_ = options.zIndex;
    }
    /**
     * Clones the style.
     * @return {Style} The cloned style.
     * @api
     */
    clone() {
      let geometry = this.getGeometry();
      if (geometry && typeof geometry === "object") {
        geometry = /** @type {import("../geom/Geometry.js").default} */
        geometry.clone();
      }
      return new _Style({
        geometry,
        fill: this.getFill() ? this.getFill().clone() : void 0,
        image: this.getImage() ? this.getImage().clone() : void 0,
        renderer: this.getRenderer(),
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        text: this.getText() ? this.getText().clone() : void 0,
        zIndex: this.getZIndex()
      });
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setRenderer} or the `renderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Sets a custom renderer function for this style. When set, `fill`, `stroke`
     * and `image` options of the style will be ignored.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setRenderer(renderer) {
      this.renderer_ = renderer;
    }
    /**
     * Sets a custom renderer function for this style used
     * in hit detection.
     * @param {RenderFunction|null} renderer Custom renderer function.
     * @api
     */
    setHitDetectionRenderer(renderer) {
      this.hitDetectionRenderer_ = renderer;
    }
    /**
     * Get the custom renderer function that was configured with
     * {@link #setHitDetectionRenderer} or the `hitDetectionRenderer` constructor option.
     * @return {RenderFunction|null} Custom renderer function.
     * @api
     */
    getHitDetectionRenderer() {
      return this.hitDetectionRenderer_;
    }
    /**
     * Get the geometry to be rendered.
     * @return {string|import("../geom/Geometry.js").default|GeometryFunction}
     * Feature property or geometry or function that returns the geometry that will
     * be rendered with this style.
     * @api
     */
    getGeometry() {
      return this.geometry_;
    }
    /**
     * Get the function used to generate a geometry for rendering.
     * @return {!GeometryFunction} Function that is called with a feature
     * and returns the geometry to render instead of the feature's geometry.
     * @api
     */
    getGeometryFunction() {
      return this.geometryFunction_;
    }
    /**
     * Get the fill style.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Set the fill style.
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    setFill(fill) {
      this.fill_ = fill;
    }
    /**
     * Get the image style.
     * @return {import("./Image.js").default} Image style.
     * @api
     */
    getImage() {
      return this.image_;
    }
    /**
     * Set the image style.
     * @param {import("./Image.js").default} image Image style.
     * @api
     */
    setImage(image) {
      this.image_ = image;
    }
    /**
     * Get the stroke style.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Set the stroke style.
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    setStroke(stroke) {
      this.stroke_ = stroke;
    }
    /**
     * Get the text style.
     * @return {import("./Text.js").default} Text style.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Set the text style.
     * @param {import("./Text.js").default} text Text style.
     * @api
     */
    setText(text) {
      this.text_ = text;
    }
    /**
     * Get the z-index for the style.
     * @return {number|undefined} ZIndex.
     * @api
     */
    getZIndex() {
      return this.zIndex_;
    }
    /**
     * Set a geometry that is rendered instead of the feature's geometry.
     *
     * @param {string|import("../geom/Geometry.js").default|GeometryFunction} geometry
     *     Feature property or geometry or function returning a geometry to render
     *     for this style.
     * @api
     */
    setGeometry(geometry) {
      if (typeof geometry === "function") {
        this.geometryFunction_ = geometry;
      } else if (typeof geometry === "string") {
        this.geometryFunction_ = function(feature) {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            feature.get(geometry)
          );
        };
      } else if (!geometry) {
        this.geometryFunction_ = defaultGeometryFunction;
      } else if (geometry !== void 0) {
        this.geometryFunction_ = function() {
          return (
            /** @type {import("../geom/Geometry.js").default} */
            geometry
          );
        };
      }
      this.geometry_ = geometry;
    }
    /**
     * Set the z-index.
     *
     * @param {number|undefined} zIndex ZIndex.
     * @api
     */
    setZIndex(zIndex) {
      this.zIndex_ = zIndex;
    }
  };
  function toFunction(obj) {
    let styleFunction;
    if (typeof obj === "function") {
      styleFunction = obj;
    } else {
      let styles;
      if (Array.isArray(obj)) {
        styles = obj;
      } else {
        assert(
          typeof /** @type {?} */
          obj.getZIndex === "function",
          "Expected an `Style` or an array of `Style`"
        );
        const style = (
          /** @type {Style} */
          obj
        );
        styles = [style];
      }
      styleFunction = function() {
        return styles;
      };
    }
    return styleFunction;
  }
  var defaultStyles = null;
  function createDefaultStyle(feature, resolution) {
    if (!defaultStyles) {
      const fill = new Fill_default({
        color: "rgba(255,255,255,0.4)"
      });
      const stroke = new Stroke_default({
        color: "#3399CC",
        width: 1.25
      });
      defaultStyles = [
        new Style({
          image: new Circle_default({
            fill,
            stroke,
            radius: 5
          }),
          fill,
          stroke
        })
      ];
    }
    return defaultStyles;
  }
  function defaultGeometryFunction(feature) {
    return feature.getGeometry();
  }
  var Style_default = Style;

  // node_modules/ol/style/Text.js
  var DEFAULT_FILL_COLOR = "#333";
  var Text = class _Text {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options || {};
      this.font_ = options.font;
      this.rotation_ = options.rotation;
      this.rotateWithView_ = options.rotateWithView;
      this.scale_ = options.scale;
      this.scaleArray_ = toSize(options.scale !== void 0 ? options.scale : 1);
      this.text_ = options.text;
      this.textAlign_ = options.textAlign;
      this.justify_ = options.justify;
      this.repeat_ = options.repeat;
      this.textBaseline_ = options.textBaseline;
      this.fill_ = options.fill !== void 0 ? options.fill : new Fill_default({ color: DEFAULT_FILL_COLOR });
      this.maxAngle_ = options.maxAngle !== void 0 ? options.maxAngle : Math.PI / 4;
      this.placement_ = options.placement !== void 0 ? options.placement : "point";
      this.overflow_ = !!options.overflow;
      this.stroke_ = options.stroke !== void 0 ? options.stroke : null;
      this.offsetX_ = options.offsetX !== void 0 ? options.offsetX : 0;
      this.offsetY_ = options.offsetY !== void 0 ? options.offsetY : 0;
      this.backgroundFill_ = options.backgroundFill ? options.backgroundFill : null;
      this.backgroundStroke_ = options.backgroundStroke ? options.backgroundStroke : null;
      this.padding_ = options.padding === void 0 ? null : options.padding;
    }
    /**
     * Clones the style.
     * @return {Text} The cloned style.
     * @api
     */
    clone() {
      const scale3 = this.getScale();
      return new _Text({
        font: this.getFont(),
        placement: this.getPlacement(),
        repeat: this.getRepeat(),
        maxAngle: this.getMaxAngle(),
        overflow: this.getOverflow(),
        rotation: this.getRotation(),
        rotateWithView: this.getRotateWithView(),
        scale: Array.isArray(scale3) ? scale3.slice() : scale3,
        text: this.getText(),
        textAlign: this.getTextAlign(),
        justify: this.getJustify(),
        textBaseline: this.getTextBaseline(),
        fill: this.getFill() ? this.getFill().clone() : void 0,
        stroke: this.getStroke() ? this.getStroke().clone() : void 0,
        offsetX: this.getOffsetX(),
        offsetY: this.getOffsetY(),
        backgroundFill: this.getBackgroundFill() ? this.getBackgroundFill().clone() : void 0,
        backgroundStroke: this.getBackgroundStroke() ? this.getBackgroundStroke().clone() : void 0,
        padding: this.getPadding() || void 0
      });
    }
    /**
     * Get the `overflow` configuration.
     * @return {boolean} Let text overflow the length of the path they follow.
     * @api
     */
    getOverflow() {
      return this.overflow_;
    }
    /**
     * Get the font name.
     * @return {string|undefined} Font.
     * @api
     */
    getFont() {
      return this.font_;
    }
    /**
     * Get the maximum angle between adjacent characters.
     * @return {number} Angle in radians.
     * @api
     */
    getMaxAngle() {
      return this.maxAngle_;
    }
    /**
     * Get the label placement.
     * @return {TextPlacement} Text placement.
     * @api
     */
    getPlacement() {
      return this.placement_;
    }
    /**
     * Get the repeat interval of the text.
     * @return {number|undefined} Repeat interval in pixels.
     * @api
     */
    getRepeat() {
      return this.repeat_;
    }
    /**
     * Get the x-offset for the text.
     * @return {number} Horizontal text offset.
     * @api
     */
    getOffsetX() {
      return this.offsetX_;
    }
    /**
     * Get the y-offset for the text.
     * @return {number} Vertical text offset.
     * @api
     */
    getOffsetY() {
      return this.offsetY_;
    }
    /**
     * Get the fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    getFill() {
      return this.fill_;
    }
    /**
     * Determine whether the text rotates with the map.
     * @return {boolean|undefined} Rotate with map.
     * @api
     */
    getRotateWithView() {
      return this.rotateWithView_;
    }
    /**
     * Get the text rotation.
     * @return {number|undefined} Rotation.
     * @api
     */
    getRotation() {
      return this.rotation_;
    }
    /**
     * Get the text scale.
     * @return {number|import("../size.js").Size|undefined} Scale.
     * @api
     */
    getScale() {
      return this.scale_;
    }
    /**
     * Get the symbolizer scale array.
     * @return {import("../size.js").Size} Scale array.
     */
    getScaleArray() {
      return this.scaleArray_;
    }
    /**
     * Get the stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    getStroke() {
      return this.stroke_;
    }
    /**
     * Get the text to be rendered.
     * @return {string|Array<string>|undefined} Text.
     * @api
     */
    getText() {
      return this.text_;
    }
    /**
     * Get the text alignment.
     * @return {CanvasTextAlign|undefined} Text align.
     * @api
     */
    getTextAlign() {
      return this.textAlign_;
    }
    /**
     * Get the justification.
     * @return {TextJustify|undefined} Justification.
     * @api
     */
    getJustify() {
      return this.justify_;
    }
    /**
     * Get the text baseline.
     * @return {CanvasTextBaseline|undefined} Text baseline.
     * @api
     */
    getTextBaseline() {
      return this.textBaseline_;
    }
    /**
     * Get the background fill style for the text.
     * @return {import("./Fill.js").default} Fill style.
     * @api
     */
    getBackgroundFill() {
      return this.backgroundFill_;
    }
    /**
     * Get the background stroke style for the text.
     * @return {import("./Stroke.js").default} Stroke style.
     * @api
     */
    getBackgroundStroke() {
      return this.backgroundStroke_;
    }
    /**
     * Get the padding for the text.
     * @return {Array<number>|null} Padding.
     * @api
     */
    getPadding() {
      return this.padding_;
    }
    /**
     * Set the `overflow` property.
     *
     * @param {boolean} overflow Let text overflow the path that it follows.
     * @api
     */
    setOverflow(overflow) {
      this.overflow_ = overflow;
    }
    /**
     * Set the font.
     *
     * @param {string|undefined} font Font.
     * @api
     */
    setFont(font) {
      this.font_ = font;
    }
    /**
     * Set the maximum angle between adjacent characters.
     *
     * @param {number} maxAngle Angle in radians.
     * @api
     */
    setMaxAngle(maxAngle) {
      this.maxAngle_ = maxAngle;
    }
    /**
     * Set the x offset.
     *
     * @param {number} offsetX Horizontal text offset.
     * @api
     */
    setOffsetX(offsetX) {
      this.offsetX_ = offsetX;
    }
    /**
     * Set the y offset.
     *
     * @param {number} offsetY Vertical text offset.
     * @api
     */
    setOffsetY(offsetY) {
      this.offsetY_ = offsetY;
    }
    /**
     * Set the text placement.
     *
     * @param {TextPlacement} placement Placement.
     * @api
     */
    setPlacement(placement) {
      this.placement_ = placement;
    }
    /**
     * Set the repeat interval of the text.
     * @param {number|undefined} [repeat] Repeat interval in pixels.
     * @api
     */
    setRepeat(repeat) {
      this.repeat_ = repeat;
    }
    /**
     * Set whether to rotate the text with the view.
     *
     * @param {boolean} rotateWithView Rotate with map.
     * @api
     */
    setRotateWithView(rotateWithView) {
      this.rotateWithView_ = rotateWithView;
    }
    /**
     * Set the fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    setFill(fill) {
      this.fill_ = fill;
    }
    /**
     * Set the rotation.
     *
     * @param {number|undefined} rotation Rotation.
     * @api
     */
    setRotation(rotation) {
      this.rotation_ = rotation;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size|undefined} scale Scale.
     * @api
     */
    setScale(scale3) {
      this.scale_ = scale3;
      this.scaleArray_ = toSize(scale3 !== void 0 ? scale3 : 1);
    }
    /**
     * Set the stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    setStroke(stroke) {
      this.stroke_ = stroke;
    }
    /**
     * Set the text.
     *
     * @param {string|Array<string>|undefined} text Text.
     * @api
     */
    setText(text) {
      this.text_ = text;
    }
    /**
     * Set the text alignment.
     *
     * @param {CanvasTextAlign|undefined} textAlign Text align.
     * @api
     */
    setTextAlign(textAlign) {
      this.textAlign_ = textAlign;
    }
    /**
     * Set the justification.
     *
     * @param {TextJustify|undefined} justify Justification.
     * @api
     */
    setJustify(justify) {
      this.justify_ = justify;
    }
    /**
     * Set the text baseline.
     *
     * @param {CanvasTextBaseline|undefined} textBaseline Text baseline.
     * @api
     */
    setTextBaseline(textBaseline) {
      this.textBaseline_ = textBaseline;
    }
    /**
     * Set the background fill.
     *
     * @param {import("./Fill.js").default} fill Fill style.
     * @api
     */
    setBackgroundFill(fill) {
      this.backgroundFill_ = fill;
    }
    /**
     * Set the background stroke.
     *
     * @param {import("./Stroke.js").default} stroke Stroke style.
     * @api
     */
    setBackgroundStroke(stroke) {
      this.backgroundStroke_ = stroke;
    }
    /**
     * Set the padding (`[top, right, bottom, left]`).
     *
     * @param {Array<number>|null} padding Padding.
     * @api
     */
    setPadding(padding) {
      this.padding_ = padding;
    }
  };
  var Text_default = Text;

  // node_modules/ol/layer/BaseVector.js
  var import_rbush = __toESM(require_rbush_min(), 1);

  // node_modules/ol/Image.js
  function load(image, src) {
    return new Promise((resolve, reject) => {
      function handleLoad() {
        unlisten();
        resolve(image);
      }
      function handleError() {
        unlisten();
        reject(new Error("Image load error"));
      }
      function unlisten() {
        image.removeEventListener("load", handleLoad);
        image.removeEventListener("error", handleError);
      }
      image.addEventListener("load", handleLoad);
      image.addEventListener("error", handleError);
      if (src) {
        image.src = src;
      }
    });
  }
  function decodeFallback(image, src) {
    if (src) {
      image.src = src;
    }
    return IMAGE_DECODE ? new Promise(
      (resolve, reject) => image.decode().then(() => resolve(image), reject)
    ) : load(image);
  }

  // node_modules/ol/style/IconImageCache.js
  var IconImageCache = class {
    constructor() {
      this.cache_ = {};
      this.cacheSize_ = 0;
      this.maxCacheSize_ = 32;
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.cache_ = {};
      this.cacheSize_ = 0;
    }
    /**
     * @return {boolean} Can expire cache.
     */
    canExpireCache() {
      return this.cacheSize_ > this.maxCacheSize_;
    }
    /**
     * FIXME empty description for jsdoc
     */
    expire() {
      if (this.canExpireCache()) {
        let i4 = 0;
        for (const key in this.cache_) {
          const iconImage = this.cache_[key];
          if ((i4++ & 3) === 0 && !iconImage.hasListener()) {
            delete this.cache_[key];
            --this.cacheSize_;
          }
        }
      }
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @return {import("./IconImage.js").default} Icon image.
     */
    get(src, crossOrigin, color) {
      const key = getKey(src, crossOrigin, color);
      return key in this.cache_ ? this.cache_[key] : null;
    }
    /**
     * @param {string} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../color.js").Color} color Color.
     * @param {import("./IconImage.js").default} iconImage Icon image.
     */
    set(src, crossOrigin, color, iconImage) {
      const key = getKey(src, crossOrigin, color);
      this.cache_[key] = iconImage;
      ++this.cacheSize_;
    }
    /**
     * Set the cache size of the icon cache. Default is `32`. Change this value when
     * your map uses more than 32 different icon images and you are not caching icon
     * styles on the application level.
     * @param {number} maxCacheSize Cache max size.
     * @api
     */
    setSize(maxCacheSize) {
      this.maxCacheSize_ = maxCacheSize;
      this.expire();
    }
  };
  function getKey(src, crossOrigin, color) {
    const colorString = color ? asString(color) : "null";
    return crossOrigin + ":" + src + ":" + colorString;
  }
  var shared = new IconImageCache();

  // node_modules/ol/style/IconImage.js
  var taintedTestContext = null;
  var IconImage = class extends Target_default {
    /**
     * @param {HTMLImageElement|HTMLCanvasElement|ImageBitmap} image Image.
     * @param {string|undefined} src Src.
     * @param {?string} crossOrigin Cross origin.
     * @param {import("../ImageState.js").default} imageState Image state.
     * @param {import("../color.js").Color} color Color.
     */
    constructor(image, src, crossOrigin, imageState, color) {
      super();
      this.hitDetectionImage_ = null;
      this.image_ = image;
      this.crossOrigin_ = crossOrigin;
      this.canvas_ = {};
      this.color_ = color;
      this.imageState_ = imageState === void 0 ? ImageState_default.IDLE : imageState;
      this.size_ = image && image.width && image.height ? [image.width, image.height] : null;
      this.src_ = src;
      this.tainted_;
    }
    /**
     * @private
     */
    initializeImage_() {
      this.image_ = new Image();
      if (this.crossOrigin_ !== null) {
        this.image_.crossOrigin = this.crossOrigin_;
      }
    }
    /**
     * @private
     * @return {boolean} The image canvas is tainted.
     */
    isTainted_() {
      if (this.tainted_ === void 0 && this.imageState_ === ImageState_default.LOADED) {
        if (!taintedTestContext) {
          taintedTestContext = createCanvasContext2D(1, 1, void 0, {
            willReadFrequently: true
          });
        }
        taintedTestContext.drawImage(this.image_, 0, 0);
        try {
          taintedTestContext.getImageData(0, 0, 1, 1);
          this.tainted_ = false;
        } catch (e3) {
          taintedTestContext = null;
          this.tainted_ = true;
        }
      }
      return this.tainted_ === true;
    }
    /**
     * @private
     */
    dispatchChangeEvent_() {
      this.dispatchEvent(EventType_default.CHANGE);
    }
    /**
     * @private
     */
    handleImageError_() {
      this.imageState_ = ImageState_default.ERROR;
      this.dispatchChangeEvent_();
    }
    /**
     * @private
     */
    handleImageLoad_() {
      this.imageState_ = ImageState_default.LOADED;
      this.size_ = [this.image_.width, this.image_.height];
      this.dispatchChangeEvent_();
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element or image bitmap.
     */
    getImage(pixelRatio) {
      if (!this.image_) {
        this.initializeImage_();
      }
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? this.canvas_[pixelRatio] : this.image_;
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} Image or Canvas element.
     */
    getPixelRatio(pixelRatio) {
      this.replaceColor_(pixelRatio);
      return this.canvas_[pixelRatio] ? pixelRatio : 1;
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return this.imageState_;
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage() {
      if (!this.image_) {
        this.initializeImage_();
      }
      if (!this.hitDetectionImage_) {
        if (this.isTainted_()) {
          const width = this.size_[0];
          const height = this.size_[1];
          const context = createCanvasContext2D(width, height);
          context.fillRect(0, 0, width, height);
          this.hitDetectionImage_ = context.canvas;
        } else {
          this.hitDetectionImage_ = this.image_;
        }
      }
      return this.hitDetectionImage_;
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     */
    getSize() {
      return this.size_;
    }
    /**
     * @return {string|undefined} Image src.
     */
    getSrc() {
      return this.src_;
    }
    /**
     * Load not yet loaded URI.
     */
    load() {
      if (this.imageState_ !== ImageState_default.IDLE) {
        return;
      }
      if (!this.image_) {
        this.initializeImage_();
      }
      this.imageState_ = ImageState_default.LOADING;
      try {
        if (this.src_ !== void 0) {
          this.image_.src = this.src_;
        }
      } catch (e3) {
        this.handleImageError_();
      }
      if (this.image_ instanceof HTMLImageElement) {
        decodeFallback(this.image_, this.src_).then((image) => {
          this.image_ = image;
          this.handleImageLoad_();
        }).catch(this.handleImageError_.bind(this));
      }
    }
    /**
     * @param {number} pixelRatio Pixel ratio.
     * @private
     */
    replaceColor_(pixelRatio) {
      if (!this.color_ || this.canvas_[pixelRatio] || this.imageState_ !== ImageState_default.LOADED) {
        return;
      }
      const image = this.image_;
      const canvas = document.createElement("canvas");
      canvas.width = Math.ceil(image.width * pixelRatio);
      canvas.height = Math.ceil(image.height * pixelRatio);
      const ctx = canvas.getContext("2d");
      ctx.scale(pixelRatio, pixelRatio);
      ctx.drawImage(image, 0, 0);
      ctx.globalCompositeOperation = "multiply";
      ctx.fillStyle = asString(this.color_);
      ctx.fillRect(0, 0, canvas.width / pixelRatio, canvas.height / pixelRatio);
      ctx.globalCompositeOperation = "destination-in";
      ctx.drawImage(image, 0, 0);
      this.canvas_[pixelRatio] = canvas;
    }
  };
  function get4(image, cacheKey, crossOrigin, imageState, color) {
    let iconImage = cacheKey === void 0 ? void 0 : shared.get(cacheKey, crossOrigin, color);
    if (!iconImage) {
      iconImage = new IconImage(
        image,
        image instanceof HTMLImageElement ? image.src || void 0 : cacheKey,
        crossOrigin,
        imageState,
        color
      );
      shared.set(cacheKey, crossOrigin, color, iconImage);
    }
    return iconImage;
  }

  // node_modules/ol/style/Icon.js
  function calculateScale(width, height, wantedWidth, wantedHeight) {
    if (wantedWidth !== void 0 && wantedHeight !== void 0) {
      return [wantedWidth / width, wantedHeight / height];
    }
    if (wantedWidth !== void 0) {
      return wantedWidth / width;
    }
    if (wantedHeight !== void 0) {
      return wantedHeight / height;
    }
    return 1;
  }
  var Icon = class _Icon extends Image_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options || {};
      const opacity = options.opacity !== void 0 ? options.opacity : 1;
      const rotation = options.rotation !== void 0 ? options.rotation : 0;
      const scale3 = options.scale !== void 0 ? options.scale : 1;
      const rotateWithView = options.rotateWithView !== void 0 ? options.rotateWithView : false;
      super({
        opacity,
        rotation,
        scale: scale3,
        displacement: options.displacement !== void 0 ? options.displacement : [0, 0],
        rotateWithView,
        declutterMode: options.declutterMode
      });
      this.anchor_ = options.anchor !== void 0 ? options.anchor : [0.5, 0.5];
      this.normalizedAnchor_ = null;
      this.anchorOrigin_ = options.anchorOrigin !== void 0 ? options.anchorOrigin : "top-left";
      this.anchorXUnits_ = options.anchorXUnits !== void 0 ? options.anchorXUnits : "fraction";
      this.anchorYUnits_ = options.anchorYUnits !== void 0 ? options.anchorYUnits : "fraction";
      this.crossOrigin_ = options.crossOrigin !== void 0 ? options.crossOrigin : null;
      const image = options.img !== void 0 ? options.img : null;
      let cacheKey = options.src;
      assert(
        !(cacheKey !== void 0 && image),
        "`image` and `src` cannot be provided at the same time"
      );
      if ((cacheKey === void 0 || cacheKey.length === 0) && image) {
        cacheKey = /** @type {HTMLImageElement} */
        image.src || getUid(image);
      }
      assert(
        cacheKey !== void 0 && cacheKey.length > 0,
        "A defined and non-empty `src` or `image` must be provided"
      );
      assert(
        !((options.width !== void 0 || options.height !== void 0) && options.scale !== void 0),
        "`width` or `height` cannot be provided together with `scale`"
      );
      let imageState;
      if (options.src !== void 0) {
        imageState = ImageState_default.IDLE;
      } else if (image !== void 0) {
        if (image instanceof HTMLImageElement) {
          if (image.complete) {
            imageState = image.src ? ImageState_default.LOADED : ImageState_default.IDLE;
          } else {
            imageState = ImageState_default.LOADING;
          }
        } else {
          imageState = ImageState_default.LOADED;
        }
      }
      this.color_ = options.color !== void 0 ? asArray(options.color) : null;
      this.iconImage_ = get4(
        image,
        /** @type {string} */
        cacheKey,
        this.crossOrigin_,
        imageState,
        this.color_
      );
      this.offset_ = options.offset !== void 0 ? options.offset : [0, 0];
      this.offsetOrigin_ = options.offsetOrigin !== void 0 ? options.offsetOrigin : "top-left";
      this.origin_ = null;
      this.size_ = options.size !== void 0 ? options.size : null;
      if (options.width !== void 0 || options.height !== void 0) {
        let width, height;
        if (options.size) {
          [width, height] = options.size;
        } else {
          const image2 = this.getImage(1);
          if (image2.width && image2.height) {
            width = image2.width;
            height = image2.height;
          } else if (image2 instanceof HTMLImageElement) {
            this.initialOptions_ = options;
            const onload = () => {
              this.unlistenImageChange(onload);
              if (!this.initialOptions_) {
                return;
              }
              const imageSize = this.iconImage_.getSize();
              this.setScale(
                calculateScale(
                  imageSize[0],
                  imageSize[1],
                  options.width,
                  options.height
                )
              );
            };
            this.listenImageChange(onload);
            return;
          }
        }
        if (width !== void 0) {
          this.setScale(
            calculateScale(width, height, options.width, options.height)
          );
        }
      }
    }
    /**
     * Clones the style. The underlying Image/HTMLCanvasElement is not cloned.
     * @return {Icon} The cloned style.
     * @api
     */
    clone() {
      let scale3, width, height;
      if (this.initialOptions_) {
        width = this.initialOptions_.width;
        height = this.initialOptions_.height;
      } else {
        scale3 = this.getScale();
        scale3 = Array.isArray(scale3) ? scale3.slice() : scale3;
      }
      return new _Icon({
        anchor: this.anchor_.slice(),
        anchorOrigin: this.anchorOrigin_,
        anchorXUnits: this.anchorXUnits_,
        anchorYUnits: this.anchorYUnits_,
        color: this.color_ && this.color_.slice ? this.color_.slice() : this.color_ || void 0,
        crossOrigin: this.crossOrigin_,
        offset: this.offset_.slice(),
        offsetOrigin: this.offsetOrigin_,
        opacity: this.getOpacity(),
        rotateWithView: this.getRotateWithView(),
        rotation: this.getRotation(),
        scale: scale3,
        width,
        height,
        size: this.size_ !== null ? this.size_.slice() : void 0,
        src: this.getSrc(),
        displacement: this.getDisplacement().slice(),
        declutterMode: this.getDeclutterMode()
      });
    }
    /**
     * Get the anchor point in pixels. The anchor determines the center point for the
     * symbolizer.
     * @return {Array<number>} Anchor.
     * @api
     */
    getAnchor() {
      let anchor = this.normalizedAnchor_;
      if (!anchor) {
        anchor = this.anchor_;
        const size = this.getSize();
        if (this.anchorXUnits_ == "fraction" || this.anchorYUnits_ == "fraction") {
          if (!size) {
            return null;
          }
          anchor = this.anchor_.slice();
          if (this.anchorXUnits_ == "fraction") {
            anchor[0] *= size[0];
          }
          if (this.anchorYUnits_ == "fraction") {
            anchor[1] *= size[1];
          }
        }
        if (this.anchorOrigin_ != "top-left") {
          if (!size) {
            return null;
          }
          if (anchor === this.anchor_) {
            anchor = this.anchor_.slice();
          }
          if (this.anchorOrigin_ == "top-right" || this.anchorOrigin_ == "bottom-right") {
            anchor[0] = -anchor[0] + size[0];
          }
          if (this.anchorOrigin_ == "bottom-left" || this.anchorOrigin_ == "bottom-right") {
            anchor[1] = -anchor[1] + size[1];
          }
        }
        this.normalizedAnchor_ = anchor;
      }
      const displacement = this.getDisplacement();
      const scale3 = this.getScaleArray();
      return [
        anchor[0] - displacement[0] / scale3[0],
        anchor[1] + displacement[1] / scale3[1]
      ];
    }
    /**
     * Set the anchor point. The anchor determines the center point for the
     * symbolizer.
     *
     * @param {Array<number>} anchor Anchor.
     * @api
     */
    setAnchor(anchor) {
      this.anchor_ = anchor;
      this.normalizedAnchor_ = null;
    }
    /**
     * Get the icon color.
     * @return {import("../color.js").Color} Color.
     * @api
     */
    getColor() {
      return this.color_;
    }
    /**
     * Get the image icon.
     * @param {number} pixelRatio Pixel ratio.
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image or Canvas element. If the Icon
     * style was configured with `src` or with a not let loaded `img`, an `ImageBitmap` will be returned.
     * @api
     */
    getImage(pixelRatio) {
      return this.iconImage_.getImage(pixelRatio);
    }
    /**
     * Get the pixel ratio.
     * @param {number} pixelRatio Pixel ratio.
     * @return {number} The pixel ratio of the image.
     * @api
     */
    getPixelRatio(pixelRatio) {
      return this.iconImage_.getPixelRatio(pixelRatio);
    }
    /**
     * @return {import("../size.js").Size} Image size.
     */
    getImageSize() {
      return this.iconImage_.getSize();
    }
    /**
     * @return {import("../ImageState.js").default} Image state.
     */
    getImageState() {
      return this.iconImage_.getImageState();
    }
    /**
     * @return {HTMLImageElement|HTMLCanvasElement|ImageBitmap} Image element.
     */
    getHitDetectionImage() {
      return this.iconImage_.getHitDetectionImage();
    }
    /**
     * Get the origin of the symbolizer.
     * @return {Array<number>} Origin.
     * @api
     */
    getOrigin() {
      if (this.origin_) {
        return this.origin_;
      }
      let offset2 = this.offset_;
      if (this.offsetOrigin_ != "top-left") {
        const size = this.getSize();
        const iconImageSize = this.iconImage_.getSize();
        if (!size || !iconImageSize) {
          return null;
        }
        offset2 = offset2.slice();
        if (this.offsetOrigin_ == "top-right" || this.offsetOrigin_ == "bottom-right") {
          offset2[0] = iconImageSize[0] - size[0] - offset2[0];
        }
        if (this.offsetOrigin_ == "bottom-left" || this.offsetOrigin_ == "bottom-right") {
          offset2[1] = iconImageSize[1] - size[1] - offset2[1];
        }
      }
      this.origin_ = offset2;
      return this.origin_;
    }
    /**
     * Get the image URL.
     * @return {string|undefined} Image src.
     * @api
     */
    getSrc() {
      return this.iconImage_.getSrc();
    }
    /**
     * Get the size of the icon (in pixels).
     * @return {import("../size.js").Size} Image size.
     * @api
     */
    getSize() {
      return !this.size_ ? this.iconImage_.getSize() : this.size_;
    }
    /**
     * Get the width of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon width (in pixels).
     * @api
     */
    getWidth() {
      const scale3 = this.getScaleArray();
      if (this.size_) {
        return this.size_[0] * scale3[0];
      }
      if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
        return this.iconImage_.getSize()[0] * scale3[0];
      }
      return void 0;
    }
    /**
     * Get the height of the icon (in pixels). Will return undefined when the icon image is not yet loaded.
     * @return {number} Icon height (in pixels).
     * @api
     */
    getHeight() {
      const scale3 = this.getScaleArray();
      if (this.size_) {
        return this.size_[1] * scale3[1];
      }
      if (this.iconImage_.getImageState() == ImageState_default.LOADED) {
        return this.iconImage_.getSize()[1] * scale3[1];
      }
      return void 0;
    }
    /**
     * Set the scale.
     *
     * @param {number|import("../size.js").Size} scale Scale.
     * @api
     */
    setScale(scale3) {
      delete this.initialOptions_;
      super.setScale(scale3);
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    listenImageChange(listener) {
      this.iconImage_.addEventListener(EventType_default.CHANGE, listener);
    }
    /**
     * Load not yet loaded URI.
     * When rendering a feature with an icon style, the vector renderer will
     * automatically call this method. However, you might want to call this
     * method yourself for preloading or other purposes.
     * @api
     */
    load() {
      this.iconImage_.load();
    }
    /**
     * @param {function(import("../events/Event.js").default): void} listener Listener function.
     */
    unlistenImageChange(listener) {
      this.iconImage_.removeEventListener(EventType_default.CHANGE, listener);
    }
  };
  var Icon_default = Icon;

  // node_modules/ol/expr/expression.js
  var numTypes = 0;
  var BooleanType = 1 << numTypes++;
  var NumberType = 1 << numTypes++;
  var StringType = 1 << numTypes++;
  var ColorType = 1 << numTypes++;
  var NumberArrayType = 1 << numTypes++;
  var AnyType = Math.pow(2, numTypes) - 1;
  var typeNames = {
    [BooleanType]: "boolean",
    [NumberType]: "number",
    [StringType]: "string",
    [ColorType]: "color",
    [NumberArrayType]: "number[]"
  };
  var namedTypes = Object.keys(typeNames).map(Number).sort(ascending);
  function typeName(type) {
    const names = [];
    for (const namedType of namedTypes) {
      if (includesType(type, namedType)) {
        names.push(typeNames[namedType]);
      }
    }
    if (names.length === 0) {
      return "untyped";
    }
    if (names.length < 3) {
      return names.join(" or ");
    }
    return names.slice(0, -1).join(", ") + ", or " + names[names.length - 1];
  }
  function includesType(broad, specific) {
    return (broad & specific) === specific;
  }
  function overlapsType(oneType, otherType) {
    return !!(oneType & otherType);
  }
  var LiteralExpression = class {
    /**
     * @param {number} type The value type.
     * @param {LiteralValue} value The literal value.
     */
    constructor(type, value) {
      this.type = type;
      this.value = value;
    }
  };
  var CallExpression = class {
    /**
     * @param {number} type The return type.
     * @param {string} operator The operator.
     * @param {...Expression} args The arguments.
     */
    constructor(type, operator, ...args) {
      this.type = type;
      this.operator = operator;
      this.args = args;
    }
  };
  function newParsingContext() {
    return {
      variables: /* @__PURE__ */ new Set(),
      properties: /* @__PURE__ */ new Set()
    };
  }
  function parse(encoded, context) {
    switch (typeof encoded) {
      case "boolean": {
        return new LiteralExpression(BooleanType, encoded);
      }
      case "number": {
        return new LiteralExpression(NumberType, encoded);
      }
      case "string": {
        return new LiteralExpression(StringType, encoded);
      }
      default: {
      }
    }
    if (!Array.isArray(encoded)) {
      throw new Error("Expression must be an array or a primitive value");
    }
    if (encoded.length === 0) {
      throw new Error("Empty expression");
    }
    if (typeof encoded[0] === "string") {
      return parseCallExpression(encoded, context);
    }
    for (const item of encoded) {
      if (typeof item !== "number") {
        throw new Error("Expected an array of numbers");
      }
    }
    let type = NumberArrayType;
    if (encoded.length === 3 || encoded.length === 4) {
      type |= ColorType;
    }
    return new LiteralExpression(type, encoded);
  }
  var Ops = {
    Number: "number",
    String: "string",
    Get: "get",
    Var: "var",
    Any: "any",
    All: "all",
    Not: "!",
    Resolution: "resolution",
    Equal: "==",
    NotEqual: "!=",
    GreaterThan: ">",
    GreaterThanOrEqualTo: ">=",
    LessThan: "<",
    LessThanOrEqualTo: "<=",
    Multiply: "*",
    Divide: "/",
    Add: "+",
    Subtract: "-",
    Clamp: "clamp",
    Mod: "%",
    Pow: "^",
    Abs: "abs",
    Floor: "floor",
    Ceil: "ceil",
    Round: "round",
    Sin: "sin",
    Cos: "cos",
    Atan: "atan",
    Sqrt: "sqrt",
    Match: "match"
  };
  var parsers = {
    [Ops.Number]: createParser(withArgs(1, Infinity, AnyType), NumberType),
    [Ops.String]: createParser(withArgs(1, Infinity, AnyType), StringType),
    [Ops.Get]: createParser(withGetArgs, AnyType),
    [Ops.Var]: createParser(withVarArgs, AnyType),
    [Ops.Resolution]: createParser(withNoArgs, NumberType),
    [Ops.Any]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),
    [Ops.All]: createParser(withArgs(2, Infinity, BooleanType), BooleanType),
    [Ops.Not]: createParser(withArgs(1, 1, BooleanType), BooleanType),
    [Ops.Equal]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.NotEqual]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.GreaterThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.GreaterThanOrEqualTo]: createParser(
      withArgs(2, 2, AnyType),
      BooleanType
    ),
    [Ops.LessThan]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.LessThanOrEqualTo]: createParser(withArgs(2, 2, AnyType), BooleanType),
    [Ops.Multiply]: createParser(withArgs(2, Infinity, NumberType), NumberType),
    [Ops.Divide]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Add]: createParser(withArgs(2, Infinity, NumberType), NumberType),
    [Ops.Subtract]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Clamp]: createParser(withArgs(3, 3, NumberType), NumberType),
    [Ops.Mod]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Pow]: createParser(withArgs(2, 2, NumberType), NumberType),
    [Ops.Abs]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Floor]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Ceil]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Round]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Sin]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Cos]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Atan]: createParser(withArgs(1, 2, NumberType), NumberType),
    [Ops.Sqrt]: createParser(withArgs(1, 1, NumberType), NumberType),
    [Ops.Match]: createParser(
      withArgs(4, Infinity, StringType | NumberType),
      AnyType
    )
  };
  function withGetArgs(encoded, context) {
    if (encoded.length !== 2) {
      throw new Error("Expected 1 argument for get operation");
    }
    const arg = parse(encoded[1], context);
    if (!(arg instanceof LiteralExpression)) {
      throw new Error("Expected a literal argument for get operation");
    }
    if (typeof arg.value !== "string") {
      throw new Error("Expected a string argument for get operation");
    }
    context.properties.add(arg.value);
    return [arg];
  }
  function withVarArgs(encoded, context) {
    if (encoded.length !== 2) {
      throw new Error("Expected 1 argument for var operation");
    }
    const arg = parse(encoded[1], context);
    if (!(arg instanceof LiteralExpression)) {
      throw new Error("Expected a literal argument for var operation");
    }
    if (typeof arg.value !== "string") {
      throw new Error("Expected a string argument for get operation");
    }
    context.variables.add(arg.value);
    return [arg];
  }
  function withNoArgs(encoded, context) {
    const operation = encoded[0];
    if (encoded.length !== 1) {
      throw new Error(`Expected no arguments for ${operation} operation`);
    }
    return [];
  }
  function withArgs(minArgs, maxArgs, argType) {
    return function(encoded, context) {
      const operation = encoded[0];
      const argCount = encoded.length - 1;
      if (minArgs === maxArgs) {
        if (argCount !== minArgs) {
          const plural = minArgs === 1 ? "" : "s";
          throw new Error(
            `Expected ${minArgs} argument${plural} for operation ${operation}, got ${argCount}`
          );
        }
      } else if (argCount < minArgs || argCount > maxArgs) {
        throw new Error(
          `Expected ${minArgs} to ${maxArgs} arguments for operation ${operation}, got ${argCount}`
        );
      }
      const args = new Array(argCount);
      for (let i4 = 0; i4 < argCount; ++i4) {
        const expression = parse(encoded[i4 + 1], context);
        if (!overlapsType(argType, expression.type)) {
          const gotType = typeName(argType);
          const expectedType = typeName(expression.type);
          throw new Error(
            `Unexpected type for argument ${i4} of ${operation} operation : got ${gotType} but expected ${expectedType}`
          );
        }
        args[i4] = expression;
      }
      return args;
    };
  }
  function createParser(argValidator, returnType) {
    return function(encoded, context) {
      const operator = encoded[0];
      const args = argValidator(encoded, context);
      return new CallExpression(returnType, operator, ...args);
    };
  }
  function parseCallExpression(encoded, context) {
    const operator = encoded[0];
    const parser = parsers[operator];
    if (!parser) {
      throw new Error(`Unknown operator: ${operator}`);
    }
    return parser(encoded, context);
  }

  // node_modules/ol/expr/cpu.js
  function newEvaluationContext() {
    return {
      variables: {},
      properties: {},
      resolution: NaN
    };
  }
  function buildExpression(encoded, type, context) {
    const expression = parse(encoded, context);
    if (!overlapsType(type, expression.type)) {
      const expected = typeName(type);
      const actual = typeName(expression.type);
      throw new Error(
        `Expected expression to be of type ${expected}, got ${actual}`
      );
    }
    return compileExpression(expression, context);
  }
  function compileExpression(expression, context) {
    if (expression instanceof LiteralExpression) {
      return function() {
        return expression.value;
      };
    }
    const operator = expression.operator;
    switch (operator) {
      case Ops.Number:
      case Ops.String: {
        return compileAssertionExpression(expression, context);
      }
      case Ops.Get:
      case Ops.Var: {
        return compileAccessorExpression(expression, context);
      }
      case Ops.Resolution: {
        return (context2) => context2.resolution;
      }
      case Ops.Any:
      case Ops.All:
      case Ops.Not: {
        return compileLogicalExpression(expression, context);
      }
      case Ops.Equal:
      case Ops.NotEqual:
      case Ops.LessThan:
      case Ops.LessThanOrEqualTo:
      case Ops.GreaterThan:
      case Ops.GreaterThanOrEqualTo: {
        return compileComparisonExpression(expression, context);
      }
      case Ops.Multiply:
      case Ops.Divide:
      case Ops.Add:
      case Ops.Subtract:
      case Ops.Clamp:
      case Ops.Mod:
      case Ops.Pow:
      case Ops.Abs:
      case Ops.Floor:
      case Ops.Ceil:
      case Ops.Round:
      case Ops.Sin:
      case Ops.Cos:
      case Ops.Atan:
      case Ops.Sqrt: {
        return compileNumericExpression(expression, context);
      }
      case Ops.Match: {
        return compileMatchExpression(expression, context);
      }
      default: {
        throw new Error(`Unsupported operator ${operator}`);
      }
    }
  }
  function compileAssertionExpression(expression, context) {
    const type = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      args[i4] = compileExpression(expression.args[i4], context);
    }
    switch (type) {
      case Ops.Number:
      case Ops.String: {
        return (context2) => {
          for (let i4 = 0; i4 < length; ++i4) {
            const value = args[i4](context2);
            if (typeof value === type) {
              return value;
            }
          }
          throw new Error(`Expected one of the values to be a ${type}`);
        };
      }
      default: {
        throw new Error(`Unsupported assertion operator ${type}`);
      }
    }
  }
  function compileAccessorExpression(expression, context) {
    const nameExpression = expression.args[0];
    if (!(nameExpression instanceof LiteralExpression)) {
      throw new Error("Expected literal name");
    }
    const name = nameExpression.value;
    if (typeof name !== "string") {
      throw new Error("Expected string name");
    }
    switch (expression.operator) {
      case Ops.Get: {
        return (context2) => context2.properties[name];
      }
      case Ops.Var: {
        return (context2) => context2.variables[name];
      }
      default: {
        throw new Error(`Unsupported accessor operator ${expression.operator}`);
      }
    }
  }
  function compileComparisonExpression(expression, context) {
    const op = expression.operator;
    const left = compileExpression(expression.args[0], context);
    const right = compileExpression(expression.args[1], context);
    switch (op) {
      case Ops.Equal: {
        return (context2) => left(context2) === right(context2);
      }
      case Ops.NotEqual: {
        return (context2) => left(context2) !== right(context2);
      }
      case Ops.LessThan: {
        return (context2) => left(context2) < right(context2);
      }
      case Ops.LessThanOrEqualTo: {
        return (context2) => left(context2) <= right(context2);
      }
      case Ops.GreaterThan: {
        return (context2) => left(context2) > right(context2);
      }
      case Ops.GreaterThanOrEqualTo: {
        return (context2) => left(context2) >= right(context2);
      }
      default: {
        throw new Error(`Unsupported comparison operator ${op}`);
      }
    }
  }
  function compileLogicalExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      args[i4] = compileExpression(expression.args[i4], context);
    }
    switch (op) {
      case Ops.Any: {
        return (context2) => {
          for (let i4 = 0; i4 < length; ++i4) {
            if (args[i4](context2)) {
              return true;
            }
          }
          return false;
        };
      }
      case Ops.All: {
        return (context2) => {
          for (let i4 = 0; i4 < length; ++i4) {
            if (!args[i4](context2)) {
              return false;
            }
          }
          return true;
        };
      }
      case Ops.Not: {
        return (context2) => !args[0](context2);
      }
      default: {
        throw new Error(`Unsupported logical operator ${op}`);
      }
    }
  }
  function compileNumericExpression(expression, context) {
    const op = expression.operator;
    const length = expression.args.length;
    const args = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      args[i4] = compileExpression(expression.args[i4], context);
    }
    switch (op) {
      case Ops.Multiply: {
        return (context2) => {
          let value = 1;
          for (let i4 = 0; i4 < length; ++i4) {
            value *= args[i4](context2);
          }
          return value;
        };
      }
      case Ops.Divide: {
        return (context2) => args[0](context2) / args[1](context2);
      }
      case Ops.Add: {
        return (context2) => {
          let value = 0;
          for (let i4 = 0; i4 < length; ++i4) {
            value += args[i4](context2);
          }
          return value;
        };
      }
      case Ops.Subtract: {
        return (context2) => args[0](context2) - args[1](context2);
      }
      case Ops.Clamp: {
        return (context2) => {
          const value = args[0](context2);
          const min = args[1](context2);
          if (value < min) {
            return min;
          }
          const max = args[2](context2);
          if (value > max) {
            return max;
          }
          return value;
        };
      }
      case Ops.Mod: {
        return (context2) => args[0](context2) % args[1](context2);
      }
      case Ops.Pow: {
        return (context2) => Math.pow(args[0](context2), args[1](context2));
      }
      case Ops.Abs: {
        return (context2) => Math.abs(args[0](context2));
      }
      case Ops.Floor: {
        return (context2) => Math.floor(args[0](context2));
      }
      case Ops.Ceil: {
        return (context2) => Math.ceil(args[0](context2));
      }
      case Ops.Round: {
        return (context2) => Math.round(args[0](context2));
      }
      case Ops.Sin: {
        return (context2) => Math.sin(args[0](context2));
      }
      case Ops.Cos: {
        return (context2) => Math.cos(args[0](context2));
      }
      case Ops.Atan: {
        if (length === 2) {
          return (context2) => Math.atan2(args[0](context2), args[1](context2));
        }
        return (context2) => Math.atan(args[0](context2));
      }
      case Ops.Sqrt: {
        return (context2) => Math.sqrt(args[0](context2));
      }
      default: {
        throw new Error(`Unsupported numeric operator ${op}`);
      }
    }
  }
  function compileMatchExpression(expression, context) {
    const length = expression.args.length;
    const args = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      args[i4] = compileExpression(expression.args[i4], context);
    }
    return (context2) => {
      const value = args[0](context2);
      for (let i4 = 1; i4 < length; i4 += 2) {
        if (value === args[i4](context2)) {
          return args[i4 + 1](context2);
        }
      }
      return args[length - 1](context2);
    };
  }

  // node_modules/ol/render/canvas/style.js
  function always(context) {
    return true;
  }
  function rulesToStyleFunction(rules) {
    const parsingContext = newParsingContext();
    const evaluator = buildRuleSet(rules, parsingContext);
    const evaluationContext = newEvaluationContext();
    return function(feature, resolution) {
      evaluationContext.properties = feature.getPropertiesInternal();
      evaluationContext.resolution = resolution;
      return evaluator(evaluationContext);
    };
  }
  function flatStylesToStyleFunction(flatStyles) {
    const parsingContext = newParsingContext();
    const length = flatStyles.length;
    const evaluators = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      evaluators[i4] = buildStyle(flatStyles[i4], parsingContext);
    }
    const evaluationContext = newEvaluationContext();
    const styles = new Array(length);
    return function(feature, resolution) {
      evaluationContext.properties = feature.getPropertiesInternal();
      evaluationContext.resolution = resolution;
      for (let i4 = 0; i4 < length; ++i4) {
        styles[i4] = evaluators[i4](evaluationContext);
      }
      return styles;
    };
  }
  function buildRuleSet(rules, context) {
    const length = rules.length;
    const compiledRules = new Array(length);
    for (let i4 = 0; i4 < length; ++i4) {
      const rule = rules[i4];
      const filter = "filter" in rule ? buildExpression(rule.filter, BooleanType, context) : always;
      let styles;
      if (Array.isArray(rule.style)) {
        const styleLength = rule.style.length;
        styles = new Array(styleLength);
        for (let j3 = 0; j3 < styleLength; ++j3) {
          styles[j3] = buildStyle(rule.style[j3], context);
        }
      } else {
        styles = [buildStyle(rule.style, context)];
      }
      compiledRules[i4] = { filter, styles };
    }
    return function(context2) {
      const styles = [];
      let someMatched = false;
      for (let i4 = 0; i4 < length; ++i4) {
        const filterEvaluator = compiledRules[i4].filter;
        if (!filterEvaluator(context2)) {
          continue;
        }
        if (rules[i4].else && someMatched) {
          continue;
        }
        someMatched = true;
        for (const styleEvaluator of compiledRules[i4].styles) {
          const style = styleEvaluator(context2);
          if (!style) {
            continue;
          }
          styles.push(style);
        }
      }
      return styles;
    };
  }
  function buildStyle(flatStyle, context) {
    const evaluateFill = buildFill(flatStyle, "", context);
    const evaluateStroke = buildStroke(flatStyle, "", context);
    const evaluateText = buildText(flatStyle, context);
    const evaluateImage = buildImage(flatStyle, context);
    const evaluateZIndex = numberEvaluator(flatStyle, "z-index", context);
    const style = new Style_default();
    return function(context2) {
      let empty = true;
      if (evaluateFill) {
        const fill = evaluateFill(context2);
        if (fill) {
          empty = false;
        }
        style.setFill(fill);
      }
      if (evaluateStroke) {
        const stroke = evaluateStroke(context2);
        if (stroke) {
          empty = false;
        }
        style.setStroke(stroke);
      }
      if (evaluateText) {
        const text = evaluateText(context2);
        if (text) {
          empty = false;
        }
        style.setText(text);
      }
      if (evaluateImage) {
        const image = evaluateImage(context2);
        if (image) {
          empty = false;
        }
        style.setImage(image);
      }
      if (evaluateZIndex) {
        style.setZIndex(evaluateZIndex(context2));
      }
      if (empty) {
        return null;
      }
      return style;
    };
  }
  function buildFill(flatStyle, prefix, context) {
    const evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "fill-color",
      context
    );
    if (!evaluateColor) {
      return null;
    }
    const fill = new Fill_default();
    return function(context2) {
      const color = evaluateColor(context2);
      if (color === "none") {
        return null;
      }
      fill.setColor(color);
      return fill;
    };
  }
  function buildStroke(flatStyle, prefix, context) {
    const evaluateWidth = numberEvaluator(
      flatStyle,
      prefix + "stroke-width",
      context
    );
    const evaluateColor = colorLikeEvaluator(
      flatStyle,
      prefix + "stroke-color",
      context
    );
    if (!evaluateWidth && !evaluateColor) {
      return null;
    }
    const evaluateLineCap = stringEvaluator(
      flatStyle,
      prefix + "stroke-line-cap",
      context
    );
    const evaluateLineJoin = stringEvaluator(
      flatStyle,
      prefix + "stroke-line-join",
      context
    );
    const evaluateLineDash = numberArrayEvaluator(
      flatStyle,
      prefix + "stroke-line-dash",
      context
    );
    const evaluateLineDashOffset = numberEvaluator(
      flatStyle,
      prefix + "stroke-line-dash-offset",
      context
    );
    const evaluateMiterLimit = numberEvaluator(
      flatStyle,
      prefix + "stroke-miter-limit",
      context
    );
    const stroke = new Stroke_default();
    return function(context2) {
      if (evaluateColor) {
        const color = evaluateColor(context2);
        if (color === "none") {
          return null;
        }
        stroke.setColor(color);
      }
      if (evaluateWidth) {
        stroke.setWidth(evaluateWidth(context2));
      }
      if (evaluateLineCap) {
        const lineCap = evaluateLineCap(context2);
        if (lineCap !== "butt" && lineCap !== "round" && lineCap !== "square") {
          throw new Error("Expected butt, round, or square line cap");
        }
        stroke.setLineCap(lineCap);
      }
      if (evaluateLineJoin) {
        const lineJoin = evaluateLineJoin(context2);
        if (lineJoin !== "bevel" && lineJoin !== "round" && lineJoin !== "miter") {
          throw new Error("Expected bevel, round, or miter line join");
        }
        stroke.setLineJoin(lineJoin);
      }
      if (evaluateLineDash) {
        stroke.setLineDash(evaluateLineDash(context2));
      }
      if (evaluateLineDashOffset) {
        stroke.setLineDashOffset(evaluateLineDashOffset(context2));
      }
      if (evaluateMiterLimit) {
        stroke.setMiterLimit(evaluateMiterLimit(context2));
      }
      return stroke;
    };
  }
  function buildText(flatStyle, context) {
    const prefix = "text-";
    const evaluateValue = stringEvaluator(flatStyle, prefix + "value", context);
    if (!evaluateValue) {
      return null;
    }
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateBackgroundFill = buildFill(
      flatStyle,
      prefix + "background-",
      context
    );
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateBackgroundStroke = buildStroke(
      flatStyle,
      prefix + "background-",
      context
    );
    const evaluateFont = stringEvaluator(flatStyle, prefix + "font", context);
    const evaluateMaxAngle = numberEvaluator(
      flatStyle,
      prefix + "max-angle",
      context
    );
    const evaluateOffsetX = numberEvaluator(
      flatStyle,
      prefix + "offset-x",
      context
    );
    const evaluateOffsetY = numberEvaluator(
      flatStyle,
      prefix + "offset-y",
      context
    );
    const evaluateOverflow = booleanEvaluator(
      flatStyle,
      prefix + "overflow",
      context
    );
    const evaluatePlacement = stringEvaluator(
      flatStyle,
      prefix + "placement",
      context
    );
    const evaluateRepeat = numberEvaluator(flatStyle, prefix + "repeat", context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
    const evaluateRotateWithView = booleanEvaluator(
      flatStyle,
      prefix + "rotate-with-view",
      context
    );
    const evaluateRotation = numberEvaluator(
      flatStyle,
      prefix + "rotation",
      context
    );
    const evaluateAlign = stringEvaluator(flatStyle, prefix + "align", context);
    const evaluateJustify = stringEvaluator(
      flatStyle,
      prefix + "justify",
      context
    );
    const evaluateBaseline = stringEvaluator(
      flatStyle,
      prefix + "baseline",
      context
    );
    const evaluatePadding = numberArrayEvaluator(
      flatStyle,
      prefix + "padding",
      context
    );
    const text = new Text_default({});
    return function(context2) {
      text.setText(evaluateValue(context2));
      if (evaluateFill) {
        text.setFill(evaluateFill(context2));
      }
      if (evaluateBackgroundFill) {
        text.setBackgroundFill(evaluateBackgroundFill(context2));
      }
      if (evaluateStroke) {
        text.setStroke(evaluateStroke(context2));
      }
      if (evaluateBackgroundStroke) {
        text.setBackgroundStroke(evaluateBackgroundStroke(context2));
      }
      if (evaluateFont) {
        text.setFont(evaluateFont(context2));
      }
      if (evaluateMaxAngle) {
        text.setMaxAngle(evaluateMaxAngle(context2));
      }
      if (evaluateOffsetX) {
        text.setOffsetX(evaluateOffsetX(context2));
      }
      if (evaluateOffsetY) {
        text.setOffsetY(evaluateOffsetY(context2));
      }
      if (evaluateOverflow) {
        text.setOverflow(evaluateOverflow(context2));
      }
      if (evaluatePlacement) {
        const placement = evaluatePlacement(context2);
        if (placement !== "point" && placement !== "line") {
          throw new Error("Expected point or line for text-placement");
        }
        text.setPlacement(placement);
      }
      if (evaluateRepeat) {
        text.setRepeat(evaluateRepeat(context2));
      }
      if (evaluateScale) {
        text.setScale(evaluateScale(context2));
      }
      if (evaluateRotateWithView) {
        text.setRotateWithView(evaluateRotateWithView(context2));
      }
      if (evaluateRotation) {
        text.setRotation(evaluateRotation(context2));
      }
      if (evaluateAlign) {
        const textAlign = evaluateAlign(context2);
        if (textAlign !== "left" && textAlign !== "center" && textAlign !== "right" && textAlign !== "end" && textAlign !== "start") {
          throw new Error(
            "Expected left, right, center, start, or end for text-align"
          );
        }
        text.setTextAlign(textAlign);
      }
      if (evaluateJustify) {
        const justify = evaluateJustify(context2);
        if (justify !== "left" && justify !== "right" && justify !== "center") {
          throw new Error("Expected left, right, or center for text-justify");
        }
        text.setJustify(justify);
      }
      if (evaluateBaseline) {
        const textBaseline = evaluateBaseline(context2);
        if (textBaseline !== "bottom" && textBaseline !== "top" && textBaseline !== "middle" && textBaseline !== "alphabetic" && textBaseline !== "hanging") {
          throw new Error(
            "Expected bottom, top, middle, alphabetic, or hanging for text-baseline"
          );
        }
        text.setTextBaseline(textBaseline);
      }
      if (evaluatePadding) {
        text.setPadding(evaluatePadding(context2));
      }
      return text;
    };
  }
  function buildImage(flatStyle, context) {
    if ("icon-src" in flatStyle) {
      return buildIcon(flatStyle, context);
    }
    if ("shape-points" in flatStyle) {
      return buildShape(flatStyle, context);
    }
    if ("circle-radius" in flatStyle) {
      return buildCircle(flatStyle, context);
    }
    return null;
  }
  function buildIcon(flatStyle, context) {
    const prefix = "icon-";
    const srcName = prefix + "src";
    const src = requireString(flatStyle[srcName], srcName);
    const evaluateAnchor = coordinateEvaluator(
      flatStyle,
      prefix + "anchor",
      context
    );
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
    const evaluateOpacity = numberEvaluator(
      flatStyle,
      prefix + "opacity",
      context
    );
    const evaluateDisplacement = coordinateEvaluator(
      flatStyle,
      prefix + "displacement",
      context
    );
    const evaluateRotation = numberEvaluator(
      flatStyle,
      prefix + "rotation",
      context
    );
    const evaluateRotateWithView = booleanEvaluator(
      flatStyle,
      prefix + "rotate-with-view",
      context
    );
    const anchorOrigin = optionalIconOrigin(flatStyle, prefix + "anchor-origin");
    const anchorXUnits = optionalIconAnchorUnits(
      flatStyle,
      prefix + "anchor-x-units"
    );
    const anchorYUnits = optionalIconAnchorUnits(
      flatStyle,
      prefix + "anchor-y-units"
    );
    const color = optionalColorLike(flatStyle, prefix + "color");
    const crossOrigin = optionalString(flatStyle, prefix + "cross-origin");
    const offset2 = optionalNumberArray(flatStyle, prefix + "offset");
    const offsetOrigin = optionalIconOrigin(flatStyle, prefix + "offset-origin");
    const width = optionalNumber(flatStyle, prefix + "width");
    const height = optionalNumber(flatStyle, prefix + "height");
    const size = optionalSize(flatStyle, prefix + "size");
    const declutterMode = optionalDeclutterMode(flatStyle, prefix + "declutter");
    const icon = new Icon_default({
      src,
      anchorOrigin,
      anchorXUnits,
      anchorYUnits,
      color,
      crossOrigin,
      offset: offset2,
      offsetOrigin,
      height,
      width,
      size,
      declutterMode
    });
    return function(context2) {
      if (evaluateOpacity) {
        icon.setOpacity(evaluateOpacity(context2));
      }
      if (evaluateDisplacement) {
        icon.setDisplacement(evaluateDisplacement(context2));
      }
      if (evaluateRotation) {
        icon.setRotation(evaluateRotation(context2));
      }
      if (evaluateRotateWithView) {
        icon.setRotateWithView(evaluateRotateWithView(context2));
      }
      if (evaluateScale) {
        icon.setScale(evaluateScale(context2));
      }
      if (evaluateAnchor) {
        icon.setAnchor(evaluateAnchor(context2));
      }
      return icon;
    };
  }
  function buildShape(flatStyle, context) {
    const prefix = "shape-";
    const pointsName = prefix + "points";
    const points = requireNumber(flatStyle[pointsName], pointsName);
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
    const evaluateDisplacement = coordinateEvaluator(
      flatStyle,
      prefix + "displacement",
      context
    );
    const evaluateRotation = numberEvaluator(
      flatStyle,
      prefix + "rotation",
      context
    );
    const evaluateRotateWithView = booleanEvaluator(
      flatStyle,
      prefix + "rotate-with-view",
      context
    );
    const radius = optionalNumber(flatStyle, prefix + "radius");
    const radius1 = optionalNumber(flatStyle, prefix + "radius1");
    const radius2 = optionalNumber(flatStyle, prefix + "radius2");
    const angle = optionalNumber(flatStyle, prefix + "angle");
    const declutterMode = optionalDeclutterMode(
      flatStyle,
      prefix + "declutter-mode"
    );
    const shape = new RegularShape_default({
      points,
      radius,
      radius1,
      radius2,
      angle,
      declutterMode
    });
    return function(context2) {
      if (evaluateFill) {
        shape.setFill(evaluateFill(context2));
      }
      if (evaluateStroke) {
        shape.setStroke(evaluateStroke(context2));
      }
      if (evaluateDisplacement) {
        shape.setDisplacement(evaluateDisplacement(context2));
      }
      if (evaluateRotation) {
        shape.setRotation(evaluateRotation(context2));
      }
      if (evaluateRotateWithView) {
        shape.setRotateWithView(evaluateRotateWithView(context2));
      }
      if (evaluateScale) {
        shape.setScale(evaluateScale(context2));
      }
      return shape;
    };
  }
  function buildCircle(flatStyle, context) {
    const prefix = "circle-";
    const evaluateFill = buildFill(flatStyle, prefix, context);
    const evaluateStroke = buildStroke(flatStyle, prefix, context);
    const evaluateRadius = numberEvaluator(flatStyle, prefix + "radius", context);
    const evaluateScale = sizeLikeEvaluator(flatStyle, prefix + "scale", context);
    const evaluateDisplacement = coordinateEvaluator(
      flatStyle,
      prefix + "displacement",
      context
    );
    const evaluateRotation = numberEvaluator(
      flatStyle,
      prefix + "rotation",
      context
    );
    const evaluateRotateWithView = booleanEvaluator(
      flatStyle,
      prefix + "rotate-with-view",
      context
    );
    const declutterMode = optionalDeclutterMode(
      flatStyle,
      prefix + "declutter-mode"
    );
    const circle = new Circle_default({
      radius: 5,
      // this is arbitrary, but required - the evaluated radius is used below
      declutterMode
    });
    return function(context2) {
      if (evaluateRadius) {
        circle.setRadius(evaluateRadius(context2));
      }
      if (evaluateFill) {
        circle.setFill(evaluateFill(context2));
      }
      if (evaluateStroke) {
        circle.setStroke(evaluateStroke(context2));
      }
      if (evaluateDisplacement) {
        circle.setDisplacement(evaluateDisplacement(context2));
      }
      if (evaluateRotation) {
        circle.setRotation(evaluateRotation(context2));
      }
      if (evaluateRotateWithView) {
        circle.setRotateWithView(evaluateRotateWithView(context2));
      }
      if (evaluateScale) {
        circle.setScale(evaluateScale(context2));
      }
      return circle;
    };
  }
  function numberEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return void 0;
    }
    const evaluator = buildExpression(flatStyle[name], NumberType, context);
    return function(context2) {
      return requireNumber(evaluator(context2), name);
    };
  }
  function stringEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(flatStyle[name], StringType, context);
    return function(context2) {
      return requireString(evaluator(context2), name);
    };
  }
  function booleanEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(flatStyle[name], BooleanType, context);
    return function(context2) {
      const value = evaluator(context2);
      if (typeof value !== "boolean") {
        throw new Error(`Expected a boolean for ${name}`);
      }
      return value;
    };
  }
  function colorLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(
      flatStyle[name],
      ColorType | StringType,
      context
    );
    return function(context2) {
      return requireColorLike(evaluator(context2), name);
    };
  }
  function numberArrayEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
    return function(context2) {
      return requireNumberArray(evaluator(context2), name);
    };
  }
  function coordinateEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(flatStyle[name], NumberArrayType, context);
    return function(context2) {
      const array = requireNumberArray(evaluator(context2), name);
      if (array.length !== 2) {
        throw new Error(`Expected two numbers for ${name}`);
      }
      return array;
    };
  }
  function sizeLikeEvaluator(flatStyle, name, context) {
    if (!(name in flatStyle)) {
      return null;
    }
    const evaluator = buildExpression(
      flatStyle[name],
      NumberArrayType | NumberType,
      context
    );
    return function(context2) {
      return requireSizeLike(evaluator(context2), name);
    };
  }
  function optionalNumber(flatStyle, property) {
    const value = flatStyle[property];
    if (value === void 0) {
      return void 0;
    }
    if (typeof value !== "number") {
      throw new Error(`Expected a number for ${property}`);
    }
    return value;
  }
  function optionalSize(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    if (typeof encoded === "number") {
      return toSize(encoded);
    }
    if (!Array.isArray(encoded)) {
      throw new Error(`Expected a number or size array for ${property}`);
    }
    if (encoded.length !== 2 || typeof encoded[0] !== "number" || typeof encoded[1] !== "number") {
      throw new Error(`Expected a number or size array for ${property}`);
    }
    return encoded;
  }
  function optionalString(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    if (typeof encoded !== "string") {
      throw new Error(`Expected a string for ${property}`);
    }
    return encoded;
  }
  function optionalIconOrigin(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    if (encoded !== "bottom-left" && encoded !== "bottom-right" && encoded !== "top-left" && encoded !== "top-right") {
      throw new Error(
        `Expected bottom-left, bottom-right, top-left, or top-right for ${property}`
      );
    }
    return encoded;
  }
  function optionalIconAnchorUnits(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    if (encoded !== "pixels" && encoded !== "fraction") {
      throw new Error(`Expected pixels or fraction for ${property}`);
    }
    return encoded;
  }
  function optionalNumberArray(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    return requireNumberArray(encoded, property);
  }
  function optionalDeclutterMode(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    if (typeof encoded !== "string") {
      throw new Error(`Expected a string for ${property}`);
    }
    if (encoded !== "declutter" && encoded !== "obstacle" && encoded !== "none") {
      throw new Error(`Expected declutter, obstacle, or none for ${property}`);
    }
    return encoded;
  }
  function optionalColorLike(flatStyle, property) {
    const encoded = flatStyle[property];
    if (encoded === void 0) {
      return void 0;
    }
    return requireColorLike(encoded, property);
  }
  function requireNumberArray(value, property) {
    if (!Array.isArray(value)) {
      throw new Error(`Expected an array for ${property}`);
    }
    const length = value.length;
    for (let i4 = 0; i4 < length; ++i4) {
      if (typeof value[i4] !== "number") {
        throw new Error(`Expected an array of numbers for ${property}`);
      }
    }
    return value;
  }
  function requireString(value, property) {
    if (typeof value !== "string") {
      throw new Error(`Expected a string for ${property}`);
    }
    return value;
  }
  function requireNumber(value, property) {
    if (typeof value !== "number") {
      throw new Error(`Expected a number for ${property}`);
    }
    return value;
  }
  function requireColorLike(value, property) {
    if (typeof value === "string") {
      return value;
    }
    const array = requireNumberArray(value, property);
    const length = array.length;
    if (length < 3 || length > 4) {
      throw new Error(`Expected a color with 3 or 4 values for ${property}`);
    }
    return array;
  }
  function requireSizeLike(value, property) {
    if (typeof value === "number") {
      return value;
    }
    const size = requireNumberArray(value, property);
    if (size.length !== 2) {
      throw new Error(`Expected an array of two numbers for ${property}`);
    }
    return size;
  }

  // node_modules/ol/layer/BaseVector.js
  var Property3 = {
    RENDER_ORDER: "renderOrder"
  };
  var BaseVectorLayer = class extends Layer_default {
    /**
     * @param {Options<VectorSourceType>} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      const baseOptions = Object.assign({}, options);
      delete baseOptions.style;
      delete baseOptions.renderBuffer;
      delete baseOptions.updateWhileAnimating;
      delete baseOptions.updateWhileInteracting;
      super(baseOptions);
      this.declutter_ = options.declutter !== void 0 ? options.declutter : false;
      this.renderBuffer_ = options.renderBuffer !== void 0 ? options.renderBuffer : 100;
      this.style_ = null;
      this.styleFunction_ = void 0;
      this.setStyle(options.style);
      this.updateWhileAnimating_ = options.updateWhileAnimating !== void 0 ? options.updateWhileAnimating : false;
      this.updateWhileInteracting_ = options.updateWhileInteracting !== void 0 ? options.updateWhileInteracting : false;
    }
    /**
     * @return {boolean} Declutter.
     */
    getDeclutter() {
      return this.declutter_;
    }
    /**
     * Get the topmost feature that intersects the given pixel on the viewport. Returns a promise
     * that resolves with an array of features. The array will either contain the topmost feature
     * when a hit was detected, or it will be empty.
     *
     * The hit detection algorithm used for this method is optimized for performance, but is less
     * accurate than the one used in [map.getFeaturesAtPixel()]{@link import("../Map.js").default#getFeaturesAtPixel}.
     * Text is not considered, and icons are only represented by their bounding box instead of the exact
     * image.
     *
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with an array of features.
     * @api
     */
    getFeatures(pixel) {
      return super.getFeatures(pixel);
    }
    /**
     * @return {number|undefined} Render buffer.
     */
    getRenderBuffer() {
      return this.renderBuffer_;
    }
    /**
     * @return {function(import("../Feature.js").default, import("../Feature.js").default): number|null|undefined} Render
     *     order.
     */
    getRenderOrder() {
      return (
        /** @type {import("../render.js").OrderFunction|null|undefined} */
        this.get(Property3.RENDER_ORDER)
      );
    }
    /**
     * Get the style for features.  This returns whatever was passed to the `style`
     * option at construction or to the `setStyle` method.
     * @return {import("../style/Style.js").StyleLike|null|undefined} Layer style.
     * @api
     */
    getStyle() {
      return this.style_;
    }
    /**
     * Get the style function.
     * @return {import("../style/Style.js").StyleFunction|undefined} Layer style function.
     * @api
     */
    getStyleFunction() {
      return this.styleFunction_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     animating.
     */
    getUpdateWhileAnimating() {
      return this.updateWhileAnimating_;
    }
    /**
     * @return {boolean} Whether the rendered layer should be updated while
     *     interacting.
     */
    getUpdateWhileInteracting() {
      return this.updateWhileInteracting_;
    }
    /**
     * Render declutter items for this layer
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(frameState) {
      if (!frameState.declutterTree) {
        frameState.declutterTree = new import_rbush.default(9);
      }
      this.getRenderer().renderDeclutter(frameState);
    }
    /**
     * @param {import("../render.js").OrderFunction|null|undefined} renderOrder
     *     Render order.
     */
    setRenderOrder(renderOrder) {
      this.set(Property3.RENDER_ORDER, renderOrder);
    }
    /**
     * Set the style for features.  This can be a single style object, an array
     * of styles, or a function that takes a feature and resolution and returns
     * an array of styles. If set to `null`, the layer has no style (a `null` style),
     * so only features that have their own styles will be rendered in the layer. Call
     * `setStyle()` without arguments to reset to the default style. See
     * [the ol/style/Style module]{@link module:ol/style/Style~Style} for information on the default style.
     *
     * If your layer has a static style, you can use [flat style]{@link module:ol/style/flat~FlatStyle} object
     * literals instead of using the `Style` and symbolizer constructors (`Fill`, `Stroke`, etc.):
     * ```js
     * vectorLayer.setStyle({
     *   "fill-color": "yellow",
     *   "stroke-color": "black",
     *   "stroke-width": 4
     * })
     * ```
     *
     * @param {import("../style/Style.js").StyleLike|import("../style/flat.js").FlatStyleLike|null} [style] Layer style.
     * @api
     */
    setStyle(style) {
      this.style_ = toStyleLike(style);
      this.styleFunction_ = style === null ? void 0 : toFunction(this.style_);
      this.changed();
    }
  };
  function toStyleLike(style) {
    if (style === void 0) {
      return createDefaultStyle;
    }
    if (!style) {
      return null;
    }
    if (typeof style === "function") {
      return style;
    }
    if (style instanceof Style_default) {
      return style;
    }
    if (!Array.isArray(style)) {
      return flatStylesToStyleFunction([style]);
    }
    if (style.length === 0) {
      return [];
    }
    const length = style.length;
    const first = style[0];
    if (first instanceof Style_default) {
      const styles = new Array(length);
      for (let i4 = 0; i4 < length; ++i4) {
        const candidate = style[i4];
        if (!(candidate instanceof Style_default)) {
          throw new Error("Expected a list of style instances");
        }
        styles[i4] = candidate;
      }
      return styles;
    }
    if ("style" in first) {
      const rules = new Array(length);
      for (let i4 = 0; i4 < length; ++i4) {
        const candidate = style[i4];
        if (!("style" in candidate)) {
          throw new Error("Expected a list of rules with a style property");
        }
        rules[i4] = candidate;
      }
      return rulesToStyleFunction(rules);
    }
    const flatStyles = (
      /** @type {Array<import("../style/flat.js").FlatStyle>} */
      style
    );
    return flatStylesToStyleFunction(flatStyles);
  }
  var BaseVector_default = BaseVectorLayer;

  // node_modules/ol/render/canvas/Instruction.js
  var Instruction = {
    BEGIN_GEOMETRY: 0,
    BEGIN_PATH: 1,
    CIRCLE: 2,
    CLOSE_PATH: 3,
    CUSTOM: 4,
    DRAW_CHARS: 5,
    DRAW_IMAGE: 6,
    END_GEOMETRY: 7,
    FILL: 8,
    MOVE_TO_LINE_TO: 9,
    SET_FILL_STYLE: 10,
    SET_STROKE_STYLE: 11,
    STROKE: 12
  };
  var fillInstruction = [Instruction.FILL];
  var strokeInstruction = [Instruction.STROKE];
  var beginPathInstruction = [Instruction.BEGIN_PATH];
  var closePathInstruction = [Instruction.CLOSE_PATH];
  var Instruction_default = Instruction;

  // node_modules/ol/render/VectorContext.js
  var VectorContext = class {
    /**
     * Render a geometry with a custom renderer.
     *
     * @param {import("../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
    }
    /**
     * Render a geometry.
     *
     * @param {import("../geom/Geometry.js").default} geometry The geometry to render.
     */
    drawGeometry(geometry) {
    }
    /**
     * Set the rendering style.
     *
     * @param {import("../style/Style.js").default} style The rendering style.
     */
    setStyle(style) {
    }
    /**
     * @param {import("../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../Feature.js").default} feature Feature.
     */
    drawCircle(circleGeometry, feature) {
    }
    /**
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("../style/Style.js").default} style Style.
     */
    drawFeature(feature, style) {
    }
    /**
     * @param {import("../geom/GeometryCollection.js").default} geometryCollectionGeometry Geometry collection.
     * @param {import("../Feature.js").default} feature Feature.
     */
    drawGeometryCollection(geometryCollectionGeometry, feature) {
    }
    /**
     * @param {import("../geom/LineString.js").default|import("./Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawLineString(lineStringGeometry, feature) {
    }
    /**
     * @param {import("../geom/MultiLineString.js").default|import("./Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiLineString(multiLineStringGeometry, feature) {
    }
    /**
     * @param {import("../geom/MultiPoint.js").default|import("./Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiPoint(multiPointGeometry, feature) {
    }
    /**
     * @param {import("../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiPolygon(multiPolygonGeometry, feature) {
    }
    /**
     * @param {import("../geom/Point.js").default|import("./Feature.js").default} pointGeometry Point geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawPoint(pointGeometry, feature) {
    }
    /**
     * @param {import("../geom/Polygon.js").default|import("./Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawPolygon(polygonGeometry, feature) {
    }
    /**
     * @param {import("../geom/SimpleGeometry.js").default|import("./Feature.js").default} geometry Geometry.
     * @param {import("../Feature.js").FeatureLike} feature Feature.
     */
    drawText(geometry, feature) {
    }
    /**
     * @param {import("../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(fillStyle, strokeStyle) {
    }
    /**
     * @param {import("../style/Image.js").default} imageStyle Image style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with a text style.
     */
    setImageStyle(imageStyle, declutterImageWithText) {
    }
    /**
     * @param {import("../style/Text.js").default} textStyle Text style.
     * @param {import("../render/canvas.js").DeclutterImageWithText} [declutterImageWithText] Shared data for combined decluttering with an image style.
     */
    setTextStyle(textStyle, declutterImageWithText) {
    }
  };
  var VectorContext_default = VectorContext;

  // node_modules/ol/render/canvas/Builder.js
  var CanvasBuilder = class extends VectorContext_default {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super();
      this.tolerance = tolerance;
      this.maxExtent = maxExtent;
      this.pixelRatio = pixelRatio;
      this.maxLineWidth = 0;
      this.resolution = resolution;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_ = null;
      this.bufferedMaxExtent_ = null;
      this.instructions = [];
      this.coordinates = [];
      this.tmpCoordinate_ = [];
      this.hitDetectionInstructions = [];
      this.state = /** @type {import("../canvas.js").FillStrokeState} */
      {};
    }
    /**
     * @protected
     * @param {Array<number>} dashArray Dash array.
     * @return {Array<number>} Dash array with pixel ratio applied
     */
    applyPixelRatio(dashArray) {
      const pixelRatio = this.pixelRatio;
      return pixelRatio == 1 ? dashArray : dashArray.map(function(dash) {
        return dash * pixelRatio;
      });
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} stride Stride.
     * @protected
     * @return {number} My end
     */
    appendFlatPointCoordinates(flatCoordinates, stride) {
      const extent = this.getBufferedMaxExtent();
      const tmpCoord = this.tmpCoordinate_;
      const coordinates2 = this.coordinates;
      let myEnd = coordinates2.length;
      for (let i4 = 0, ii = flatCoordinates.length; i4 < ii; i4 += stride) {
        tmpCoord[0] = flatCoordinates[i4];
        tmpCoord[1] = flatCoordinates[i4 + 1];
        if (containsCoordinate(extent, tmpCoord)) {
          coordinates2[myEnd++] = tmpCoord[0];
          coordinates2[myEnd++] = tmpCoord[1];
        }
      }
      return myEnd;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} closed Last input coordinate equals first.
     * @param {boolean} skipFirst Skip first coordinate.
     * @protected
     * @return {number} My end.
     */
    appendFlatLineCoordinates(flatCoordinates, offset2, end, stride, closed, skipFirst) {
      const coordinates2 = this.coordinates;
      let myEnd = coordinates2.length;
      const extent = this.getBufferedMaxExtent();
      if (skipFirst) {
        offset2 += stride;
      }
      let lastXCoord = flatCoordinates[offset2];
      let lastYCoord = flatCoordinates[offset2 + 1];
      const nextCoord = this.tmpCoordinate_;
      let skipped = true;
      let i4, lastRel, nextRel;
      for (i4 = offset2 + stride; i4 < end; i4 += stride) {
        nextCoord[0] = flatCoordinates[i4];
        nextCoord[1] = flatCoordinates[i4 + 1];
        nextRel = coordinateRelationship(extent, nextCoord);
        if (nextRel !== lastRel) {
          if (skipped) {
            coordinates2[myEnd++] = lastXCoord;
            coordinates2[myEnd++] = lastYCoord;
            skipped = false;
          }
          coordinates2[myEnd++] = nextCoord[0];
          coordinates2[myEnd++] = nextCoord[1];
        } else if (nextRel === Relationship_default.INTERSECTING) {
          coordinates2[myEnd++] = nextCoord[0];
          coordinates2[myEnd++] = nextCoord[1];
          skipped = false;
        } else {
          skipped = true;
        }
        lastXCoord = nextCoord[0];
        lastYCoord = nextCoord[1];
        lastRel = nextRel;
      }
      if (closed && skipped || i4 === offset2 + stride) {
        coordinates2[myEnd++] = lastXCoord;
        coordinates2[myEnd++] = lastYCoord;
      }
      return myEnd;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @param {Array<number>} builderEnds Builder ends.
     * @return {number} Offset.
     */
    drawCustomCoordinates_(flatCoordinates, offset2, ends, stride, builderEnds) {
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        const end = ends[i4];
        const builderEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset2,
          end,
          stride,
          false,
          false
        );
        builderEnds.push(builderEnd);
        offset2 = end;
      }
      return offset2;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @param {Function} renderer Renderer.
     * @param {Function} hitDetectionRenderer Renderer.
     */
    drawCustom(geometry, feature, renderer, hitDetectionRenderer) {
      this.beginGeometry(geometry, feature);
      const type = geometry.getType();
      const stride = geometry.getStride();
      const builderBegin = this.coordinates.length;
      let flatCoordinates, builderEnd, builderEnds, builderEndss;
      let offset2;
      switch (type) {
        case "MultiPolygon":
          flatCoordinates = /** @type {import("../../geom/MultiPolygon.js").default} */
          geometry.getOrientedFlatCoordinates();
          builderEndss = [];
          const endss = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getEndss()
          );
          offset2 = 0;
          for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
            const myEnds = [];
            offset2 = this.drawCustomCoordinates_(
              flatCoordinates,
              offset2,
              endss[i4],
              stride,
              myEnds
            );
            builderEndss.push(myEnds);
          }
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEndss,
            geometry,
            renderer,
            inflateMultiCoordinatesArray
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEndss,
            geometry,
            hitDetectionRenderer || renderer,
            inflateMultiCoordinatesArray
          ]);
          break;
        case "Polygon":
        case "MultiLineString":
          builderEnds = [];
          flatCoordinates = type == "Polygon" ? (
            /** @type {import("../../geom/Polygon.js").default} */
            geometry.getOrientedFlatCoordinates()
          ) : geometry.getFlatCoordinates();
          offset2 = this.drawCustomCoordinates_(
            flatCoordinates,
            0,
            /** @type {import("../../geom/Polygon.js").default|import("../../geom/MultiLineString.js").default} */
            geometry.getEnds(),
            stride,
            builderEnds
          );
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnds,
            geometry,
            renderer,
            inflateCoordinatesArray
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnds,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinatesArray
          ]);
          break;
        case "LineString":
        case "Circle":
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatLineCoordinates(
            flatCoordinates,
            0,
            flatCoordinates.length,
            stride,
            false,
            false
          );
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer,
            inflateCoordinates
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer,
            inflateCoordinates
          ]);
          break;
        case "MultiPoint":
          flatCoordinates = geometry.getFlatCoordinates();
          builderEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
          if (builderEnd > builderBegin) {
            this.instructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              renderer,
              inflateCoordinates
            ]);
            this.hitDetectionInstructions.push([
              Instruction_default.CUSTOM,
              builderBegin,
              builderEnd,
              geometry,
              hitDetectionRenderer || renderer,
              inflateCoordinates
            ]);
          }
          break;
        case "Point":
          flatCoordinates = geometry.getFlatCoordinates();
          this.coordinates.push(flatCoordinates[0], flatCoordinates[1]);
          builderEnd = this.coordinates.length;
          this.instructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            renderer
          ]);
          this.hitDetectionInstructions.push([
            Instruction_default.CUSTOM,
            builderBegin,
            builderEnd,
            geometry,
            hitDetectionRenderer || renderer
          ]);
          break;
        default:
      }
      this.endGeometry(feature);
    }
    /**
     * @protected
     * @param {import("../../geom/Geometry").default|import("../Feature.js").default} geometry The geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    beginGeometry(geometry, feature) {
      this.beginGeometryInstruction1_ = [
        Instruction_default.BEGIN_GEOMETRY,
        feature,
        0,
        geometry
      ];
      this.instructions.push(this.beginGeometryInstruction1_);
      this.beginGeometryInstruction2_ = [
        Instruction_default.BEGIN_GEOMETRY,
        feature,
        0,
        geometry
      ];
      this.hitDetectionInstructions.push(this.beginGeometryInstruction2_);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      return {
        instructions: this.instructions,
        hitDetectionInstructions: this.hitDetectionInstructions,
        coordinates: this.coordinates
      };
    }
    /**
     * Reverse the hit detection instructions.
     */
    reverseHitDetectionInstructions() {
      const hitDetectionInstructions = this.hitDetectionInstructions;
      hitDetectionInstructions.reverse();
      let i4;
      const n2 = hitDetectionInstructions.length;
      let instruction;
      let type;
      let begin = -1;
      for (i4 = 0; i4 < n2; ++i4) {
        instruction = hitDetectionInstructions[i4];
        type = /** @type {import("./Instruction.js").default} */
        instruction[0];
        if (type == Instruction_default.END_GEOMETRY) {
          begin = i4;
        } else if (type == Instruction_default.BEGIN_GEOMETRY) {
          instruction[2] = i4;
          reverseSubArray(this.hitDetectionInstructions, begin, i4);
          begin = -1;
        }
      }
    }
    /**
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(fillStyle, strokeStyle) {
      const state = this.state;
      if (fillStyle) {
        const fillStyleColor = fillStyle.getColor();
        state.fillStyle = asColorLike(
          fillStyleColor ? fillStyleColor : defaultFillStyle
        );
      } else {
        state.fillStyle = void 0;
      }
      if (strokeStyle) {
        const strokeStyleColor = strokeStyle.getColor();
        state.strokeStyle = asColorLike(
          strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
        );
        const strokeStyleLineCap = strokeStyle.getLineCap();
        state.lineCap = strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap;
        const strokeStyleLineDash = strokeStyle.getLineDash();
        state.lineDash = strokeStyleLineDash ? strokeStyleLineDash.slice() : defaultLineDash;
        const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        state.lineDashOffset = strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset;
        const strokeStyleLineJoin = strokeStyle.getLineJoin();
        state.lineJoin = strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin;
        const strokeStyleWidth = strokeStyle.getWidth();
        state.lineWidth = strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth;
        const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        state.miterLimit = strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit;
        if (state.lineWidth > this.maxLineWidth) {
          this.maxLineWidth = state.lineWidth;
          this.bufferedMaxExtent_ = null;
        }
      } else {
        state.strokeStyle = void 0;
        state.lineCap = void 0;
        state.lineDash = null;
        state.lineDashOffset = void 0;
        state.lineJoin = void 0;
        state.lineWidth = void 0;
        state.miterLimit = void 0;
      }
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Fill instruction.
     */
    createFill(state) {
      const fillStyle = state.fillStyle;
      const fillInstruction2 = [Instruction_default.SET_FILL_STYLE, fillStyle];
      if (typeof fillStyle !== "string") {
        fillInstruction2.push(true);
      }
      return fillInstruction2;
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(state) {
      this.instructions.push(this.createStroke(state));
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @return {Array<*>} Stroke instruction.
     */
    createStroke(state) {
      return [
        Instruction_default.SET_STROKE_STYLE,
        state.strokeStyle,
        state.lineWidth * this.pixelRatio,
        state.lineCap,
        state.lineJoin,
        state.miterLimit,
        this.applyPixelRatio(state.lineDash),
        state.lineDashOffset * this.pixelRatio
      ];
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState):Array<*>} createFill Create fill.
     */
    updateFillStyle(state, createFill) {
      const fillStyle = state.fillStyle;
      if (typeof fillStyle !== "string" || state.currentFillStyle != fillStyle) {
        if (fillStyle !== void 0) {
          this.instructions.push(createFill.call(this, state));
        }
        state.currentFillStyle = fillStyle;
      }
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     * @param {function(this:CanvasBuilder, import("../canvas.js").FillStrokeState): void} applyStroke Apply stroke.
     */
    updateStrokeStyle(state, applyStroke) {
      const strokeStyle = state.strokeStyle;
      const lineCap = state.lineCap;
      const lineDash = state.lineDash;
      const lineDashOffset = state.lineDashOffset;
      const lineJoin = state.lineJoin;
      const lineWidth = state.lineWidth;
      const miterLimit = state.miterLimit;
      if (state.currentStrokeStyle != strokeStyle || state.currentLineCap != lineCap || lineDash != state.currentLineDash && !equals(state.currentLineDash, lineDash) || state.currentLineDashOffset != lineDashOffset || state.currentLineJoin != lineJoin || state.currentLineWidth != lineWidth || state.currentMiterLimit != miterLimit) {
        if (strokeStyle !== void 0) {
          applyStroke.call(this, state);
        }
        state.currentStrokeStyle = strokeStyle;
        state.currentLineCap = lineCap;
        state.currentLineDash = lineDash;
        state.currentLineDashOffset = lineDashOffset;
        state.currentLineJoin = lineJoin;
        state.currentLineWidth = lineWidth;
        state.currentMiterLimit = miterLimit;
      }
    }
    /**
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    endGeometry(feature) {
      this.beginGeometryInstruction1_[2] = this.instructions.length;
      this.beginGeometryInstruction1_ = null;
      this.beginGeometryInstruction2_[2] = this.hitDetectionInstructions.length;
      this.beginGeometryInstruction2_ = null;
      const endGeometryInstruction = [Instruction_default.END_GEOMETRY, feature];
      this.instructions.push(endGeometryInstruction);
      this.hitDetectionInstructions.push(endGeometryInstruction);
    }
    /**
     * Get the buffered rendering extent.  Rendering will be clipped to the extent
     * provided to the constructor.  To account for symbolizers that may intersect
     * this extent, we calculate a buffered extent (e.g. based on stroke width).
     * @return {import("../../extent.js").Extent} The buffered rendering extent.
     * @protected
     */
    getBufferedMaxExtent() {
      if (!this.bufferedMaxExtent_) {
        this.bufferedMaxExtent_ = clone(this.maxExtent);
        if (this.maxLineWidth > 0) {
          const width = this.resolution * (this.maxLineWidth + 1) / 2;
          buffer(this.bufferedMaxExtent_, width, this.bufferedMaxExtent_);
        }
      }
      return this.bufferedMaxExtent_;
    }
  };
  var Builder_default = CanvasBuilder;

  // node_modules/ol/render/canvas/ImageBuilder.js
  var CanvasImageBuilder = class extends Builder_default {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
      this.hitDetectionImage_ = null;
      this.image_ = null;
      this.imagePixelRatio_ = void 0;
      this.anchorX_ = void 0;
      this.anchorY_ = void 0;
      this.height_ = void 0;
      this.opacity_ = void 0;
      this.originX_ = void 0;
      this.originY_ = void 0;
      this.rotateWithView_ = void 0;
      this.rotation_ = void 0;
      this.scale_ = void 0;
      this.width_ = void 0;
      this.declutterMode_ = void 0;
      this.declutterImageWithText_ = void 0;
    }
    /**
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} pointGeometry Point geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawPoint(pointGeometry, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(pointGeometry, feature);
      const flatCoordinates = pointGeometry.getFlatCoordinates();
      const stride = pointGeometry.getStride();
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([
        Instruction_default.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.hitDetectionInstructions.push([
        Instruction_default.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} multiPointGeometry MultiPoint geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiPoint(multiPointGeometry, feature) {
      if (!this.image_) {
        return;
      }
      this.beginGeometry(multiPointGeometry, feature);
      const flatCoordinates = multiPointGeometry.getFlatCoordinates();
      const stride = multiPointGeometry.getStride();
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatPointCoordinates(flatCoordinates, stride);
      this.instructions.push([
        Instruction_default.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.image_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_ * this.imagePixelRatio_,
        this.anchorY_ * this.imagePixelRatio_,
        Math.ceil(this.height_ * this.imagePixelRatio_),
        this.opacity_,
        this.originX_ * this.imagePixelRatio_,
        this.originY_ * this.imagePixelRatio_,
        this.rotateWithView_,
        this.rotation_,
        [
          this.scale_[0] * this.pixelRatio / this.imagePixelRatio_,
          this.scale_[1] * this.pixelRatio / this.imagePixelRatio_
        ],
        Math.ceil(this.width_ * this.imagePixelRatio_),
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.hitDetectionInstructions.push([
        Instruction_default.DRAW_IMAGE,
        myBegin,
        myEnd,
        this.hitDetectionImage_,
        // Remaining arguments to DRAW_IMAGE are in alphabetical order
        this.anchorX_,
        this.anchorY_,
        this.height_,
        1,
        this.originX_,
        this.originY_,
        this.rotateWithView_,
        this.rotation_,
        this.scale_,
        this.width_,
        this.declutterMode_,
        this.declutterImageWithText_
      ]);
      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      this.reverseHitDetectionInstructions();
      this.anchorX_ = void 0;
      this.anchorY_ = void 0;
      this.hitDetectionImage_ = null;
      this.image_ = null;
      this.imagePixelRatio_ = void 0;
      this.height_ = void 0;
      this.scale_ = void 0;
      this.opacity_ = void 0;
      this.originX_ = void 0;
      this.originY_ = void 0;
      this.rotateWithView_ = void 0;
      this.rotation_ = void 0;
      this.width_ = void 0;
      return super.finish();
    }
    /**
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     * @param {Object} [sharedData] Shared data.
     */
    setImageStyle(imageStyle, sharedData) {
      const anchor = imageStyle.getAnchor();
      const size = imageStyle.getSize();
      const origin = imageStyle.getOrigin();
      this.imagePixelRatio_ = imageStyle.getPixelRatio(this.pixelRatio);
      this.anchorX_ = anchor[0];
      this.anchorY_ = anchor[1];
      this.hitDetectionImage_ = imageStyle.getHitDetectionImage();
      this.image_ = imageStyle.getImage(this.pixelRatio);
      this.height_ = size[1];
      this.opacity_ = imageStyle.getOpacity();
      this.originX_ = origin[0];
      this.originY_ = origin[1];
      this.rotateWithView_ = imageStyle.getRotateWithView();
      this.rotation_ = imageStyle.getRotation();
      this.scale_ = imageStyle.getScaleArray();
      this.width_ = size[0];
      this.declutterMode_ = imageStyle.getDeclutterMode();
      this.declutterImageWithText_ = sharedData;
    }
  };
  var ImageBuilder_default = CanvasImageBuilder;

  // node_modules/ol/render/canvas/LineStringBuilder.js
  var CanvasLineStringBuilder = class extends Builder_default {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     * @return {number} end.
     */
    drawFlatCoordinates_(flatCoordinates, offset2, end, stride) {
      const myBegin = this.coordinates.length;
      const myEnd = this.appendFlatLineCoordinates(
        flatCoordinates,
        offset2,
        end,
        stride,
        false,
        false
      );
      const moveToLineToInstruction = [
        Instruction_default.MOVE_TO_LINE_TO,
        myBegin,
        myEnd
      ];
      this.instructions.push(moveToLineToInstruction);
      this.hitDetectionInstructions.push(moveToLineToInstruction);
      return end;
    }
    /**
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} lineStringGeometry Line string geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawLineString(lineStringGeometry, feature) {
      const state = this.state;
      const strokeStyle = state.strokeStyle;
      const lineWidth = state.lineWidth;
      if (strokeStyle === void 0 || lineWidth === void 0) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(lineStringGeometry, feature);
      this.hitDetectionInstructions.push(
        [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          defaultLineDash,
          defaultLineDashOffset
        ],
        beginPathInstruction
      );
      const flatCoordinates = lineStringGeometry.getFlatCoordinates();
      const stride = lineStringGeometry.getStride();
      this.drawFlatCoordinates_(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride
      );
      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} multiLineStringGeometry MultiLineString geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiLineString(multiLineStringGeometry, feature) {
      const state = this.state;
      const strokeStyle = state.strokeStyle;
      const lineWidth = state.lineWidth;
      if (strokeStyle === void 0 || lineWidth === void 0) {
        return;
      }
      this.updateStrokeStyle(state, this.applyStroke);
      this.beginGeometry(multiLineStringGeometry, feature);
      this.hitDetectionInstructions.push(
        [
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          defaultLineDash,
          defaultLineDashOffset
        ],
        beginPathInstruction
      );
      const ends = multiLineStringGeometry.getEnds();
      const flatCoordinates = multiLineStringGeometry.getFlatCoordinates();
      const stride = multiLineStringGeometry.getStride();
      let offset2 = 0;
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        offset2 = this.drawFlatCoordinates_(
          flatCoordinates,
          offset2,
          /** @type {number} */
          ends[i4],
          stride
        );
      }
      this.hitDetectionInstructions.push(strokeInstruction);
      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      const state = this.state;
      if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
      }
      this.reverseHitDetectionInstructions();
      this.state = null;
      return super.finish();
    }
    /**
     * @param {import("../canvas.js").FillStrokeState} state State.
     */
    applyStroke(state) {
      if (state.lastStroke != void 0 && state.lastStroke != this.coordinates.length) {
        this.instructions.push(strokeInstruction);
        state.lastStroke = this.coordinates.length;
      }
      state.lastStroke = 0;
      super.applyStroke(state);
      this.instructions.push(beginPathInstruction);
    }
  };
  var LineStringBuilder_default = CanvasLineStringBuilder;

  // node_modules/ol/render/canvas/PolygonBuilder.js
  var CanvasPolygonBuilder = class extends Builder_default {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawFlatCoordinatess_(flatCoordinates, offset2, ends, stride) {
      const state = this.state;
      const fill = state.fillStyle !== void 0;
      const stroke = state.strokeStyle !== void 0;
      const numEnds = ends.length;
      this.instructions.push(beginPathInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction);
      for (let i4 = 0; i4 < numEnds; ++i4) {
        const end = ends[i4];
        const myBegin = this.coordinates.length;
        const myEnd = this.appendFlatLineCoordinates(
          flatCoordinates,
          offset2,
          end,
          stride,
          true,
          !stroke
        );
        const moveToLineToInstruction = [
          Instruction_default.MOVE_TO_LINE_TO,
          myBegin,
          myEnd
        ];
        this.instructions.push(moveToLineToInstruction);
        this.hitDetectionInstructions.push(moveToLineToInstruction);
        if (stroke) {
          this.instructions.push(closePathInstruction);
          this.hitDetectionInstructions.push(closePathInstruction);
        }
        offset2 = end;
      }
      if (fill) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }
      if (stroke) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }
      return offset2;
    }
    /**
     * @param {import("../../geom/Circle.js").default} circleGeometry Circle geometry.
     * @param {import("../../Feature.js").default} feature Feature.
     */
    drawCircle(circleGeometry, feature) {
      const state = this.state;
      const fillStyle = state.fillStyle;
      const strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(circleGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          defaultLineDash,
          defaultLineDashOffset
        ]);
      }
      const flatCoordinates = circleGeometry.getFlatCoordinates();
      const stride = circleGeometry.getStride();
      const myBegin = this.coordinates.length;
      this.appendFlatLineCoordinates(
        flatCoordinates,
        0,
        flatCoordinates.length,
        stride,
        false,
        false
      );
      const circleInstruction = [Instruction_default.CIRCLE, myBegin];
      this.instructions.push(beginPathInstruction, circleInstruction);
      this.hitDetectionInstructions.push(beginPathInstruction, circleInstruction);
      if (state.fillStyle !== void 0) {
        this.instructions.push(fillInstruction);
        this.hitDetectionInstructions.push(fillInstruction);
      }
      if (state.strokeStyle !== void 0) {
        this.instructions.push(strokeInstruction);
        this.hitDetectionInstructions.push(strokeInstruction);
      }
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} polygonGeometry Polygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawPolygon(polygonGeometry, feature) {
      const state = this.state;
      const fillStyle = state.fillStyle;
      const strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(polygonGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          defaultLineDash,
          defaultLineDashOffset
        ]);
      }
      const ends = polygonGeometry.getEnds();
      const flatCoordinates = polygonGeometry.getOrientedFlatCoordinates();
      const stride = polygonGeometry.getStride();
      this.drawFlatCoordinatess_(
        flatCoordinates,
        0,
        /** @type {Array<number>} */
        ends,
        stride
      );
      this.endGeometry(feature);
    }
    /**
     * @param {import("../../geom/MultiPolygon.js").default} multiPolygonGeometry MultiPolygon geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawMultiPolygon(multiPolygonGeometry, feature) {
      const state = this.state;
      const fillStyle = state.fillStyle;
      const strokeStyle = state.strokeStyle;
      if (fillStyle === void 0 && strokeStyle === void 0) {
        return;
      }
      this.setFillStrokeStyles_();
      this.beginGeometry(multiPolygonGeometry, feature);
      if (state.fillStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_FILL_STYLE,
          defaultFillStyle
        ]);
      }
      if (state.strokeStyle !== void 0) {
        this.hitDetectionInstructions.push([
          Instruction_default.SET_STROKE_STYLE,
          state.strokeStyle,
          state.lineWidth,
          state.lineCap,
          state.lineJoin,
          state.miterLimit,
          defaultLineDash,
          defaultLineDashOffset
        ]);
      }
      const endss = multiPolygonGeometry.getEndss();
      const flatCoordinates = multiPolygonGeometry.getOrientedFlatCoordinates();
      const stride = multiPolygonGeometry.getStride();
      let offset2 = 0;
      for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
        offset2 = this.drawFlatCoordinatess_(
          flatCoordinates,
          offset2,
          endss[i4],
          stride
        );
      }
      this.endGeometry(feature);
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      this.reverseHitDetectionInstructions();
      this.state = null;
      const tolerance = this.tolerance;
      if (tolerance !== 0) {
        const coordinates2 = this.coordinates;
        for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
          coordinates2[i4] = snap(coordinates2[i4], tolerance);
        }
      }
      return super.finish();
    }
    /**
     * @private
     */
    setFillStrokeStyles_() {
      const state = this.state;
      const fillStyle = state.fillStyle;
      if (fillStyle !== void 0) {
        this.updateFillStyle(state, this.createFill);
      }
      if (state.strokeStyle !== void 0) {
        this.updateStrokeStyle(state, this.applyStroke);
      }
    }
  };
  var PolygonBuilder_default = CanvasPolygonBuilder;

  // node_modules/ol/geom/flat/linechunk.js
  function lineChunk(chunkLength, flatCoordinates, offset2, end, stride) {
    const chunks = [];
    let cursor = offset2;
    let chunkM = 0;
    let currentChunk = flatCoordinates.slice(offset2, 2);
    while (chunkM < chunkLength && cursor + stride < end) {
      const [x1, y1] = currentChunk.slice(-2);
      const x2 = flatCoordinates[cursor + stride];
      const y2 = flatCoordinates[cursor + stride + 1];
      const segmentLength = Math.sqrt(
        (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1)
      );
      chunkM += segmentLength;
      if (chunkM >= chunkLength) {
        const m3 = (chunkLength - chunkM + segmentLength) / segmentLength;
        const x3 = lerp(x1, x2, m3);
        const y3 = lerp(y1, y2, m3);
        currentChunk.push(x3, y3);
        chunks.push(currentChunk);
        currentChunk = [x3, y3];
        if (chunkM == chunkLength) {
          cursor += stride;
        }
        chunkM = 0;
      } else if (chunkM < chunkLength) {
        currentChunk.push(
          flatCoordinates[cursor + stride],
          flatCoordinates[cursor + stride + 1]
        );
        cursor += stride;
      } else {
        const missing = segmentLength - chunkM;
        const x3 = lerp(x1, x2, missing / segmentLength);
        const y3 = lerp(y1, y2, missing / segmentLength);
        currentChunk.push(x3, y3);
        chunks.push(currentChunk);
        currentChunk = [x3, y3];
        chunkM = 0;
        cursor += stride;
      }
    }
    if (chunkM > 0) {
      chunks.push(currentChunk);
    }
    return chunks;
  }

  // node_modules/ol/geom/flat/straightchunk.js
  function matchingChunk(maxAngle, flatCoordinates, offset2, end, stride) {
    let chunkStart = offset2;
    let chunkEnd = offset2;
    let chunkM = 0;
    let m3 = 0;
    let start = offset2;
    let acos, i4, m12, m23, x1, y1, x12, y12, x23, y23;
    for (i4 = offset2; i4 < end; i4 += stride) {
      const x2 = flatCoordinates[i4];
      const y2 = flatCoordinates[i4 + 1];
      if (x1 !== void 0) {
        x23 = x2 - x1;
        y23 = y2 - y1;
        m23 = Math.sqrt(x23 * x23 + y23 * y23);
        if (x12 !== void 0) {
          m3 += m12;
          acos = Math.acos((x12 * x23 + y12 * y23) / (m12 * m23));
          if (acos > maxAngle) {
            if (m3 > chunkM) {
              chunkM = m3;
              chunkStart = start;
              chunkEnd = i4;
            }
            m3 = 0;
            start = i4 - stride;
          }
        }
        m12 = m23;
        x12 = x23;
        y12 = y23;
      }
      x1 = x2;
      y1 = y2;
    }
    m3 += m23;
    return m3 > chunkM ? [start, i4] : [chunkStart, chunkEnd];
  }

  // node_modules/ol/render/canvas/TextBuilder.js
  var TEXT_ALIGN = {
    "left": 0,
    "center": 0.5,
    "right": 1,
    "top": 0,
    "middle": 0.5,
    "hanging": 0.2,
    "alphabetic": 0.8,
    "ideographic": 0.8,
    "bottom": 1
  };
  var CanvasTextBuilder = class extends Builder_default {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Maximum extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      super(tolerance, maxExtent, resolution, pixelRatio);
      this.labels_ = null;
      this.text_ = "";
      this.textOffsetX_ = 0;
      this.textOffsetY_ = 0;
      this.textRotateWithView_ = void 0;
      this.textRotation_ = 0;
      this.textFillState_ = null;
      this.fillStates = {};
      this.fillStates[defaultFillStyle] = { fillStyle: defaultFillStyle };
      this.textStrokeState_ = null;
      this.strokeStates = {};
      this.textState_ = /** @type {import("../canvas.js").TextState} */
      {};
      this.textStates = {};
      this.textKey_ = "";
      this.fillKey_ = "";
      this.strokeKey_ = "";
      this.declutterImageWithText_ = void 0;
    }
    /**
     * @return {import("../canvas.js").SerializableInstructions} the serializable instructions.
     */
    finish() {
      const instructions = super.finish();
      instructions.textStates = this.textStates;
      instructions.fillStates = this.fillStates;
      instructions.strokeStates = this.strokeStates;
      return instructions;
    }
    /**
     * @param {import("../../geom/SimpleGeometry.js").default|import("../Feature.js").default} geometry Geometry.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     */
    drawText(geometry, feature) {
      const fillState = this.textFillState_;
      const strokeState = this.textStrokeState_;
      const textState = this.textState_;
      if (this.text_ === "" || !textState || !fillState && !strokeState) {
        return;
      }
      const coordinates2 = this.coordinates;
      let begin = coordinates2.length;
      const geometryType = geometry.getType();
      let flatCoordinates = null;
      let stride = geometry.getStride();
      if (textState.placement === "line" && (geometryType == "LineString" || geometryType == "MultiLineString" || geometryType == "Polygon" || geometryType == "MultiPolygon")) {
        if (!intersects(this.getBufferedMaxExtent(), geometry.getExtent())) {
          return;
        }
        let ends;
        flatCoordinates = geometry.getFlatCoordinates();
        if (geometryType == "LineString") {
          ends = [flatCoordinates.length];
        } else if (geometryType == "MultiLineString") {
          ends = /** @type {import("../../geom/MultiLineString.js").default} */
          geometry.getEnds();
        } else if (geometryType == "Polygon") {
          ends = /** @type {import("../../geom/Polygon.js").default} */
          geometry.getEnds().slice(0, 1);
        } else if (geometryType == "MultiPolygon") {
          const endss = (
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry.getEndss()
          );
          ends = [];
          for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
            ends.push(endss[i4][0]);
          }
        }
        this.beginGeometry(geometry, feature);
        const repeat = textState.repeat;
        const textAlign = repeat ? void 0 : textState.textAlign;
        let flatOffset = 0;
        for (let o4 = 0, oo = ends.length; o4 < oo; ++o4) {
          let chunks;
          if (repeat) {
            chunks = lineChunk(
              repeat * this.resolution,
              flatCoordinates,
              flatOffset,
              ends[o4],
              stride
            );
          } else {
            chunks = [flatCoordinates.slice(flatOffset, ends[o4])];
          }
          for (let c4 = 0, cc = chunks.length; c4 < cc; ++c4) {
            const chunk = chunks[c4];
            let chunkBegin = 0;
            let chunkEnd = chunk.length;
            if (textAlign == void 0) {
              const range = matchingChunk(
                textState.maxAngle,
                chunk,
                0,
                chunk.length,
                2
              );
              chunkBegin = range[0];
              chunkEnd = range[1];
            }
            for (let i4 = chunkBegin; i4 < chunkEnd; i4 += stride) {
              coordinates2.push(chunk[i4], chunk[i4 + 1]);
            }
            const end = coordinates2.length;
            flatOffset = ends[o4];
            this.drawChars_(begin, end);
            begin = end;
          }
        }
        this.endGeometry(feature);
      } else {
        let geometryWidths = textState.overflow ? null : [];
        switch (geometryType) {
          case "Point":
          case "MultiPoint":
            flatCoordinates = /** @type {import("../../geom/MultiPoint.js").default} */
            geometry.getFlatCoordinates();
            break;
          case "LineString":
            flatCoordinates = /** @type {import("../../geom/LineString.js").default} */
            geometry.getFlatMidpoint();
            break;
          case "Circle":
            flatCoordinates = /** @type {import("../../geom/Circle.js").default} */
            geometry.getCenter();
            break;
          case "MultiLineString":
            flatCoordinates = /** @type {import("../../geom/MultiLineString.js").default} */
            geometry.getFlatMidpoints();
            stride = 2;
            break;
          case "Polygon":
            flatCoordinates = /** @type {import("../../geom/Polygon.js").default} */
            geometry.getFlatInteriorPoint();
            if (!textState.overflow) {
              geometryWidths.push(flatCoordinates[2] / this.resolution);
            }
            stride = 3;
            break;
          case "MultiPolygon":
            const interiorPoints = (
              /** @type {import("../../geom/MultiPolygon.js").default} */
              geometry.getFlatInteriorPoints()
            );
            flatCoordinates = [];
            for (let i4 = 0, ii = interiorPoints.length; i4 < ii; i4 += 3) {
              if (!textState.overflow) {
                geometryWidths.push(interiorPoints[i4 + 2] / this.resolution);
              }
              flatCoordinates.push(interiorPoints[i4], interiorPoints[i4 + 1]);
            }
            if (flatCoordinates.length === 0) {
              return;
            }
            stride = 2;
            break;
          default:
        }
        const end = this.appendFlatPointCoordinates(flatCoordinates, stride);
        if (end === begin) {
          return;
        }
        if (geometryWidths && (end - begin) / 2 !== flatCoordinates.length / stride) {
          let beg = begin / 2;
          geometryWidths = geometryWidths.filter((w3, i4) => {
            const keep = coordinates2[(beg + i4) * 2] === flatCoordinates[i4 * stride] && coordinates2[(beg + i4) * 2 + 1] === flatCoordinates[i4 * stride + 1];
            if (!keep) {
              --beg;
            }
            return keep;
          });
        }
        this.saveTextStates_();
        if (textState.backgroundFill || textState.backgroundStroke) {
          this.setFillStrokeStyle(
            textState.backgroundFill,
            textState.backgroundStroke
          );
          if (textState.backgroundFill) {
            this.updateFillStyle(this.state, this.createFill);
          }
          if (textState.backgroundStroke) {
            this.updateStrokeStyle(this.state, this.applyStroke);
            this.hitDetectionInstructions.push(this.createStroke(this.state));
          }
        }
        this.beginGeometry(geometry, feature);
        let padding = textState.padding;
        if (padding != defaultPadding && (textState.scale[0] < 0 || textState.scale[1] < 0)) {
          let p0 = textState.padding[0];
          let p12 = textState.padding[1];
          let p23 = textState.padding[2];
          let p32 = textState.padding[3];
          if (textState.scale[0] < 0) {
            p12 = -p12;
            p32 = -p32;
          }
          if (textState.scale[1] < 0) {
            p0 = -p0;
            p23 = -p23;
          }
          padding = [p0, p12, p23, p32];
        }
        const pixelRatio = this.pixelRatio;
        this.instructions.push([
          Instruction_default.DRAW_IMAGE,
          begin,
          end,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [1, 1],
          NaN,
          void 0,
          this.declutterImageWithText_,
          padding == defaultPadding ? defaultPadding : padding.map(function(p6) {
            return p6 * pixelRatio;
          }),
          !!textState.backgroundFill,
          !!textState.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          geometryWidths
        ]);
        const scale3 = 1 / pixelRatio;
        const currentFillStyle = this.state.fillStyle;
        if (textState.backgroundFill) {
          this.state.fillStyle = defaultFillStyle;
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        this.hitDetectionInstructions.push([
          Instruction_default.DRAW_IMAGE,
          begin,
          end,
          null,
          NaN,
          NaN,
          NaN,
          1,
          0,
          0,
          this.textRotateWithView_,
          this.textRotation_,
          [scale3, scale3],
          NaN,
          void 0,
          this.declutterImageWithText_,
          padding,
          !!textState.backgroundFill,
          !!textState.backgroundStroke,
          this.text_,
          this.textKey_,
          this.strokeKey_,
          this.fillKey_ ? defaultFillStyle : this.fillKey_,
          this.textOffsetX_,
          this.textOffsetY_,
          geometryWidths
        ]);
        if (textState.backgroundFill) {
          this.state.fillStyle = currentFillStyle;
          this.hitDetectionInstructions.push(this.createFill(this.state));
        }
        this.endGeometry(feature);
      }
    }
    /**
     * @private
     */
    saveTextStates_() {
      const strokeState = this.textStrokeState_;
      const textState = this.textState_;
      const fillState = this.textFillState_;
      const strokeKey = this.strokeKey_;
      if (strokeState) {
        if (!(strokeKey in this.strokeStates)) {
          this.strokeStates[strokeKey] = {
            strokeStyle: strokeState.strokeStyle,
            lineCap: strokeState.lineCap,
            lineDashOffset: strokeState.lineDashOffset,
            lineWidth: strokeState.lineWidth,
            lineJoin: strokeState.lineJoin,
            miterLimit: strokeState.miterLimit,
            lineDash: strokeState.lineDash
          };
        }
      }
      const textKey = this.textKey_;
      if (!(textKey in this.textStates)) {
        this.textStates[textKey] = {
          font: textState.font,
          textAlign: textState.textAlign || defaultTextAlign,
          justify: textState.justify,
          textBaseline: textState.textBaseline || defaultTextBaseline,
          scale: textState.scale
        };
      }
      const fillKey = this.fillKey_;
      if (fillState) {
        if (!(fillKey in this.fillStates)) {
          this.fillStates[fillKey] = {
            fillStyle: fillState.fillStyle
          };
        }
      }
    }
    /**
     * @private
     * @param {number} begin Begin.
     * @param {number} end End.
     */
    drawChars_(begin, end) {
      const strokeState = this.textStrokeState_;
      const textState = this.textState_;
      const strokeKey = this.strokeKey_;
      const textKey = this.textKey_;
      const fillKey = this.fillKey_;
      this.saveTextStates_();
      const pixelRatio = this.pixelRatio;
      const baseline = TEXT_ALIGN[textState.textBaseline];
      const offsetY = this.textOffsetY_ * pixelRatio;
      const text = this.text_;
      const strokeWidth = strokeState ? strokeState.lineWidth * Math.abs(textState.scale[0]) / 2 : 0;
      this.instructions.push([
        Instruction_default.DRAW_CHARS,
        begin,
        end,
        baseline,
        textState.overflow,
        fillKey,
        textState.maxAngle,
        pixelRatio,
        offsetY,
        strokeKey,
        strokeWidth * pixelRatio,
        text,
        textKey,
        1
      ]);
      this.hitDetectionInstructions.push([
        Instruction_default.DRAW_CHARS,
        begin,
        end,
        baseline,
        textState.overflow,
        fillKey ? defaultFillStyle : fillKey,
        textState.maxAngle,
        pixelRatio,
        offsetY,
        strokeKey,
        strokeWidth * pixelRatio,
        text,
        textKey,
        1 / pixelRatio
      ]);
    }
    /**
     * @param {import("../../style/Text.js").default} textStyle Text style.
     * @param {Object} [sharedData] Shared data.
     */
    setTextStyle(textStyle, sharedData) {
      let textState, fillState, strokeState;
      if (!textStyle) {
        this.text_ = "";
      } else {
        const textFillStyle = textStyle.getFill();
        if (!textFillStyle) {
          fillState = null;
          this.textFillState_ = fillState;
        } else {
          fillState = this.textFillState_;
          if (!fillState) {
            fillState = /** @type {import("../canvas.js").FillState} */
            {};
            this.textFillState_ = fillState;
          }
          fillState.fillStyle = asColorLike(
            textFillStyle.getColor() || defaultFillStyle
          );
        }
        const textStrokeStyle = textStyle.getStroke();
        if (!textStrokeStyle) {
          strokeState = null;
          this.textStrokeState_ = strokeState;
        } else {
          strokeState = this.textStrokeState_;
          if (!strokeState) {
            strokeState = /** @type {import("../canvas.js").StrokeState} */
            {};
            this.textStrokeState_ = strokeState;
          }
          const lineDash = textStrokeStyle.getLineDash();
          const lineDashOffset = textStrokeStyle.getLineDashOffset();
          const lineWidth = textStrokeStyle.getWidth();
          const miterLimit = textStrokeStyle.getMiterLimit();
          strokeState.lineCap = textStrokeStyle.getLineCap() || defaultLineCap;
          strokeState.lineDash = lineDash ? lineDash.slice() : defaultLineDash;
          strokeState.lineDashOffset = lineDashOffset === void 0 ? defaultLineDashOffset : lineDashOffset;
          strokeState.lineJoin = textStrokeStyle.getLineJoin() || defaultLineJoin;
          strokeState.lineWidth = lineWidth === void 0 ? defaultLineWidth : lineWidth;
          strokeState.miterLimit = miterLimit === void 0 ? defaultMiterLimit : miterLimit;
          strokeState.strokeStyle = asColorLike(
            textStrokeStyle.getColor() || defaultStrokeStyle
          );
        }
        textState = this.textState_;
        const font = textStyle.getFont() || defaultFont;
        registerFont(font);
        const textScale = textStyle.getScaleArray();
        textState.overflow = textStyle.getOverflow();
        textState.font = font;
        textState.maxAngle = textStyle.getMaxAngle();
        textState.placement = textStyle.getPlacement();
        textState.textAlign = textStyle.getTextAlign();
        textState.repeat = textStyle.getRepeat();
        textState.justify = textStyle.getJustify();
        textState.textBaseline = textStyle.getTextBaseline() || defaultTextBaseline;
        textState.backgroundFill = textStyle.getBackgroundFill();
        textState.backgroundStroke = textStyle.getBackgroundStroke();
        textState.padding = textStyle.getPadding() || defaultPadding;
        textState.scale = textScale === void 0 ? [1, 1] : textScale;
        const textOffsetX = textStyle.getOffsetX();
        const textOffsetY = textStyle.getOffsetY();
        const textRotateWithView = textStyle.getRotateWithView();
        const textRotation = textStyle.getRotation();
        this.text_ = textStyle.getText() || "";
        this.textOffsetX_ = textOffsetX === void 0 ? 0 : textOffsetX;
        this.textOffsetY_ = textOffsetY === void 0 ? 0 : textOffsetY;
        this.textRotateWithView_ = textRotateWithView === void 0 ? false : textRotateWithView;
        this.textRotation_ = textRotation === void 0 ? 0 : textRotation;
        this.strokeKey_ = strokeState ? (typeof strokeState.strokeStyle == "string" ? strokeState.strokeStyle : getUid(strokeState.strokeStyle)) + strokeState.lineCap + strokeState.lineDashOffset + "|" + strokeState.lineWidth + strokeState.lineJoin + strokeState.miterLimit + "[" + strokeState.lineDash.join() + "]" : "";
        this.textKey_ = textState.font + textState.scale + (textState.textAlign || "?") + (textState.repeat || "?") + (textState.justify || "?") + (textState.textBaseline || "?");
        this.fillKey_ = fillState ? typeof fillState.fillStyle == "string" ? fillState.fillStyle : "|" + getUid(fillState.fillStyle) : "";
      }
      this.declutterImageWithText_ = sharedData;
    }
  };
  var TextBuilder_default = CanvasTextBuilder;

  // node_modules/ol/render/canvas/BuilderGroup.js
  var BATCH_CONSTRUCTORS = {
    "Circle": PolygonBuilder_default,
    "Default": Builder_default,
    "Image": ImageBuilder_default,
    "LineString": LineStringBuilder_default,
    "Polygon": PolygonBuilder_default,
    "Text": TextBuilder_default
  };
  var BuilderGroup = class {
    /**
     * @param {number} tolerance Tolerance.
     * @param {import("../../extent.js").Extent} maxExtent Max extent.
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     */
    constructor(tolerance, maxExtent, resolution, pixelRatio) {
      this.tolerance_ = tolerance;
      this.maxExtent_ = maxExtent;
      this.pixelRatio_ = pixelRatio;
      this.resolution_ = resolution;
      this.buildersByZIndex_ = {};
    }
    /**
     * @return {!Object<string, !Object<import("../canvas.js").BuilderType, import("./Builder.js").SerializableInstructions>>} The serializable instructions
     */
    finish() {
      const builderInstructions = {};
      for (const zKey in this.buildersByZIndex_) {
        builderInstructions[zKey] = builderInstructions[zKey] || {};
        const builders = this.buildersByZIndex_[zKey];
        for (const builderKey in builders) {
          const builderInstruction = builders[builderKey].finish();
          builderInstructions[zKey][builderKey] = builderInstruction;
        }
      }
      return builderInstructions;
    }
    /**
     * @param {number|undefined} zIndex Z index.
     * @param {import("../canvas.js").BuilderType} builderType Replay type.
     * @return {import("../VectorContext.js").default} Replay.
     */
    getBuilder(zIndex, builderType) {
      const zIndexKey = zIndex !== void 0 ? zIndex.toString() : "0";
      let replays = this.buildersByZIndex_[zIndexKey];
      if (replays === void 0) {
        replays = {};
        this.buildersByZIndex_[zIndexKey] = replays;
      }
      let replay = replays[builderType];
      if (replay === void 0) {
        const Constructor = BATCH_CONSTRUCTORS[builderType];
        replay = new Constructor(
          this.tolerance_,
          this.maxExtent_,
          this.resolution_,
          this.pixelRatio_
        );
        replays[builderType] = replay;
      }
      return replay;
    }
  };
  var BuilderGroup_default = BuilderGroup;

  // node_modules/ol/renderer/Layer.js
  var LayerRenderer = class extends Observable_default {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(layer) {
      super();
      this.ready = true;
      this.boundHandleImageChange_ = this.handleImageChange_.bind(this);
      this.layer_ = layer;
      this.declutterExecutorGroup = null;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../Feature").FeatureLike>>} Promise that resolves with
     * an array of features.
     */
    getFeatures(pixel) {
      return abstract();
    }
    /**
     * @param {import("../pixel.js").Pixel} pixel Pixel.
     * @return {Uint8ClampedArray|Uint8Array|Float32Array|DataView|null} Pixel data.
     */
    getData(pixel) {
      return null;
    }
    /**
     * Determine whether render should be called.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(frameState) {
      return abstract();
    }
    /**
     * Render the layer.
     * @abstract
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(frameState, target) {
      return abstract();
    }
    /**
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @param {number} zoom Zoom level.
     * @param {import("../Tile.js").default} tile Tile.
     * @return {boolean|void} If `false`, the tile will not be considered loaded.
     */
    loadedTileCallback(tiles, zoom, tile) {
      if (!tiles[zoom]) {
        tiles[zoom] = {};
      }
      tiles[zoom][tile.tileCoord.toString()] = tile;
      return void 0;
    }
    /**
     * Create a function that adds loaded tiles to the tile lookup.
     * @param {import("../source/Tile.js").default} source Tile source.
     * @param {import("../proj/Projection.js").default} projection Projection of the tiles.
     * @param {Object<number, Object<string, import("../Tile.js").default>>} tiles Lookup of loaded tiles by zoom level.
     * @return {function(number, import("../TileRange.js").default):boolean} A function that can be
     *     called with a zoom level and a tile range to add loaded tiles to the lookup.
     * @protected
     */
    createLoadedTileFinder(source, projection, tiles) {
      return (
        /**
         * @param {number} zoom Zoom level.
         * @param {import("../TileRange.js").default} tileRange Tile range.
         * @return {boolean} The tile range is fully loaded.
         */
        (zoom, tileRange) => {
          const callback = this.loadedTileCallback.bind(this, tiles, zoom);
          return source.forEachLoadedTile(projection, zoom, tileRange, callback);
        }
      );
    }
    /**
     * @abstract
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("./Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      return void 0;
    }
    /**
     * @return {LayerType} Layer.
     */
    getLayer() {
      return this.layer_;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     * @abstract
     */
    handleFontsChanged() {
    }
    /**
     * Handle changes in image state.
     * @param {import("../events/Event.js").default} event Image change event.
     * @private
     */
    handleImageChange_(event) {
      const image = (
        /** @type {import("../Image.js").default} */
        event.target
      );
      if (image.getState() === ImageState_default.LOADED || image.getState() === ImageState_default.ERROR) {
        this.renderIfReadyAndVisible();
      }
    }
    /**
     * Load the image if not already loaded, and register the image change
     * listener if needed.
     * @param {import("../Image.js").default} image Image.
     * @return {boolean} `true` if the image is already loaded, `false` otherwise.
     * @protected
     */
    loadImage(image) {
      let imageState = image.getState();
      if (imageState != ImageState_default.LOADED && imageState != ImageState_default.ERROR) {
        image.addEventListener(EventType_default.CHANGE, this.boundHandleImageChange_);
      }
      if (imageState == ImageState_default.IDLE) {
        image.load();
        imageState = image.getState();
      }
      return imageState == ImageState_default.LOADED;
    }
    /**
     * @protected
     */
    renderIfReadyAndVisible() {
      const layer = this.getLayer();
      if (layer && layer.getVisible() && layer.getSourceState() === "ready") {
        layer.changed();
      }
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      delete this.layer_;
      super.disposeInternal();
    }
  };
  var Layer_default2 = LayerRenderer;

  // node_modules/ol/render/Event.js
  var RenderEvent = class extends Event_default {
    /**
     * @param {import("./EventType.js").default} type Type.
     * @param {import("../transform.js").Transform} [inversePixelTransform] Transform for
     *     CSS pixels to rendered pixels.
     * @param {import("../Map.js").FrameState} [frameState] Frame state.
     * @param {?(CanvasRenderingContext2D|WebGLRenderingContext)} [context] Context.
     */
    constructor(type, inversePixelTransform, frameState, context) {
      super(type);
      this.inversePixelTransform = inversePixelTransform;
      this.frameState = frameState;
      this.context = context;
    }
  };
  var Event_default2 = RenderEvent;

  // node_modules/ol/renderer/canvas/Layer.js
  var canvasPool = [];
  var pixelContext = null;
  function createPixelContext() {
    pixelContext = createCanvasContext2D(1, 1, void 0, {
      willReadFrequently: true
    });
  }
  var CanvasLayerRenderer = class extends Layer_default2 {
    /**
     * @param {LayerType} layer Layer.
     */
    constructor(layer) {
      super(layer);
      this.container = null;
      this.renderedResolution;
      this.tempTransform = create();
      this.pixelTransform = create();
      this.inversePixelTransform = create();
      this.context = null;
      this.containerReused = false;
      this.pixelContext_ = null;
      this.frameState = null;
    }
    /**
     * @param {import('../../DataTile.js').ImageLike} image Image.
     * @param {number} col The column index.
     * @param {number} row The row index.
     * @return {Uint8ClampedArray|null} The image data.
     */
    getImageData(image, col, row) {
      if (!pixelContext) {
        createPixelContext();
      }
      pixelContext.clearRect(0, 0, 1, 1);
      let data;
      try {
        pixelContext.drawImage(image, col, row, 1, 1, 0, 0, 1, 1);
        data = pixelContext.getImageData(0, 0, 1, 1).data;
      } catch (err) {
        pixelContext = null;
        return null;
      }
      return data;
    }
    /**
     * @param {import('../../Map.js').FrameState} frameState Frame state.
     * @return {string} Background color.
     */
    getBackground(frameState) {
      const layer = this.getLayer();
      let background = layer.getBackground();
      if (typeof background === "function") {
        background = background(frameState.viewState.resolution);
      }
      return background || void 0;
    }
    /**
     * Get a rendering container from an existing target, if compatible.
     * @param {HTMLElement} target Potential render target.
     * @param {string} transform CSS Transform.
     * @param {string} [backgroundColor] Background color.
     */
    useContainer(target, transform2, backgroundColor) {
      const layerClassName = this.getLayer().getClassName();
      let container, context;
      if (target && target.className === layerClassName && (!backgroundColor || target && target.style.backgroundColor && equals(
        asArray(target.style.backgroundColor),
        asArray(backgroundColor)
      ))) {
        const canvas = target.firstElementChild;
        if (canvas instanceof HTMLCanvasElement) {
          context = canvas.getContext("2d");
        }
      }
      if (context && context.canvas.style.transform === transform2) {
        this.container = target;
        this.context = context;
        this.containerReused = true;
      } else if (this.containerReused) {
        this.container = null;
        this.context = null;
        this.containerReused = false;
      } else if (this.container) {
        this.container.style.backgroundColor = null;
      }
      if (!this.container) {
        container = document.createElement("div");
        container.className = layerClassName;
        let style = container.style;
        style.position = "absolute";
        style.width = "100%";
        style.height = "100%";
        context = createCanvasContext2D();
        const canvas = context.canvas;
        container.appendChild(canvas);
        style = canvas.style;
        style.position = "absolute";
        style.left = "0";
        style.transformOrigin = "top left";
        this.container = container;
        this.context = context;
      }
      if (!this.containerReused && backgroundColor && !this.container.style.backgroundColor) {
        this.container.style.backgroundColor = backgroundColor;
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("../../extent.js").Extent} extent Clip extent.
     * @protected
     */
    clipUnrotated(context, frameState, extent) {
      const topLeft = getTopLeft(extent);
      const topRight = getTopRight(extent);
      const bottomRight = getBottomRight(extent);
      const bottomLeft = getBottomLeft(extent);
      apply(frameState.coordinateToPixelTransform, topLeft);
      apply(frameState.coordinateToPixelTransform, topRight);
      apply(frameState.coordinateToPixelTransform, bottomRight);
      apply(frameState.coordinateToPixelTransform, bottomLeft);
      const inverted = this.inversePixelTransform;
      apply(inverted, topLeft);
      apply(inverted, topRight);
      apply(inverted, bottomRight);
      apply(inverted, bottomLeft);
      context.save();
      context.beginPath();
      context.moveTo(Math.round(topLeft[0]), Math.round(topLeft[1]));
      context.lineTo(Math.round(topRight[0]), Math.round(topRight[1]));
      context.lineTo(Math.round(bottomRight[0]), Math.round(bottomRight[1]));
      context.lineTo(Math.round(bottomLeft[0]), Math.round(bottomLeft[1]));
      context.clip();
    }
    /**
     * @param {import("../../render/EventType.js").default} type Event type.
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @private
     */
    dispatchRenderEvent_(type, context, frameState) {
      const layer = this.getLayer();
      if (layer.hasListener(type)) {
        const event = new Event_default2(
          type,
          this.inversePixelTransform,
          frameState,
          context
        );
        layer.dispatchEvent(event);
      }
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    preRender(context, frameState) {
      this.frameState = frameState;
      this.dispatchRenderEvent_(EventType_default2.PRERENDER, context, frameState);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    postRender(context, frameState) {
      this.dispatchRenderEvent_(EventType_default2.POSTRENDER, context, frameState);
    }
    /**
     * Creates a transform for rendering to an element that will be rotated after rendering.
     * @param {import("../../coordinate.js").Coordinate} center Center.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} pixelRatio Pixel ratio.
     * @param {number} width Width of the rendered element (in pixels).
     * @param {number} height Height of the rendered element (in pixels).
     * @param {number} offsetX Offset on the x-axis in view coordinates.
     * @protected
     * @return {!import("../../transform.js").Transform} Transform.
     */
    getRenderTransform(center, resolution, rotation, pixelRatio, width, height, offsetX) {
      const dx1 = width / 2;
      const dy1 = height / 2;
      const sx = pixelRatio / resolution;
      const sy = -sx;
      const dx2 = -center[0] + offsetX;
      const dy2 = -center[1];
      return compose(
        this.tempTransform,
        dx1,
        dy1,
        sx,
        sy,
        -rotation,
        dx2,
        dy2
      );
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      delete this.frameState;
      super.disposeInternal();
    }
  };
  var Layer_default3 = CanvasLayerRenderer;

  // node_modules/ol/geom/flat/textpath.js
  function drawTextOnPath(flatCoordinates, offset2, end, stride, text, startM, maxAngle, scale3, measureAndCacheTextWidth2, font, cache3, rotation) {
    let x2 = flatCoordinates[offset2];
    let y2 = flatCoordinates[offset2 + 1];
    let x1 = 0;
    let y1 = 0;
    let segmentLength = 0;
    let segmentM = 0;
    function advance() {
      x1 = x2;
      y1 = y2;
      offset2 += stride;
      x2 = flatCoordinates[offset2];
      y2 = flatCoordinates[offset2 + 1];
      segmentM += segmentLength;
      segmentLength = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    }
    do {
      advance();
    } while (offset2 < end - stride && segmentM + segmentLength < startM);
    let interpolate = segmentLength === 0 ? 0 : (startM - segmentM) / segmentLength;
    const beginX = lerp(x1, x2, interpolate);
    const beginY = lerp(y1, y2, interpolate);
    const startOffset = offset2 - stride;
    const startLength = segmentM;
    const endM = startM + scale3 * measureAndCacheTextWidth2(font, text, cache3);
    while (offset2 < end - stride && segmentM + segmentLength < endM) {
      advance();
    }
    interpolate = segmentLength === 0 ? 0 : (endM - segmentM) / segmentLength;
    const endX = lerp(x1, x2, interpolate);
    const endY = lerp(y1, y2, interpolate);
    let reverse;
    if (rotation) {
      const flat = [beginX, beginY, endX, endY];
      rotate2(flat, 0, 4, 2, rotation, flat, flat);
      reverse = flat[0] > flat[2];
    } else {
      reverse = beginX > endX;
    }
    const PI = Math.PI;
    const result = [];
    const singleSegment = startOffset + stride === offset2;
    offset2 = startOffset;
    segmentLength = 0;
    segmentM = startLength;
    x2 = flatCoordinates[offset2];
    y2 = flatCoordinates[offset2 + 1];
    let previousAngle;
    if (singleSegment) {
      advance();
      previousAngle = Math.atan2(y2 - y1, x2 - x1);
      if (reverse) {
        previousAngle += previousAngle > 0 ? -PI : PI;
      }
      const x3 = (endX + beginX) / 2;
      const y3 = (endY + beginY) / 2;
      result[0] = [x3, y3, (endM - startM) / 2, previousAngle, text];
      return result;
    }
    text = text.replace(/\n/g, " ");
    for (let i4 = 0, ii = text.length; i4 < ii; ) {
      advance();
      let angle = Math.atan2(y2 - y1, x2 - x1);
      if (reverse) {
        angle += angle > 0 ? -PI : PI;
      }
      if (previousAngle !== void 0) {
        let delta = angle - previousAngle;
        delta += delta > PI ? -2 * PI : delta < -PI ? 2 * PI : 0;
        if (Math.abs(delta) > maxAngle) {
          return null;
        }
      }
      previousAngle = angle;
      const iStart = i4;
      let charLength = 0;
      for (; i4 < ii; ++i4) {
        const index = reverse ? ii - i4 - 1 : i4;
        const len = scale3 * measureAndCacheTextWidth2(font, text[index], cache3);
        if (offset2 + stride < end && segmentM + segmentLength < startM + charLength + len / 2) {
          break;
        }
        charLength += len;
      }
      if (i4 === iStart) {
        continue;
      }
      const chars = reverse ? text.substring(ii - iStart, ii - i4) : text.substring(iStart, i4);
      interpolate = segmentLength === 0 ? 0 : (startM + charLength / 2 - segmentM) / segmentLength;
      const x3 = lerp(x1, x2, interpolate);
      const y3 = lerp(y1, y2, interpolate);
      result.push([x3, y3, charLength / 2, angle, chars]);
      startM += charLength;
    }
    return result;
  }

  // node_modules/ol/render/canvas/Executor.js
  var tmpExtent = createEmpty();
  var p1 = [];
  var p22 = [];
  var p3 = [];
  var p4 = [];
  function getDeclutterBox(replayImageOrLabelArgs) {
    return replayImageOrLabelArgs[3].declutterBox;
  }
  var rtlRegEx = new RegExp(
    /* eslint-disable prettier/prettier */
    "[" + String.fromCharCode(1425) + "-" + String.fromCharCode(2303) + String.fromCharCode(64285) + "-" + String.fromCharCode(65023) + String.fromCharCode(65136) + "-" + String.fromCharCode(65276) + String.fromCharCode(67584) + "-" + String.fromCharCode(69631) + String.fromCharCode(124928) + "-" + String.fromCharCode(126975) + "]"
    /* eslint-enable prettier/prettier */
  );
  function horizontalTextAlign(text, align) {
    if (align === "start") {
      align = rtlRegEx.test(text) ? "right" : "left";
    } else if (align === "end") {
      align = rtlRegEx.test(text) ? "left" : "right";
    }
    return TEXT_ALIGN[align];
  }
  function createTextChunks(acc, line, i4) {
    if (i4 > 0) {
      acc.push("\n", "");
    }
    acc.push(line, "");
    return acc;
  }
  var Executor = class {
    /**
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The replay can have overlapping geometries.
     * @param {import("../canvas.js").SerializableInstructions} instructions The serializable instructions
     */
    constructor(resolution, pixelRatio, overlaps, instructions) {
      this.overlaps = overlaps;
      this.pixelRatio = pixelRatio;
      this.resolution = resolution;
      this.alignFill_;
      this.instructions = instructions.instructions;
      this.coordinates = instructions.coordinates;
      this.coordinateCache_ = {};
      this.renderedTransform_ = create();
      this.hitDetectionInstructions = instructions.hitDetectionInstructions;
      this.pixelCoordinates_ = null;
      this.viewRotation_ = 0;
      this.fillStates = instructions.fillStates || {};
      this.strokeStates = instructions.strokeStates || {};
      this.textStates = instructions.textStates || {};
      this.widths_ = {};
      this.labels_ = {};
    }
    /**
     * @param {string|Array<string>} text Text.
     * @param {string} textKey Text style key.
     * @param {string} fillKey Fill style key.
     * @param {string} strokeKey Stroke style key.
     * @return {import("../canvas.js").Label} Label.
     */
    createLabel(text, textKey, fillKey, strokeKey) {
      const key = text + textKey + fillKey + strokeKey;
      if (this.labels_[key]) {
        return this.labels_[key];
      }
      const strokeState = strokeKey ? this.strokeStates[strokeKey] : null;
      const fillState = fillKey ? this.fillStates[fillKey] : null;
      const textState = this.textStates[textKey];
      const pixelRatio = this.pixelRatio;
      const scale3 = [
        textState.scale[0] * pixelRatio,
        textState.scale[1] * pixelRatio
      ];
      const textIsArray = Array.isArray(text);
      const align = textState.justify ? TEXT_ALIGN[textState.justify] : horizontalTextAlign(
        Array.isArray(text) ? text[0] : text,
        textState.textAlign || defaultTextAlign
      );
      const strokeWidth = strokeKey && strokeState.lineWidth ? strokeState.lineWidth : 0;
      const chunks = textIsArray ? text : text.split("\n").reduce(createTextChunks, []);
      const { width, height, widths, heights, lineWidths } = getTextDimensions(
        textState,
        chunks
      );
      const renderWidth = width + strokeWidth;
      const contextInstructions = [];
      const w3 = (renderWidth + 2) * scale3[0];
      const h3 = (height + strokeWidth) * scale3[1];
      const label = {
        width: w3 < 0 ? Math.floor(w3) : Math.ceil(w3),
        height: h3 < 0 ? Math.floor(h3) : Math.ceil(h3),
        contextInstructions
      };
      if (scale3[0] != 1 || scale3[1] != 1) {
        contextInstructions.push("scale", scale3);
      }
      if (strokeKey) {
        contextInstructions.push("strokeStyle", strokeState.strokeStyle);
        contextInstructions.push("lineWidth", strokeWidth);
        contextInstructions.push("lineCap", strokeState.lineCap);
        contextInstructions.push("lineJoin", strokeState.lineJoin);
        contextInstructions.push("miterLimit", strokeState.miterLimit);
        contextInstructions.push("setLineDash", [strokeState.lineDash]);
        contextInstructions.push("lineDashOffset", strokeState.lineDashOffset);
      }
      if (fillKey) {
        contextInstructions.push("fillStyle", fillState.fillStyle);
      }
      contextInstructions.push("textBaseline", "middle");
      contextInstructions.push("textAlign", "center");
      const leftRight = 0.5 - align;
      let x2 = align * renderWidth + leftRight * strokeWidth;
      const strokeInstructions = [];
      const fillInstructions = [];
      let lineHeight = 0;
      let lineOffset = 0;
      let widthHeightIndex = 0;
      let lineWidthIndex = 0;
      let previousFont;
      for (let i4 = 0, ii = chunks.length; i4 < ii; i4 += 2) {
        const text2 = chunks[i4];
        if (text2 === "\n") {
          lineOffset += lineHeight;
          lineHeight = 0;
          x2 = align * renderWidth + leftRight * strokeWidth;
          ++lineWidthIndex;
          continue;
        }
        const font = chunks[i4 + 1] || textState.font;
        if (font !== previousFont) {
          if (strokeKey) {
            strokeInstructions.push("font", font);
          }
          if (fillKey) {
            fillInstructions.push("font", font);
          }
          previousFont = font;
        }
        lineHeight = Math.max(lineHeight, heights[widthHeightIndex]);
        const fillStrokeArgs = [
          text2,
          x2 + leftRight * widths[widthHeightIndex] + align * (widths[widthHeightIndex] - lineWidths[lineWidthIndex]),
          0.5 * (strokeWidth + lineHeight) + lineOffset
        ];
        x2 += widths[widthHeightIndex];
        if (strokeKey) {
          strokeInstructions.push("strokeText", fillStrokeArgs);
        }
        if (fillKey) {
          fillInstructions.push("fillText", fillStrokeArgs);
        }
        ++widthHeightIndex;
      }
      Array.prototype.push.apply(contextInstructions, strokeInstructions);
      Array.prototype.push.apply(contextInstructions, fillInstructions);
      this.labels_[key] = label;
      return label;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../coordinate.js").Coordinate} p1 1st point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p2 2nd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p3 3rd point of the background box.
     * @param {import("../../coordinate.js").Coordinate} p4 4th point of the background box.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     */
    replayTextBackground_(context, p12, p23, p32, p42, fillInstruction2, strokeInstruction2) {
      context.beginPath();
      context.moveTo.apply(context, p12);
      context.lineTo.apply(context, p23);
      context.lineTo.apply(context, p32);
      context.lineTo.apply(context, p42);
      context.lineTo.apply(context, p12);
      if (fillInstruction2) {
        this.alignFill_ = /** @type {boolean} */
        fillInstruction2[2];
        this.fill_(context);
      }
      if (strokeInstruction2) {
        this.setStrokeStyle_(
          context,
          /** @type {Array<*>} */
          strokeInstruction2
        );
        context.stroke();
      }
    }
    /**
     * @private
     * @param {number} sheetWidth Width of the sprite sheet.
     * @param {number} sheetHeight Height of the sprite sheet.
     * @param {number} centerX X.
     * @param {number} centerY Y.
     * @param {number} width Width.
     * @param {number} height Height.
     * @param {number} anchorX Anchor X.
     * @param {number} anchorY Anchor Y.
     * @param {number} originX Origin X.
     * @param {number} originY Origin Y.
     * @param {number} rotation Rotation.
     * @param {import("../../size.js").Size} scale Scale.
     * @param {boolean} snapToPixel Snap to pixel.
     * @param {Array<number>} padding Padding.
     * @param {boolean} fillStroke Background fill or stroke.
     * @param {import("../../Feature.js").FeatureLike} feature Feature.
     * @return {ImageOrLabelDimensions} Dimensions for positioning and decluttering the image or label.
     */
    calculateImageOrLabelDimensions_(sheetWidth, sheetHeight, centerX, centerY, width, height, anchorX, anchorY, originX, originY, rotation, scale3, snapToPixel, padding, fillStroke, feature) {
      anchorX *= scale3[0];
      anchorY *= scale3[1];
      let x2 = centerX - anchorX;
      let y2 = centerY - anchorY;
      const w3 = width + originX > sheetWidth ? sheetWidth - originX : width;
      const h3 = height + originY > sheetHeight ? sheetHeight - originY : height;
      const boxW = padding[3] + w3 * scale3[0] + padding[1];
      const boxH = padding[0] + h3 * scale3[1] + padding[2];
      const boxX = x2 - padding[3];
      const boxY = y2 - padding[0];
      if (fillStroke || rotation !== 0) {
        p1[0] = boxX;
        p4[0] = boxX;
        p1[1] = boxY;
        p22[1] = boxY;
        p22[0] = boxX + boxW;
        p3[0] = p22[0];
        p3[1] = boxY + boxH;
        p4[1] = p3[1];
      }
      let transform2;
      if (rotation !== 0) {
        transform2 = compose(
          create(),
          centerX,
          centerY,
          1,
          1,
          rotation,
          -centerX,
          -centerY
        );
        apply(transform2, p1);
        apply(transform2, p22);
        apply(transform2, p3);
        apply(transform2, p4);
        createOrUpdate(
          Math.min(p1[0], p22[0], p3[0], p4[0]),
          Math.min(p1[1], p22[1], p3[1], p4[1]),
          Math.max(p1[0], p22[0], p3[0], p4[0]),
          Math.max(p1[1], p22[1], p3[1], p4[1]),
          tmpExtent
        );
      } else {
        createOrUpdate(
          Math.min(boxX, boxX + boxW),
          Math.min(boxY, boxY + boxH),
          Math.max(boxX, boxX + boxW),
          Math.max(boxY, boxY + boxH),
          tmpExtent
        );
      }
      if (snapToPixel) {
        x2 = Math.round(x2);
        y2 = Math.round(y2);
      }
      return {
        drawImageX: x2,
        drawImageY: y2,
        drawImageW: w3,
        drawImageH: h3,
        originX,
        originY,
        declutterBox: {
          minX: tmpExtent[0],
          minY: tmpExtent[1],
          maxX: tmpExtent[2],
          maxY: tmpExtent[3],
          value: feature
        },
        canvasTransform: transform2,
        scale: scale3
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../canvas.js").Label|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imageOrLabel Image.
     * @param {ImageOrLabelDimensions} dimensions Dimensions.
     * @param {number} opacity Opacity.
     * @param {Array<*>} fillInstruction Fill instruction.
     * @param {Array<*>} strokeInstruction Stroke instruction.
     * @return {boolean} The image or label was rendered.
     */
    replayImageOrLabel_(context, contextScale, imageOrLabel, dimensions, opacity, fillInstruction2, strokeInstruction2) {
      const fillStroke = !!(fillInstruction2 || strokeInstruction2);
      const box = dimensions.declutterBox;
      const canvas = context.canvas;
      const strokePadding = strokeInstruction2 ? strokeInstruction2[2] * dimensions.scale[0] / 2 : 0;
      const intersects2 = box.minX - strokePadding <= canvas.width / contextScale && box.maxX + strokePadding >= 0 && box.minY - strokePadding <= canvas.height / contextScale && box.maxY + strokePadding >= 0;
      if (intersects2) {
        if (fillStroke) {
          this.replayTextBackground_(
            context,
            p1,
            p22,
            p3,
            p4,
            /** @type {Array<*>} */
            fillInstruction2,
            /** @type {Array<*>} */
            strokeInstruction2
          );
        }
        drawImageOrLabel(
          context,
          dimensions.canvasTransform,
          opacity,
          imageOrLabel,
          dimensions.originX,
          dimensions.originY,
          dimensions.drawImageW,
          dimensions.drawImageH,
          dimensions.drawImageX,
          dimensions.drawImageY,
          dimensions.scale
        );
      }
      return true;
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     */
    fill_(context) {
      if (this.alignFill_) {
        const origin = apply(this.renderedTransform_, [0, 0]);
        const repeatSize = 512 * this.pixelRatio;
        context.save();
        context.translate(origin[0] % repeatSize, origin[1] % repeatSize);
        context.rotate(this.viewRotation_);
      }
      context.fill();
      if (this.alignFill_) {
        context.restore();
      }
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {Array<*>} instruction Instruction.
     */
    setStrokeStyle_(context, instruction) {
      context["strokeStyle"] = /** @type {import("../../colorlike.js").ColorLike} */
      instruction[1];
      context.lineWidth = /** @type {number} */
      instruction[2];
      context.lineCap = /** @type {CanvasLineCap} */
      instruction[3];
      context.lineJoin = /** @type {CanvasLineJoin} */
      instruction[4];
      context.miterLimit = /** @type {number} */
      instruction[5];
      context.lineDashOffset = /** @type {number} */
      instruction[7];
      context.setLineDash(
        /** @type {Array<number>} */
        instruction[6]
      );
    }
    /**
     * @private
     * @param {string|Array<string>} text The text to draw.
     * @param {string} textKey The key of the text state.
     * @param {string} strokeKey The key for the stroke state.
     * @param {string} fillKey The key for the fill state.
     * @return {{label: import("../canvas.js").Label, anchorX: number, anchorY: number}} The text image and its anchor.
     */
    drawLabelWithPointPlacement_(text, textKey, strokeKey, fillKey) {
      const textState = this.textStates[textKey];
      const label = this.createLabel(text, textKey, fillKey, strokeKey);
      const strokeState = this.strokeStates[strokeKey];
      const pixelRatio = this.pixelRatio;
      const align = horizontalTextAlign(
        Array.isArray(text) ? text[0] : text,
        textState.textAlign || defaultTextAlign
      );
      const baseline = TEXT_ALIGN[textState.textBaseline || defaultTextBaseline];
      const strokeWidth = strokeState && strokeState.lineWidth ? strokeState.lineWidth : 0;
      const width = label.width / pixelRatio - 2 * textState.scale[0];
      const anchorX = align * width + 2 * (0.5 - align) * strokeWidth;
      const anchorY = baseline * label.height / pixelRatio + 2 * (0.5 - baseline) * strokeWidth;
      return {
        label,
        anchorX,
        anchorY
      };
    }
    /**
     * @private
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {Array<*>} instructions Instructions array.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     * @return {T|undefined} Callback result.
     * @template T
     */
    execute_(context, contextScale, transform2, instructions, snapToPixel, featureCallback, hitExtent, declutterTree) {
      let pixelCoordinates;
      if (this.pixelCoordinates_ && equals(transform2, this.renderedTransform_)) {
        pixelCoordinates = this.pixelCoordinates_;
      } else {
        if (!this.pixelCoordinates_) {
          this.pixelCoordinates_ = [];
        }
        pixelCoordinates = transform2D(
          this.coordinates,
          0,
          this.coordinates.length,
          2,
          transform2,
          this.pixelCoordinates_
        );
        setFromArray(this.renderedTransform_, transform2);
      }
      let i4 = 0;
      const ii = instructions.length;
      let d3 = 0;
      let dd;
      let anchorX, anchorY, prevX, prevY, roundX, roundY, image, text, textKey, strokeKey, fillKey;
      let pendingFill = 0;
      let pendingStroke = 0;
      let lastFillInstruction = null;
      let lastStrokeInstruction = null;
      const coordinateCache = this.coordinateCache_;
      const viewRotation = this.viewRotation_;
      const viewRotationFromTransform = Math.round(Math.atan2(-transform2[1], transform2[0]) * 1e12) / 1e12;
      const state = (
        /** @type {import("../../render.js").State} */
        {
          context,
          pixelRatio: this.pixelRatio,
          resolution: this.resolution,
          rotation: viewRotation
        }
      );
      const batchSize = this.instructions != instructions || this.overlaps ? 0 : 200;
      let feature;
      let x2, y2, currentGeometry;
      while (i4 < ii) {
        const instruction = instructions[i4];
        const type = (
          /** @type {import("./Instruction.js").default} */
          instruction[0]
        );
        switch (type) {
          case Instruction_default.BEGIN_GEOMETRY:
            feature = /** @type {import("../../Feature.js").FeatureLike} */
            instruction[1];
            currentGeometry = instruction[3];
            if (!feature.getGeometry()) {
              i4 = /** @type {number} */
              instruction[2];
            } else if (hitExtent !== void 0 && !intersects(hitExtent, currentGeometry.getExtent())) {
              i4 = /** @type {number} */
              instruction[2] + 1;
            } else {
              ++i4;
            }
            break;
          case Instruction_default.BEGIN_PATH:
            if (pendingFill > batchSize) {
              this.fill_(context);
              pendingFill = 0;
            }
            if (pendingStroke > batchSize) {
              context.stroke();
              pendingStroke = 0;
            }
            if (!pendingFill && !pendingStroke) {
              context.beginPath();
              prevX = NaN;
              prevY = NaN;
            }
            ++i4;
            break;
          case Instruction_default.CIRCLE:
            d3 = /** @type {number} */
            instruction[1];
            const x1 = pixelCoordinates[d3];
            const y1 = pixelCoordinates[d3 + 1];
            const x22 = pixelCoordinates[d3 + 2];
            const y22 = pixelCoordinates[d3 + 3];
            const dx = x22 - x1;
            const dy = y22 - y1;
            const r4 = Math.sqrt(dx * dx + dy * dy);
            context.moveTo(x1 + r4, y1);
            context.arc(x1, y1, r4, 0, 2 * Math.PI, true);
            ++i4;
            break;
          case Instruction_default.CLOSE_PATH:
            context.closePath();
            ++i4;
            break;
          case Instruction_default.CUSTOM:
            d3 = /** @type {number} */
            instruction[1];
            dd = instruction[2];
            const geometry = (
              /** @type {import("../../geom/SimpleGeometry.js").default} */
              instruction[3]
            );
            const renderer = instruction[4];
            const fn = instruction.length == 6 ? instruction[5] : void 0;
            state.geometry = geometry;
            state.feature = feature;
            if (!(i4 in coordinateCache)) {
              coordinateCache[i4] = [];
            }
            const coords = coordinateCache[i4];
            if (fn) {
              fn(pixelCoordinates, d3, dd, 2, coords);
            } else {
              coords[0] = pixelCoordinates[d3];
              coords[1] = pixelCoordinates[d3 + 1];
              coords.length = 2;
            }
            renderer(coords, state);
            ++i4;
            break;
          case Instruction_default.DRAW_IMAGE:
            d3 = /** @type {number} */
            instruction[1];
            dd = /** @type {number} */
            instruction[2];
            image = /** @type {HTMLCanvasElement|HTMLVideoElement|HTMLImageElement} */
            instruction[3];
            anchorX = /** @type {number} */
            instruction[4];
            anchorY = /** @type {number} */
            instruction[5];
            let height = (
              /** @type {number} */
              instruction[6]
            );
            const opacity = (
              /** @type {number} */
              instruction[7]
            );
            const originX = (
              /** @type {number} */
              instruction[8]
            );
            const originY = (
              /** @type {number} */
              instruction[9]
            );
            const rotateWithView = (
              /** @type {boolean} */
              instruction[10]
            );
            let rotation = (
              /** @type {number} */
              instruction[11]
            );
            const scale3 = (
              /** @type {import("../../size.js").Size} */
              instruction[12]
            );
            let width = (
              /** @type {number} */
              instruction[13]
            );
            const declutterMode = (
              /** @type {"declutter"|"obstacle"|"none"|undefined} */
              instruction[14]
            );
            const declutterImageWithText = (
              /** @type {import("../canvas.js").DeclutterImageWithText} */
              instruction[15]
            );
            if (!image && instruction.length >= 20) {
              text = /** @type {string} */
              instruction[19];
              textKey = /** @type {string} */
              instruction[20];
              strokeKey = /** @type {string} */
              instruction[21];
              fillKey = /** @type {string} */
              instruction[22];
              const labelWithAnchor = this.drawLabelWithPointPlacement_(
                text,
                textKey,
                strokeKey,
                fillKey
              );
              image = labelWithAnchor.label;
              instruction[3] = image;
              const textOffsetX = (
                /** @type {number} */
                instruction[23]
              );
              anchorX = (labelWithAnchor.anchorX - textOffsetX) * this.pixelRatio;
              instruction[4] = anchorX;
              const textOffsetY = (
                /** @type {number} */
                instruction[24]
              );
              anchorY = (labelWithAnchor.anchorY - textOffsetY) * this.pixelRatio;
              instruction[5] = anchorY;
              height = image.height;
              instruction[6] = height;
              width = image.width;
              instruction[13] = width;
            }
            let geometryWidths;
            if (instruction.length > 25) {
              geometryWidths = /** @type {number} */
              instruction[25];
            }
            let padding, backgroundFill, backgroundStroke;
            if (instruction.length > 17) {
              padding = /** @type {Array<number>} */
              instruction[16];
              backgroundFill = /** @type {boolean} */
              instruction[17];
              backgroundStroke = /** @type {boolean} */
              instruction[18];
            } else {
              padding = defaultPadding;
              backgroundFill = false;
              backgroundStroke = false;
            }
            if (rotateWithView && viewRotationFromTransform) {
              rotation += viewRotation;
            } else if (!rotateWithView && !viewRotationFromTransform) {
              rotation -= viewRotation;
            }
            let widthIndex = 0;
            for (; d3 < dd; d3 += 2) {
              if (geometryWidths && geometryWidths[widthIndex++] < width / this.pixelRatio) {
                continue;
              }
              const dimensions = this.calculateImageOrLabelDimensions_(
                image.width,
                image.height,
                pixelCoordinates[d3],
                pixelCoordinates[d3 + 1],
                width,
                height,
                anchorX,
                anchorY,
                originX,
                originY,
                rotation,
                scale3,
                snapToPixel,
                padding,
                backgroundFill || backgroundStroke,
                feature
              );
              const args = [
                context,
                contextScale,
                image,
                dimensions,
                opacity,
                backgroundFill ? (
                  /** @type {Array<*>} */
                  lastFillInstruction
                ) : null,
                backgroundStroke ? (
                  /** @type {Array<*>} */
                  lastStrokeInstruction
                ) : null
              ];
              if (declutterTree) {
                if (declutterMode === "none") {
                  continue;
                } else if (declutterMode === "obstacle") {
                  declutterTree.insert(dimensions.declutterBox);
                  continue;
                } else {
                  let imageArgs;
                  let imageDeclutterBox;
                  if (declutterImageWithText) {
                    const index = dd - d3;
                    if (!declutterImageWithText[index]) {
                      declutterImageWithText[index] = args;
                      continue;
                    }
                    imageArgs = declutterImageWithText[index];
                    delete declutterImageWithText[index];
                    imageDeclutterBox = getDeclutterBox(imageArgs);
                    if (declutterTree.collides(imageDeclutterBox)) {
                      continue;
                    }
                  }
                  if (declutterTree.collides(dimensions.declutterBox)) {
                    continue;
                  }
                  if (imageArgs) {
                    declutterTree.insert(imageDeclutterBox);
                    this.replayImageOrLabel_.apply(this, imageArgs);
                  }
                  declutterTree.insert(dimensions.declutterBox);
                }
              }
              this.replayImageOrLabel_.apply(this, args);
            }
            ++i4;
            break;
          case Instruction_default.DRAW_CHARS:
            const begin = (
              /** @type {number} */
              instruction[1]
            );
            const end = (
              /** @type {number} */
              instruction[2]
            );
            const baseline = (
              /** @type {number} */
              instruction[3]
            );
            const overflow = (
              /** @type {number} */
              instruction[4]
            );
            fillKey = /** @type {string} */
            instruction[5];
            const maxAngle = (
              /** @type {number} */
              instruction[6]
            );
            const measurePixelRatio = (
              /** @type {number} */
              instruction[7]
            );
            const offsetY = (
              /** @type {number} */
              instruction[8]
            );
            strokeKey = /** @type {string} */
            instruction[9];
            const strokeWidth = (
              /** @type {number} */
              instruction[10]
            );
            text = /** @type {string} */
            instruction[11];
            textKey = /** @type {string} */
            instruction[12];
            const pixelRatioScale = [
              /** @type {number} */
              instruction[13],
              /** @type {number} */
              instruction[13]
            ];
            const textState = this.textStates[textKey];
            const font = textState.font;
            const textScale = [
              textState.scale[0] * measurePixelRatio,
              textState.scale[1] * measurePixelRatio
            ];
            let cachedWidths;
            if (font in this.widths_) {
              cachedWidths = this.widths_[font];
            } else {
              cachedWidths = {};
              this.widths_[font] = cachedWidths;
            }
            const pathLength = lineStringLength(pixelCoordinates, begin, end, 2);
            const textLength = Math.abs(textScale[0]) * measureAndCacheTextWidth(font, text, cachedWidths);
            if (overflow || textLength <= pathLength) {
              const textAlign = this.textStates[textKey].textAlign;
              const startM = (pathLength - textLength) * horizontalTextAlign(text, textAlign);
              const parts = drawTextOnPath(
                pixelCoordinates,
                begin,
                end,
                2,
                text,
                startM,
                maxAngle,
                Math.abs(textScale[0]),
                measureAndCacheTextWidth,
                font,
                cachedWidths,
                viewRotationFromTransform ? 0 : this.viewRotation_
              );
              drawChars:
                if (parts) {
                  const replayImageOrLabelArgs = [];
                  let c4, cc, chars, label, part;
                  if (strokeKey) {
                    for (c4 = 0, cc = parts.length; c4 < cc; ++c4) {
                      part = parts[c4];
                      chars = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars, textKey, "", strokeKey);
                      anchorX = /** @type {number} */
                      part[2] + (textScale[0] < 0 ? -strokeWidth : strokeWidth);
                      anchorY = baseline * label.height + (0.5 - baseline) * 2 * strokeWidth * textScale[1] / textScale[0] - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(
                        label.width,
                        label.height,
                        part[0],
                        part[1],
                        label.width,
                        label.height,
                        anchorX,
                        anchorY,
                        0,
                        0,
                        part[3],
                        pixelRatioScale,
                        false,
                        defaultPadding,
                        false,
                        feature
                      );
                      if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        contextScale,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (fillKey) {
                    for (c4 = 0, cc = parts.length; c4 < cc; ++c4) {
                      part = parts[c4];
                      chars = /** @type {string} */
                      part[4];
                      label = this.createLabel(chars, textKey, fillKey, "");
                      anchorX = /** @type {number} */
                      part[2];
                      anchorY = baseline * label.height - offsetY;
                      const dimensions = this.calculateImageOrLabelDimensions_(
                        label.width,
                        label.height,
                        part[0],
                        part[1],
                        label.width,
                        label.height,
                        anchorX,
                        anchorY,
                        0,
                        0,
                        part[3],
                        pixelRatioScale,
                        false,
                        defaultPadding,
                        false,
                        feature
                      );
                      if (declutterTree && declutterTree.collides(dimensions.declutterBox)) {
                        break drawChars;
                      }
                      replayImageOrLabelArgs.push([
                        context,
                        contextScale,
                        label,
                        dimensions,
                        1,
                        null,
                        null
                      ]);
                    }
                  }
                  if (declutterTree) {
                    declutterTree.load(replayImageOrLabelArgs.map(getDeclutterBox));
                  }
                  for (let i5 = 0, ii2 = replayImageOrLabelArgs.length; i5 < ii2; ++i5) {
                    this.replayImageOrLabel_.apply(this, replayImageOrLabelArgs[i5]);
                  }
                }
            }
            ++i4;
            break;
          case Instruction_default.END_GEOMETRY:
            if (featureCallback !== void 0) {
              feature = /** @type {import("../../Feature.js").FeatureLike} */
              instruction[1];
              const result = featureCallback(feature, currentGeometry);
              if (result) {
                return result;
              }
            }
            ++i4;
            break;
          case Instruction_default.FILL:
            if (batchSize) {
              pendingFill++;
            } else {
              this.fill_(context);
            }
            ++i4;
            break;
          case Instruction_default.MOVE_TO_LINE_TO:
            d3 = /** @type {number} */
            instruction[1];
            dd = /** @type {number} */
            instruction[2];
            x2 = pixelCoordinates[d3];
            y2 = pixelCoordinates[d3 + 1];
            roundX = x2 + 0.5 | 0;
            roundY = y2 + 0.5 | 0;
            if (roundX !== prevX || roundY !== prevY) {
              context.moveTo(x2, y2);
              prevX = roundX;
              prevY = roundY;
            }
            for (d3 += 2; d3 < dd; d3 += 2) {
              x2 = pixelCoordinates[d3];
              y2 = pixelCoordinates[d3 + 1];
              roundX = x2 + 0.5 | 0;
              roundY = y2 + 0.5 | 0;
              if (d3 == dd - 2 || roundX !== prevX || roundY !== prevY) {
                context.lineTo(x2, y2);
                prevX = roundX;
                prevY = roundY;
              }
            }
            ++i4;
            break;
          case Instruction_default.SET_FILL_STYLE:
            lastFillInstruction = instruction;
            this.alignFill_ = instruction[2];
            if (pendingFill) {
              this.fill_(context);
              pendingFill = 0;
              if (pendingStroke) {
                context.stroke();
                pendingStroke = 0;
              }
            }
            context.fillStyle = /** @type {import("../../colorlike.js").ColorLike} */
            instruction[1];
            ++i4;
            break;
          case Instruction_default.SET_STROKE_STYLE:
            lastStrokeInstruction = instruction;
            if (pendingStroke) {
              context.stroke();
              pendingStroke = 0;
            }
            this.setStrokeStyle_(
              context,
              /** @type {Array<*>} */
              instruction
            );
            ++i4;
            break;
          case Instruction_default.STROKE:
            if (batchSize) {
              pendingStroke++;
            } else {
              context.stroke();
            }
            ++i4;
            break;
          default:
            ++i4;
            break;
        }
      }
      if (pendingFill) {
        this.fill_(context);
      }
      if (pendingStroke) {
        context.stroke();
      }
      return void 0;
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and text to integer pixels.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */
    execute(context, contextScale, transform2, viewRotation, snapToPixel, declutterTree) {
      this.viewRotation_ = viewRotation;
      this.execute_(
        context,
        contextScale,
        transform2,
        this.instructions,
        snapToPixel,
        void 0,
        void 0,
        declutterTree
      );
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {FeatureCallback<T>} [featureCallback] Feature callback.
     * @param {import("../../extent.js").Extent} [hitExtent] Only check
     *     features that intersect this extent.
     * @return {T|undefined} Callback result.
     * @template T
     */
    executeHitDetection(context, transform2, viewRotation, featureCallback, hitExtent) {
      this.viewRotation_ = viewRotation;
      return this.execute_(
        context,
        1,
        transform2,
        this.hitDetectionInstructions,
        true,
        featureCallback,
        hitExtent
      );
    }
  };
  var Executor_default = Executor;

  // node_modules/ol/render/canvas/ExecutorGroup.js
  var ORDER = ["Polygon", "Circle", "LineString", "Image", "Text", "Default"];
  var ExecutorGroup = class {
    /**
     * @param {import("../../extent.js").Extent} maxExtent Max extent for clipping. When a
     * `maxExtent` was set on the Builder for this executor group, the same `maxExtent`
     * should be set here, unless the target context does not exceed that extent (which
     * can be the case when rendering to tiles).
     * @param {number} resolution Resolution.
     * @param {number} pixelRatio Pixel ratio.
     * @param {boolean} overlaps The executor group can have overlapping geometries.
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions
     * The serializable instructions.
     * @param {number} [renderBuffer] Optional rendering buffer.
     */
    constructor(maxExtent, resolution, pixelRatio, overlaps, allInstructions, renderBuffer) {
      this.maxExtent_ = maxExtent;
      this.overlaps_ = overlaps;
      this.pixelRatio_ = pixelRatio;
      this.resolution_ = resolution;
      this.renderBuffer_ = renderBuffer;
      this.executorsByZIndex_ = {};
      this.hitDetectionContext_ = null;
      this.hitDetectionTransform_ = create();
      this.createExecutors_(allInstructions);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    clip(context, transform2) {
      const flatClipCoords = this.getClipCoords(transform2);
      context.beginPath();
      context.moveTo(flatClipCoords[0], flatClipCoords[1]);
      context.lineTo(flatClipCoords[2], flatClipCoords[3]);
      context.lineTo(flatClipCoords[4], flatClipCoords[5]);
      context.lineTo(flatClipCoords[6], flatClipCoords[7]);
      context.clip();
    }
    /**
     * Create executors and populate them using the provided instructions.
     * @private
     * @param {!Object<string, !Object<import("../canvas.js").BuilderType, import("../canvas.js").SerializableInstructions>>} allInstructions The serializable instructions
     */
    createExecutors_(allInstructions) {
      for (const zIndex in allInstructions) {
        let executors = this.executorsByZIndex_[zIndex];
        if (executors === void 0) {
          executors = {};
          this.executorsByZIndex_[zIndex] = executors;
        }
        const instructionByZindex = allInstructions[zIndex];
        for (const builderType in instructionByZindex) {
          const instructions = instructionByZindex[builderType];
          executors[builderType] = new Executor_default(
            this.resolution_,
            this.pixelRatio_,
            this.overlaps_,
            instructions
          );
        }
      }
    }
    /**
     * @param {Array<import("../canvas.js").BuilderType>} executors Executors.
     * @return {boolean} Has executors of the provided types.
     */
    hasExecutors(executors) {
      for (const zIndex in this.executorsByZIndex_) {
        const candidates = this.executorsByZIndex_[zIndex];
        for (let i4 = 0, ii = executors.length; i4 < ii; ++i4) {
          if (executors[i4] in candidates) {
            return true;
          }
        }
      }
      return false;
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {number} resolution Resolution.
     * @param {number} rotation Rotation.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {function(import("../../Feature.js").FeatureLike, import("../../geom/SimpleGeometry.js").default, number): T} callback Feature callback.
     * @param {Array<import("../../Feature.js").FeatureLike>} declutteredFeatures Decluttered features.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(coordinate, resolution, rotation, hitTolerance, callback, declutteredFeatures) {
      hitTolerance = Math.round(hitTolerance);
      const contextSize = hitTolerance * 2 + 1;
      const transform2 = compose(
        this.hitDetectionTransform_,
        hitTolerance + 0.5,
        hitTolerance + 0.5,
        1 / resolution,
        -1 / resolution,
        -rotation,
        -coordinate[0],
        -coordinate[1]
      );
      const newContext = !this.hitDetectionContext_;
      if (newContext) {
        this.hitDetectionContext_ = createCanvasContext2D(
          contextSize,
          contextSize,
          void 0,
          { willReadFrequently: true }
        );
      }
      const context = this.hitDetectionContext_;
      if (context.canvas.width !== contextSize || context.canvas.height !== contextSize) {
        context.canvas.width = contextSize;
        context.canvas.height = contextSize;
      } else if (!newContext) {
        context.clearRect(0, 0, contextSize, contextSize);
      }
      let hitExtent;
      if (this.renderBuffer_ !== void 0) {
        hitExtent = createEmpty();
        extendCoordinate(hitExtent, coordinate);
        buffer(
          hitExtent,
          resolution * (this.renderBuffer_ + hitTolerance),
          hitExtent
        );
      }
      const indexes = getPixelIndexArray(hitTolerance);
      let builderType;
      function featureCallback(feature, geometry) {
        const imageData = context.getImageData(
          0,
          0,
          contextSize,
          contextSize
        ).data;
        for (let i5 = 0, ii = indexes.length; i5 < ii; i5++) {
          if (imageData[indexes[i5]] > 0) {
            if (!declutteredFeatures || builderType !== "Image" && builderType !== "Text" || declutteredFeatures.includes(feature)) {
              const idx = (indexes[i5] - 3) / 4;
              const x2 = hitTolerance - idx % contextSize;
              const y2 = hitTolerance - (idx / contextSize | 0);
              const result2 = callback(feature, geometry, x2 * x2 + y2 * y2);
              if (result2) {
                return result2;
              }
            }
            context.clearRect(0, 0, contextSize, contextSize);
            break;
          }
        }
        return void 0;
      }
      const zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(ascending);
      let i4, j3, executors, executor, result;
      for (i4 = zs.length - 1; i4 >= 0; --i4) {
        const zIndexKey = zs[i4].toString();
        executors = this.executorsByZIndex_[zIndexKey];
        for (j3 = ORDER.length - 1; j3 >= 0; --j3) {
          builderType = ORDER[j3];
          executor = executors[builderType];
          if (executor !== void 0) {
            result = executor.executeHitDetection(
              context,
              transform2,
              rotation,
              featureCallback,
              hitExtent
            );
            if (result) {
              return result;
            }
          }
        }
      }
      return void 0;
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     * @return {Array<number>|null} Clip coordinates.
     */
    getClipCoords(transform2) {
      const maxExtent = this.maxExtent_;
      if (!maxExtent) {
        return null;
      }
      const minX = maxExtent[0];
      const minY = maxExtent[1];
      const maxX = maxExtent[2];
      const maxY = maxExtent[3];
      const flatClipCoords = [minX, minY, minX, maxY, maxX, maxY, maxX, minY];
      transform2D(flatClipCoords, 0, 8, 2, transform2, flatClipCoords);
      return flatClipCoords;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return isEmpty(this.executorsByZIndex_);
    }
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} contextScale Scale of the context.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {boolean} snapToPixel Snap point symbols and test to integer pixel.
     * @param {Array<import("../canvas.js").BuilderType>} [builderTypes] Ordered replay types to replay.
     *     Default is {@link module:ol/render/replay~ORDER}
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */
    execute(context, contextScale, transform2, viewRotation, snapToPixel, builderTypes, declutterTree) {
      const zs = Object.keys(this.executorsByZIndex_).map(Number);
      zs.sort(ascending);
      if (this.maxExtent_) {
        context.save();
        this.clip(context, transform2);
      }
      builderTypes = builderTypes ? builderTypes : ORDER;
      let i4, ii, j3, jj, replays, replay;
      if (declutterTree) {
        zs.reverse();
      }
      for (i4 = 0, ii = zs.length; i4 < ii; ++i4) {
        const zIndexKey = zs[i4].toString();
        replays = this.executorsByZIndex_[zIndexKey];
        for (j3 = 0, jj = builderTypes.length; j3 < jj; ++j3) {
          const builderType = builderTypes[j3];
          replay = replays[builderType];
          if (replay !== void 0) {
            replay.execute(
              context,
              contextScale,
              transform2,
              viewRotation,
              snapToPixel,
              declutterTree
            );
          }
        }
      }
      if (this.maxExtent_) {
        context.restore();
      }
    }
  };
  var circlePixelIndexArrayCache = {};
  function getPixelIndexArray(radius) {
    if (circlePixelIndexArrayCache[radius] !== void 0) {
      return circlePixelIndexArrayCache[radius];
    }
    const size = radius * 2 + 1;
    const maxDistanceSq = radius * radius;
    const distances = new Array(maxDistanceSq + 1);
    for (let i4 = 0; i4 <= radius; ++i4) {
      for (let j3 = 0; j3 <= radius; ++j3) {
        const distanceSq = i4 * i4 + j3 * j3;
        if (distanceSq > maxDistanceSq) {
          break;
        }
        let distance = distances[distanceSq];
        if (!distance) {
          distance = [];
          distances[distanceSq] = distance;
        }
        distance.push(((radius + i4) * size + (radius + j3)) * 4 + 3);
        if (i4 > 0) {
          distance.push(((radius - i4) * size + (radius + j3)) * 4 + 3);
        }
        if (j3 > 0) {
          distance.push(((radius + i4) * size + (radius - j3)) * 4 + 3);
          if (i4 > 0) {
            distance.push(((radius - i4) * size + (radius - j3)) * 4 + 3);
          }
        }
      }
    }
    const pixelIndex = [];
    for (let i4 = 0, ii = distances.length; i4 < ii; ++i4) {
      if (distances[i4]) {
        pixelIndex.push(...distances[i4]);
      }
    }
    circlePixelIndexArrayCache[radius] = pixelIndex;
    return pixelIndex;
  }
  var ExecutorGroup_default = ExecutorGroup;

  // node_modules/ol/render/canvas/Immediate.js
  var CanvasImmediateRenderer = class extends VectorContext_default {
    /**
     * @param {CanvasRenderingContext2D} context Context.
     * @param {number} pixelRatio Pixel ratio.
     * @param {import("../../extent.js").Extent} extent Extent.
     * @param {import("../../transform.js").Transform} transform Transform.
     * @param {number} viewRotation View rotation.
     * @param {number} [squaredTolerance] Optional squared tolerance for simplification.
     * @param {import("../../proj.js").TransformFunction} [userTransform] Transform from user to view projection.
     */
    constructor(context, pixelRatio, extent, transform2, viewRotation, squaredTolerance, userTransform) {
      super();
      this.context_ = context;
      this.pixelRatio_ = pixelRatio;
      this.extent_ = extent;
      this.transform_ = transform2;
      this.transformRotation_ = transform2 ? toFixed(Math.atan2(transform2[1], transform2[0]), 10) : 0;
      this.viewRotation_ = viewRotation;
      this.squaredTolerance_ = squaredTolerance;
      this.userTransform_ = userTransform;
      this.contextFillState_ = null;
      this.contextStrokeState_ = null;
      this.contextTextState_ = null;
      this.fillState_ = null;
      this.strokeState_ = null;
      this.image_ = null;
      this.imageAnchorX_ = 0;
      this.imageAnchorY_ = 0;
      this.imageHeight_ = 0;
      this.imageOpacity_ = 0;
      this.imageOriginX_ = 0;
      this.imageOriginY_ = 0;
      this.imageRotateWithView_ = false;
      this.imageRotation_ = 0;
      this.imageScale_ = [0, 0];
      this.imageWidth_ = 0;
      this.text_ = "";
      this.textOffsetX_ = 0;
      this.textOffsetY_ = 0;
      this.textRotateWithView_ = false;
      this.textRotation_ = 0;
      this.textScale_ = [0, 0];
      this.textFillState_ = null;
      this.textStrokeState_ = null;
      this.textState_ = null;
      this.pixelCoordinates_ = [];
      this.tmpLocalTransform_ = create();
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawImages_(flatCoordinates, offset2, end, stride) {
      if (!this.image_) {
        return;
      }
      const pixelCoordinates = transform2D(
        flatCoordinates,
        offset2,
        end,
        stride,
        this.transform_,
        this.pixelCoordinates_
      );
      const context = this.context_;
      const localTransform = this.tmpLocalTransform_;
      const alpha = context.globalAlpha;
      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha * this.imageOpacity_;
      }
      let rotation = this.imageRotation_;
      if (this.transformRotation_ === 0) {
        rotation -= this.viewRotation_;
      }
      if (this.imageRotateWithView_) {
        rotation += this.viewRotation_;
      }
      for (let i4 = 0, ii = pixelCoordinates.length; i4 < ii; i4 += 2) {
        const x2 = pixelCoordinates[i4] - this.imageAnchorX_;
        const y2 = pixelCoordinates[i4 + 1] - this.imageAnchorY_;
        if (rotation !== 0 || this.imageScale_[0] != 1 || this.imageScale_[1] != 1) {
          const centerX = x2 + this.imageAnchorX_;
          const centerY = y2 + this.imageAnchorY_;
          compose(
            localTransform,
            centerX,
            centerY,
            1,
            1,
            rotation,
            -centerX,
            -centerY
          );
          context.save();
          context.transform.apply(context, localTransform);
          context.translate(centerX, centerY);
          context.scale(this.imageScale_[0], this.imageScale_[1]);
          context.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            -this.imageAnchorX_,
            -this.imageAnchorY_,
            this.imageWidth_,
            this.imageHeight_
          );
          context.restore();
        } else {
          context.drawImage(
            this.image_,
            this.imageOriginX_,
            this.imageOriginY_,
            this.imageWidth_,
            this.imageHeight_,
            x2,
            y2,
            this.imageWidth_,
            this.imageHeight_
          );
        }
      }
      if (this.imageOpacity_ != 1) {
        context.globalAlpha = alpha;
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @private
     */
    drawText_(flatCoordinates, offset2, end, stride) {
      if (!this.textState_ || this.text_ === "") {
        return;
      }
      if (this.textFillState_) {
        this.setContextFillState_(this.textFillState_);
      }
      if (this.textStrokeState_) {
        this.setContextStrokeState_(this.textStrokeState_);
      }
      this.setContextTextState_(this.textState_);
      const pixelCoordinates = transform2D(
        flatCoordinates,
        offset2,
        end,
        stride,
        this.transform_,
        this.pixelCoordinates_
      );
      const context = this.context_;
      let rotation = this.textRotation_;
      if (this.transformRotation_ === 0) {
        rotation -= this.viewRotation_;
      }
      if (this.textRotateWithView_) {
        rotation += this.viewRotation_;
      }
      for (; offset2 < end; offset2 += stride) {
        const x2 = pixelCoordinates[offset2] + this.textOffsetX_;
        const y2 = pixelCoordinates[offset2 + 1] + this.textOffsetY_;
        if (rotation !== 0 || this.textScale_[0] != 1 || this.textScale_[1] != 1) {
          context.save();
          context.translate(x2 - this.textOffsetX_, y2 - this.textOffsetY_);
          context.rotate(rotation);
          context.translate(this.textOffsetX_, this.textOffsetY_);
          context.scale(this.textScale_[0], this.textScale_[1]);
          if (this.textStrokeState_) {
            context.strokeText(this.text_, 0, 0);
          }
          if (this.textFillState_) {
            context.fillText(this.text_, 0, 0);
          }
          context.restore();
        } else {
          if (this.textStrokeState_) {
            context.strokeText(this.text_, x2, y2);
          }
          if (this.textFillState_) {
            context.fillText(this.text_, x2, y2);
          }
        }
      }
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {number} end End.
     * @param {number} stride Stride.
     * @param {boolean} close Close.
     * @private
     * @return {number} end End.
     */
    moveToLineTo_(flatCoordinates, offset2, end, stride, close) {
      const context = this.context_;
      const pixelCoordinates = transform2D(
        flatCoordinates,
        offset2,
        end,
        stride,
        this.transform_,
        this.pixelCoordinates_
      );
      context.moveTo(pixelCoordinates[0], pixelCoordinates[1]);
      let length = pixelCoordinates.length;
      if (close) {
        length -= 2;
      }
      for (let i4 = 2; i4 < length; i4 += 2) {
        context.lineTo(pixelCoordinates[i4], pixelCoordinates[i4 + 1]);
      }
      if (close) {
        context.closePath();
      }
      return end;
    }
    /**
     * @param {Array<number>} flatCoordinates Flat coordinates.
     * @param {number} offset Offset.
     * @param {Array<number>} ends Ends.
     * @param {number} stride Stride.
     * @private
     * @return {number} End.
     */
    drawRings_(flatCoordinates, offset2, ends, stride) {
      for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
        offset2 = this.moveToLineTo_(
          flatCoordinates,
          offset2,
          ends[i4],
          stride,
          true
        );
      }
      return offset2;
    }
    /**
     * Render a circle geometry into the canvas.  Rendering is immediate and uses
     * the current fill and stroke styles.
     *
     * @param {import("../../geom/Circle.js").default} geometry Circle geometry.
     * @api
     */
    drawCircle(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Circle.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.fillState_ || this.strokeState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        const pixelCoordinates = transformGeom2D(
          geometry,
          this.transform_,
          this.pixelCoordinates_
        );
        const dx = pixelCoordinates[2] - pixelCoordinates[0];
        const dy = pixelCoordinates[3] - pixelCoordinates[1];
        const radius = Math.sqrt(dx * dx + dy * dy);
        const context = this.context_;
        context.beginPath();
        context.arc(
          pixelCoordinates[0],
          pixelCoordinates[1],
          radius,
          0,
          2 * Math.PI
        );
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== "") {
        this.drawText_(geometry.getCenter(), 0, 2, 2);
      }
    }
    /**
     * Set the rendering style.  Note that since this is an immediate rendering API,
     * any `zIndex` on the provided style will be ignored.
     *
     * @param {import("../../style/Style.js").default} style The rendering style.
     * @api
     */
    setStyle(style) {
      this.setFillStrokeStyle(style.getFill(), style.getStroke());
      this.setImageStyle(style.getImage());
      this.setTextStyle(style.getText());
    }
    /**
     * @param {import("../../transform.js").Transform} transform Transform.
     */
    setTransform(transform2) {
      this.transform_ = transform2;
    }
    /**
     * Render a geometry into the canvas.  Call
     * {@link module:ol/render/canvas/Immediate~CanvasImmediateRenderer#setStyle renderer.setStyle()} first to set the rendering style.
     *
     * @param {import("../../geom/Geometry.js").default|import("../Feature.js").default} geometry The geometry to render.
     * @api
     */
    drawGeometry(geometry) {
      const type = geometry.getType();
      switch (type) {
        case "Point":
          this.drawPoint(
            /** @type {import("../../geom/Point.js").default} */
            geometry
          );
          break;
        case "LineString":
          this.drawLineString(
            /** @type {import("../../geom/LineString.js").default} */
            geometry
          );
          break;
        case "Polygon":
          this.drawPolygon(
            /** @type {import("../../geom/Polygon.js").default} */
            geometry
          );
          break;
        case "MultiPoint":
          this.drawMultiPoint(
            /** @type {import("../../geom/MultiPoint.js").default} */
            geometry
          );
          break;
        case "MultiLineString":
          this.drawMultiLineString(
            /** @type {import("../../geom/MultiLineString.js").default} */
            geometry
          );
          break;
        case "MultiPolygon":
          this.drawMultiPolygon(
            /** @type {import("../../geom/MultiPolygon.js").default} */
            geometry
          );
          break;
        case "GeometryCollection":
          this.drawGeometryCollection(
            /** @type {import("../../geom/GeometryCollection.js").default} */
            geometry
          );
          break;
        case "Circle":
          this.drawCircle(
            /** @type {import("../../geom/Circle.js").default} */
            geometry
          );
          break;
        default:
      }
    }
    /**
     * Render a feature into the canvas.  Note that any `zIndex` on the provided
     * style will be ignored - features are rendered immediately in the order that
     * this method is called.  If you need `zIndex` support, you should be using an
     * {@link module:ol/layer/Vector~VectorLayer} instead.
     *
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {import("../../style/Style.js").default} style Style.
     * @api
     */
    drawFeature(feature, style) {
      const geometry = style.getGeometryFunction()(feature);
      if (!geometry) {
        return;
      }
      this.setStyle(style);
      this.drawGeometry(geometry);
    }
    /**
     * Render a GeometryCollection to the canvas.  Rendering is immediate and
     * uses the current styles appropriate for each geometry in the collection.
     *
     * @param {import("../../geom/GeometryCollection.js").default} geometry Geometry collection.
     */
    drawGeometryCollection(geometry) {
      const geometries = geometry.getGeometriesArray();
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        this.drawGeometry(geometries[i4]);
      }
    }
    /**
     * Render a Point geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Point.js").default|import("../Feature.js").default} geometry Point geometry.
     */
    drawPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Point.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      const flatCoordinates = geometry.getFlatCoordinates();
      const stride = geometry.getStride();
      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
      if (this.text_ !== "") {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }
    /**
     * Render a MultiPoint geometry  into the canvas.  Rendering is immediate and
     * uses the current style.
     *
     * @param {import("../../geom/MultiPoint.js").default|import("../Feature.js").default} geometry MultiPoint geometry.
     */
    drawMultiPoint(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiPoint.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      const flatCoordinates = geometry.getFlatCoordinates();
      const stride = geometry.getStride();
      if (this.image_) {
        this.drawImages_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
      if (this.text_ !== "") {
        this.drawText_(flatCoordinates, 0, flatCoordinates.length, stride);
      }
    }
    /**
     * Render a LineString into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/LineString.js").default|import("../Feature.js").default} geometry LineString geometry.
     */
    drawLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/LineString.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const context = this.context_;
        const flatCoordinates = geometry.getFlatCoordinates();
        context.beginPath();
        this.moveToLineTo_(
          flatCoordinates,
          0,
          flatCoordinates.length,
          geometry.getStride(),
          false
        );
        context.stroke();
      }
      if (this.text_ !== "") {
        const flatMidpoint = geometry.getFlatMidpoint();
        this.drawText_(flatMidpoint, 0, 2, 2);
      }
    }
    /**
     * Render a MultiLineString geometry into the canvas.  Rendering is immediate
     * and uses the current style.
     *
     * @param {import("../../geom/MultiLineString.js").default|import("../Feature.js").default} geometry MultiLineString geometry.
     */
    drawMultiLineString(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiLineString.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      const geometryExtent = geometry.getExtent();
      if (!intersects(this.extent_, geometryExtent)) {
        return;
      }
      if (this.strokeState_) {
        this.setContextStrokeState_(this.strokeState_);
        const context = this.context_;
        const flatCoordinates = geometry.getFlatCoordinates();
        let offset2 = 0;
        const ends = (
          /** @type {Array<number>} */
          geometry.getEnds()
        );
        const stride = geometry.getStride();
        context.beginPath();
        for (let i4 = 0, ii = ends.length; i4 < ii; ++i4) {
          offset2 = this.moveToLineTo_(
            flatCoordinates,
            offset2,
            ends[i4],
            stride,
            false
          );
        }
        context.stroke();
      }
      if (this.text_ !== "") {
        const flatMidpoints = geometry.getFlatMidpoints();
        this.drawText_(flatMidpoints, 0, flatMidpoints.length, 2);
      }
    }
    /**
     * Render a Polygon geometry into the canvas.  Rendering is immediate and uses
     * the current style.
     *
     * @param {import("../../geom/Polygon.js").default|import("../Feature.js").default} geometry Polygon geometry.
     */
    drawPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/Polygon.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        const context = this.context_;
        context.beginPath();
        this.drawRings_(
          geometry.getOrientedFlatCoordinates(),
          0,
          /** @type {Array<number>} */
          geometry.getEnds(),
          geometry.getStride()
        );
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== "") {
        const flatInteriorPoint = geometry.getFlatInteriorPoint();
        this.drawText_(flatInteriorPoint, 0, 2, 2);
      }
    }
    /**
     * Render MultiPolygon geometry into the canvas.  Rendering is immediate and
     * uses the current style.
     * @param {import("../../geom/MultiPolygon.js").default} geometry MultiPolygon geometry.
     */
    drawMultiPolygon(geometry) {
      if (this.squaredTolerance_) {
        geometry = /** @type {import("../../geom/MultiPolygon.js").default} */
        geometry.simplifyTransformed(
          this.squaredTolerance_,
          this.userTransform_
        );
      }
      if (!intersects(this.extent_, geometry.getExtent())) {
        return;
      }
      if (this.strokeState_ || this.fillState_) {
        if (this.fillState_) {
          this.setContextFillState_(this.fillState_);
        }
        if (this.strokeState_) {
          this.setContextStrokeState_(this.strokeState_);
        }
        const context = this.context_;
        const flatCoordinates = geometry.getOrientedFlatCoordinates();
        let offset2 = 0;
        const endss = geometry.getEndss();
        const stride = geometry.getStride();
        context.beginPath();
        for (let i4 = 0, ii = endss.length; i4 < ii; ++i4) {
          const ends = endss[i4];
          offset2 = this.drawRings_(flatCoordinates, offset2, ends, stride);
        }
        if (this.fillState_) {
          context.fill();
        }
        if (this.strokeState_) {
          context.stroke();
        }
      }
      if (this.text_ !== "") {
        const flatInteriorPoints = geometry.getFlatInteriorPoints();
        this.drawText_(flatInteriorPoints, 0, flatInteriorPoints.length, 2);
      }
    }
    /**
     * @param {import("../canvas.js").FillState} fillState Fill state.
     * @private
     */
    setContextFillState_(fillState) {
      const context = this.context_;
      const contextFillState = this.contextFillState_;
      if (!contextFillState) {
        context.fillStyle = fillState.fillStyle;
        this.contextFillState_ = {
          fillStyle: fillState.fillStyle
        };
      } else {
        if (contextFillState.fillStyle != fillState.fillStyle) {
          contextFillState.fillStyle = fillState.fillStyle;
          context.fillStyle = fillState.fillStyle;
        }
      }
    }
    /**
     * @param {import("../canvas.js").StrokeState} strokeState Stroke state.
     * @private
     */
    setContextStrokeState_(strokeState) {
      const context = this.context_;
      const contextStrokeState = this.contextStrokeState_;
      if (!contextStrokeState) {
        context.lineCap = strokeState.lineCap;
        context.setLineDash(strokeState.lineDash);
        context.lineDashOffset = strokeState.lineDashOffset;
        context.lineJoin = strokeState.lineJoin;
        context.lineWidth = strokeState.lineWidth;
        context.miterLimit = strokeState.miterLimit;
        context.strokeStyle = strokeState.strokeStyle;
        this.contextStrokeState_ = {
          lineCap: strokeState.lineCap,
          lineDash: strokeState.lineDash,
          lineDashOffset: strokeState.lineDashOffset,
          lineJoin: strokeState.lineJoin,
          lineWidth: strokeState.lineWidth,
          miterLimit: strokeState.miterLimit,
          strokeStyle: strokeState.strokeStyle
        };
      } else {
        if (contextStrokeState.lineCap != strokeState.lineCap) {
          contextStrokeState.lineCap = strokeState.lineCap;
          context.lineCap = strokeState.lineCap;
        }
        if (!equals(contextStrokeState.lineDash, strokeState.lineDash)) {
          context.setLineDash(
            contextStrokeState.lineDash = strokeState.lineDash
          );
        }
        if (contextStrokeState.lineDashOffset != strokeState.lineDashOffset) {
          contextStrokeState.lineDashOffset = strokeState.lineDashOffset;
          context.lineDashOffset = strokeState.lineDashOffset;
        }
        if (contextStrokeState.lineJoin != strokeState.lineJoin) {
          contextStrokeState.lineJoin = strokeState.lineJoin;
          context.lineJoin = strokeState.lineJoin;
        }
        if (contextStrokeState.lineWidth != strokeState.lineWidth) {
          contextStrokeState.lineWidth = strokeState.lineWidth;
          context.lineWidth = strokeState.lineWidth;
        }
        if (contextStrokeState.miterLimit != strokeState.miterLimit) {
          contextStrokeState.miterLimit = strokeState.miterLimit;
          context.miterLimit = strokeState.miterLimit;
        }
        if (contextStrokeState.strokeStyle != strokeState.strokeStyle) {
          contextStrokeState.strokeStyle = strokeState.strokeStyle;
          context.strokeStyle = strokeState.strokeStyle;
        }
      }
    }
    /**
     * @param {import("../canvas.js").TextState} textState Text state.
     * @private
     */
    setContextTextState_(textState) {
      const context = this.context_;
      const contextTextState = this.contextTextState_;
      const textAlign = textState.textAlign ? textState.textAlign : defaultTextAlign;
      if (!contextTextState) {
        context.font = textState.font;
        context.textAlign = textAlign;
        context.textBaseline = textState.textBaseline;
        this.contextTextState_ = {
          font: textState.font,
          textAlign,
          textBaseline: textState.textBaseline
        };
      } else {
        if (contextTextState.font != textState.font) {
          contextTextState.font = textState.font;
          context.font = textState.font;
        }
        if (contextTextState.textAlign != textAlign) {
          contextTextState.textAlign = textAlign;
          context.textAlign = textAlign;
        }
        if (contextTextState.textBaseline != textState.textBaseline) {
          contextTextState.textBaseline = textState.textBaseline;
          context.textBaseline = textState.textBaseline;
        }
      }
    }
    /**
     * Set the fill and stroke style for subsequent draw operations.  To clear
     * either fill or stroke styles, pass null for the appropriate parameter.
     *
     * @param {import("../../style/Fill.js").default} fillStyle Fill style.
     * @param {import("../../style/Stroke.js").default} strokeStyle Stroke style.
     */
    setFillStrokeStyle(fillStyle, strokeStyle) {
      if (!fillStyle) {
        this.fillState_ = null;
      } else {
        const fillStyleColor = fillStyle.getColor();
        this.fillState_ = {
          fillStyle: asColorLike(
            fillStyleColor ? fillStyleColor : defaultFillStyle
          )
        };
      }
      if (!strokeStyle) {
        this.strokeState_ = null;
      } else {
        const strokeStyleColor = strokeStyle.getColor();
        const strokeStyleLineCap = strokeStyle.getLineCap();
        const strokeStyleLineDash = strokeStyle.getLineDash();
        const strokeStyleLineDashOffset = strokeStyle.getLineDashOffset();
        const strokeStyleLineJoin = strokeStyle.getLineJoin();
        const strokeStyleWidth = strokeStyle.getWidth();
        const strokeStyleMiterLimit = strokeStyle.getMiterLimit();
        const lineDash = strokeStyleLineDash ? strokeStyleLineDash : defaultLineDash;
        this.strokeState_ = {
          lineCap: strokeStyleLineCap !== void 0 ? strokeStyleLineCap : defaultLineCap,
          lineDash: this.pixelRatio_ === 1 ? lineDash : lineDash.map((n2) => n2 * this.pixelRatio_),
          lineDashOffset: (strokeStyleLineDashOffset ? strokeStyleLineDashOffset : defaultLineDashOffset) * this.pixelRatio_,
          lineJoin: strokeStyleLineJoin !== void 0 ? strokeStyleLineJoin : defaultLineJoin,
          lineWidth: (strokeStyleWidth !== void 0 ? strokeStyleWidth : defaultLineWidth) * this.pixelRatio_,
          miterLimit: strokeStyleMiterLimit !== void 0 ? strokeStyleMiterLimit : defaultMiterLimit,
          strokeStyle: asColorLike(
            strokeStyleColor ? strokeStyleColor : defaultStrokeStyle
          )
        };
      }
    }
    /**
     * Set the image style for subsequent draw operations.  Pass null to remove
     * the image style.
     *
     * @param {import("../../style/Image.js").default} imageStyle Image style.
     */
    setImageStyle(imageStyle) {
      let imageSize;
      if (!imageStyle || !(imageSize = imageStyle.getSize())) {
        this.image_ = null;
        return;
      }
      const imagePixelRatio = imageStyle.getPixelRatio(this.pixelRatio_);
      const imageAnchor = imageStyle.getAnchor();
      const imageOrigin = imageStyle.getOrigin();
      this.image_ = imageStyle.getImage(this.pixelRatio_);
      this.imageAnchorX_ = imageAnchor[0] * imagePixelRatio;
      this.imageAnchorY_ = imageAnchor[1] * imagePixelRatio;
      this.imageHeight_ = imageSize[1] * imagePixelRatio;
      this.imageOpacity_ = imageStyle.getOpacity();
      this.imageOriginX_ = imageOrigin[0];
      this.imageOriginY_ = imageOrigin[1];
      this.imageRotateWithView_ = imageStyle.getRotateWithView();
      this.imageRotation_ = imageStyle.getRotation();
      const imageScale = imageStyle.getScaleArray();
      this.imageScale_ = [
        imageScale[0] * this.pixelRatio_ / imagePixelRatio,
        imageScale[1] * this.pixelRatio_ / imagePixelRatio
      ];
      this.imageWidth_ = imageSize[0] * imagePixelRatio;
    }
    /**
     * Set the text style for subsequent draw operations.  Pass null to
     * remove the text style.
     *
     * @param {import("../../style/Text.js").default} textStyle Text style.
     */
    setTextStyle(textStyle) {
      if (!textStyle) {
        this.text_ = "";
      } else {
        const textFillStyle = textStyle.getFill();
        if (!textFillStyle) {
          this.textFillState_ = null;
        } else {
          const textFillStyleColor = textFillStyle.getColor();
          this.textFillState_ = {
            fillStyle: asColorLike(
              textFillStyleColor ? textFillStyleColor : defaultFillStyle
            )
          };
        }
        const textStrokeStyle = textStyle.getStroke();
        if (!textStrokeStyle) {
          this.textStrokeState_ = null;
        } else {
          const textStrokeStyleColor = textStrokeStyle.getColor();
          const textStrokeStyleLineCap = textStrokeStyle.getLineCap();
          const textStrokeStyleLineDash = textStrokeStyle.getLineDash();
          const textStrokeStyleLineDashOffset = textStrokeStyle.getLineDashOffset();
          const textStrokeStyleLineJoin = textStrokeStyle.getLineJoin();
          const textStrokeStyleWidth = textStrokeStyle.getWidth();
          const textStrokeStyleMiterLimit = textStrokeStyle.getMiterLimit();
          this.textStrokeState_ = {
            lineCap: textStrokeStyleLineCap !== void 0 ? textStrokeStyleLineCap : defaultLineCap,
            lineDash: textStrokeStyleLineDash ? textStrokeStyleLineDash : defaultLineDash,
            lineDashOffset: textStrokeStyleLineDashOffset ? textStrokeStyleLineDashOffset : defaultLineDashOffset,
            lineJoin: textStrokeStyleLineJoin !== void 0 ? textStrokeStyleLineJoin : defaultLineJoin,
            lineWidth: textStrokeStyleWidth !== void 0 ? textStrokeStyleWidth : defaultLineWidth,
            miterLimit: textStrokeStyleMiterLimit !== void 0 ? textStrokeStyleMiterLimit : defaultMiterLimit,
            strokeStyle: asColorLike(
              textStrokeStyleColor ? textStrokeStyleColor : defaultStrokeStyle
            )
          };
        }
        const textFont = textStyle.getFont();
        const textOffsetX = textStyle.getOffsetX();
        const textOffsetY = textStyle.getOffsetY();
        const textRotateWithView = textStyle.getRotateWithView();
        const textRotation = textStyle.getRotation();
        const textScale = textStyle.getScaleArray();
        const textText = textStyle.getText();
        const textTextAlign = textStyle.getTextAlign();
        const textTextBaseline = textStyle.getTextBaseline();
        this.textState_ = {
          font: textFont !== void 0 ? textFont : defaultFont,
          textAlign: textTextAlign !== void 0 ? textTextAlign : defaultTextAlign,
          textBaseline: textTextBaseline !== void 0 ? textTextBaseline : defaultTextBaseline
        };
        this.text_ = textText !== void 0 ? Array.isArray(textText) ? textText.reduce((acc, t3, i4) => acc += i4 % 2 ? " " : t3, "") : textText : "";
        this.textOffsetX_ = textOffsetX !== void 0 ? this.pixelRatio_ * textOffsetX : 0;
        this.textOffsetY_ = textOffsetY !== void 0 ? this.pixelRatio_ * textOffsetY : 0;
        this.textRotateWithView_ = textRotateWithView !== void 0 ? textRotateWithView : false;
        this.textRotation_ = textRotation !== void 0 ? textRotation : 0;
        this.textScale_ = [
          this.pixelRatio_ * textScale[0],
          this.pixelRatio_ * textScale[1]
        ];
      }
    }
  };
  var Immediate_default = CanvasImmediateRenderer;

  // node_modules/ol/render/canvas/hitdetect.js
  var HIT_DETECT_RESOLUTION = 0.5;
  function createHitDetectionImageData(size, transforms2, features, styleFunction, extent, resolution, rotation) {
    const width = size[0] * HIT_DETECT_RESOLUTION;
    const height = size[1] * HIT_DETECT_RESOLUTION;
    const context = createCanvasContext2D(width, height);
    context.imageSmoothingEnabled = false;
    const canvas = context.canvas;
    const renderer = new Immediate_default(
      context,
      HIT_DETECT_RESOLUTION,
      extent,
      null,
      rotation
    );
    const featureCount = features.length;
    const indexFactor = Math.floor((256 * 256 * 256 - 1) / featureCount);
    const featuresByZIndex = {};
    for (let i4 = 1; i4 <= featureCount; ++i4) {
      const feature = features[i4 - 1];
      const featureStyleFunction = feature.getStyleFunction() || styleFunction;
      if (!featureStyleFunction) {
        continue;
      }
      let styles = featureStyleFunction(feature, resolution);
      if (!styles) {
        continue;
      }
      if (!Array.isArray(styles)) {
        styles = [styles];
      }
      const index = i4 * indexFactor;
      const color = index.toString(16).padStart(7, "#00000");
      for (let j3 = 0, jj = styles.length; j3 < jj; ++j3) {
        const originalStyle = styles[j3];
        const geometry = originalStyle.getGeometryFunction()(feature);
        if (!geometry || !intersects(extent, geometry.getExtent())) {
          continue;
        }
        const style = originalStyle.clone();
        const fill = style.getFill();
        if (fill) {
          fill.setColor(color);
        }
        const stroke = style.getStroke();
        if (stroke) {
          stroke.setColor(color);
          stroke.setLineDash(null);
        }
        style.setText(void 0);
        const image = originalStyle.getImage();
        if (image) {
          const imgSize = image.getImageSize();
          if (!imgSize) {
            continue;
          }
          const imgContext = createCanvasContext2D(
            imgSize[0],
            imgSize[1],
            void 0,
            { alpha: false }
          );
          const img = imgContext.canvas;
          imgContext.fillStyle = color;
          imgContext.fillRect(0, 0, img.width, img.height);
          style.setImage(
            new Icon_default({
              img,
              anchor: image.getAnchor(),
              anchorXUnits: "pixels",
              anchorYUnits: "pixels",
              offset: image.getOrigin(),
              opacity: 1,
              size: image.getSize(),
              scale: image.getScale(),
              rotation: image.getRotation(),
              rotateWithView: image.getRotateWithView()
            })
          );
        }
        const zIndex = style.getZIndex() || 0;
        let byGeometryType = featuresByZIndex[zIndex];
        if (!byGeometryType) {
          byGeometryType = {};
          featuresByZIndex[zIndex] = byGeometryType;
          byGeometryType["Polygon"] = [];
          byGeometryType["Circle"] = [];
          byGeometryType["LineString"] = [];
          byGeometryType["Point"] = [];
        }
        const type = geometry.getType();
        if (type === "GeometryCollection") {
          const geometries = (
            /** @type {import("../../geom/GeometryCollection.js").default} */
            geometry.getGeometriesArrayRecursive()
          );
          for (let i5 = 0, ii = geometries.length; i5 < ii; ++i5) {
            const geometry2 = geometries[i5];
            byGeometryType[geometry2.getType().replace("Multi", "")].push(
              geometry2,
              style
            );
          }
        } else {
          byGeometryType[type.replace("Multi", "")].push(geometry, style);
        }
      }
    }
    const zIndexKeys = Object.keys(featuresByZIndex).map(Number).sort(ascending);
    for (let i4 = 0, ii = zIndexKeys.length; i4 < ii; ++i4) {
      const byGeometryType = featuresByZIndex[zIndexKeys[i4]];
      for (const type in byGeometryType) {
        const geomAndStyle = byGeometryType[type];
        for (let j3 = 0, jj = geomAndStyle.length; j3 < jj; j3 += 2) {
          renderer.setStyle(geomAndStyle[j3 + 1]);
          for (let k3 = 0, kk = transforms2.length; k3 < kk; ++k3) {
            renderer.setTransform(transforms2[k3]);
            renderer.drawGeometry(geomAndStyle[j3]);
          }
        }
      }
    }
    return context.getImageData(0, 0, canvas.width, canvas.height);
  }
  function hitDetect(pixel, features, imageData) {
    const resultFeatures = [];
    if (imageData) {
      const x2 = Math.floor(Math.round(pixel[0]) * HIT_DETECT_RESOLUTION);
      const y2 = Math.floor(Math.round(pixel[1]) * HIT_DETECT_RESOLUTION);
      const index = (clamp(x2, 0, imageData.width - 1) + clamp(y2, 0, imageData.height - 1) * imageData.width) * 4;
      const r4 = imageData.data[index];
      const g3 = imageData.data[index + 1];
      const b3 = imageData.data[index + 2];
      const i4 = b3 + 256 * (g3 + 256 * r4);
      const indexFactor = Math.floor((256 * 256 * 256 - 1) / features.length);
      if (i4 && i4 % indexFactor === 0) {
        resultFeatures.push(features[i4 / indexFactor - 1]);
      }
    }
    return resultFeatures;
  }

  // node_modules/ol/renderer/vector.js
  var SIMPLIFY_TOLERANCE = 0.5;
  var GEOMETRY_RENDERERS = {
    "Point": renderPointGeometry,
    "LineString": renderLineStringGeometry,
    "Polygon": renderPolygonGeometry,
    "MultiPoint": renderMultiPointGeometry,
    "MultiLineString": renderMultiLineStringGeometry,
    "MultiPolygon": renderMultiPolygonGeometry,
    "GeometryCollection": renderGeometryCollectionGeometry,
    "Circle": renderCircleGeometry
  };
  function defaultOrder(feature1, feature2) {
    return parseInt(getUid(feature1), 10) - parseInt(getUid(feature2), 10);
  }
  function getSquaredTolerance(resolution, pixelRatio) {
    const tolerance = getTolerance(resolution, pixelRatio);
    return tolerance * tolerance;
  }
  function getTolerance(resolution, pixelRatio) {
    return SIMPLIFY_TOLERANCE * resolution / pixelRatio;
  }
  function renderCircleGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
      const circleReplay = builderGroup.getBuilder(style.getZIndex(), "Circle");
      circleReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      circleReplay.drawCircle(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
      const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
        style.getZIndex(),
        "Text"
      );
      textReplay.setTextStyle(textStyle);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderFeature(replayGroup, feature, style, squaredTolerance, listener, transform2, declutterBuilderGroup) {
    let loading = false;
    const imageStyle = style.getImage();
    if (imageStyle) {
      const imageState = imageStyle.getImageState();
      if (imageState == ImageState_default.LOADED || imageState == ImageState_default.ERROR) {
        imageStyle.unlistenImageChange(listener);
      } else {
        if (imageState == ImageState_default.IDLE) {
          imageStyle.load();
        }
        imageStyle.listenImageChange(listener);
        loading = true;
      }
    }
    renderFeatureInternal(
      replayGroup,
      feature,
      style,
      squaredTolerance,
      transform2,
      declutterBuilderGroup
    );
    return loading;
  }
  function renderFeatureInternal(replayGroup, feature, style, squaredTolerance, transform2, declutterBuilderGroup) {
    const geometry = style.getGeometryFunction()(feature);
    if (!geometry) {
      return;
    }
    const simplifiedGeometry = geometry.simplifyTransformed(
      squaredTolerance,
      transform2
    );
    const renderer = style.getRenderer();
    if (renderer) {
      renderGeometry(replayGroup, simplifiedGeometry, style, feature);
    } else {
      const geometryRenderer = GEOMETRY_RENDERERS[simplifiedGeometry.getType()];
      geometryRenderer(
        replayGroup,
        simplifiedGeometry,
        style,
        feature,
        declutterBuilderGroup
      );
    }
  }
  function renderGeometry(replayGroup, geometry, style, feature) {
    if (geometry.getType() == "GeometryCollection") {
      const geometries = (
        /** @type {import("../geom/GeometryCollection.js").default} */
        geometry.getGeometries()
      );
      for (let i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
        renderGeometry(replayGroup, geometries[i4], style, feature);
      }
      return;
    }
    const replay = replayGroup.getBuilder(style.getZIndex(), "Default");
    replay.drawCustom(
      /** @type {import("../geom/SimpleGeometry.js").default} */
      geometry,
      feature,
      style.getRenderer(),
      style.getHitDetectionRenderer()
    );
  }
  function renderGeometryCollectionGeometry(replayGroup, geometry, style, feature, declutterBuilderGroup) {
    const geometries = geometry.getGeometriesArray();
    let i4, ii;
    for (i4 = 0, ii = geometries.length; i4 < ii; ++i4) {
      const geometryRenderer = GEOMETRY_RENDERERS[geometries[i4].getType()];
      geometryRenderer(
        replayGroup,
        geometries[i4],
        style,
        feature,
        declutterBuilderGroup
      );
    }
  }
  function renderLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
      const lineStringReplay = builderGroup.getBuilder(
        style.getZIndex(),
        "LineString"
      );
      lineStringReplay.setFillStrokeStyle(null, strokeStyle);
      lineStringReplay.drawLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
      const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
        style.getZIndex(),
        "Text"
      );
      textReplay.setTextStyle(textStyle);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderMultiLineStringGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const strokeStyle = style.getStroke();
    if (strokeStyle) {
      const lineStringReplay = builderGroup.getBuilder(
        style.getZIndex(),
        "LineString"
      );
      lineStringReplay.setFillStrokeStyle(null, strokeStyle);
      lineStringReplay.drawMultiLineString(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
      const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
        style.getZIndex(),
        "Text"
      );
      textReplay.setTextStyle(textStyle);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderMultiPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (strokeStyle || fillStyle) {
      const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      polygonReplay.drawMultiPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
      const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
        style.getZIndex(),
        "Text"
      );
      textReplay.setTextStyle(textStyle);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    let declutterImageWithText;
    if (imageStyle) {
      if (imageStyle.getImageState() != ImageState_default.LOADED) {
        return;
      }
      let imageBuilderGroup = builderGroup;
      if (declutterBuilderGroup) {
        const declutterMode = imageStyle.getDeclutterMode();
        if (declutterMode !== "none") {
          imageBuilderGroup = declutterBuilderGroup;
          if (declutterMode === "obstacle") {
            const imageReplay2 = builderGroup.getBuilder(
              style.getZIndex(),
              "Image"
            );
            imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay2.drawPoint(geometry, feature);
          } else if (textStyle && textStyle.getText()) {
            declutterImageWithText = {};
          }
        }
      }
      const imageReplay = imageBuilderGroup.getBuilder(
        style.getZIndex(),
        "Image"
      );
      imageReplay.setImageStyle(imageStyle, declutterImageWithText);
      imageReplay.drawPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
      let textBuilderGroup = builderGroup;
      if (declutterBuilderGroup) {
        textBuilderGroup = declutterBuilderGroup;
      }
      const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
      textReplay.setTextStyle(textStyle, declutterImageWithText);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderMultiPointGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const imageStyle = style.getImage();
    const textStyle = style.getText();
    let declutterImageWithText;
    if (imageStyle) {
      if (imageStyle.getImageState() != ImageState_default.LOADED) {
        return;
      }
      let imageBuilderGroup = builderGroup;
      if (declutterBuilderGroup) {
        const declutterMode = imageStyle.getDeclutterMode();
        if (declutterMode !== "none") {
          imageBuilderGroup = declutterBuilderGroup;
          if (declutterMode === "obstacle") {
            const imageReplay2 = builderGroup.getBuilder(
              style.getZIndex(),
              "Image"
            );
            imageReplay2.setImageStyle(imageStyle, declutterImageWithText);
            imageReplay2.drawMultiPoint(geometry, feature);
          } else if (textStyle && textStyle.getText()) {
            declutterImageWithText = {};
          }
        }
      }
      const imageReplay = imageBuilderGroup.getBuilder(
        style.getZIndex(),
        "Image"
      );
      imageReplay.setImageStyle(imageStyle, declutterImageWithText);
      imageReplay.drawMultiPoint(geometry, feature);
    }
    if (textStyle && textStyle.getText()) {
      let textBuilderGroup = builderGroup;
      if (declutterBuilderGroup) {
        textBuilderGroup = declutterBuilderGroup;
      }
      const textReplay = textBuilderGroup.getBuilder(style.getZIndex(), "Text");
      textReplay.setTextStyle(textStyle, declutterImageWithText);
      textReplay.drawText(geometry, feature);
    }
  }
  function renderPolygonGeometry(builderGroup, geometry, style, feature, declutterBuilderGroup) {
    const fillStyle = style.getFill();
    const strokeStyle = style.getStroke();
    if (fillStyle || strokeStyle) {
      const polygonReplay = builderGroup.getBuilder(style.getZIndex(), "Polygon");
      polygonReplay.setFillStrokeStyle(fillStyle, strokeStyle);
      polygonReplay.drawPolygon(geometry, feature);
    }
    const textStyle = style.getText();
    if (textStyle && textStyle.getText()) {
      const textReplay = (declutterBuilderGroup || builderGroup).getBuilder(
        style.getZIndex(),
        "Text"
      );
      textReplay.setTextStyle(textStyle);
      textReplay.drawText(geometry, feature);
    }
  }

  // node_modules/ol/renderer/canvas/VectorLayer.js
  var CanvasVectorLayerRenderer = class extends Layer_default3 {
    /**
     * @param {import("../../layer/BaseVector.js").default} vectorLayer Vector layer.
     */
    constructor(vectorLayer) {
      super(vectorLayer);
      this.boundHandleStyleImageChange_ = this.handleStyleImageChange_.bind(this);
      this.animatingOrInteracting_;
      this.hitDetectionImageData_ = null;
      this.renderedFeatures_ = null;
      this.renderedRevision_ = -1;
      this.renderedResolution_ = NaN;
      this.renderedExtent_ = createEmpty();
      this.wrappedRenderedExtent_ = createEmpty();
      this.renderedRotation_;
      this.renderedCenter_ = null;
      this.renderedProjection_ = null;
      this.renderedRenderOrder_ = null;
      this.replayGroup_ = null;
      this.replayGroupChanged = true;
      this.declutterExecutorGroup = null;
      this.clipping = true;
      this.compositionContext_ = null;
      this.opacity_ = 1;
    }
    /**
     * @param {ExecutorGroup} executorGroup Executor group.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {import("rbush").default} [declutterTree] Declutter tree.
     */
    renderWorlds(executorGroup, frameState, declutterTree) {
      const extent = frameState.extent;
      const viewState = frameState.viewState;
      const center = viewState.center;
      const resolution = viewState.resolution;
      const projection = viewState.projection;
      const rotation = viewState.rotation;
      const projectionExtent = projection.getExtent();
      const vectorSource = this.getLayer().getSource();
      const pixelRatio = frameState.pixelRatio;
      const viewHints = frameState.viewHints;
      const snapToPixel = !(viewHints[ViewHint_default.ANIMATING] || viewHints[ViewHint_default.INTERACTING]);
      const context = this.compositionContext_;
      const width = Math.round(frameState.size[0] * pixelRatio);
      const height = Math.round(frameState.size[1] * pixelRatio);
      const multiWorld = vectorSource.getWrapX() && projection.canWrapX();
      const worldWidth = multiWorld ? getWidth(projectionExtent) : null;
      const endWorld = multiWorld ? Math.ceil((extent[2] - projectionExtent[2]) / worldWidth) + 1 : 1;
      let world = multiWorld ? Math.floor((extent[0] - projectionExtent[0]) / worldWidth) : 0;
      do {
        const transform2 = this.getRenderTransform(
          center,
          resolution,
          rotation,
          pixelRatio,
          width,
          height,
          world * worldWidth
        );
        executorGroup.execute(
          context,
          1,
          transform2,
          rotation,
          snapToPixel,
          void 0,
          declutterTree
        );
      } while (++world < endWorld);
    }
    setupCompositionContext_() {
      if (this.opacity_ !== 1) {
        const compositionContext = createCanvasContext2D(
          this.context.canvas.width,
          this.context.canvas.height,
          canvasPool
        );
        this.compositionContext_ = compositionContext;
      } else {
        this.compositionContext_ = this.context;
      }
    }
    releaseCompositionContext_() {
      if (this.opacity_ !== 1) {
        const alpha = this.context.globalAlpha;
        this.context.globalAlpha = this.opacity_;
        this.context.drawImage(this.compositionContext_.canvas, 0, 0);
        this.context.globalAlpha = alpha;
        releaseCanvas(this.compositionContext_);
        canvasPool.push(this.compositionContext_.canvas);
        this.compositionContext_ = null;
      }
    }
    /**
     * Render declutter items for this layer
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     */
    renderDeclutter(frameState) {
      if (this.declutterExecutorGroup) {
        this.setupCompositionContext_();
        this.renderWorlds(
          this.declutterExecutorGroup,
          frameState,
          frameState.declutterTree
        );
        this.releaseCompositionContext_();
      }
    }
    /**
     * Render the layer.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {HTMLElement|null} target Target that may be used to render content to.
     * @return {HTMLElement|null} The rendered element.
     */
    renderFrame(frameState, target) {
      const pixelRatio = frameState.pixelRatio;
      const layerState = frameState.layerStatesArray[frameState.layerIndex];
      makeScale(this.pixelTransform, 1 / pixelRatio, 1 / pixelRatio);
      makeInverse(this.inversePixelTransform, this.pixelTransform);
      const canvasTransform = toString(this.pixelTransform);
      this.useContainer(target, canvasTransform, this.getBackground(frameState));
      const context = this.context;
      const canvas = context.canvas;
      const replayGroup = this.replayGroup_;
      const declutterExecutorGroup = this.declutterExecutorGroup;
      let render = replayGroup && !replayGroup.isEmpty() || declutterExecutorGroup && !declutterExecutorGroup.isEmpty();
      if (!render) {
        const hasRenderListeners = this.getLayer().hasListener(EventType_default2.PRERENDER) || this.getLayer().hasListener(EventType_default2.POSTRENDER);
        if (!hasRenderListeners) {
          return null;
        }
      }
      const width = Math.round(frameState.size[0] * pixelRatio);
      const height = Math.round(frameState.size[1] * pixelRatio);
      if (canvas.width != width || canvas.height != height) {
        canvas.width = width;
        canvas.height = height;
        if (canvas.style.transform !== canvasTransform) {
          canvas.style.transform = canvasTransform;
        }
      } else if (!this.containerReused) {
        context.clearRect(0, 0, width, height);
      }
      this.preRender(context, frameState);
      const viewState = frameState.viewState;
      const projection = viewState.projection;
      this.opacity_ = layerState.opacity;
      this.setupCompositionContext_();
      let clipped = false;
      if (render && layerState.extent && this.clipping) {
        const layerExtent = fromUserExtent(layerState.extent, projection);
        render = intersects(layerExtent, frameState.extent);
        clipped = render && !containsExtent(layerExtent, frameState.extent);
        if (clipped) {
          this.clipUnrotated(this.compositionContext_, frameState, layerExtent);
        }
      }
      if (render) {
        this.renderWorlds(replayGroup, frameState);
      }
      if (clipped) {
        this.compositionContext_.restore();
      }
      this.releaseCompositionContext_();
      this.postRender(context, frameState);
      if (this.renderedRotation_ !== viewState.rotation) {
        this.renderedRotation_ = viewState.rotation;
        this.hitDetectionImageData_ = null;
      }
      return this.container;
    }
    /**
     * Asynchronous layer level hit detection.
     * @param {import("../../pixel.js").Pixel} pixel Pixel.
     * @return {Promise<Array<import("../../Feature").default>>} Promise
     * that resolves with an array of features.
     */
    getFeatures(pixel) {
      return new Promise((resolve) => {
        if (!this.hitDetectionImageData_ && !this.animatingOrInteracting_) {
          const size = [this.context.canvas.width, this.context.canvas.height];
          apply(this.pixelTransform, size);
          const center = this.renderedCenter_;
          const resolution = this.renderedResolution_;
          const rotation = this.renderedRotation_;
          const projection = this.renderedProjection_;
          const extent = this.wrappedRenderedExtent_;
          const layer = this.getLayer();
          const transforms2 = [];
          const width = size[0] * HIT_DETECT_RESOLUTION;
          const height = size[1] * HIT_DETECT_RESOLUTION;
          transforms2.push(
            this.getRenderTransform(
              center,
              resolution,
              rotation,
              HIT_DETECT_RESOLUTION,
              width,
              height,
              0
            ).slice()
          );
          const source = layer.getSource();
          const projectionExtent = projection.getExtent();
          if (source.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, extent)) {
            let startX = extent[0];
            const worldWidth = getWidth(projectionExtent);
            let world = 0;
            let offsetX;
            while (startX < projectionExtent[0]) {
              --world;
              offsetX = worldWidth * world;
              transforms2.push(
                this.getRenderTransform(
                  center,
                  resolution,
                  rotation,
                  HIT_DETECT_RESOLUTION,
                  width,
                  height,
                  offsetX
                ).slice()
              );
              startX += worldWidth;
            }
            world = 0;
            startX = extent[2];
            while (startX > projectionExtent[2]) {
              ++world;
              offsetX = worldWidth * world;
              transforms2.push(
                this.getRenderTransform(
                  center,
                  resolution,
                  rotation,
                  HIT_DETECT_RESOLUTION,
                  width,
                  height,
                  offsetX
                ).slice()
              );
              startX -= worldWidth;
            }
          }
          this.hitDetectionImageData_ = createHitDetectionImageData(
            size,
            transforms2,
            this.renderedFeatures_,
            layer.getStyleFunction(),
            extent,
            resolution,
            rotation
          );
        }
        resolve(
          hitDetect(pixel, this.renderedFeatures_, this.hitDetectionImageData_)
        );
      });
    }
    /**
     * @param {import("../../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {import("../vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {Array<import("../Map.js").HitMatch<T>>} matches The hit detected matches with tolerance.
     * @return {T|undefined} Callback result.
     * @template T
     */
    forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, callback, matches) {
      if (!this.replayGroup_) {
        return void 0;
      }
      const resolution = frameState.viewState.resolution;
      const rotation = frameState.viewState.rotation;
      const layer = this.getLayer();
      const features = {};
      const featureCallback = function(feature, geometry, distanceSq) {
        const key = getUid(feature);
        const match = features[key];
        if (!match) {
          if (distanceSq === 0) {
            features[key] = true;
            return callback(feature, layer, geometry);
          }
          matches.push(
            features[key] = {
              feature,
              layer,
              geometry,
              distanceSq,
              callback
            }
          );
        } else if (match !== true && distanceSq < match.distanceSq) {
          if (distanceSq === 0) {
            features[key] = true;
            matches.splice(matches.lastIndexOf(match), 1);
            return callback(feature, layer, geometry);
          }
          match.geometry = geometry;
          match.distanceSq = distanceSq;
        }
        return void 0;
      };
      let result;
      const executorGroups = [this.replayGroup_];
      if (this.declutterExecutorGroup) {
        executorGroups.push(this.declutterExecutorGroup);
      }
      executorGroups.some((executorGroup) => {
        return result = executorGroup.forEachFeatureAtCoordinate(
          coordinate,
          resolution,
          rotation,
          hitTolerance,
          featureCallback,
          executorGroup === this.declutterExecutorGroup && frameState.declutterTree ? frameState.declutterTree.all().map((item) => item.value) : null
        );
      });
      return result;
    }
    /**
     * Perform action necessary to get the layer rendered after new fonts have loaded
     */
    handleFontsChanged() {
      const layer = this.getLayer();
      if (layer.getVisible() && this.replayGroup_) {
        layer.changed();
      }
    }
    /**
     * Handle changes in image style state.
     * @param {import("../../events/Event.js").default} event Image style change event.
     * @private
     */
    handleStyleImageChange_(event) {
      this.renderIfReadyAndVisible();
    }
    /**
     * Determine whether render should be called.
     * @param {import("../../Map.js").FrameState} frameState Frame state.
     * @return {boolean} Layer is ready to be rendered.
     */
    prepareFrame(frameState) {
      const vectorLayer = this.getLayer();
      const vectorSource = vectorLayer.getSource();
      if (!vectorSource) {
        return false;
      }
      const animating = frameState.viewHints[ViewHint_default.ANIMATING];
      const interacting = frameState.viewHints[ViewHint_default.INTERACTING];
      const updateWhileAnimating = vectorLayer.getUpdateWhileAnimating();
      const updateWhileInteracting = vectorLayer.getUpdateWhileInteracting();
      if (this.ready && !updateWhileAnimating && animating || !updateWhileInteracting && interacting) {
        this.animatingOrInteracting_ = true;
        return true;
      }
      this.animatingOrInteracting_ = false;
      const frameStateExtent = frameState.extent;
      const viewState = frameState.viewState;
      const projection = viewState.projection;
      const resolution = viewState.resolution;
      const pixelRatio = frameState.pixelRatio;
      const vectorLayerRevision = vectorLayer.getRevision();
      const vectorLayerRenderBuffer = vectorLayer.getRenderBuffer();
      let vectorLayerRenderOrder = vectorLayer.getRenderOrder();
      if (vectorLayerRenderOrder === void 0) {
        vectorLayerRenderOrder = defaultOrder;
      }
      const center = viewState.center.slice();
      const extent = buffer(
        frameStateExtent,
        vectorLayerRenderBuffer * resolution
      );
      const renderedExtent = extent.slice();
      const loadExtents = [extent.slice()];
      const projectionExtent = projection.getExtent();
      if (vectorSource.getWrapX() && projection.canWrapX() && !containsExtent(projectionExtent, frameState.extent)) {
        const worldWidth = getWidth(projectionExtent);
        const gutter = Math.max(getWidth(extent) / 2, worldWidth);
        extent[0] = projectionExtent[0] - gutter;
        extent[2] = projectionExtent[2] + gutter;
        wrapX2(center, projection);
        const loadExtent = wrapX(loadExtents[0], projection);
        if (loadExtent[0] < projectionExtent[0] && loadExtent[2] < projectionExtent[2]) {
          loadExtents.push([
            loadExtent[0] + worldWidth,
            loadExtent[1],
            loadExtent[2] + worldWidth,
            loadExtent[3]
          ]);
        } else if (loadExtent[0] > projectionExtent[0] && loadExtent[2] > projectionExtent[2]) {
          loadExtents.push([
            loadExtent[0] - worldWidth,
            loadExtent[1],
            loadExtent[2] - worldWidth,
            loadExtent[3]
          ]);
        }
      }
      if (this.ready && this.renderedResolution_ == resolution && this.renderedRevision_ == vectorLayerRevision && this.renderedRenderOrder_ == vectorLayerRenderOrder && containsExtent(this.wrappedRenderedExtent_, extent)) {
        if (!equals(this.renderedExtent_, renderedExtent)) {
          this.hitDetectionImageData_ = null;
          this.renderedExtent_ = renderedExtent;
        }
        this.renderedCenter_ = center;
        this.replayGroupChanged = false;
        return true;
      }
      this.replayGroup_ = null;
      const replayGroup = new BuilderGroup_default(
        getTolerance(resolution, pixelRatio),
        extent,
        resolution,
        pixelRatio
      );
      let declutterBuilderGroup;
      if (this.getLayer().getDeclutter()) {
        declutterBuilderGroup = new BuilderGroup_default(
          getTolerance(resolution, pixelRatio),
          extent,
          resolution,
          pixelRatio
        );
      }
      const userProjection2 = getUserProjection();
      let userTransform;
      if (userProjection2) {
        for (let i4 = 0, ii = loadExtents.length; i4 < ii; ++i4) {
          const extent2 = loadExtents[i4];
          const userExtent2 = toUserExtent(extent2, projection);
          vectorSource.loadFeatures(
            userExtent2,
            toUserResolution(resolution, projection),
            userProjection2
          );
        }
        userTransform = getTransformFromProjections(userProjection2, projection);
      } else {
        for (let i4 = 0, ii = loadExtents.length; i4 < ii; ++i4) {
          vectorSource.loadFeatures(loadExtents[i4], resolution, projection);
        }
      }
      const squaredTolerance = getSquaredTolerance(resolution, pixelRatio);
      let ready = true;
      const render = (
        /**
         * @param {import("../../Feature.js").default} feature Feature.
         */
        (feature) => {
          let styles;
          const styleFunction = feature.getStyleFunction() || vectorLayer.getStyleFunction();
          if (styleFunction) {
            styles = styleFunction(feature, resolution);
          }
          if (styles) {
            const dirty = this.renderFeature(
              feature,
              squaredTolerance,
              styles,
              replayGroup,
              userTransform,
              declutterBuilderGroup
            );
            ready = ready && !dirty;
          }
        }
      );
      const userExtent = toUserExtent(extent, projection);
      const features = vectorSource.getFeaturesInExtent(userExtent);
      if (vectorLayerRenderOrder) {
        features.sort(vectorLayerRenderOrder);
      }
      for (let i4 = 0, ii = features.length; i4 < ii; ++i4) {
        render(features[i4]);
      }
      this.renderedFeatures_ = features;
      this.ready = ready;
      const replayGroupInstructions = replayGroup.finish();
      const executorGroup = new ExecutorGroup_default(
        extent,
        resolution,
        pixelRatio,
        vectorSource.getOverlaps(),
        replayGroupInstructions,
        vectorLayer.getRenderBuffer()
      );
      if (declutterBuilderGroup) {
        this.declutterExecutorGroup = new ExecutorGroup_default(
          extent,
          resolution,
          pixelRatio,
          vectorSource.getOverlaps(),
          declutterBuilderGroup.finish(),
          vectorLayer.getRenderBuffer()
        );
      }
      this.renderedResolution_ = resolution;
      this.renderedRevision_ = vectorLayerRevision;
      this.renderedRenderOrder_ = vectorLayerRenderOrder;
      this.renderedExtent_ = renderedExtent;
      this.wrappedRenderedExtent_ = extent;
      this.renderedCenter_ = center;
      this.renderedProjection_ = projection;
      this.replayGroup_ = executorGroup;
      this.hitDetectionImageData_ = null;
      this.replayGroupChanged = true;
      return true;
    }
    /**
     * @param {import("../../Feature.js").default} feature Feature.
     * @param {number} squaredTolerance Squared render tolerance.
     * @param {import("../../style/Style.js").default|Array<import("../../style/Style.js").default>} styles The style or array of styles.
     * @param {import("../../render/canvas/BuilderGroup.js").default} builderGroup Builder group.
     * @param {import("../../proj.js").TransformFunction} [transform] Transform from user to view projection.
     * @param {import("../../render/canvas/BuilderGroup.js").default} [declutterBuilderGroup] Builder for decluttering.
     * @return {boolean} `true` if an image is loading.
     */
    renderFeature(feature, squaredTolerance, styles, builderGroup, transform2, declutterBuilderGroup) {
      if (!styles) {
        return false;
      }
      let loading = false;
      if (Array.isArray(styles)) {
        for (let i4 = 0, ii = styles.length; i4 < ii; ++i4) {
          loading = renderFeature(
            builderGroup,
            feature,
            styles[i4],
            squaredTolerance,
            this.boundHandleStyleImageChange_,
            transform2,
            declutterBuilderGroup
          ) || loading;
        }
      } else {
        loading = renderFeature(
          builderGroup,
          feature,
          styles,
          squaredTolerance,
          this.boundHandleStyleImageChange_,
          transform2,
          declutterBuilderGroup
        );
      }
      return loading;
    }
  };
  var VectorLayer_default = CanvasVectorLayerRenderer;

  // node_modules/ol/layer/Vector.js
  var VectorLayer = class extends BaseVector_default {
    /**
     * @param {import("./BaseVector.js").Options<VectorSourceType>} [options] Options.
     */
    constructor(options) {
      super(options);
    }
    createRenderer() {
      return new VectorLayer_default(this);
    }
  };
  var Vector_default = VectorLayer;

  // node_modules/ol/structs/RBush.js
  var import_rbush2 = __toESM(require_rbush_min(), 1);
  var RBush2 = class {
    /**
     * @param {number} [maxEntries] Max entries.
     */
    constructor(maxEntries) {
      this.rbush_ = new import_rbush2.default(maxEntries);
      this.items_ = {};
    }
    /**
     * Insert a value into the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    insert(extent, value) {
      const item = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3],
        value
      };
      this.rbush_.insert(item);
      this.items_[getUid(value)] = item;
    }
    /**
     * Bulk-insert values into the RBush.
     * @param {Array<import("../extent.js").Extent>} extents Extents.
     * @param {Array<T>} values Values.
     */
    load(extents, values) {
      const items = new Array(values.length);
      for (let i4 = 0, l4 = values.length; i4 < l4; i4++) {
        const extent = extents[i4];
        const value = values[i4];
        const item = {
          minX: extent[0],
          minY: extent[1],
          maxX: extent[2],
          maxY: extent[3],
          value
        };
        items[i4] = item;
        this.items_[getUid(value)] = item;
      }
      this.rbush_.load(items);
    }
    /**
     * Remove a value from the RBush.
     * @param {T} value Value.
     * @return {boolean} Removed.
     */
    remove(value) {
      const uid = getUid(value);
      const item = this.items_[uid];
      delete this.items_[uid];
      return this.rbush_.remove(item) !== null;
    }
    /**
     * Update the extent of a value in the RBush.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {T} value Value.
     */
    update(extent, value) {
      const item = this.items_[getUid(value)];
      const bbox = [item.minX, item.minY, item.maxX, item.maxY];
      if (!equals2(bbox, extent)) {
        this.remove(value);
        this.insert(extent, value);
      }
    }
    /**
     * Return all values in the RBush.
     * @return {Array<T>} All.
     */
    getAll() {
      const items = this.rbush_.all();
      return items.map(function(item) {
        return item.value;
      });
    }
    /**
     * Return all values in the given extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @return {Array<T>} All in extent.
     */
    getInExtent(extent) {
      const bbox = {
        minX: extent[0],
        minY: extent[1],
        maxX: extent[2],
        maxY: extent[3]
      };
      const items = this.rbush_.search(bbox);
      return items.map(function(item) {
        return item.value;
      });
    }
    /**
     * Calls a callback function with each value in the tree.
     * If the callback returns a truthy value, this value is returned without
     * checking the rest of the tree.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
    forEach(callback) {
      return this.forEach_(this.getAll(), callback);
    }
    /**
     * Calls a callback function with each value in the provided extent.
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(T): *} callback Callback.
     * @return {*} Callback return value.
     */
    forEachInExtent(extent, callback) {
      return this.forEach_(this.getInExtent(extent), callback);
    }
    /**
     * @param {Array<T>} values Values.
     * @param {function(T): *} callback Callback.
     * @private
     * @return {*} Callback return value.
     */
    forEach_(values, callback) {
      let result;
      for (let i4 = 0, l4 = values.length; i4 < l4; i4++) {
        result = callback(values[i4]);
        if (result) {
          return result;
        }
      }
      return result;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return isEmpty(this.items_);
    }
    /**
     * Remove all values from the RBush.
     */
    clear() {
      this.rbush_.clear();
      this.items_ = {};
    }
    /**
     * @param {import("../extent.js").Extent} [extent] Extent.
     * @return {import("../extent.js").Extent} Extent.
     */
    getExtent(extent) {
      const data = this.rbush_.toJSON();
      return createOrUpdate(data.minX, data.minY, data.maxX, data.maxY, extent);
    }
    /**
     * @param {RBush} rbush R-Tree.
     */
    concat(rbush) {
      this.rbush_.load(rbush.rbush_.all());
      for (const i4 in rbush.items_) {
        this.items_[i4] = rbush.items_[i4];
      }
    }
  };
  var RBush_default = RBush2;

  // node_modules/ol/source/Source.js
  var Source = class extends Object_default {
    /**
     * @param {Options} options Source options.
     */
    constructor(options) {
      super();
      this.projection = get3(options.projection);
      this.attributions_ = adaptAttributions(options.attributions);
      this.attributionsCollapsible_ = options.attributionsCollapsible !== void 0 ? options.attributionsCollapsible : true;
      this.loading = false;
      this.state_ = options.state !== void 0 ? options.state : "ready";
      this.wrapX_ = options.wrapX !== void 0 ? options.wrapX : false;
      this.interpolate_ = !!options.interpolate;
      this.viewResolver = null;
      this.viewRejector = null;
      const self2 = this;
      this.viewPromise_ = new Promise(function(resolve, reject) {
        self2.viewResolver = resolve;
        self2.viewRejector = reject;
      });
    }
    /**
     * Get the attribution function for the source.
     * @return {?Attribution} Attribution function.
     * @api
     */
    getAttributions() {
      return this.attributions_;
    }
    /**
     * @return {boolean} Attributions are collapsible.
     * @api
     */
    getAttributionsCollapsible() {
      return this.attributionsCollapsible_;
    }
    /**
     * Get the projection of the source.
     * @return {import("../proj/Projection.js").default|null} Projection.
     * @api
     */
    getProjection() {
      return this.projection;
    }
    /**
     * @param {import("../proj/Projection").default} [projection] Projection.
     * @return {Array<number>|null} Resolutions.
     */
    getResolutions(projection) {
      return null;
    }
    /**
     * @return {Promise<import("../View.js").ViewOptions>} A promise for view-related properties.
     */
    getView() {
      return this.viewPromise_;
    }
    /**
     * Get the state of the source, see {@link import("./Source.js").State} for possible states.
     * @return {import("./Source.js").State} State.
     * @api
     */
    getState() {
      return this.state_;
    }
    /**
     * @return {boolean|undefined} Wrap X.
     */
    getWrapX() {
      return this.wrapX_;
    }
    /**
     * @return {boolean} Use linear interpolation when resampling.
     */
    getInterpolate() {
      return this.interpolate_;
    }
    /**
     * Refreshes the source. The source will be cleared, and data from the server will be reloaded.
     * @api
     */
    refresh() {
      this.changed();
    }
    /**
     * Set the attributions of the source.
     * @param {AttributionLike|undefined} attributions Attributions.
     *     Can be passed as `string`, `Array<string>`, {@link module:ol/source/Source~Attribution},
     *     or `undefined`.
     * @api
     */
    setAttributions(attributions) {
      this.attributions_ = adaptAttributions(attributions);
      this.changed();
    }
    /**
     * Set the state of the source.
     * @param {import("./Source.js").State} state State.
     */
    setState(state) {
      this.state_ = state;
      this.changed();
    }
  };
  function adaptAttributions(attributionLike) {
    if (!attributionLike) {
      return null;
    }
    if (Array.isArray(attributionLike)) {
      return function(frameState) {
        return attributionLike;
      };
    }
    if (typeof attributionLike === "function") {
      return attributionLike;
    }
    return function(frameState) {
      return [attributionLike];
    };
  }
  var Source_default = Source;

  // node_modules/ol/source/VectorEventType.js
  var VectorEventType_default = {
    /**
     * Triggered when a feature is added to the source.
     * @event module:ol/source/Vector.VectorSourceEvent#addfeature
     * @api
     */
    ADDFEATURE: "addfeature",
    /**
     * Triggered when a feature is updated.
     * @event module:ol/source/Vector.VectorSourceEvent#changefeature
     * @api
     */
    CHANGEFEATURE: "changefeature",
    /**
     * Triggered when the clear method is called on the source.
     * @event module:ol/source/Vector.VectorSourceEvent#clear
     * @api
     */
    CLEAR: "clear",
    /**
     * Triggered when a feature is removed from the source.
     * See {@link module:ol/source/Vector~VectorSource#clear source.clear()} for exceptions.
     * @event module:ol/source/Vector.VectorSourceEvent#removefeature
     * @api
     */
    REMOVEFEATURE: "removefeature",
    /**
     * Triggered when features starts loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadstart
     * @api
     */
    FEATURESLOADSTART: "featuresloadstart",
    /**
     * Triggered when features finishes loading.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloadend
     * @api
     */
    FEATURESLOADEND: "featuresloadend",
    /**
     * Triggered if feature loading results in an error.
     * @event module:ol/source/Vector.VectorSourceEvent#featuresloaderror
     * @api
     */
    FEATURESLOADERROR: "featuresloaderror"
  };

  // node_modules/ol/loadingstrategy.js
  function all(extent, resolution) {
    return [[-Infinity, -Infinity, Infinity, Infinity]];
  }

  // node_modules/ol/featureloader.js
  var withCredentials = false;
  function loadFeaturesXhr(url, format3, extent, resolution, projection, success, failure) {
    const xhr2 = new XMLHttpRequest();
    xhr2.open(
      "GET",
      typeof url === "function" ? url(extent, resolution, projection) : url,
      true
    );
    if (format3.getType() == "arraybuffer") {
      xhr2.responseType = "arraybuffer";
    }
    xhr2.withCredentials = withCredentials;
    xhr2.onload = function(event) {
      if (!xhr2.status || xhr2.status >= 200 && xhr2.status < 300) {
        const type = format3.getType();
        let source;
        if (type == "json" || type == "text") {
          source = xhr2.responseText;
        } else if (type == "xml") {
          source = xhr2.responseXML;
          if (!source) {
            source = new DOMParser().parseFromString(
              xhr2.responseText,
              "application/xml"
            );
          }
        } else if (type == "arraybuffer") {
          source = /** @type {ArrayBuffer} */
          xhr2.response;
        }
        if (source) {
          success(
            /** @type {Array<import("./Feature.js").default>} */
            format3.readFeatures(source, {
              extent,
              featureProjection: projection
            }),
            format3.readProjection(source)
          );
        } else {
          failure();
        }
      } else {
        failure();
      }
    };
    xhr2.onerror = failure;
    xhr2.send();
  }
  function xhr(url, format3) {
    return function(extent, resolution, projection, success, failure) {
      const source = (
        /** @type {import("./source/Vector").default} */
        this
      );
      loadFeaturesXhr(
        url,
        format3,
        extent,
        resolution,
        projection,
        /**
         * @param {Array<import("./Feature.js").default>} features The loaded features.
         * @param {import("./proj/Projection.js").default} dataProjection Data
         * projection.
         */
        function(features, dataProjection) {
          source.addFeatures(features);
          if (success !== void 0) {
            success(features);
          }
        },
        /* FIXME handle error */
        failure ? failure : VOID
      );
    };
  }

  // node_modules/ol/source/Vector.js
  var VectorSourceEvent = class extends Event_default {
    /**
     * @param {string} type Type.
     * @param {import("../Feature.js").default<Geometry>} [feature] Feature.
     * @param {Array<import("../Feature.js").default<Geometry>>} [features] Features.
     */
    constructor(type, feature, features) {
      super(type);
      this.feature = feature;
      this.features = features;
    }
  };
  var VectorSource = class extends Source_default {
    /**
     * @param {Options<Geometry>} [options] Vector source options.
     */
    constructor(options) {
      options = options || {};
      super({
        attributions: options.attributions,
        interpolate: true,
        projection: void 0,
        state: "ready",
        wrapX: options.wrapX !== void 0 ? options.wrapX : true
      });
      this.on;
      this.once;
      this.un;
      this.loader_ = VOID;
      this.format_ = options.format;
      this.overlaps_ = options.overlaps === void 0 ? true : options.overlaps;
      this.url_ = options.url;
      if (options.loader !== void 0) {
        this.loader_ = options.loader;
      } else if (this.url_ !== void 0) {
        assert(this.format_, "`format` must be set when `url` is set");
        this.loader_ = xhr(
          this.url_,
          /** @type {import("../format/Feature.js").default} */
          this.format_
        );
      }
      this.strategy_ = options.strategy !== void 0 ? options.strategy : all;
      const useSpatialIndex = options.useSpatialIndex !== void 0 ? options.useSpatialIndex : true;
      this.featuresRtree_ = useSpatialIndex ? new RBush_default() : null;
      this.loadedExtentsRtree_ = new RBush_default();
      this.loadingExtentsCount_ = 0;
      this.nullGeometryFeatures_ = {};
      this.idIndex_ = {};
      this.uidIndex_ = {};
      this.featureChangeKeys_ = {};
      this.featuresCollection_ = null;
      let collection;
      let features;
      if (Array.isArray(options.features)) {
        features = options.features;
      } else if (options.features) {
        collection = options.features;
        features = collection.getArray();
      }
      if (!useSpatialIndex && collection === void 0) {
        collection = new Collection_default(features);
      }
      if (features !== void 0) {
        this.addFeaturesInternal(features);
      }
      if (collection !== void 0) {
        this.bindFeaturesCollection_(collection);
      }
    }
    /**
     * Add a single feature to the source.  If you want to add a batch of features
     * at once, call {@link module:ol/source/Vector~VectorSource#addFeatures #addFeatures()}
     * instead. A feature will not be added to the source if feature with
     * the same id is already there. The reason for this behavior is to avoid
     * feature duplication when using bbox or tile loading strategies.
     * Note: this also applies if an {@link module:ol/Collection~Collection} is used for features,
     * meaning that if a feature with a duplicate id is added in the collection, it will
     * be removed from it right away.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to add.
     * @api
     */
    addFeature(feature) {
      this.addFeatureInternal(feature);
      this.changed();
    }
    /**
     * Add a feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @protected
     */
    addFeatureInternal(feature) {
      const featureKey = getUid(feature);
      if (!this.addToIndex_(featureKey, feature)) {
        if (this.featuresCollection_) {
          this.featuresCollection_.remove(feature);
        }
        return;
      }
      this.setupChangeEvents_(featureKey, feature);
      const geometry = feature.getGeometry();
      if (geometry) {
        const extent = geometry.getExtent();
        if (this.featuresRtree_) {
          this.featuresRtree_.insert(extent, feature);
        }
      } else {
        this.nullGeometryFeatures_[featureKey] = feature;
      }
      this.dispatchEvent(
        new VectorSourceEvent(VectorEventType_default.ADDFEATURE, feature)
      );
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @private
     */
    setupChangeEvents_(featureKey, feature) {
      this.featureChangeKeys_[featureKey] = [
        listen(feature, EventType_default.CHANGE, this.handleFeatureChange_, this),
        listen(
          feature,
          ObjectEventType_default.PROPERTYCHANGE,
          this.handleFeatureChange_,
          this
        )
      ];
    }
    /**
     * @param {string} featureKey Unique identifier for the feature.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} The feature is "valid", in the sense that it is also a
     *     candidate for insertion into the Rtree.
     * @private
     */
    addToIndex_(featureKey, feature) {
      let valid = true;
      const id = feature.getId();
      if (id !== void 0) {
        if (!(id.toString() in this.idIndex_)) {
          this.idIndex_[id.toString()] = feature;
        } else {
          valid = false;
        }
      }
      if (valid) {
        assert(
          !(featureKey in this.uidIndex_),
          "The passed `feature` was already added to the source"
        );
        this.uidIndex_[featureKey] = feature;
      }
      return valid;
    }
    /**
     * Add a batch of features to the source.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features to add.
     * @api
     */
    addFeatures(features) {
      this.addFeaturesInternal(features);
      this.changed();
    }
    /**
     * Add features without firing a `change` event.
     * @param {Array<import("../Feature.js").default<Geometry>>} features Features.
     * @protected
     */
    addFeaturesInternal(features) {
      const extents = [];
      const newFeatures = [];
      const geometryFeatures = [];
      for (let i4 = 0, length = features.length; i4 < length; i4++) {
        const feature = features[i4];
        const featureKey = getUid(feature);
        if (this.addToIndex_(featureKey, feature)) {
          newFeatures.push(feature);
        }
      }
      for (let i4 = 0, length = newFeatures.length; i4 < length; i4++) {
        const feature = newFeatures[i4];
        const featureKey = getUid(feature);
        this.setupChangeEvents_(featureKey, feature);
        const geometry = feature.getGeometry();
        if (geometry) {
          const extent = geometry.getExtent();
          extents.push(extent);
          geometryFeatures.push(feature);
        } else {
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.load(extents, geometryFeatures);
      }
      if (this.hasListener(VectorEventType_default.ADDFEATURE)) {
        for (let i4 = 0, length = newFeatures.length; i4 < length; i4++) {
          this.dispatchEvent(
            new VectorSourceEvent(VectorEventType_default.ADDFEATURE, newFeatures[i4])
          );
        }
      }
    }
    /**
     * @param {!Collection<import("../Feature.js").default<Geometry>>} collection Collection.
     * @private
     */
    bindFeaturesCollection_(collection) {
      let modifyingCollection = false;
      this.addEventListener(
        VectorEventType_default.ADDFEATURE,
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.push(evt.feature);
            modifyingCollection = false;
          }
        }
      );
      this.addEventListener(
        VectorEventType_default.REMOVEFEATURE,
        /**
         * @param {VectorSourceEvent<Geometry>} evt The vector source event
         */
        function(evt) {
          if (!modifyingCollection) {
            modifyingCollection = true;
            collection.remove(evt.feature);
            modifyingCollection = false;
          }
        }
      );
      collection.addEventListener(
        CollectionEventType_default.ADD,
        /**
         * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
         */
        (evt) => {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.addFeature(evt.element);
            modifyingCollection = false;
          }
        }
      );
      collection.addEventListener(
        CollectionEventType_default.REMOVE,
        /**
         * @param {import("../Collection.js").CollectionEvent<import("../Feature.js").default<Geometry>>} evt The collection event
         */
        (evt) => {
          if (!modifyingCollection) {
            modifyingCollection = true;
            this.removeFeature(evt.element);
            modifyingCollection = false;
          }
        }
      );
      this.featuresCollection_ = collection;
    }
    /**
     * Remove all features from the source.
     * @param {boolean} [fast] Skip dispatching of {@link module:ol/source/Vector.VectorSourceEvent#event:removefeature} events.
     * @api
     */
    clear(fast) {
      if (fast) {
        for (const featureId in this.featureChangeKeys_) {
          const keys = this.featureChangeKeys_[featureId];
          keys.forEach(unlistenByKey);
        }
        if (!this.featuresCollection_) {
          this.featureChangeKeys_ = {};
          this.idIndex_ = {};
          this.uidIndex_ = {};
        }
      } else {
        if (this.featuresRtree_) {
          const removeAndIgnoreReturn = (feature) => {
            this.removeFeatureInternal(feature);
          };
          this.featuresRtree_.forEach(removeAndIgnoreReturn);
          for (const id in this.nullGeometryFeatures_) {
            this.removeFeatureInternal(this.nullGeometryFeatures_[id]);
          }
        }
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.clear();
      }
      if (this.featuresRtree_) {
        this.featuresRtree_.clear();
      }
      this.nullGeometryFeatures_ = {};
      const clearEvent = new VectorSourceEvent(VectorEventType_default.CLEAR);
      this.dispatchEvent(clearEvent);
      this.changed();
    }
    /**
     * Iterate through all features on the source, calling the provided callback
     * with each one.  If the callback returns any "truthy" value, iteration will
     * stop and the function will return the same value.
     * Note: this function only iterate through the feature that have a defined geometry.
     *
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     on the source.  Return a truthy value to stop iteration.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeature(callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEach(callback);
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }
    /**
     * Iterate through all features whose geometries contain the provided
     * coordinate, calling the callback with each feature.  If the callback returns
     * a "truthy" value, iteration will stop and the function will return the same
     * value.
     *
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose goemetry contains the provided coordinate.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     */
    forEachFeatureAtCoordinateDirect(coordinate, callback) {
      const extent = [coordinate[0], coordinate[1], coordinate[0], coordinate[1]];
      return this.forEachFeatureInExtent(extent, function(feature) {
        const geometry = feature.getGeometry();
        if (geometry.intersectsCoordinate(coordinate)) {
          return callback(feature);
        }
        return void 0;
      });
    }
    /**
     * Iterate through all features whose bounding box intersects the provided
     * extent (note that the feature's geometry may not intersect the extent),
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you are interested in features whose geometry intersects an extent, call
     * the {@link module:ol/source/Vector~VectorSource#forEachFeatureIntersectingExtent #forEachFeatureIntersectingExtent()} method instead.
     *
     * When `useSpatialIndex` is set to false, this method will loop through all
     * features, equivalent to {@link module:ol/source/Vector~VectorSource#forEachFeature #forEachFeature()}.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose bounding box intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureInExtent(extent, callback) {
      if (this.featuresRtree_) {
        return this.featuresRtree_.forEachInExtent(extent, callback);
      }
      if (this.featuresCollection_) {
        this.featuresCollection_.forEach(callback);
      }
    }
    /**
     * Iterate through all features whose geometry intersects the provided extent,
     * calling the callback with each feature.  If the callback returns a "truthy"
     * value, iteration will stop and the function will return the same value.
     *
     * If you only want to test for bounding box intersection, call the
     * {@link module:ol/source/Vector~VectorSource#forEachFeatureInExtent #forEachFeatureInExtent()} method instead.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {function(import("../Feature.js").default<Geometry>): T} callback Called with each feature
     *     whose geometry intersects the provided extent.
     * @return {T|undefined} The return value from the last call to the callback.
     * @template T
     * @api
     */
    forEachFeatureIntersectingExtent(extent, callback) {
      return this.forEachFeatureInExtent(
        extent,
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         * @return {T|undefined} The return value from the last call to the callback.
         */
        function(feature) {
          const geometry = feature.getGeometry();
          if (geometry.intersectsExtent(extent)) {
            const result = callback(feature);
            if (result) {
              return result;
            }
          }
        }
      );
    }
    /**
     * Get the features collection associated with this source. Will be `null`
     * unless the source was configured with `useSpatialIndex` set to `false`, or
     * with an {@link module:ol/Collection~Collection} as `features`.
     * @return {Collection<import("../Feature.js").default<Geometry>>|null} The collection of features.
     * @api
     */
    getFeaturesCollection() {
      return this.featuresCollection_;
    }
    /**
     * Get a snapshot of the features currently on the source in random order. The returned array
     * is a copy, the features are references to the features in the source.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    getFeatures() {
      let features;
      if (this.featuresCollection_) {
        features = this.featuresCollection_.getArray().slice(0);
      } else if (this.featuresRtree_) {
        features = this.featuresRtree_.getAll();
        if (!isEmpty(this.nullGeometryFeatures_)) {
          extend(features, Object.values(this.nullGeometryFeatures_));
        }
      }
      return (
        /** @type {Array<import("../Feature.js").default<Geometry>>} */
        features
      );
    }
    /**
     * Get all features whose geometry intersects the provided coordinate.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    getFeaturesAtCoordinate(coordinate) {
      const features = [];
      this.forEachFeatureAtCoordinateDirect(coordinate, function(feature) {
        features.push(feature);
      });
      return features;
    }
    /**
     * Get all features whose bounding box intersects the provided extent.  Note that this returns an array of
     * all features intersecting the given extent in random order (so it may include
     * features whose geometries do not intersect the extent).
     *
     * When `useSpatialIndex` is set to false, this method will return all
     * features.
     *
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {import("../proj/Projection.js").default} [projection] Include features
     * where `extent` exceeds the x-axis bounds of `projection` and wraps around the world.
     * @return {Array<import("../Feature.js").default<Geometry>>} Features.
     * @api
     */
    getFeaturesInExtent(extent, projection) {
      if (this.featuresRtree_) {
        const multiWorld = projection && projection.canWrapX() && this.getWrapX();
        if (!multiWorld) {
          return this.featuresRtree_.getInExtent(extent);
        }
        const extents = wrapAndSliceX(extent, projection);
        return [].concat(
          ...extents.map((anExtent) => this.featuresRtree_.getInExtent(anExtent))
        );
      }
      if (this.featuresCollection_) {
        return this.featuresCollection_.getArray().slice(0);
      }
      return [];
    }
    /**
     * Get the closest feature to the provided coordinate.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {function(import("../Feature.js").default<Geometry>):boolean} [filter] Feature filter function.
     *     The filter function will receive one argument, the {@link module:ol/Feature~Feature feature}
     *     and it should return a boolean value. By default, no filtering is made.
     * @return {import("../Feature.js").default<Geometry>} Closest feature.
     * @api
     */
    getClosestFeatureToCoordinate(coordinate, filter) {
      const x2 = coordinate[0];
      const y2 = coordinate[1];
      let closestFeature = null;
      const closestPoint = [NaN, NaN];
      let minSquaredDistance = Infinity;
      const extent = [-Infinity, -Infinity, Infinity, Infinity];
      filter = filter ? filter : TRUE;
      this.featuresRtree_.forEachInExtent(
        extent,
        /**
         * @param {import("../Feature.js").default<Geometry>} feature Feature.
         */
        function(feature) {
          if (filter(feature)) {
            const geometry = feature.getGeometry();
            const previousMinSquaredDistance = minSquaredDistance;
            minSquaredDistance = geometry.closestPointXY(
              x2,
              y2,
              closestPoint,
              minSquaredDistance
            );
            if (minSquaredDistance < previousMinSquaredDistance) {
              closestFeature = feature;
              const minDistance = Math.sqrt(minSquaredDistance);
              extent[0] = x2 - minDistance;
              extent[1] = y2 - minDistance;
              extent[2] = x2 + minDistance;
              extent[3] = y2 + minDistance;
            }
          }
        }
      );
      return closestFeature;
    }
    /**
     * Get the extent of the features currently in the source.
     *
     * This method is not available when the source is configured with
     * `useSpatialIndex` set to `false`.
     * @param {import("../extent.js").Extent} [extent] Destination extent. If provided, no new extent
     *     will be created. Instead, that extent's coordinates will be overwritten.
     * @return {import("../extent.js").Extent} Extent.
     * @api
     */
    getExtent(extent) {
      return this.featuresRtree_.getExtent(extent);
    }
    /**
     * Get a feature by its identifier (the value returned by feature.getId()).
     * Note that the index treats string and numeric identifiers as the same.  So
     * `source.getFeatureById(2)` will return a feature with id `'2'` or `2`.
     *
     * @param {string|number} id Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     * @api
     */
    getFeatureById(id) {
      const feature = this.idIndex_[id.toString()];
      return feature !== void 0 ? feature : null;
    }
    /**
     * Get a feature by its internal unique identifier (using `getUid`).
     *
     * @param {string} uid Feature identifier.
     * @return {import("../Feature.js").default<Geometry>|null} The feature (or `null` if not found).
     */
    getFeatureByUid(uid) {
      const feature = this.uidIndex_[uid];
      return feature !== void 0 ? feature : null;
    }
    /**
     * Get the format associated with this source.
     *
     * @return {import("../format/Feature.js").default|undefined} The feature format.
     * @api
     */
    getFormat() {
      return this.format_;
    }
    /**
     * @return {boolean} The source can have overlapping geometries.
     */
    getOverlaps() {
      return this.overlaps_;
    }
    /**
     * Get the url associated with this source.
     *
     * @return {string|import("../featureloader.js").FeatureUrlFunction|undefined} The url.
     * @api
     */
    getUrl() {
      return this.url_;
    }
    /**
     * @param {Event} event Event.
     * @private
     */
    handleFeatureChange_(event) {
      const feature = (
        /** @type {import("../Feature.js").default<Geometry>} */
        event.target
      );
      const featureKey = getUid(feature);
      const geometry = feature.getGeometry();
      if (!geometry) {
        if (!(featureKey in this.nullGeometryFeatures_)) {
          if (this.featuresRtree_) {
            this.featuresRtree_.remove(feature);
          }
          this.nullGeometryFeatures_[featureKey] = feature;
        }
      } else {
        const extent = geometry.getExtent();
        if (featureKey in this.nullGeometryFeatures_) {
          delete this.nullGeometryFeatures_[featureKey];
          if (this.featuresRtree_) {
            this.featuresRtree_.insert(extent, feature);
          }
        } else {
          if (this.featuresRtree_) {
            this.featuresRtree_.update(extent, feature);
          }
        }
      }
      const id = feature.getId();
      if (id !== void 0) {
        const sid = id.toString();
        if (this.idIndex_[sid] !== feature) {
          this.removeFromIdIndex_(feature);
          this.idIndex_[sid] = feature;
        }
      } else {
        this.removeFromIdIndex_(feature);
        this.uidIndex_[featureKey] = feature;
      }
      this.changed();
      this.dispatchEvent(
        new VectorSourceEvent(VectorEventType_default.CHANGEFEATURE, feature)
      );
    }
    /**
     * Returns true if the feature is contained within the source.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {boolean} Has feature.
     * @api
     */
    hasFeature(feature) {
      const id = feature.getId();
      if (id !== void 0) {
        return id in this.idIndex_;
      }
      return getUid(feature) in this.uidIndex_;
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      if (this.featuresRtree_) {
        return this.featuresRtree_.isEmpty() && isEmpty(this.nullGeometryFeatures_);
      }
      if (this.featuresCollection_) {
        return this.featuresCollection_.getLength() === 0;
      }
      return true;
    }
    /**
     * @param {import("../extent.js").Extent} extent Extent.
     * @param {number} resolution Resolution.
     * @param {import("../proj/Projection.js").default} projection Projection.
     */
    loadFeatures(extent, resolution, projection) {
      const loadedExtentsRtree = this.loadedExtentsRtree_;
      const extentsToLoad = this.strategy_(extent, resolution, projection);
      for (let i4 = 0, ii = extentsToLoad.length; i4 < ii; ++i4) {
        const extentToLoad = extentsToLoad[i4];
        const alreadyLoaded = loadedExtentsRtree.forEachInExtent(
          extentToLoad,
          /**
           * @param {{extent: import("../extent.js").Extent}} object Object.
           * @return {boolean} Contains.
           */
          function(object) {
            return containsExtent(object.extent, extentToLoad);
          }
        );
        if (!alreadyLoaded) {
          ++this.loadingExtentsCount_;
          this.dispatchEvent(
            new VectorSourceEvent(VectorEventType_default.FEATURESLOADSTART)
          );
          this.loader_.call(
            this,
            extentToLoad,
            resolution,
            projection,
            (features) => {
              --this.loadingExtentsCount_;
              this.dispatchEvent(
                new VectorSourceEvent(
                  VectorEventType_default.FEATURESLOADEND,
                  void 0,
                  features
                )
              );
            },
            () => {
              --this.loadingExtentsCount_;
              this.dispatchEvent(
                new VectorSourceEvent(VectorEventType_default.FEATURESLOADERROR)
              );
            }
          );
          loadedExtentsRtree.insert(extentToLoad, { extent: extentToLoad.slice() });
        }
      }
      this.loading = this.loader_.length < 4 ? false : this.loadingExtentsCount_ > 0;
    }
    refresh() {
      this.clear(true);
      this.loadedExtentsRtree_.clear();
      super.refresh();
    }
    /**
     * Remove an extent from the list of loaded extents.
     * @param {import("../extent.js").Extent} extent Extent.
     * @api
     */
    removeLoadedExtent(extent) {
      const loadedExtentsRtree = this.loadedExtentsRtree_;
      let obj;
      loadedExtentsRtree.forEachInExtent(extent, function(object) {
        if (equals2(object.extent, extent)) {
          obj = object;
          return true;
        }
      });
      if (obj) {
        loadedExtentsRtree.remove(obj);
      }
    }
    /**
     * Remove a single feature from the source.  If you want to remove all features
     * at once, use the {@link module:ol/source/Vector~VectorSource#clear #clear()} method
     * instead.
     * @param {import("../Feature.js").default<Geometry>} feature Feature to remove.
     * @api
     */
    removeFeature(feature) {
      if (!feature) {
        return;
      }
      const featureKey = getUid(feature);
      if (featureKey in this.nullGeometryFeatures_) {
        delete this.nullGeometryFeatures_[featureKey];
      } else {
        if (this.featuresRtree_) {
          this.featuresRtree_.remove(feature);
        }
      }
      const result = this.removeFeatureInternal(feature);
      if (result) {
        this.changed();
      }
    }
    /**
     * Remove feature without firing a `change` event.
     * @param {import("../Feature.js").default<Geometry>} feature Feature.
     * @return {import("../Feature.js").default<Geometry>|undefined} The removed feature
     *     (or undefined if the feature was not found).
     * @protected
     */
    removeFeatureInternal(feature) {
      const featureKey = getUid(feature);
      const featureChangeKeys = this.featureChangeKeys_[featureKey];
      if (!featureChangeKeys) {
        return;
      }
      featureChangeKeys.forEach(unlistenByKey);
      delete this.featureChangeKeys_[featureKey];
      const id = feature.getId();
      if (id !== void 0) {
        delete this.idIndex_[id.toString()];
      }
      delete this.uidIndex_[featureKey];
      this.dispatchEvent(
        new VectorSourceEvent(VectorEventType_default.REMOVEFEATURE, feature)
      );
      return feature;
    }
    /**
     * Remove a feature from the id index.  Called internally when the feature id
     * may have changed.
     * @param {import("../Feature.js").default<Geometry>} feature The feature.
     * @return {boolean} Removed the feature from the index.
     * @private
     */
    removeFromIdIndex_(feature) {
      let removed = false;
      for (const id in this.idIndex_) {
        if (this.idIndex_[id] === feature) {
          delete this.idIndex_[id];
          removed = true;
          break;
        }
      }
      return removed;
    }
    /**
     * Set the new loader of the source. The next render cycle will use the
     * new loader.
     * @param {import("../featureloader.js").FeatureLoader} loader The loader to set.
     * @api
     */
    setLoader(loader) {
      this.loader_ = loader;
    }
    /**
     * Points the source to a new url. The next render cycle will use the new url.
     * @param {string|import("../featureloader.js").FeatureUrlFunction} url Url.
     * @api
     */
    setUrl(url) {
      assert(this.format_, "`format` must be set when `url` is set");
      this.url_ = url;
      this.setLoader(xhr(url, this.format_));
    }
  };
  var Vector_default2 = VectorSource;

  // node_modules/ol/TileState.js
  var TileState_default = {
    IDLE: 0,
    LOADING: 1,
    LOADED: 2,
    /**
     * Indicates that tile loading failed
     * @type {number}
     */
    ERROR: 3,
    EMPTY: 4
  };

  // node_modules/ol/Kinetic.js
  var Kinetic = class {
    /**
     * @param {number} decay Rate of decay (must be negative).
     * @param {number} minVelocity Minimum velocity (pixels/millisecond).
     * @param {number} delay Delay to consider to calculate the kinetic
     *     initial values (milliseconds).
     */
    constructor(decay, minVelocity, delay) {
      this.decay_ = decay;
      this.minVelocity_ = minVelocity;
      this.delay_ = delay;
      this.points_ = [];
      this.angle_ = 0;
      this.initialVelocity_ = 0;
    }
    /**
     * FIXME empty description for jsdoc
     */
    begin() {
      this.points_.length = 0;
      this.angle_ = 0;
      this.initialVelocity_ = 0;
    }
    /**
     * @param {number} x X.
     * @param {number} y Y.
     */
    update(x2, y2) {
      this.points_.push(x2, y2, Date.now());
    }
    /**
     * @return {boolean} Whether we should do kinetic animation.
     */
    end() {
      if (this.points_.length < 6) {
        return false;
      }
      const delay = Date.now() - this.delay_;
      const lastIndex = this.points_.length - 3;
      if (this.points_[lastIndex + 2] < delay) {
        return false;
      }
      let firstIndex = lastIndex - 3;
      while (firstIndex > 0 && this.points_[firstIndex + 2] > delay) {
        firstIndex -= 3;
      }
      const duration = this.points_[lastIndex + 2] - this.points_[firstIndex + 2];
      if (duration < 1e3 / 60) {
        return false;
      }
      const dx = this.points_[lastIndex] - this.points_[firstIndex];
      const dy = this.points_[lastIndex + 1] - this.points_[firstIndex + 1];
      this.angle_ = Math.atan2(dy, dx);
      this.initialVelocity_ = Math.sqrt(dx * dx + dy * dy) / duration;
      return this.initialVelocity_ > this.minVelocity_;
    }
    /**
     * @return {number} Total distance travelled (pixels).
     */
    getDistance() {
      return (this.minVelocity_ - this.initialVelocity_) / this.decay_;
    }
    /**
     * @return {number} Angle of the kinetic panning animation (radians).
     */
    getAngle() {
      return this.angle_;
    }
  };
  var Kinetic_default = Kinetic;

  // node_modules/ol/renderer/Map.js
  var MapRenderer = class extends Disposable_default {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(map2) {
      super();
      this.map_ = map2;
    }
    /**
     * @abstract
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(type, frameState) {
      abstract();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @protected
     */
    calculateMatrices2D(frameState) {
      const viewState = frameState.viewState;
      const coordinateToPixelTransform = frameState.coordinateToPixelTransform;
      const pixelToCoordinateTransform = frameState.pixelToCoordinateTransform;
      compose(
        coordinateToPixelTransform,
        frameState.size[0] / 2,
        frameState.size[1] / 2,
        1 / viewState.resolution,
        -1 / viewState.resolution,
        -viewState.rotation,
        -viewState.center[0],
        -viewState.center[1]
      );
      makeInverse(pixelToCoordinateTransform, coordinateToPixelTransform);
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {import("./vector.js").FeatureCallback<T>} callback Feature callback.
     * @param {S} thisArg Value to use as `this` when executing `callback`.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg2 Value to use as `this` when executing `layerFilter`.
     * @return {T|undefined} Callback result.
     * @template S,T,U
     */
    forEachFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, callback, thisArg, layerFilter, thisArg2) {
      let result;
      const viewState = frameState.viewState;
      function forEachFeatureAtCoordinate(managed, feature, layer, geometry) {
        return callback.call(thisArg, feature, managed ? layer : null, geometry);
      }
      const projection = viewState.projection;
      const translatedCoordinate = wrapX2(coordinate.slice(), projection);
      const offsets = [[0, 0]];
      if (projection.canWrapX() && checkWrapped) {
        const projectionExtent = projection.getExtent();
        const worldWidth = getWidth(projectionExtent);
        offsets.push([-worldWidth, 0], [worldWidth, 0]);
      }
      const layerStates = frameState.layerStatesArray;
      const numLayers = layerStates.length;
      const matches = (
        /** @type {Array<HitMatch<T>>} */
        []
      );
      const tmpCoord = [];
      for (let i4 = 0; i4 < offsets.length; i4++) {
        for (let j3 = numLayers - 1; j3 >= 0; --j3) {
          const layerState = layerStates[j3];
          const layer = layerState.layer;
          if (layer.hasRenderer() && inView(layerState, viewState) && layerFilter.call(thisArg2, layer)) {
            const layerRenderer = layer.getRenderer();
            const source = layer.getSource();
            if (layerRenderer && source) {
              const coordinates2 = source.getWrapX() ? translatedCoordinate : coordinate;
              const callback2 = forEachFeatureAtCoordinate.bind(
                null,
                layerState.managed
              );
              tmpCoord[0] = coordinates2[0] + offsets[i4][0];
              tmpCoord[1] = coordinates2[1] + offsets[i4][1];
              result = layerRenderer.forEachFeatureAtCoordinate(
                tmpCoord,
                frameState,
                hitTolerance,
                callback2,
                matches
              );
            }
            if (result) {
              return result;
            }
          }
        }
      }
      if (matches.length === 0) {
        return void 0;
      }
      const order = 1 / matches.length;
      matches.forEach((m3, i4) => m3.distanceSq += i4 * order);
      matches.sort((a4, b3) => a4.distanceSq - b3.distanceSq);
      matches.some((m3) => {
        return result = m3.callback(m3.feature, m3.layer, m3.geometry);
      });
      return result;
    }
    /**
     * @param {import("../coordinate.js").Coordinate} coordinate Coordinate.
     * @param {import("../Map.js").FrameState} frameState FrameState.
     * @param {number} hitTolerance Hit tolerance in pixels.
     * @param {boolean} checkWrapped Check for wrapped geometries.
     * @param {function(this: U, import("../layer/Layer.js").default): boolean} layerFilter Layer filter
     *     function, only layers which are visible and for which this function
     *     returns `true` will be tested for features.  By default, all visible
     *     layers will be tested.
     * @param {U} thisArg Value to use as `this` when executing `layerFilter`.
     * @return {boolean} Is there a feature at the given coordinate?
     * @template U
     */
    hasFeatureAtCoordinate(coordinate, frameState, hitTolerance, checkWrapped, layerFilter, thisArg) {
      const hasFeature = this.forEachFeatureAtCoordinate(
        coordinate,
        frameState,
        hitTolerance,
        checkWrapped,
        TRUE,
        this,
        layerFilter,
        thisArg
      );
      return hasFeature !== void 0;
    }
    /**
     * @return {import("../Map.js").default} Map.
     */
    getMap() {
      return this.map_;
    }
    /**
     * Render.
     * @abstract
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(frameState) {
      abstract();
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    flushDeclutterItems(frameState) {
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @protected
     */
    scheduleExpireIconCache(frameState) {
      if (shared.canExpireCache()) {
        frameState.postRenderFunctions.push(expireIconCache);
      }
    }
  };
  function expireIconCache(map2, frameState) {
    shared.expire();
  }
  var Map_default = MapRenderer;

  // node_modules/ol/renderer/Composite.js
  var CompositeMapRenderer = class extends Map_default {
    /**
     * @param {import("../Map.js").default} map Map.
     */
    constructor(map2) {
      super(map2);
      this.fontChangeListenerKey_ = listen(
        checkedFonts,
        ObjectEventType_default.PROPERTYCHANGE,
        map2.redrawText.bind(map2)
      );
      this.element_ = document.createElement("div");
      const style = this.element_.style;
      style.position = "absolute";
      style.width = "100%";
      style.height = "100%";
      style.zIndex = "0";
      this.element_.className = CLASS_UNSELECTABLE + " ol-layers";
      const container = map2.getViewport();
      container.insertBefore(this.element_, container.firstChild || null);
      this.children_ = [];
      this.renderedVisible_ = true;
      this.declutterLayers_ = [];
    }
    /**
     * @param {import("../render/EventType.js").default} type Event type.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    dispatchRenderEvent(type, frameState) {
      const map2 = this.getMap();
      if (map2.hasListener(type)) {
        const event = new Event_default2(type, void 0, frameState);
        map2.dispatchEvent(event);
      }
    }
    disposeInternal() {
      unlistenByKey(this.fontChangeListenerKey_);
      this.element_.parentNode.removeChild(this.element_);
      super.disposeInternal();
    }
    /**
     * Render.
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    renderFrame(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element_.style.display = "none";
          this.renderedVisible_ = false;
        }
        return;
      }
      this.calculateMatrices2D(frameState);
      this.dispatchRenderEvent(EventType_default2.PRECOMPOSE, frameState);
      const layerStatesArray = frameState.layerStatesArray.sort(function(a4, b3) {
        return a4.zIndex - b3.zIndex;
      });
      const viewState = frameState.viewState;
      this.children_.length = 0;
      const declutterLayers = this.declutterLayers_;
      declutterLayers.length = 0;
      let previousElement = null;
      for (let i4 = 0, ii = layerStatesArray.length; i4 < ii; ++i4) {
        const layerState = layerStatesArray[i4];
        frameState.layerIndex = i4;
        const layer = layerState.layer;
        const sourceState = layer.getSourceState();
        if (!inView(layerState, viewState) || sourceState != "ready" && sourceState != "undefined") {
          layer.unrender();
          continue;
        }
        const element = layer.render(frameState, previousElement);
        if (!element) {
          continue;
        }
        if (element !== previousElement) {
          this.children_.push(element);
          previousElement = element;
        }
        if ("getDeclutter" in layer) {
          declutterLayers.push(
            /** @type {import("../layer/BaseVector.js").default} */
            layer
          );
        }
      }
      this.flushDeclutterItems(frameState);
      replaceChildren(this.element_, this.children_);
      this.dispatchRenderEvent(EventType_default2.POSTCOMPOSE, frameState);
      if (!this.renderedVisible_) {
        this.element_.style.display = "";
        this.renderedVisible_ = true;
      }
      this.scheduleExpireIconCache(frameState);
    }
    /**
     * @param {import("../Map.js").FrameState} frameState Frame state.
     */
    flushDeclutterItems(frameState) {
      const layers = this.declutterLayers_;
      for (let i4 = layers.length - 1; i4 >= 0; --i4) {
        layers[i4].renderDeclutter(frameState);
      }
      layers.length = 0;
    }
  };
  var Composite_default = CompositeMapRenderer;

  // node_modules/ol/layer/Group.js
  var GroupEvent = class extends Event_default {
    /**
     * @param {EventType} type The event type.
     * @param {BaseLayer} layer The layer.
     */
    constructor(type, layer) {
      super(type);
      this.layer = layer;
    }
  };
  var Property4 = {
    LAYERS: "layers"
  };
  var LayerGroup = class _LayerGroup extends Base_default {
    /**
     * @param {Options} [options] Layer options.
     */
    constructor(options) {
      options = options || {};
      const baseOptions = (
        /** @type {Options} */
        Object.assign({}, options)
      );
      delete baseOptions.layers;
      let layers = options.layers;
      super(baseOptions);
      this.on;
      this.once;
      this.un;
      this.layersListenerKeys_ = [];
      this.listenerKeys_ = {};
      this.addChangeListener(Property4.LAYERS, this.handleLayersChanged_);
      if (layers) {
        if (Array.isArray(layers)) {
          layers = new Collection_default(layers.slice(), { unique: true });
        } else {
          assert(
            typeof /** @type {?} */
            layers.getArray === "function",
            "Expected `layers` to be an array or a `Collection`"
          );
        }
      } else {
        layers = new Collection_default(void 0, { unique: true });
      }
      this.setLayers(layers);
    }
    /**
     * @private
     */
    handleLayerChange_() {
      this.changed();
    }
    /**
     * @private
     */
    handleLayersChanged_() {
      this.layersListenerKeys_.forEach(unlistenByKey);
      this.layersListenerKeys_.length = 0;
      const layers = this.getLayers();
      this.layersListenerKeys_.push(
        listen(layers, CollectionEventType_default.ADD, this.handleLayersAdd_, this),
        listen(layers, CollectionEventType_default.REMOVE, this.handleLayersRemove_, this)
      );
      for (const id in this.listenerKeys_) {
        this.listenerKeys_[id].forEach(unlistenByKey);
      }
      clear(this.listenerKeys_);
      const layersArray = layers.getArray();
      for (let i4 = 0, ii = layersArray.length; i4 < ii; i4++) {
        const layer = layersArray[i4];
        this.registerLayerListeners_(layer);
        this.dispatchEvent(new GroupEvent("addlayer", layer));
      }
      this.changed();
    }
    /**
     * @param {BaseLayer} layer The layer.
     */
    registerLayerListeners_(layer) {
      const listenerKeys = [
        listen(
          layer,
          ObjectEventType_default.PROPERTYCHANGE,
          this.handleLayerChange_,
          this
        ),
        listen(layer, EventType_default.CHANGE, this.handleLayerChange_, this)
      ];
      if (layer instanceof _LayerGroup) {
        listenerKeys.push(
          listen(layer, "addlayer", this.handleLayerGroupAdd_, this),
          listen(layer, "removelayer", this.handleLayerGroupRemove_, this)
        );
      }
      this.listenerKeys_[getUid(layer)] = listenerKeys;
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupAdd_(event) {
      this.dispatchEvent(new GroupEvent("addlayer", event.layer));
    }
    /**
     * @param {GroupEvent} event The layer group event.
     */
    handleLayerGroupRemove_(event) {
      this.dispatchEvent(new GroupEvent("removelayer", event.layer));
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersAdd_(collectionEvent) {
      const layer = collectionEvent.element;
      this.registerLayerListeners_(layer);
      this.dispatchEvent(new GroupEvent("addlayer", layer));
      this.changed();
    }
    /**
     * @param {import("../Collection.js").CollectionEvent<import("./Base.js").default>} collectionEvent CollectionEvent.
     * @private
     */
    handleLayersRemove_(collectionEvent) {
      const layer = collectionEvent.element;
      const key = getUid(layer);
      this.listenerKeys_[key].forEach(unlistenByKey);
      delete this.listenerKeys_[key];
      this.dispatchEvent(new GroupEvent("removelayer", layer));
      this.changed();
    }
    /**
     * Returns the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @return {!Collection<import("./Base.js").default>} Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    getLayers() {
      return (
        /** @type {!Collection<import("./Base.js").default>} */
        this.get(Property4.LAYERS)
      );
    }
    /**
     * Set the {@link module:ol/Collection~Collection collection} of {@link module:ol/layer/Layer~Layer layers}
     * in this group.
     * @param {!Collection<import("./Base.js").default>} layers Collection of
     *   {@link module:ol/layer/Base~BaseLayer layers} that are part of this group.
     * @observable
     * @api
     */
    setLayers(layers) {
      const collection = this.getLayers();
      if (collection) {
        const currentLayers = collection.getArray();
        for (let i4 = 0, ii = currentLayers.length; i4 < ii; ++i4) {
          this.dispatchEvent(new GroupEvent("removelayer", currentLayers[i4]));
        }
      }
      this.set(Property4.LAYERS, layers);
    }
    /**
     * @param {Array<import("./Layer.js").default>} [array] Array of layers (to be modified in place).
     * @return {Array<import("./Layer.js").default>} Array of layers.
     */
    getLayersArray(array) {
      array = array !== void 0 ? array : [];
      this.getLayers().forEach(function(layer) {
        layer.getLayersArray(array);
      });
      return array;
    }
    /**
     * Get the layer states list and use this groups z-index as the default
     * for all layers in this and nested groups, if it is unset at this point.
     * If dest is not provided and this group's z-index is undefined
     * 0 is used a the default z-index.
     * @param {Array<import("./Layer.js").State>} [dest] Optional list
     * of layer states (to be modified in place).
     * @return {Array<import("./Layer.js").State>} List of layer states.
     */
    getLayerStatesArray(dest) {
      const states = dest !== void 0 ? dest : [];
      const pos = states.length;
      this.getLayers().forEach(function(layer) {
        layer.getLayerStatesArray(states);
      });
      const ownLayerState = this.getLayerState();
      let defaultZIndex = ownLayerState.zIndex;
      if (!dest && ownLayerState.zIndex === void 0) {
        defaultZIndex = 0;
      }
      for (let i4 = pos, ii = states.length; i4 < ii; i4++) {
        const layerState = states[i4];
        layerState.opacity *= ownLayerState.opacity;
        layerState.visible = layerState.visible && ownLayerState.visible;
        layerState.maxResolution = Math.min(
          layerState.maxResolution,
          ownLayerState.maxResolution
        );
        layerState.minResolution = Math.max(
          layerState.minResolution,
          ownLayerState.minResolution
        );
        layerState.minZoom = Math.max(layerState.minZoom, ownLayerState.minZoom);
        layerState.maxZoom = Math.min(layerState.maxZoom, ownLayerState.maxZoom);
        if (ownLayerState.extent !== void 0) {
          if (layerState.extent !== void 0) {
            layerState.extent = getIntersection(
              layerState.extent,
              ownLayerState.extent
            );
          } else {
            layerState.extent = ownLayerState.extent;
          }
        }
        if (layerState.zIndex === void 0) {
          layerState.zIndex = defaultZIndex;
        }
      }
      return states;
    }
    /**
     * @return {import("../source/Source.js").State} Source state.
     */
    getSourceState() {
      return "ready";
    }
  };
  var Group_default = LayerGroup;

  // node_modules/ol/MapEvent.js
  var MapEvent = class extends Event_default {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {?import("./Map.js").FrameState} [frameState] Frame state.
     */
    constructor(type, map2, frameState) {
      super(type);
      this.map = map2;
      this.frameState = frameState !== void 0 ? frameState : null;
    }
  };
  var MapEvent_default = MapEvent;

  // node_modules/ol/MapBrowserEvent.js
  var MapBrowserEvent = class extends MapEvent_default {
    /**
     * @param {string} type Event type.
     * @param {import("./Map.js").default} map Map.
     * @param {EVENT} originalEvent Original event.
     * @param {boolean} [dragging] Is the map currently being dragged?
     * @param {import("./Map.js").FrameState} [frameState] Frame state.
     * @param {Array<PointerEvent>} [activePointers] Active pointers.
     */
    constructor(type, map2, originalEvent, dragging, frameState, activePointers) {
      super(type, map2, frameState);
      this.originalEvent = originalEvent;
      this.pixel_ = null;
      this.coordinate_ = null;
      this.dragging = dragging !== void 0 ? dragging : false;
      this.activePointers = activePointers;
    }
    /**
     * The map pixel relative to the viewport corresponding to the original event.
     * @type {import("./pixel.js").Pixel}
     * @api
     */
    get pixel() {
      if (!this.pixel_) {
        this.pixel_ = this.map.getEventPixel(this.originalEvent);
      }
      return this.pixel_;
    }
    set pixel(pixel) {
      this.pixel_ = pixel;
    }
    /**
     * The coordinate corresponding to the original browser event.  This will be in the user
     * projection if one is set.  Otherwise it will be in the view projection.
     * @type {import("./coordinate.js").Coordinate}
     * @api
     */
    get coordinate() {
      if (!this.coordinate_) {
        this.coordinate_ = this.map.getCoordinateFromPixel(this.pixel);
      }
      return this.coordinate_;
    }
    set coordinate(coordinate) {
      this.coordinate_ = coordinate;
    }
    /**
     * Prevents the default browser action.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.preventDefault.
     * @api
     */
    preventDefault() {
      super.preventDefault();
      if ("preventDefault" in this.originalEvent) {
        this.originalEvent.preventDefault();
      }
    }
    /**
     * Prevents further propagation of the current event.
     * See https://developer.mozilla.org/en-US/docs/Web/API/event.stopPropagation.
     * @api
     */
    stopPropagation() {
      super.stopPropagation();
      if ("stopPropagation" in this.originalEvent) {
        this.originalEvent.stopPropagation();
      }
    }
  };
  var MapBrowserEvent_default = MapBrowserEvent;

  // node_modules/ol/MapBrowserEventType.js
  var MapBrowserEventType_default = {
    /**
     * A true single click with no dragging and no double click. Note that this
     * event is delayed by 250 ms to ensure that it is not a double click.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#singleclick
     * @api
     */
    SINGLECLICK: "singleclick",
    /**
     * A click with no dragging. A double click will fire two of this.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#click
     * @api
     */
    CLICK: EventType_default.CLICK,
    /**
     * A true double click, with no dragging.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#dblclick
     * @api
     */
    DBLCLICK: EventType_default.DBLCLICK,
    /**
     * Triggered when a pointer is dragged.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointerdrag
     * @api
     */
    POINTERDRAG: "pointerdrag",
    /**
     * Triggered when a pointer is moved. Note that on touch devices this is
     * triggered when the map is panned, so is not the same as mousemove.
     * @event module:ol/MapBrowserEvent~MapBrowserEvent#pointermove
     * @api
     */
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  };

  // node_modules/ol/pointer/EventType.js
  var EventType_default3 = {
    POINTERMOVE: "pointermove",
    POINTERDOWN: "pointerdown",
    POINTERUP: "pointerup",
    POINTEROVER: "pointerover",
    POINTEROUT: "pointerout",
    POINTERENTER: "pointerenter",
    POINTERLEAVE: "pointerleave",
    POINTERCANCEL: "pointercancel"
  };

  // node_modules/ol/MapBrowserEventHandler.js
  var MapBrowserEventHandler = class extends Target_default {
    /**
     * @param {import("./Map.js").default} map The map with the viewport to listen to events on.
     * @param {number} [moveTolerance] The minimal distance the pointer must travel to trigger a move.
     */
    constructor(map2, moveTolerance) {
      super(map2);
      this.map_ = map2;
      this.clickTimeoutId_;
      this.emulateClicks_ = false;
      this.dragging_ = false;
      this.dragListenerKeys_ = [];
      this.moveTolerance_ = moveTolerance === void 0 ? 1 : moveTolerance;
      this.down_ = null;
      const element = this.map_.getViewport();
      this.activePointers_ = [];
      this.trackedTouches_ = {};
      this.element_ = element;
      this.pointerdownListenerKey_ = listen(
        element,
        EventType_default3.POINTERDOWN,
        this.handlePointerDown_,
        this
      );
      this.originalPointerMoveEvent_;
      this.relayedListenerKey_ = listen(
        element,
        EventType_default3.POINTERMOVE,
        this.relayMoveEvent_,
        this
      );
      this.boundHandleTouchMove_ = this.handleTouchMove_.bind(this);
      this.element_.addEventListener(
        EventType_default.TOUCHMOVE,
        this.boundHandleTouchMove_,
        PASSIVE_EVENT_LISTENERS ? { passive: false } : false
      );
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    emulateClick_(pointerEvent) {
      let newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.CLICK,
        this.map_,
        pointerEvent
      );
      this.dispatchEvent(newEvent);
      if (this.clickTimeoutId_ !== void 0) {
        clearTimeout(this.clickTimeoutId_);
        this.clickTimeoutId_ = void 0;
        newEvent = new MapBrowserEvent_default(
          MapBrowserEventType_default.DBLCLICK,
          this.map_,
          pointerEvent
        );
        this.dispatchEvent(newEvent);
      } else {
        this.clickTimeoutId_ = setTimeout(() => {
          this.clickTimeoutId_ = void 0;
          const newEvent2 = new MapBrowserEvent_default(
            MapBrowserEventType_default.SINGLECLICK,
            this.map_,
            pointerEvent
          );
          this.dispatchEvent(newEvent2);
        }, 250);
      }
    }
    /**
     * Keeps track on how many pointers are currently active.
     *
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    updateActivePointers_(pointerEvent) {
      const event = pointerEvent;
      const id = event.pointerId;
      if (event.type == MapBrowserEventType_default.POINTERUP || event.type == MapBrowserEventType_default.POINTERCANCEL) {
        delete this.trackedTouches_[id];
        for (const pointerId in this.trackedTouches_) {
          if (this.trackedTouches_[pointerId].target !== event.target) {
            delete this.trackedTouches_[pointerId];
            break;
          }
        }
      } else if (event.type == MapBrowserEventType_default.POINTERDOWN || event.type == MapBrowserEventType_default.POINTERMOVE) {
        this.trackedTouches_[id] = event;
      }
      this.activePointers_ = Object.values(this.trackedTouches_);
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerUp_(pointerEvent) {
      this.updateActivePointers_(pointerEvent);
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERUP,
        this.map_,
        pointerEvent,
        void 0,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
      if (this.emulateClicks_ && !newEvent.defaultPrevented && !this.dragging_ && this.isMouseActionButton_(pointerEvent)) {
        this.emulateClick_(this.down_);
      }
      if (this.activePointers_.length === 0) {
        this.dragListenerKeys_.forEach(unlistenByKey);
        this.dragListenerKeys_.length = 0;
        this.dragging_ = false;
        this.down_ = null;
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} If the left mouse button was pressed.
     * @private
     */
    isMouseActionButton_(pointerEvent) {
      return pointerEvent.button === 0;
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerDown_(pointerEvent) {
      this.emulateClicks_ = this.activePointers_.length === 0;
      this.updateActivePointers_(pointerEvent);
      const newEvent = new MapBrowserEvent_default(
        MapBrowserEventType_default.POINTERDOWN,
        this.map_,
        pointerEvent,
        void 0,
        void 0,
        this.activePointers_
      );
      this.dispatchEvent(newEvent);
      this.down_ = new PointerEvent(pointerEvent.type, pointerEvent);
      Object.defineProperty(this.down_, "target", {
        writable: false,
        value: pointerEvent.target
      });
      if (this.dragListenerKeys_.length === 0) {
        const doc = this.map_.getOwnerDocument();
        this.dragListenerKeys_.push(
          listen(
            doc,
            MapBrowserEventType_default.POINTERMOVE,
            this.handlePointerMove_,
            this
          ),
          listen(doc, MapBrowserEventType_default.POINTERUP, this.handlePointerUp_, this),
          /* Note that the listener for `pointercancel is set up on
           * `pointerEventHandler_` and not `documentPointerEventHandler_` like
           * the `pointerup` and `pointermove` listeners.
           *
           * The reason for this is the following: `TouchSource.vacuumTouches_()`
           * issues `pointercancel` events, when there was no `touchend` for a
           * `touchstart`. Now, let's say a first `touchstart` is registered on
           * `pointerEventHandler_`. The `documentPointerEventHandler_` is set up.
           * But `documentPointerEventHandler_` doesn't know about the first
           * `touchstart`. If there is no `touchend` for the `touchstart`, we can
           * only receive a `touchcancel` from `pointerEventHandler_`, because it is
           * only registered there.
           */
          listen(
            this.element_,
            MapBrowserEventType_default.POINTERCANCEL,
            this.handlePointerUp_,
            this
          )
        );
        if (this.element_.getRootNode && this.element_.getRootNode() !== doc) {
          this.dragListenerKeys_.push(
            listen(
              this.element_.getRootNode(),
              MapBrowserEventType_default.POINTERUP,
              this.handlePointerUp_,
              this
            )
          );
        }
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    handlePointerMove_(pointerEvent) {
      if (this.isMoving_(pointerEvent)) {
        this.updateActivePointers_(pointerEvent);
        this.dragging_ = true;
        const newEvent = new MapBrowserEvent_default(
          MapBrowserEventType_default.POINTERDRAG,
          this.map_,
          pointerEvent,
          this.dragging_,
          void 0,
          this.activePointers_
        );
        this.dispatchEvent(newEvent);
      }
    }
    /**
     * Wrap and relay a pointermove event.
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @private
     */
    relayMoveEvent_(pointerEvent) {
      this.originalPointerMoveEvent_ = pointerEvent;
      const dragging = !!(this.down_ && this.isMoving_(pointerEvent));
      this.dispatchEvent(
        new MapBrowserEvent_default(
          MapBrowserEventType_default.POINTERMOVE,
          this.map_,
          pointerEvent,
          dragging
        )
      );
    }
    /**
     * Flexible handling of a `touch-action: none` css equivalent: because calling
     * `preventDefault()` on a `pointermove` event does not stop native page scrolling
     * and zooming, we also listen for `touchmove` and call `preventDefault()` on it
     * when an interaction (currently `DragPan` handles the event.
     * @param {TouchEvent} event Event.
     * @private
     */
    handleTouchMove_(event) {
      const originalEvent = this.originalPointerMoveEvent_;
      if ((!originalEvent || originalEvent.defaultPrevented) && (typeof event.cancelable !== "boolean" || event.cancelable === true)) {
        event.preventDefault();
      }
    }
    /**
     * @param {PointerEvent} pointerEvent Pointer
     * event.
     * @return {boolean} Is moving.
     * @private
     */
    isMoving_(pointerEvent) {
      return this.dragging_ || Math.abs(pointerEvent.clientX - this.down_.clientX) > this.moveTolerance_ || Math.abs(pointerEvent.clientY - this.down_.clientY) > this.moveTolerance_;
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      if (this.relayedListenerKey_) {
        unlistenByKey(this.relayedListenerKey_);
        this.relayedListenerKey_ = null;
      }
      this.element_.removeEventListener(
        EventType_default.TOUCHMOVE,
        this.boundHandleTouchMove_
      );
      if (this.pointerdownListenerKey_) {
        unlistenByKey(this.pointerdownListenerKey_);
        this.pointerdownListenerKey_ = null;
      }
      this.dragListenerKeys_.forEach(unlistenByKey);
      this.dragListenerKeys_.length = 0;
      this.element_ = null;
      super.disposeInternal();
    }
  };
  var MapBrowserEventHandler_default = MapBrowserEventHandler;

  // node_modules/ol/MapEventType.js
  var MapEventType_default = {
    /**
     * Triggered after a map frame is rendered.
     * @event module:ol/MapEvent~MapEvent#postrender
     * @api
     */
    POSTRENDER: "postrender",
    /**
     * Triggered when the map starts moving.
     * @event module:ol/MapEvent~MapEvent#movestart
     * @api
     */
    MOVESTART: "movestart",
    /**
     * Triggered after the map is moved.
     * @event module:ol/MapEvent~MapEvent#moveend
     * @api
     */
    MOVEEND: "moveend",
    /**
     * Triggered when loading of additional map data (tiles, images, features) starts.
     * @event module:ol/MapEvent~MapEvent#loadstart
     * @api
     */
    LOADSTART: "loadstart",
    /**
     * Triggered when loading of additional map data has completed.
     * @event module:ol/MapEvent~MapEvent#loadend
     * @api
     */
    LOADEND: "loadend"
  };

  // node_modules/ol/MapProperty.js
  var MapProperty_default = {
    LAYERGROUP: "layergroup",
    SIZE: "size",
    TARGET: "target",
    VIEW: "view"
  };

  // node_modules/ol/structs/PriorityQueue.js
  var DROP = Infinity;
  var PriorityQueue = class {
    /**
     * @param {function(T): number} priorityFunction Priority function.
     * @param {function(T): string} keyFunction Key function.
     */
    constructor(priorityFunction, keyFunction) {
      this.priorityFunction_ = priorityFunction;
      this.keyFunction_ = keyFunction;
      this.elements_ = [];
      this.priorities_ = [];
      this.queuedElements_ = {};
    }
    /**
     * FIXME empty description for jsdoc
     */
    clear() {
      this.elements_.length = 0;
      this.priorities_.length = 0;
      clear(this.queuedElements_);
    }
    /**
     * Remove and return the highest-priority element. O(log N).
     * @return {T} Element.
     */
    dequeue() {
      const elements = this.elements_;
      const priorities = this.priorities_;
      const element = elements[0];
      if (elements.length == 1) {
        elements.length = 0;
        priorities.length = 0;
      } else {
        elements[0] = elements.pop();
        priorities[0] = priorities.pop();
        this.siftUp_(0);
      }
      const elementKey = this.keyFunction_(element);
      delete this.queuedElements_[elementKey];
      return element;
    }
    /**
     * Enqueue an element. O(log N).
     * @param {T} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(element) {
      assert(
        !(this.keyFunction_(element) in this.queuedElements_),
        "Tried to enqueue an `element` that was already added to the queue"
      );
      const priority = this.priorityFunction_(element);
      if (priority != DROP) {
        this.elements_.push(element);
        this.priorities_.push(priority);
        this.queuedElements_[this.keyFunction_(element)] = true;
        this.siftDown_(0, this.elements_.length - 1);
        return true;
      }
      return false;
    }
    /**
     * @return {number} Count.
     */
    getCount() {
      return this.elements_.length;
    }
    /**
     * Gets the index of the left child of the node at the given index.
     * @param {number} index The index of the node to get the left child for.
     * @return {number} The index of the left child.
     * @private
     */
    getLeftChildIndex_(index) {
      return index * 2 + 1;
    }
    /**
     * Gets the index of the right child of the node at the given index.
     * @param {number} index The index of the node to get the right child for.
     * @return {number} The index of the right child.
     * @private
     */
    getRightChildIndex_(index) {
      return index * 2 + 2;
    }
    /**
     * Gets the index of the parent of the node at the given index.
     * @param {number} index The index of the node to get the parent for.
     * @return {number} The index of the parent.
     * @private
     */
    getParentIndex_(index) {
      return index - 1 >> 1;
    }
    /**
     * Make this a heap. O(N).
     * @private
     */
    heapify_() {
      let i4;
      for (i4 = (this.elements_.length >> 1) - 1; i4 >= 0; i4--) {
        this.siftUp_(i4);
      }
    }
    /**
     * @return {boolean} Is empty.
     */
    isEmpty() {
      return this.elements_.length === 0;
    }
    /**
     * @param {string} key Key.
     * @return {boolean} Is key queued.
     */
    isKeyQueued(key) {
      return key in this.queuedElements_;
    }
    /**
     * @param {T} element Element.
     * @return {boolean} Is queued.
     */
    isQueued(element) {
      return this.isKeyQueued(this.keyFunction_(element));
    }
    /**
     * @param {number} index The index of the node to move down.
     * @private
     */
    siftUp_(index) {
      const elements = this.elements_;
      const priorities = this.priorities_;
      const count = elements.length;
      const element = elements[index];
      const priority = priorities[index];
      const startIndex = index;
      while (index < count >> 1) {
        const lIndex = this.getLeftChildIndex_(index);
        const rIndex = this.getRightChildIndex_(index);
        const smallerChildIndex = rIndex < count && priorities[rIndex] < priorities[lIndex] ? rIndex : lIndex;
        elements[index] = elements[smallerChildIndex];
        priorities[index] = priorities[smallerChildIndex];
        index = smallerChildIndex;
      }
      elements[index] = element;
      priorities[index] = priority;
      this.siftDown_(startIndex, index);
    }
    /**
     * @param {number} startIndex The index of the root.
     * @param {number} index The index of the node to move up.
     * @private
     */
    siftDown_(startIndex, index) {
      const elements = this.elements_;
      const priorities = this.priorities_;
      const element = elements[index];
      const priority = priorities[index];
      while (index > startIndex) {
        const parentIndex = this.getParentIndex_(index);
        if (priorities[parentIndex] > priority) {
          elements[index] = elements[parentIndex];
          priorities[index] = priorities[parentIndex];
          index = parentIndex;
        } else {
          break;
        }
      }
      elements[index] = element;
      priorities[index] = priority;
    }
    /**
     * FIXME empty description for jsdoc
     */
    reprioritize() {
      const priorityFunction = this.priorityFunction_;
      const elements = this.elements_;
      const priorities = this.priorities_;
      let index = 0;
      const n2 = elements.length;
      let element, i4, priority;
      for (i4 = 0; i4 < n2; ++i4) {
        element = elements[i4];
        priority = priorityFunction(element);
        if (priority == DROP) {
          delete this.queuedElements_[this.keyFunction_(element)];
        } else {
          priorities[index] = priority;
          elements[index++] = element;
        }
      }
      elements.length = index;
      priorities.length = index;
      this.heapify_();
    }
  };
  var PriorityQueue_default = PriorityQueue;

  // node_modules/ol/TileQueue.js
  var TileQueue = class extends PriorityQueue_default {
    /**
     * @param {PriorityFunction} tilePriorityFunction Tile priority function.
     * @param {function(): ?} tileChangeCallback Function called on each tile change event.
     */
    constructor(tilePriorityFunction, tileChangeCallback) {
      super(
        /**
         * @param {Array} element Element.
         * @return {number} Priority.
         */
        function(element) {
          return tilePriorityFunction.apply(null, element);
        },
        /**
         * @param {Array} element Element.
         * @return {string} Key.
         */
        function(element) {
          return (
            /** @type {import("./Tile.js").default} */
            element[0].getKey()
          );
        }
      );
      this.boundHandleTileChange_ = this.handleTileChange.bind(this);
      this.tileChangeCallback_ = tileChangeCallback;
      this.tilesLoading_ = 0;
      this.tilesLoadingKeys_ = {};
    }
    /**
     * @param {Array} element Element.
     * @return {boolean} The element was added to the queue.
     */
    enqueue(element) {
      const added = super.enqueue(element);
      if (added) {
        const tile = element[0];
        tile.addEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
      }
      return added;
    }
    /**
     * @return {number} Number of tiles loading.
     */
    getTilesLoading() {
      return this.tilesLoading_;
    }
    /**
     * @param {import("./events/Event.js").default} event Event.
     * @protected
     */
    handleTileChange(event) {
      const tile = (
        /** @type {import("./Tile.js").default} */
        event.target
      );
      const state = tile.getState();
      if (state === TileState_default.LOADED || state === TileState_default.ERROR || state === TileState_default.EMPTY) {
        if (state !== TileState_default.ERROR) {
          tile.removeEventListener(EventType_default.CHANGE, this.boundHandleTileChange_);
        }
        const tileKey = tile.getKey();
        if (tileKey in this.tilesLoadingKeys_) {
          delete this.tilesLoadingKeys_[tileKey];
          --this.tilesLoading_;
        }
        this.tileChangeCallback_();
      }
    }
    /**
     * @param {number} maxTotalLoading Maximum number tiles to load simultaneously.
     * @param {number} maxNewLoads Maximum number of new tiles to load.
     */
    loadMoreTiles(maxTotalLoading, maxNewLoads) {
      let newLoads = 0;
      let state, tile, tileKey;
      while (this.tilesLoading_ < maxTotalLoading && newLoads < maxNewLoads && this.getCount() > 0) {
        tile = /** @type {import("./Tile.js").default} */
        this.dequeue()[0];
        tileKey = tile.getKey();
        state = tile.getState();
        if (state === TileState_default.IDLE && !(tileKey in this.tilesLoadingKeys_)) {
          this.tilesLoadingKeys_[tileKey] = true;
          ++this.tilesLoading_;
          ++newLoads;
          tile.load();
        }
      }
    }
  };
  var TileQueue_default = TileQueue;
  function getTilePriority(frameState, tile, tileSourceKey, tileCenter, tileResolution) {
    if (!frameState || !(tileSourceKey in frameState.wantedTiles)) {
      return DROP;
    }
    if (!frameState.wantedTiles[tileSourceKey][tile.getKey()]) {
      return DROP;
    }
    const center = frameState.viewState.center;
    const deltaX = tileCenter[0] - center[0];
    const deltaY = tileCenter[1] - center[1];
    return 65536 * Math.log(tileResolution) + Math.sqrt(deltaX * deltaX + deltaY * deltaY) / tileResolution;
  }

  // node_modules/ol/control/Control.js
  var Control = class extends Object_default {
    /**
     * @param {Options} options Control options.
     */
    constructor(options) {
      super();
      const element = options.element;
      if (element && !options.target && !element.style.pointerEvents) {
        element.style.pointerEvents = "auto";
      }
      this.element = element ? element : null;
      this.target_ = null;
      this.map_ = null;
      this.listenerKeys = [];
      if (options.render) {
        this.render = options.render;
      }
      if (options.target) {
        this.setTarget(options.target);
      }
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      removeNode(this.element);
      super.disposeInternal();
    }
    /**
     * Get the map associated with this control.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Remove the control from its current map and attach it to the new map.
     * Pass `null` to just remove the control from the current map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     * @api
     */
    setMap(map2) {
      if (this.map_) {
        removeNode(this.element);
      }
      for (let i4 = 0, ii = this.listenerKeys.length; i4 < ii; ++i4) {
        unlistenByKey(this.listenerKeys[i4]);
      }
      this.listenerKeys.length = 0;
      this.map_ = map2;
      if (map2) {
        const target = this.target_ ? this.target_ : map2.getOverlayContainerStopEvent();
        target.appendChild(this.element);
        if (this.render !== VOID) {
          this.listenerKeys.push(
            listen(map2, MapEventType_default.POSTRENDER, this.render, this)
          );
        }
        map2.render();
      }
    }
    /**
     * Renders the control.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @api
     */
    render(mapEvent) {
    }
    /**
     * This function is used to set a target element for the control. It has no
     * effect if it is called after the control has been added to the map (i.e.
     * after `setMap` is called on the control). If no `target` is set in the
     * options passed to the control constructor and if `setTarget` is not called
     * then the control is added to the map's overlay container.
     * @param {HTMLElement|string} target Target.
     * @api
     */
    setTarget(target) {
      this.target_ = typeof target === "string" ? document.getElementById(target) : target;
    }
  };
  var Control_default = Control;

  // node_modules/ol/control/Attribution.js
  var Attribution = class extends Control_default {
    /**
     * @param {Options} [options] Attribution options.
     */
    constructor(options) {
      options = options ? options : {};
      super({
        element: document.createElement("div"),
        render: options.render,
        target: options.target
      });
      this.ulElement_ = document.createElement("ul");
      this.collapsed_ = options.collapsed !== void 0 ? options.collapsed : true;
      this.userCollapsed_ = this.collapsed_;
      this.overrideCollapsible_ = options.collapsible !== void 0;
      this.collapsible_ = options.collapsible !== void 0 ? options.collapsible : true;
      if (!this.collapsible_) {
        this.collapsed_ = false;
      }
      const className = options.className !== void 0 ? options.className : "ol-attribution";
      const tipLabel = options.tipLabel !== void 0 ? options.tipLabel : "Attributions";
      const expandClassName = options.expandClassName !== void 0 ? options.expandClassName : className + "-expand";
      const collapseLabel = options.collapseLabel !== void 0 ? options.collapseLabel : "\u203A";
      const collapseClassName = options.collapseClassName !== void 0 ? options.collapseClassName : className + "-collapse";
      if (typeof collapseLabel === "string") {
        this.collapseLabel_ = document.createElement("span");
        this.collapseLabel_.textContent = collapseLabel;
        this.collapseLabel_.className = collapseClassName;
      } else {
        this.collapseLabel_ = collapseLabel;
      }
      const label = options.label !== void 0 ? options.label : "i";
      if (typeof label === "string") {
        this.label_ = document.createElement("span");
        this.label_.textContent = label;
        this.label_.className = expandClassName;
      } else {
        this.label_ = label;
      }
      const activeLabel = this.collapsible_ && !this.collapsed_ ? this.collapseLabel_ : this.label_;
      this.toggleButton_ = document.createElement("button");
      this.toggleButton_.setAttribute("type", "button");
      this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
      this.toggleButton_.title = tipLabel;
      this.toggleButton_.appendChild(activeLabel);
      this.toggleButton_.addEventListener(
        EventType_default.CLICK,
        this.handleClick_.bind(this),
        false
      );
      const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL + (this.collapsed_ && this.collapsible_ ? " " + CLASS_COLLAPSED : "") + (this.collapsible_ ? "" : " ol-uncollapsible");
      const element = this.element;
      element.className = cssClasses;
      element.appendChild(this.toggleButton_);
      element.appendChild(this.ulElement_);
      this.renderedAttributions_ = [];
      this.renderedVisible_ = true;
    }
    /**
     * Collect a list of visible attributions and set the collapsible state.
     * @param {import("../Map.js").FrameState} frameState Frame state.
     * @return {Array<string>} Attributions.
     * @private
     */
    collectSourceAttributions_(frameState) {
      const visibleAttributions = Array.from(
        new Set(
          this.getMap().getAllLayers().flatMap((layer) => layer.getAttributions(frameState))
        )
      );
      const collapsible = !this.getMap().getAllLayers().some(
        (layer) => layer.getSource() && layer.getSource().getAttributionsCollapsible() === false
      );
      if (!this.overrideCollapsible_) {
        this.setCollapsible(collapsible);
      }
      return visibleAttributions;
    }
    /**
     * @private
     * @param {?import("../Map.js").FrameState} frameState Frame state.
     */
    updateElement_(frameState) {
      if (!frameState) {
        if (this.renderedVisible_) {
          this.element.style.display = "none";
          this.renderedVisible_ = false;
        }
        return;
      }
      const attributions = this.collectSourceAttributions_(frameState);
      const visible = attributions.length > 0;
      if (this.renderedVisible_ != visible) {
        this.element.style.display = visible ? "" : "none";
        this.renderedVisible_ = visible;
      }
      if (equals(attributions, this.renderedAttributions_)) {
        return;
      }
      removeChildren(this.ulElement_);
      for (let i4 = 0, ii = attributions.length; i4 < ii; ++i4) {
        const element = document.createElement("li");
        element.innerHTML = attributions[i4];
        this.ulElement_.appendChild(element);
      }
      this.renderedAttributions_ = attributions;
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(event) {
      event.preventDefault();
      this.handleToggle_();
      this.userCollapsed_ = this.collapsed_;
    }
    /**
     * @private
     */
    handleToggle_() {
      this.element.classList.toggle(CLASS_COLLAPSED);
      if (this.collapsed_) {
        replaceNode(this.collapseLabel_, this.label_);
      } else {
        replaceNode(this.label_, this.collapseLabel_);
      }
      this.collapsed_ = !this.collapsed_;
      this.toggleButton_.setAttribute("aria-expanded", String(!this.collapsed_));
    }
    /**
     * Return `true` if the attribution is collapsible, `false` otherwise.
     * @return {boolean} True if the widget is collapsible.
     * @api
     */
    getCollapsible() {
      return this.collapsible_;
    }
    /**
     * Set whether the attribution should be collapsible.
     * @param {boolean} collapsible True if the widget is collapsible.
     * @api
     */
    setCollapsible(collapsible) {
      if (this.collapsible_ === collapsible) {
        return;
      }
      this.collapsible_ = collapsible;
      this.element.classList.toggle("ol-uncollapsible");
      if (this.userCollapsed_) {
        this.handleToggle_();
      }
    }
    /**
     * Collapse or expand the attribution according to the passed parameter. Will
     * not do anything if the attribution isn't collapsible or if the current
     * collapsed state is already the one requested.
     * @param {boolean} collapsed True if the widget is collapsed.
     * @api
     */
    setCollapsed(collapsed) {
      this.userCollapsed_ = collapsed;
      if (!this.collapsible_ || this.collapsed_ === collapsed) {
        return;
      }
      this.handleToggle_();
    }
    /**
     * Return `true` when the attribution is currently collapsed or `false`
     * otherwise.
     * @return {boolean} True if the widget is collapsed.
     * @api
     */
    getCollapsed() {
      return this.collapsed_;
    }
    /**
     * Update the attribution element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(mapEvent) {
      this.updateElement_(mapEvent.frameState);
    }
  };
  var Attribution_default = Attribution;

  // node_modules/ol/control/Rotate.js
  var Rotate = class extends Control_default {
    /**
     * @param {Options} [options] Rotate options.
     */
    constructor(options) {
      options = options ? options : {};
      super({
        element: document.createElement("div"),
        render: options.render,
        target: options.target
      });
      const className = options.className !== void 0 ? options.className : "ol-rotate";
      const label = options.label !== void 0 ? options.label : "\u21E7";
      const compassClassName = options.compassClassName !== void 0 ? options.compassClassName : "ol-compass";
      this.label_ = null;
      if (typeof label === "string") {
        this.label_ = document.createElement("span");
        this.label_.className = compassClassName;
        this.label_.textContent = label;
      } else {
        this.label_ = label;
        this.label_.classList.add(compassClassName);
      }
      const tipLabel = options.tipLabel ? options.tipLabel : "Reset rotation";
      const button = document.createElement("button");
      button.className = className + "-reset";
      button.setAttribute("type", "button");
      button.title = tipLabel;
      button.appendChild(this.label_);
      button.addEventListener(
        EventType_default.CLICK,
        this.handleClick_.bind(this),
        false
      );
      const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
      const element = this.element;
      element.className = cssClasses;
      element.appendChild(button);
      this.callResetNorth_ = options.resetNorth ? options.resetNorth : void 0;
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
      this.autoHide_ = options.autoHide !== void 0 ? options.autoHide : true;
      this.rotation_ = void 0;
      if (this.autoHide_) {
        this.element.classList.add(CLASS_HIDDEN);
      }
    }
    /**
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(event) {
      event.preventDefault();
      if (this.callResetNorth_ !== void 0) {
        this.callResetNorth_();
      } else {
        this.resetNorth_();
      }
    }
    /**
     * @private
     */
    resetNorth_() {
      const map2 = this.getMap();
      const view = map2.getView();
      if (!view) {
        return;
      }
      const rotation = view.getRotation();
      if (rotation !== void 0) {
        if (this.duration_ > 0 && rotation % (2 * Math.PI) !== 0) {
          view.animate({
            rotation: 0,
            duration: this.duration_,
            easing: easeOut
          });
        } else {
          view.setRotation(0);
        }
      }
    }
    /**
     * Update the rotate control element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(mapEvent) {
      const frameState = mapEvent.frameState;
      if (!frameState) {
        return;
      }
      const rotation = frameState.viewState.rotation;
      if (rotation != this.rotation_) {
        const transform2 = "rotate(" + rotation + "rad)";
        if (this.autoHide_) {
          const contains = this.element.classList.contains(CLASS_HIDDEN);
          if (!contains && rotation === 0) {
            this.element.classList.add(CLASS_HIDDEN);
          } else if (contains && rotation !== 0) {
            this.element.classList.remove(CLASS_HIDDEN);
          }
        }
        this.label_.style.transform = transform2;
      }
      this.rotation_ = rotation;
    }
  };
  var Rotate_default = Rotate;

  // node_modules/ol/control/Zoom.js
  var Zoom = class extends Control_default {
    /**
     * @param {Options} [options] Zoom options.
     */
    constructor(options) {
      options = options ? options : {};
      super({
        element: document.createElement("div"),
        target: options.target
      });
      const className = options.className !== void 0 ? options.className : "ol-zoom";
      const delta = options.delta !== void 0 ? options.delta : 1;
      const zoomInClassName = options.zoomInClassName !== void 0 ? options.zoomInClassName : className + "-in";
      const zoomOutClassName = options.zoomOutClassName !== void 0 ? options.zoomOutClassName : className + "-out";
      const zoomInLabel = options.zoomInLabel !== void 0 ? options.zoomInLabel : "+";
      const zoomOutLabel = options.zoomOutLabel !== void 0 ? options.zoomOutLabel : "\u2013";
      const zoomInTipLabel = options.zoomInTipLabel !== void 0 ? options.zoomInTipLabel : "Zoom in";
      const zoomOutTipLabel = options.zoomOutTipLabel !== void 0 ? options.zoomOutTipLabel : "Zoom out";
      const inElement = document.createElement("button");
      inElement.className = zoomInClassName;
      inElement.setAttribute("type", "button");
      inElement.title = zoomInTipLabel;
      inElement.appendChild(
        typeof zoomInLabel === "string" ? document.createTextNode(zoomInLabel) : zoomInLabel
      );
      inElement.addEventListener(
        EventType_default.CLICK,
        this.handleClick_.bind(this, delta),
        false
      );
      const outElement = document.createElement("button");
      outElement.className = zoomOutClassName;
      outElement.setAttribute("type", "button");
      outElement.title = zoomOutTipLabel;
      outElement.appendChild(
        typeof zoomOutLabel === "string" ? document.createTextNode(zoomOutLabel) : zoomOutLabel
      );
      outElement.addEventListener(
        EventType_default.CLICK,
        this.handleClick_.bind(this, -delta),
        false
      );
      const cssClasses = className + " " + CLASS_UNSELECTABLE + " " + CLASS_CONTROL;
      const element = this.element;
      element.className = cssClasses;
      element.appendChild(inElement);
      element.appendChild(outElement);
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
    }
    /**
     * @param {number} delta Zoom delta.
     * @param {MouseEvent} event The event to handle
     * @private
     */
    handleClick_(delta, event) {
      event.preventDefault();
      this.zoomByDelta_(delta);
    }
    /**
     * @param {number} delta Zoom delta.
     * @private
     */
    zoomByDelta_(delta) {
      const map2 = this.getMap();
      const view = map2.getView();
      if (!view) {
        return;
      }
      const currentZoom = view.getZoom();
      if (currentZoom !== void 0) {
        const newZoom = view.getConstrainedZoom(currentZoom + delta);
        if (this.duration_ > 0) {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }
          view.animate({
            zoom: newZoom,
            duration: this.duration_,
            easing: easeOut
          });
        } else {
          view.setZoom(newZoom);
        }
      }
    }
  };
  var Zoom_default = Zoom;

  // node_modules/ol/control/defaults.js
  function defaults(options) {
    options = options ? options : {};
    const controls = new Collection_default();
    const zoomControl = options.zoom !== void 0 ? options.zoom : true;
    if (zoomControl) {
      controls.push(new Zoom_default(options.zoomOptions));
    }
    const rotateControl = options.rotate !== void 0 ? options.rotate : true;
    if (rotateControl) {
      controls.push(new Rotate_default(options.rotateOptions));
    }
    const attributionControl = options.attribution !== void 0 ? options.attribution : true;
    if (attributionControl) {
      controls.push(new Attribution_default(options.attributionOptions));
    }
    return controls;
  }

  // node_modules/ol/interaction/Property.js
  var Property_default2 = {
    ACTIVE: "active"
  };

  // node_modules/ol/interaction/Interaction.js
  var Interaction = class extends Object_default {
    /**
     * @param {InteractionOptions} [options] Options.
     */
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      if (options && options.handleEvent) {
        this.handleEvent = options.handleEvent;
      }
      this.map_ = null;
      this.setActive(true);
    }
    /**
     * Return whether the interaction is currently active.
     * @return {boolean} `true` if the interaction is active, `false` otherwise.
     * @observable
     * @api
     */
    getActive() {
      return (
        /** @type {boolean} */
        this.get(Property_default2.ACTIVE)
      );
    }
    /**
     * Get the map associated with this interaction.
     * @return {import("../Map.js").default|null} Map.
     * @api
     */
    getMap() {
      return this.map_;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event}.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(mapBrowserEvent) {
      return true;
    }
    /**
     * Activate or deactivate the interaction.
     * @param {boolean} active Active.
     * @observable
     * @api
     */
    setActive(active) {
      this.set(Property_default2.ACTIVE, active);
    }
    /**
     * Remove the interaction from its current map and attach it to the new map.
     * Subclasses may set up event handlers to get notified about changes to
     * the map here.
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(map2) {
      this.map_ = map2;
    }
  };
  function pan(view, delta, duration) {
    const currentCenter = view.getCenterInternal();
    if (currentCenter) {
      const center = [currentCenter[0] + delta[0], currentCenter[1] + delta[1]];
      view.animateInternal({
        duration: duration !== void 0 ? duration : 250,
        easing: linear,
        center: view.getConstrainedCenter(center)
      });
    }
  }
  function zoomByDelta(view, delta, anchor, duration) {
    const currentZoom = view.getZoom();
    if (currentZoom === void 0) {
      return;
    }
    const newZoom = view.getConstrainedZoom(currentZoom + delta);
    const newResolution = view.getResolutionForZoom(newZoom);
    if (view.getAnimating()) {
      view.cancelAnimations();
    }
    view.animate({
      resolution: newResolution,
      anchor,
      duration: duration !== void 0 ? duration : 250,
      easing: easeOut
    });
  }
  var Interaction_default = Interaction;

  // node_modules/ol/interaction/DoubleClickZoom.js
  var DoubleClickZoom = class extends Interaction_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super();
      options = options ? options : {};
      this.delta_ = options.delta ? options.delta : 1;
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a
     * doubleclick) and eventually zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    handleEvent(mapBrowserEvent) {
      let stopEvent = false;
      if (mapBrowserEvent.type == MapBrowserEventType_default.DBLCLICK) {
        const browserEvent = (
          /** @type {MouseEvent} */
          mapBrowserEvent.originalEvent
        );
        const map2 = mapBrowserEvent.map;
        const anchor = mapBrowserEvent.coordinate;
        const delta = browserEvent.shiftKey ? -this.delta_ : this.delta_;
        const view = map2.getView();
        zoomByDelta(view, delta, anchor, this.duration_);
        browserEvent.preventDefault();
        stopEvent = true;
      }
      return !stopEvent;
    }
  };
  var DoubleClickZoom_default = DoubleClickZoom;

  // node_modules/ol/interaction/Pointer.js
  var PointerInteraction = class extends Interaction_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        options
      );
      if (options.handleDownEvent) {
        this.handleDownEvent = options.handleDownEvent;
      }
      if (options.handleDragEvent) {
        this.handleDragEvent = options.handleDragEvent;
      }
      if (options.handleMoveEvent) {
        this.handleMoveEvent = options.handleMoveEvent;
      }
      if (options.handleUpEvent) {
        this.handleUpEvent = options.handleUpEvent;
      }
      if (options.stopDown) {
        this.stopDown = options.stopDown;
      }
      this.handlingDownUpSequence = false;
      this.targetPointers = [];
    }
    /**
     * Returns the current number of pointers involved in the interaction,
     * e.g. `2` when two fingers are used.
     * @return {number} The number of pointers.
     * @api
     */
    getPointerCount() {
      return this.targetPointers.length;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleDownEvent(mapBrowserEvent) {
      return false;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleDragEvent(mapBrowserEvent) {
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} and may call into
     * other functions, if event sequences like e.g. 'drag' or 'down-up' etc. are
     * detected.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     * @api
     */
    handleEvent(mapBrowserEvent) {
      if (!mapBrowserEvent.originalEvent) {
        return true;
      }
      let stopEvent = false;
      this.updateTrackedPointers_(mapBrowserEvent);
      if (this.handlingDownUpSequence) {
        if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDRAG) {
          this.handleDragEvent(mapBrowserEvent);
          mapBrowserEvent.originalEvent.preventDefault();
        } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERUP) {
          const handledUp = this.handleUpEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handledUp && this.targetPointers.length > 0;
        }
      } else {
        if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERDOWN) {
          const handled = this.handleDownEvent(mapBrowserEvent);
          this.handlingDownUpSequence = handled;
          stopEvent = this.stopDown(handled);
        } else if (mapBrowserEvent.type == MapBrowserEventType_default.POINTERMOVE) {
          this.handleMoveEvent(mapBrowserEvent);
        }
      }
      return !stopEvent;
    }
    /**
     * Handle pointer move events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @protected
     */
    handleMoveEvent(mapBrowserEvent) {
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     * @protected
     */
    handleUpEvent(mapBrowserEvent) {
      return false;
    }
    /**
     * This function is used to determine if "down" events should be propagated
     * to other interactions or should be stopped.
     * @param {boolean} handled Was the event handled by the interaction?
     * @return {boolean} Should the `down` event be stopped?
     */
    stopDown(handled) {
      return handled;
    }
    /**
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @private
     */
    updateTrackedPointers_(mapBrowserEvent) {
      if (mapBrowserEvent.activePointers) {
        this.targetPointers = mapBrowserEvent.activePointers;
      }
    }
  };
  function centroid(pointerEvents) {
    const length = pointerEvents.length;
    let clientX = 0;
    let clientY = 0;
    for (let i4 = 0; i4 < length; i4++) {
      clientX += pointerEvents[i4].clientX;
      clientY += pointerEvents[i4].clientY;
    }
    return { clientX: clientX / length, clientY: clientY / length };
  }
  var Pointer_default = PointerInteraction;

  // node_modules/ol/events/condition.js
  function all2(var_args) {
    const conditions = arguments;
    return function(event) {
      let pass = true;
      for (let i4 = 0, ii = conditions.length; i4 < ii; ++i4) {
        pass = pass && conditions[i4](event);
        if (!pass) {
          break;
        }
      }
      return pass;
    };
  }
  var altShiftKeysOnly = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      mapBrowserEvent.originalEvent
    );
    return originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
  };
  var focus = function(event) {
    const targetElement = event.map.getTargetElement();
    const activeElement = event.map.getOwnerDocument().activeElement;
    return targetElement.contains(activeElement);
  };
  var focusWithTabindex = function(event) {
    return event.map.getTargetElement().hasAttribute("tabindex") ? focus(event) : true;
  };
  var always2 = TRUE;
  var mouseActionButton = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {MouseEvent} */
      mapBrowserEvent.originalEvent
    );
    return originalEvent.button == 0 && !(WEBKIT && MAC && originalEvent.ctrlKey);
  };
  var noModifierKeys = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      mapBrowserEvent.originalEvent
    );
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && !originalEvent.shiftKey;
  };
  var platformModifierKey = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      mapBrowserEvent.originalEvent
    );
    return MAC ? originalEvent.metaKey : originalEvent.ctrlKey;
  };
  var shiftKeyOnly = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      mapBrowserEvent.originalEvent
    );
    return !originalEvent.altKey && !(originalEvent.metaKey || originalEvent.ctrlKey) && originalEvent.shiftKey;
  };
  var targetNotEditable = function(mapBrowserEvent) {
    const originalEvent = (
      /** @type {KeyboardEvent|MouseEvent|TouchEvent} */
      mapBrowserEvent.originalEvent
    );
    const tagName = (
      /** @type {Element} */
      originalEvent.target.tagName
    );
    return tagName !== "INPUT" && tagName !== "SELECT" && tagName !== "TEXTAREA" && // `isContentEditable` is only available on `HTMLElement`, but it may also be a
    // different type like `SVGElement`.
    // @ts-ignore
    !originalEvent.target.isContentEditable;
  };
  var mouseOnly = function(mapBrowserEvent) {
    const pointerEvent = (
      /** @type {import("../MapBrowserEvent").default} */
      mapBrowserEvent.originalEvent
    );
    assert(
      pointerEvent !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    );
    return pointerEvent.pointerType == "mouse";
  };
  var primaryAction = function(mapBrowserEvent) {
    const pointerEvent = (
      /** @type {import("../MapBrowserEvent").default} */
      mapBrowserEvent.originalEvent
    );
    assert(
      pointerEvent !== void 0,
      "mapBrowserEvent must originate from a pointer event"
    );
    return pointerEvent.isPrimary && pointerEvent.button === 0;
  };

  // node_modules/ol/interaction/DragPan.js
  var DragPan = class extends Pointer_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super({
        stopDown: FALSE
      });
      options = options ? options : {};
      this.kinetic_ = options.kinetic;
      this.lastCentroid = null;
      this.lastPointersCount_;
      this.panning_ = false;
      const condition = options.condition ? options.condition : all2(noModifierKeys, primaryAction);
      this.condition_ = options.onFocusOnly ? all2(focusWithTabindex, condition) : condition;
      this.noKinetic_ = false;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent) {
      const map2 = mapBrowserEvent.map;
      if (!this.panning_) {
        this.panning_ = true;
        map2.getView().beginInteraction();
      }
      const targetPointers = this.targetPointers;
      const centroid2 = map2.getEventPixel(centroid(targetPointers));
      if (targetPointers.length == this.lastPointersCount_) {
        if (this.kinetic_) {
          this.kinetic_.update(centroid2[0], centroid2[1]);
        }
        if (this.lastCentroid) {
          const delta = [
            this.lastCentroid[0] - centroid2[0],
            centroid2[1] - this.lastCentroid[1]
          ];
          const map3 = mapBrowserEvent.map;
          const view = map3.getView();
          scale(delta, view.getResolution());
          rotate(delta, view.getRotation());
          view.adjustCenterInternal(delta);
        }
      } else if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.lastCentroid = centroid2;
      this.lastPointersCount_ = targetPointers.length;
      mapBrowserEvent.originalEvent.preventDefault();
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent) {
      const map2 = mapBrowserEvent.map;
      const view = map2.getView();
      if (this.targetPointers.length === 0) {
        if (!this.noKinetic_ && this.kinetic_ && this.kinetic_.end()) {
          const distance = this.kinetic_.getDistance();
          const angle = this.kinetic_.getAngle();
          const center = view.getCenterInternal();
          const centerpx = map2.getPixelFromCoordinateInternal(center);
          const dest = map2.getCoordinateFromPixelInternal([
            centerpx[0] - distance * Math.cos(angle),
            centerpx[1] - distance * Math.sin(angle)
          ]);
          view.animateInternal({
            center: view.getConstrainedCenter(dest),
            duration: 500,
            easing: easeOut
          });
        }
        if (this.panning_) {
          this.panning_ = false;
          view.endInteraction();
        }
        return false;
      }
      if (this.kinetic_) {
        this.kinetic_.begin();
      }
      this.lastCentroid = null;
      return true;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length > 0 && this.condition_(mapBrowserEvent)) {
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        this.lastCentroid = null;
        if (view.getAnimating()) {
          view.cancelAnimations();
        }
        if (this.kinetic_) {
          this.kinetic_.begin();
        }
        this.noKinetic_ = this.targetPointers.length > 1;
        return true;
      }
      return false;
    }
  };
  var DragPan_default = DragPan;

  // node_modules/ol/interaction/DragRotate.js
  var DragRotate = class extends Pointer_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      super({
        stopDown: FALSE
      });
      this.condition_ = options.condition ? options.condition : altShiftKeysOnly;
      this.lastAngle_ = void 0;
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return;
      }
      const map2 = mapBrowserEvent.map;
      const view = map2.getView();
      if (view.getConstraints().rotation === disable) {
        return;
      }
      const size = map2.getSize();
      const offset2 = mapBrowserEvent.pixel;
      const theta = Math.atan2(size[1] / 2 - offset2[1], offset2[0] - size[0] / 2);
      if (this.lastAngle_ !== void 0) {
        const delta = theta - this.lastAngle_;
        view.adjustRotationInternal(-delta);
      }
      this.lastAngle_ = theta;
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return true;
      }
      const map2 = mapBrowserEvent.map;
      const view = map2.getView();
      view.endInteraction(this.duration_);
      return false;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent) {
      if (!mouseOnly(mapBrowserEvent)) {
        return false;
      }
      if (mouseActionButton(mapBrowserEvent) && this.condition_(mapBrowserEvent)) {
        const map2 = mapBrowserEvent.map;
        map2.getView().beginInteraction();
        this.lastAngle_ = void 0;
        return true;
      }
      return false;
    }
  };
  var DragRotate_default = DragRotate;

  // node_modules/ol/render/Box.js
  var RenderBox = class extends Disposable_default {
    /**
     * @param {string} className CSS class name.
     */
    constructor(className) {
      super();
      this.geometry_ = null;
      this.element_ = document.createElement("div");
      this.element_.style.position = "absolute";
      this.element_.style.pointerEvents = "auto";
      this.element_.className = "ol-box " + className;
      this.map_ = null;
      this.startPixel_ = null;
      this.endPixel_ = null;
    }
    /**
     * Clean up.
     */
    disposeInternal() {
      this.setMap(null);
    }
    /**
     * @private
     */
    render_() {
      const startPixel = this.startPixel_;
      const endPixel = this.endPixel_;
      const px = "px";
      const style = this.element_.style;
      style.left = Math.min(startPixel[0], endPixel[0]) + px;
      style.top = Math.min(startPixel[1], endPixel[1]) + px;
      style.width = Math.abs(endPixel[0] - startPixel[0]) + px;
      style.height = Math.abs(endPixel[1] - startPixel[1]) + px;
    }
    /**
     * @param {import("../Map.js").default|null} map Map.
     */
    setMap(map2) {
      if (this.map_) {
        this.map_.getOverlayContainer().removeChild(this.element_);
        const style = this.element_.style;
        style.left = "inherit";
        style.top = "inherit";
        style.width = "inherit";
        style.height = "inherit";
      }
      this.map_ = map2;
      if (this.map_) {
        this.map_.getOverlayContainer().appendChild(this.element_);
      }
    }
    /**
     * @param {import("../pixel.js").Pixel} startPixel Start pixel.
     * @param {import("../pixel.js").Pixel} endPixel End pixel.
     */
    setPixels(startPixel, endPixel) {
      this.startPixel_ = startPixel;
      this.endPixel_ = endPixel;
      this.createOrUpdateGeometry();
      this.render_();
    }
    /**
     * Creates or updates the cached geometry.
     */
    createOrUpdateGeometry() {
      const startPixel = this.startPixel_;
      const endPixel = this.endPixel_;
      const pixels = [
        startPixel,
        [startPixel[0], endPixel[1]],
        endPixel,
        [endPixel[0], startPixel[1]]
      ];
      const coordinates2 = pixels.map(
        this.map_.getCoordinateFromPixelInternal,
        this.map_
      );
      coordinates2[4] = coordinates2[0].slice();
      if (!this.geometry_) {
        this.geometry_ = new Polygon_default([coordinates2]);
      } else {
        this.geometry_.setCoordinates([coordinates2]);
      }
    }
    /**
     * @return {import("../geom/Polygon.js").default} Geometry.
     */
    getGeometry() {
      return this.geometry_;
    }
  };
  var Box_default = RenderBox;

  // node_modules/ol/interaction/DragBox.js
  var DragBoxEventType = {
    /**
     * Triggered upon drag box start.
     * @event DragBoxEvent#boxstart
     * @api
     */
    BOXSTART: "boxstart",
    /**
     * Triggered on drag when box is active.
     * @event DragBoxEvent#boxdrag
     * @api
     */
    BOXDRAG: "boxdrag",
    /**
     * Triggered upon drag box end.
     * @event DragBoxEvent#boxend
     * @api
     */
    BOXEND: "boxend",
    /**
     * Triggered upon drag box canceled.
     * @event DragBoxEvent#boxcancel
     * @api
     */
    BOXCANCEL: "boxcancel"
  };
  var DragBoxEvent = class extends Event_default {
    /**
     * @param {string} type The event type.
     * @param {import("../coordinate.js").Coordinate} coordinate The event coordinate.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Originating event.
     */
    constructor(type, coordinate, mapBrowserEvent) {
      super(type);
      this.coordinate = coordinate;
      this.mapBrowserEvent = mapBrowserEvent;
    }
  };
  var DragBox = class extends Pointer_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super();
      this.on;
      this.once;
      this.un;
      options = options ? options : {};
      this.box_ = new Box_default(options.className || "ol-dragbox");
      this.minArea_ = options.minArea !== void 0 ? options.minArea : 64;
      if (options.onBoxEnd) {
        this.onBoxEnd = options.onBoxEnd;
      }
      this.startPixel_ = null;
      this.condition_ = options.condition ? options.condition : mouseActionButton;
      this.boxEndCondition_ = options.boxEndCondition ? options.boxEndCondition : this.defaultBoxEndCondition;
    }
    /**
     * The default condition for determining whether the boxend event
     * should fire.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent The originating MapBrowserEvent
     *     leading to the box end.
     * @param {import("../pixel.js").Pixel} startPixel The starting pixel of the box.
     * @param {import("../pixel.js").Pixel} endPixel The end pixel of the box.
     * @return {boolean} Whether or not the boxend condition should be fired.
     */
    defaultBoxEndCondition(mapBrowserEvent, startPixel, endPixel) {
      const width = endPixel[0] - startPixel[0];
      const height = endPixel[1] - startPixel[1];
      return width * width + height * height >= this.minArea_;
    }
    /**
     * Returns geometry of last drawn box.
     * @return {import("../geom/Polygon.js").default} Geometry.
     * @api
     */
    getGeometry() {
      return this.box_.getGeometry();
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent) {
      this.box_.setPixels(this.startPixel_, mapBrowserEvent.pixel);
      this.dispatchEvent(
        new DragBoxEvent(
          DragBoxEventType.BOXDRAG,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent) {
      this.box_.setMap(null);
      const completeBox = this.boxEndCondition_(
        mapBrowserEvent,
        this.startPixel_,
        mapBrowserEvent.pixel
      );
      if (completeBox) {
        this.onBoxEnd(mapBrowserEvent);
      }
      this.dispatchEvent(
        new DragBoxEvent(
          completeBox ? DragBoxEventType.BOXEND : DragBoxEventType.BOXCANCEL,
          mapBrowserEvent.coordinate,
          mapBrowserEvent
        )
      );
      return false;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent) {
      if (this.condition_(mapBrowserEvent)) {
        this.startPixel_ = mapBrowserEvent.pixel;
        this.box_.setMap(mapBrowserEvent.map);
        this.box_.setPixels(this.startPixel_, this.startPixel_);
        this.dispatchEvent(
          new DragBoxEvent(
            DragBoxEventType.BOXSTART,
            mapBrowserEvent.coordinate,
            mapBrowserEvent
          )
        );
        return true;
      }
      return false;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(event) {
    }
  };
  var DragBox_default = DragBox;

  // node_modules/ol/interaction/DragZoom.js
  var DragZoom = class extends DragBox_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      const condition = options.condition ? options.condition : shiftKeyOnly;
      super({
        condition,
        className: options.className || "ol-dragzoom",
        minArea: options.minArea
      });
      this.duration_ = options.duration !== void 0 ? options.duration : 200;
      this.out_ = options.out !== void 0 ? options.out : false;
    }
    /**
     * Function to execute just before `onboxend` is fired
     * @param {import("../MapBrowserEvent.js").default} event Event.
     */
    onBoxEnd(event) {
      const map2 = this.getMap();
      const view = (
        /** @type {!import("../View.js").default} */
        map2.getView()
      );
      let geometry = this.getGeometry();
      if (this.out_) {
        const rotatedExtent = view.rotatedExtentForGeometry(geometry);
        const resolution = view.getResolutionForExtentInternal(rotatedExtent);
        const factor = view.getResolution() / resolution;
        geometry = geometry.clone();
        geometry.scale(factor * factor);
      }
      view.fitInternal(geometry, {
        duration: this.duration_,
        easing: easeOut
      });
    }
  };
  var DragZoom_default = DragZoom;

  // node_modules/ol/events/Key.js
  var Key_default = {
    LEFT: "ArrowLeft",
    UP: "ArrowUp",
    RIGHT: "ArrowRight",
    DOWN: "ArrowDown"
  };

  // node_modules/ol/interaction/KeyboardPan.js
  var KeyboardPan = class extends Interaction_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super();
      options = options || {};
      this.defaultCondition_ = function(mapBrowserEvent) {
        return noModifierKeys(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
      };
      this.condition_ = options.condition !== void 0 ? options.condition : this.defaultCondition_;
      this.duration_ = options.duration !== void 0 ? options.duration : 100;
      this.pixelDelta_ = options.pixelDelta !== void 0 ? options.pixelDelta : 128;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides the direction to pan to (if an arrow key was
     * pressed).
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    handleEvent(mapBrowserEvent) {
      let stopEvent = false;
      if (mapBrowserEvent.type == EventType_default.KEYDOWN) {
        const keyEvent = (
          /** @type {KeyboardEvent} */
          mapBrowserEvent.originalEvent
        );
        const key = keyEvent.key;
        if (this.condition_(mapBrowserEvent) && (key == Key_default.DOWN || key == Key_default.LEFT || key == Key_default.RIGHT || key == Key_default.UP)) {
          const map2 = mapBrowserEvent.map;
          const view = map2.getView();
          const mapUnitsDelta = view.getResolution() * this.pixelDelta_;
          let deltaX = 0, deltaY = 0;
          if (key == Key_default.DOWN) {
            deltaY = -mapUnitsDelta;
          } else if (key == Key_default.LEFT) {
            deltaX = -mapUnitsDelta;
          } else if (key == Key_default.RIGHT) {
            deltaX = mapUnitsDelta;
          } else {
            deltaY = mapUnitsDelta;
          }
          const delta = [deltaX, deltaY];
          rotate(delta, view.getRotation());
          pan(view, delta, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }
  };
  var KeyboardPan_default = KeyboardPan;

  // node_modules/ol/interaction/KeyboardZoom.js
  var KeyboardZoom = class extends Interaction_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      super();
      options = options ? options : {};
      this.condition_ = options.condition ? options.condition : function(mapBrowserEvent) {
        return !platformModifierKey(mapBrowserEvent) && targetNotEditable(mapBrowserEvent);
      };
      this.delta_ = options.delta ? options.delta : 1;
      this.duration_ = options.duration !== void 0 ? options.duration : 100;
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} if it was a
     * `KeyEvent`, and decides whether to zoom in or out (depending on whether the
     * key pressed was '+' or '-').
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    handleEvent(mapBrowserEvent) {
      let stopEvent = false;
      if (mapBrowserEvent.type == EventType_default.KEYDOWN || mapBrowserEvent.type == EventType_default.KEYPRESS) {
        const keyEvent = (
          /** @type {KeyboardEvent} */
          mapBrowserEvent.originalEvent
        );
        const key = keyEvent.key;
        if (this.condition_(mapBrowserEvent) && (key === "+" || key === "-")) {
          const map2 = mapBrowserEvent.map;
          const delta = key === "+" ? this.delta_ : -this.delta_;
          const view = map2.getView();
          zoomByDelta(view, delta, void 0, this.duration_);
          keyEvent.preventDefault();
          stopEvent = true;
        }
      }
      return !stopEvent;
    }
  };
  var KeyboardZoom_default = KeyboardZoom;

  // node_modules/ol/interaction/MouseWheelZoom.js
  var MouseWheelZoom = class extends Interaction_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      super(
        /** @type {import("./Interaction.js").InteractionOptions} */
        options
      );
      this.totalDelta_ = 0;
      this.lastDelta_ = 0;
      this.maxDelta_ = options.maxDelta !== void 0 ? options.maxDelta : 1;
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
      this.timeout_ = options.timeout !== void 0 ? options.timeout : 80;
      this.useAnchor_ = options.useAnchor !== void 0 ? options.useAnchor : true;
      this.constrainResolution_ = options.constrainResolution !== void 0 ? options.constrainResolution : false;
      const condition = options.condition ? options.condition : always2;
      this.condition_ = options.onFocusOnly ? all2(focusWithTabindex, condition) : condition;
      this.lastAnchor_ = null;
      this.startTime_ = void 0;
      this.timeoutId_;
      this.mode_ = void 0;
      this.trackpadEventGap_ = 400;
      this.trackpadTimeoutId_;
      this.deltaPerZoom_ = 300;
    }
    /**
     * @private
     */
    endInteraction_() {
      this.trackpadTimeoutId_ = void 0;
      const map2 = this.getMap();
      if (!map2) {
        return;
      }
      const view = map2.getView();
      view.endInteraction(
        void 0,
        this.lastDelta_ ? this.lastDelta_ > 0 ? 1 : -1 : 0,
        this.lastAnchor_
      );
    }
    /**
     * Handles the {@link module:ol/MapBrowserEvent~MapBrowserEvent map browser event} (if it was a mousewheel-event) and eventually
     * zooms the map.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Map browser event.
     * @return {boolean} `false` to stop event propagation.
     */
    handleEvent(mapBrowserEvent) {
      if (!this.condition_(mapBrowserEvent)) {
        return true;
      }
      const type = mapBrowserEvent.type;
      if (type !== EventType_default.WHEEL) {
        return true;
      }
      const map2 = mapBrowserEvent.map;
      const wheelEvent = (
        /** @type {WheelEvent} */
        mapBrowserEvent.originalEvent
      );
      wheelEvent.preventDefault();
      if (this.useAnchor_) {
        this.lastAnchor_ = mapBrowserEvent.coordinate;
      }
      let delta;
      if (mapBrowserEvent.type == EventType_default.WHEEL) {
        delta = wheelEvent.deltaY;
        if (FIREFOX && wheelEvent.deltaMode === WheelEvent.DOM_DELTA_PIXEL) {
          delta /= DEVICE_PIXEL_RATIO;
        }
        if (wheelEvent.deltaMode === WheelEvent.DOM_DELTA_LINE) {
          delta *= 40;
        }
      }
      if (delta === 0) {
        return false;
      }
      this.lastDelta_ = delta;
      const now = Date.now();
      if (this.startTime_ === void 0) {
        this.startTime_ = now;
      }
      if (!this.mode_ || now - this.startTime_ > this.trackpadEventGap_) {
        this.mode_ = Math.abs(delta) < 4 ? "trackpad" : "wheel";
      }
      const view = map2.getView();
      if (this.mode_ === "trackpad" && !(view.getConstrainResolution() || this.constrainResolution_)) {
        if (this.trackpadTimeoutId_) {
          clearTimeout(this.trackpadTimeoutId_);
        } else {
          if (view.getAnimating()) {
            view.cancelAnimations();
          }
          view.beginInteraction();
        }
        this.trackpadTimeoutId_ = setTimeout(
          this.endInteraction_.bind(this),
          this.timeout_
        );
        view.adjustZoom(-delta / this.deltaPerZoom_, this.lastAnchor_);
        this.startTime_ = now;
        return false;
      }
      this.totalDelta_ += delta;
      const timeLeft = Math.max(this.timeout_ - (now - this.startTime_), 0);
      clearTimeout(this.timeoutId_);
      this.timeoutId_ = setTimeout(
        this.handleWheelZoom_.bind(this, map2),
        timeLeft
      );
      return false;
    }
    /**
     * @private
     * @param {import("../Map.js").default} map Map.
     */
    handleWheelZoom_(map2) {
      const view = map2.getView();
      if (view.getAnimating()) {
        view.cancelAnimations();
      }
      let delta = -clamp(
        this.totalDelta_,
        -this.maxDelta_ * this.deltaPerZoom_,
        this.maxDelta_ * this.deltaPerZoom_
      ) / this.deltaPerZoom_;
      if (view.getConstrainResolution() || this.constrainResolution_) {
        delta = delta ? delta > 0 ? 1 : -1 : 0;
      }
      zoomByDelta(view, delta, this.lastAnchor_, this.duration_);
      this.mode_ = void 0;
      this.totalDelta_ = 0;
      this.lastAnchor_ = null;
      this.startTime_ = void 0;
      this.timeoutId_ = void 0;
    }
    /**
     * Enable or disable using the mouse's location as an anchor when zooming
     * @param {boolean} useAnchor true to zoom to the mouse's location, false
     * to zoom to the center of the map
     * @api
     */
    setMouseAnchor(useAnchor) {
      this.useAnchor_ = useAnchor;
      if (!useAnchor) {
        this.lastAnchor_ = null;
      }
    }
  };
  var MouseWheelZoom_default = MouseWheelZoom;

  // node_modules/ol/interaction/PinchRotate.js
  var PinchRotate = class extends Pointer_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      const pointerOptions = (
        /** @type {import("./Pointer.js").Options} */
        options
      );
      if (!pointerOptions.stopDown) {
        pointerOptions.stopDown = FALSE;
      }
      super(pointerOptions);
      this.anchor_ = null;
      this.lastAngle_ = void 0;
      this.rotating_ = false;
      this.rotationDelta_ = 0;
      this.threshold_ = options.threshold !== void 0 ? options.threshold : 0.3;
      this.duration_ = options.duration !== void 0 ? options.duration : 250;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent) {
      let rotationDelta = 0;
      const touch0 = this.targetPointers[0];
      const touch1 = this.targetPointers[1];
      const angle = Math.atan2(
        touch1.clientY - touch0.clientY,
        touch1.clientX - touch0.clientX
      );
      if (this.lastAngle_ !== void 0) {
        const delta = angle - this.lastAngle_;
        this.rotationDelta_ += delta;
        if (!this.rotating_ && Math.abs(this.rotationDelta_) > this.threshold_) {
          this.rotating_ = true;
        }
        rotationDelta = delta;
      }
      this.lastAngle_ = angle;
      const map2 = mapBrowserEvent.map;
      const view = map2.getView();
      if (view.getConstraints().rotation === disable) {
        return;
      }
      this.anchor_ = map2.getCoordinateFromPixelInternal(
        map2.getEventPixel(centroid(this.targetPointers))
      );
      if (this.rotating_) {
        map2.render();
        view.adjustRotationInternal(rotationDelta, this.anchor_);
      }
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        view.endInteraction(this.duration_);
        return false;
      }
      return true;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        const map2 = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastAngle_ = void 0;
        this.rotating_ = false;
        this.rotationDelta_ = 0;
        if (!this.handlingDownUpSequence) {
          map2.getView().beginInteraction();
        }
        return true;
      }
      return false;
    }
  };
  var PinchRotate_default = PinchRotate;

  // node_modules/ol/interaction/PinchZoom.js
  var PinchZoom = class extends Pointer_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      const pointerOptions = (
        /** @type {import("./Pointer.js").Options} */
        options
      );
      if (!pointerOptions.stopDown) {
        pointerOptions.stopDown = FALSE;
      }
      super(pointerOptions);
      this.anchor_ = null;
      this.duration_ = options.duration !== void 0 ? options.duration : 400;
      this.lastDistance_ = void 0;
      this.lastScaleDelta_ = 1;
    }
    /**
     * Handle pointer drag events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     */
    handleDragEvent(mapBrowserEvent) {
      let scaleDelta = 1;
      const touch0 = this.targetPointers[0];
      const touch1 = this.targetPointers[1];
      const dx = touch0.clientX - touch1.clientX;
      const dy = touch0.clientY - touch1.clientY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      if (this.lastDistance_ !== void 0) {
        scaleDelta = this.lastDistance_ / distance;
      }
      this.lastDistance_ = distance;
      const map2 = mapBrowserEvent.map;
      const view = map2.getView();
      if (scaleDelta != 1) {
        this.lastScaleDelta_ = scaleDelta;
      }
      this.anchor_ = map2.getCoordinateFromPixelInternal(
        map2.getEventPixel(centroid(this.targetPointers))
      );
      map2.render();
      view.adjustResolutionInternal(scaleDelta, this.anchor_);
    }
    /**
     * Handle pointer up events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleUpEvent(mapBrowserEvent) {
      if (this.targetPointers.length < 2) {
        const map2 = mapBrowserEvent.map;
        const view = map2.getView();
        const direction = this.lastScaleDelta_ > 1 ? 1 : -1;
        view.endInteraction(this.duration_, direction);
        return false;
      }
      return true;
    }
    /**
     * Handle pointer down events.
     * @param {import("../MapBrowserEvent.js").default} mapBrowserEvent Event.
     * @return {boolean} If the event was consumed.
     */
    handleDownEvent(mapBrowserEvent) {
      if (this.targetPointers.length >= 2) {
        const map2 = mapBrowserEvent.map;
        this.anchor_ = null;
        this.lastDistance_ = void 0;
        this.lastScaleDelta_ = 1;
        if (!this.handlingDownUpSequence) {
          map2.getView().beginInteraction();
        }
        return true;
      }
      return false;
    }
  };
  var PinchZoom_default = PinchZoom;

  // node_modules/ol/interaction/defaults.js
  function defaults2(options) {
    options = options ? options : {};
    const interactions = new Collection_default();
    const kinetic = new Kinetic_default(-5e-3, 0.05, 100);
    const altShiftDragRotate = options.altShiftDragRotate !== void 0 ? options.altShiftDragRotate : true;
    if (altShiftDragRotate) {
      interactions.push(new DragRotate_default());
    }
    const doubleClickZoom = options.doubleClickZoom !== void 0 ? options.doubleClickZoom : true;
    if (doubleClickZoom) {
      interactions.push(
        new DoubleClickZoom_default({
          delta: options.zoomDelta,
          duration: options.zoomDuration
        })
      );
    }
    const dragPan = options.dragPan !== void 0 ? options.dragPan : true;
    if (dragPan) {
      interactions.push(
        new DragPan_default({
          onFocusOnly: options.onFocusOnly,
          kinetic
        })
      );
    }
    const pinchRotate = options.pinchRotate !== void 0 ? options.pinchRotate : true;
    if (pinchRotate) {
      interactions.push(new PinchRotate_default());
    }
    const pinchZoom = options.pinchZoom !== void 0 ? options.pinchZoom : true;
    if (pinchZoom) {
      interactions.push(
        new PinchZoom_default({
          duration: options.zoomDuration
        })
      );
    }
    const keyboard = options.keyboard !== void 0 ? options.keyboard : true;
    if (keyboard) {
      interactions.push(new KeyboardPan_default());
      interactions.push(
        new KeyboardZoom_default({
          delta: options.zoomDelta,
          duration: options.zoomDuration
        })
      );
    }
    const mouseWheelZoom = options.mouseWheelZoom !== void 0 ? options.mouseWheelZoom : true;
    if (mouseWheelZoom) {
      interactions.push(
        new MouseWheelZoom_default({
          onFocusOnly: options.onFocusOnly,
          duration: options.zoomDuration
        })
      );
    }
    const shiftDragZoom = options.shiftDragZoom !== void 0 ? options.shiftDragZoom : true;
    if (shiftDragZoom) {
      interactions.push(
        new DragZoom_default({
          duration: options.zoomDuration
        })
      );
    }
    return interactions;
  }

  // node_modules/ol/Map.js
  function removeLayerMapProperty(layer) {
    if (layer instanceof Layer_default) {
      layer.setMapInternal(null);
      return;
    }
    if (layer instanceof Group_default) {
      layer.getLayers().forEach(removeLayerMapProperty);
    }
  }
  function setLayerMapProperty(layer, map2) {
    if (layer instanceof Layer_default) {
      layer.setMapInternal(map2);
      return;
    }
    if (layer instanceof Group_default) {
      const layers = layer.getLayers().getArray();
      for (let i4 = 0, ii = layers.length; i4 < ii; ++i4) {
        setLayerMapProperty(layers[i4], map2);
      }
    }
  }
  var Map2 = class extends Object_default {
    /**
     * @param {MapOptions} [options] Map options.
     */
    constructor(options) {
      super();
      options = options || {};
      this.on;
      this.once;
      this.un;
      const optionsInternal = createOptionsInternal(options);
      this.renderComplete_;
      this.loaded_ = true;
      this.boundHandleBrowserEvent_ = this.handleBrowserEvent.bind(this);
      this.maxTilesLoading_ = options.maxTilesLoading !== void 0 ? options.maxTilesLoading : 16;
      this.pixelRatio_ = options.pixelRatio !== void 0 ? options.pixelRatio : DEVICE_PIXEL_RATIO;
      this.postRenderTimeoutHandle_;
      this.animationDelayKey_;
      this.animationDelay_ = this.animationDelay_.bind(this);
      this.coordinateToPixelTransform_ = create();
      this.pixelToCoordinateTransform_ = create();
      this.frameIndex_ = 0;
      this.frameState_ = null;
      this.previousExtent_ = null;
      this.viewPropertyListenerKey_ = null;
      this.viewChangeListenerKey_ = null;
      this.layerGroupPropertyListenerKeys_ = null;
      this.viewport_ = document.createElement("div");
      this.viewport_.className = "ol-viewport" + ("ontouchstart" in window ? " ol-touch" : "");
      this.viewport_.style.position = "relative";
      this.viewport_.style.overflow = "hidden";
      this.viewport_.style.width = "100%";
      this.viewport_.style.height = "100%";
      this.overlayContainer_ = document.createElement("div");
      this.overlayContainer_.style.position = "absolute";
      this.overlayContainer_.style.zIndex = "0";
      this.overlayContainer_.style.width = "100%";
      this.overlayContainer_.style.height = "100%";
      this.overlayContainer_.style.pointerEvents = "none";
      this.overlayContainer_.className = "ol-overlaycontainer";
      this.viewport_.appendChild(this.overlayContainer_);
      this.overlayContainerStopEvent_ = document.createElement("div");
      this.overlayContainerStopEvent_.style.position = "absolute";
      this.overlayContainerStopEvent_.style.zIndex = "0";
      this.overlayContainerStopEvent_.style.width = "100%";
      this.overlayContainerStopEvent_.style.height = "100%";
      this.overlayContainerStopEvent_.style.pointerEvents = "none";
      this.overlayContainerStopEvent_.className = "ol-overlaycontainer-stopevent";
      this.viewport_.appendChild(this.overlayContainerStopEvent_);
      this.mapBrowserEventHandler_ = null;
      this.moveTolerance_ = options.moveTolerance;
      this.keyboardEventTarget_ = optionsInternal.keyboardEventTarget;
      this.targetChangeHandlerKeys_ = null;
      this.targetElement_ = null;
      this.resizeObserver_ = new ResizeObserver(() => this.updateSize());
      this.controls = optionsInternal.controls || defaults();
      this.interactions = optionsInternal.interactions || defaults2({
        onFocusOnly: true
      });
      this.overlays_ = optionsInternal.overlays;
      this.overlayIdIndex_ = {};
      this.renderer_ = null;
      this.postRenderFunctions_ = [];
      this.tileQueue_ = new TileQueue_default(
        this.getTilePriority.bind(this),
        this.handleTileChange_.bind(this)
      );
      this.addChangeListener(
        MapProperty_default.LAYERGROUP,
        this.handleLayerGroupChanged_
      );
      this.addChangeListener(MapProperty_default.VIEW, this.handleViewChanged_);
      this.addChangeListener(MapProperty_default.SIZE, this.handleSizeChanged_);
      this.addChangeListener(MapProperty_default.TARGET, this.handleTargetChanged_);
      this.setProperties(optionsInternal.values);
      const map2 = this;
      if (options.view && !(options.view instanceof View_default)) {
        options.view.then(function(viewOptions) {
          map2.setView(new View_default(viewOptions));
        });
      }
      this.controls.addEventListener(
        CollectionEventType_default.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent
         */
        (event) => {
          event.element.setMap(this);
        }
      );
      this.controls.addEventListener(
        CollectionEventType_default.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./control/Control.js").default>} event CollectionEvent.
         */
        (event) => {
          event.element.setMap(null);
        }
      );
      this.interactions.addEventListener(
        CollectionEventType_default.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (event) => {
          event.element.setMap(this);
        }
      );
      this.interactions.addEventListener(
        CollectionEventType_default.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./interaction/Interaction.js").default>} event CollectionEvent.
         */
        (event) => {
          event.element.setMap(null);
        }
      );
      this.overlays_.addEventListener(
        CollectionEventType_default.ADD,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (event) => {
          this.addOverlayInternal_(event.element);
        }
      );
      this.overlays_.addEventListener(
        CollectionEventType_default.REMOVE,
        /**
         * @param {import("./Collection.js").CollectionEvent<import("./Overlay.js").default>} event CollectionEvent.
         */
        (event) => {
          const id = event.element.getId();
          if (id !== void 0) {
            delete this.overlayIdIndex_[id.toString()];
          }
          event.element.setMap(null);
        }
      );
      this.controls.forEach(
        /**
         * @param {import("./control/Control.js").default} control Control.
         */
        (control) => {
          control.setMap(this);
        }
      );
      this.interactions.forEach(
        /**
         * @param {import("./interaction/Interaction.js").default} interaction Interaction.
         */
        (interaction) => {
          interaction.setMap(this);
        }
      );
      this.overlays_.forEach(this.addOverlayInternal_.bind(this));
    }
    /**
     * Add the given control to the map.
     * @param {import("./control/Control.js").default} control Control.
     * @api
     */
    addControl(control) {
      this.getControls().push(control);
    }
    /**
     * Add the given interaction to the map. If you want to add an interaction
     * at another point of the collection use `getInteractions()` and the methods
     * available on {@link module:ol/Collection~Collection}. This can be used to
     * stop the event propagation from the handleEvent function. The interactions
     * get to handle the events in the reverse order of this collection.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to add.
     * @api
     */
    addInteraction(interaction) {
      this.getInteractions().push(interaction);
    }
    /**
     * Adds the given layer to the top of this map. If you want to add a layer
     * elsewhere in the stack, use `getLayers()` and the methods available on
     * {@link module:ol/Collection~Collection}.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @api
     */
    addLayer(layer) {
      const layers = this.getLayerGroup().getLayers();
      layers.push(layer);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer add event.
     * @private
     */
    handleLayerAdd_(event) {
      setLayerMapProperty(event.layer, this);
    }
    /**
     * Add the given overlay to the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @api
     */
    addOverlay(overlay) {
      this.getOverlays().push(overlay);
    }
    /**
     * This deals with map's overlay collection changes.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @private
     */
    addOverlayInternal_(overlay) {
      const id = overlay.getId();
      if (id !== void 0) {
        this.overlayIdIndex_[id.toString()] = overlay;
      }
      overlay.setMap(this);
    }
    /**
     *
     * Clean up.
     */
    disposeInternal() {
      this.controls.clear();
      this.interactions.clear();
      this.overlays_.clear();
      this.resizeObserver_.disconnect();
      this.setTarget(null);
      super.disposeInternal();
    }
    /**
     * Detect features that intersect a pixel on the viewport, and execute a
     * callback with each intersecting feature. Layers included in the detection can
     * be configured through the `layerFilter` option in `options`.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {function(import("./Feature.js").FeatureLike, import("./layer/Layer.js").default<import("./source/Source").default>, import("./geom/SimpleGeometry.js").default): T} callback Feature callback. The callback will be
     *     called with two arguments. The first argument is one
     *     {@link module:ol/Feature~Feature feature} or
     *     {@link module:ol/render/Feature~RenderFeature render feature} at the pixel, the second is
     *     the {@link module:ol/layer/Layer~Layer layer} of the feature and will be null for
     *     unmanaged layers. To stop detection, callback functions can return a
     *     truthy value.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {T|undefined} Callback result, i.e. the return value of last
     * callback execution, or the first truthy callback return value.
     * @template T
     * @api
     */
    forEachFeatureAtPixel(pixel, callback, options) {
      if (!this.frameState_ || !this.renderer_) {
        return;
      }
      const coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== void 0 ? options : {};
      const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
      const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
      const checkWrapped = options.checkWrapped !== false;
      return this.renderer_.forEachFeatureAtCoordinate(
        coordinate,
        this.frameState_,
        hitTolerance,
        checkWrapped,
        callback,
        null,
        layerFilter,
        null
      );
    }
    /**
     * Get all features that intersect a pixel on the viewport.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {Array<import("./Feature.js").FeatureLike>} The detected features or
     * an empty array if none were found.
     * @api
     */
    getFeaturesAtPixel(pixel, options) {
      const features = [];
      this.forEachFeatureAtPixel(
        pixel,
        function(feature) {
          features.push(feature);
        },
        options
      );
      return features;
    }
    /**
     * Get all layers from all layer groups.
     * @return {Array<import("./layer/Layer.js").default>} Layers.
     * @api
     */
    getAllLayers() {
      const layers = [];
      function addLayersFrom(layerGroup) {
        layerGroup.forEach(function(layer) {
          if (layer instanceof Group_default) {
            addLayersFrom(layer.getLayers());
          } else {
            layers.push(layer);
          }
        });
      }
      addLayersFrom(this.getLayers());
      return layers;
    }
    /**
     * Detect if features intersect a pixel on the viewport. Layers included in the
     * detection can be configured through the `layerFilter` option.
     * @param {import("./pixel.js").Pixel} pixel Pixel.
     * @param {AtPixelOptions} [options] Optional options.
     * @return {boolean} Is there a feature at the given pixel?
     * @api
     */
    hasFeatureAtPixel(pixel, options) {
      if (!this.frameState_ || !this.renderer_) {
        return false;
      }
      const coordinate = this.getCoordinateFromPixelInternal(pixel);
      options = options !== void 0 ? options : {};
      const layerFilter = options.layerFilter !== void 0 ? options.layerFilter : TRUE;
      const hitTolerance = options.hitTolerance !== void 0 ? options.hitTolerance : 0;
      const checkWrapped = options.checkWrapped !== false;
      return this.renderer_.hasFeatureAtCoordinate(
        coordinate,
        this.frameState_,
        hitTolerance,
        checkWrapped,
        layerFilter,
        null
      );
    }
    /**
     * Returns the coordinate in user projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     * @api
     */
    getEventCoordinate(event) {
      return this.getCoordinateFromPixel(this.getEventPixel(event));
    }
    /**
     * Returns the coordinate in view projection for a browser event.
     * @param {MouseEvent} event Event.
     * @return {import("./coordinate.js").Coordinate} Coordinate.
     */
    getEventCoordinateInternal(event) {
      return this.getCoordinateFromPixelInternal(this.getEventPixel(event));
    }
    /**
     * Returns the map pixel position for a browser event relative to the viewport.
     * @param {UIEvent|{clientX: number, clientY: number}} event Event.
     * @return {import("./pixel.js").Pixel} Pixel.
     * @api
     */
    getEventPixel(event) {
      const viewport = this.viewport_;
      const viewportPosition = viewport.getBoundingClientRect();
      const viewportSize = this.getSize();
      const scaleX = viewportPosition.width / viewportSize[0];
      const scaleY = viewportPosition.height / viewportSize[1];
      const eventPosition = (
        //FIXME Are we really calling this with a TouchEvent anywhere?
        "changedTouches" in event ? (
          /** @type {TouchEvent} */
          event.changedTouches[0]
        ) : (
          /** @type {MouseEvent} */
          event
        )
      );
      return [
        (eventPosition.clientX - viewportPosition.left) / scaleX,
        (eventPosition.clientY - viewportPosition.top) / scaleY
      ];
    }
    /**
     * Get the target in which this map is rendered.
     * Note that this returns what is entered as an option or in setTarget:
     * if that was an element, it returns an element; if a string, it returns that.
     * @return {HTMLElement|string|undefined} The Element or id of the Element that the
     *     map is rendered in.
     * @observable
     * @api
     */
    getTarget() {
      return (
        /** @type {HTMLElement|string|undefined} */
        this.get(MapProperty_default.TARGET)
      );
    }
    /**
     * Get the DOM element into which this map is rendered. In contrast to
     * `getTarget` this method always return an `Element`, or `null` if the
     * map has no target.
     * @return {HTMLElement} The element that the map is rendered in.
     * @api
     */
    getTargetElement() {
      return this.targetElement_;
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * user projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     * @api
     */
    getCoordinateFromPixel(pixel) {
      return toUserCoordinate(
        this.getCoordinateFromPixelInternal(pixel),
        this.getView().getProjection()
      );
    }
    /**
     * Get the coordinate for a given pixel.  This returns a coordinate in the
     * map view projection.
     * @param {import("./pixel.js").Pixel} pixel Pixel position in the map viewport.
     * @return {import("./coordinate.js").Coordinate} The coordinate for the pixel position.
     */
    getCoordinateFromPixelInternal(pixel) {
      const frameState = this.frameState_;
      if (!frameState) {
        return null;
      }
      return apply(frameState.pixelToCoordinateTransform, pixel.slice());
    }
    /**
     * Get the map controls. Modifying this collection changes the controls
     * associated with the map.
     * @return {Collection<import("./control/Control.js").default>} Controls.
     * @api
     */
    getControls() {
      return this.controls;
    }
    /**
     * Get the map overlays. Modifying this collection changes the overlays
     * associated with the map.
     * @return {Collection<import("./Overlay.js").default>} Overlays.
     * @api
     */
    getOverlays() {
      return this.overlays_;
    }
    /**
     * Get an overlay by its identifier (the value returned by overlay.getId()).
     * Note that the index treats string and numeric identifiers as the same. So
     * `map.getOverlayById(2)` will return an overlay with id `'2'` or `2`.
     * @param {string|number} id Overlay identifier.
     * @return {import("./Overlay.js").default} Overlay.
     * @api
     */
    getOverlayById(id) {
      const overlay = this.overlayIdIndex_[id.toString()];
      return overlay !== void 0 ? overlay : null;
    }
    /**
     * Get the map interactions. Modifying this collection changes the interactions
     * associated with the map.
     *
     * Interactions are used for e.g. pan, zoom and rotate.
     * @return {Collection<import("./interaction/Interaction.js").default>} Interactions.
     * @api
     */
    getInteractions() {
      return this.interactions;
    }
    /**
     * Get the layergroup associated with this map.
     * @return {LayerGroup} A layer group containing the layers in this map.
     * @observable
     * @api
     */
    getLayerGroup() {
      return (
        /** @type {LayerGroup} */
        this.get(MapProperty_default.LAYERGROUP)
      );
    }
    /**
     * Clear any existing layers and add layers to the map.
     * @param {Array<import("./layer/Base.js").default>|Collection<import("./layer/Base.js").default>} layers The layers to be added to the map.
     * @api
     */
    setLayers(layers) {
      const group = this.getLayerGroup();
      if (layers instanceof Collection_default) {
        group.setLayers(layers);
        return;
      }
      const collection = group.getLayers();
      collection.clear();
      collection.extend(layers);
    }
    /**
     * Get the collection of layers associated with this map.
     * @return {!Collection<import("./layer/Base.js").default>} Layers.
     * @api
     */
    getLayers() {
      const layers = this.getLayerGroup().getLayers();
      return layers;
    }
    /**
     * @return {boolean} Layers have sources that are still loading.
     */
    getLoadingOrNotReady() {
      const layerStatesArray = this.getLayerGroup().getLayerStatesArray();
      for (let i4 = 0, ii = layerStatesArray.length; i4 < ii; ++i4) {
        const state = layerStatesArray[i4];
        if (!state.visible) {
          continue;
        }
        const renderer = state.layer.getRenderer();
        if (renderer && !renderer.ready) {
          return true;
        }
        const source = state.layer.getSource();
        if (source && source.loading) {
          return true;
        }
      }
      return false;
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the user
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     * @api
     */
    getPixelFromCoordinate(coordinate) {
      const viewCoordinate = fromUserCoordinate(
        coordinate,
        this.getView().getProjection()
      );
      return this.getPixelFromCoordinateInternal(viewCoordinate);
    }
    /**
     * Get the pixel for a coordinate.  This takes a coordinate in the map view
     * projection and returns the corresponding pixel.
     * @param {import("./coordinate.js").Coordinate} coordinate A map coordinate.
     * @return {import("./pixel.js").Pixel} A pixel position in the map viewport.
     */
    getPixelFromCoordinateInternal(coordinate) {
      const frameState = this.frameState_;
      if (!frameState) {
        return null;
      }
      return apply(
        frameState.coordinateToPixelTransform,
        coordinate.slice(0, 2)
      );
    }
    /**
     * Get the map renderer.
     * @return {import("./renderer/Map.js").default|null} Renderer
     */
    getRenderer() {
      return this.renderer_;
    }
    /**
     * Get the size of this map.
     * @return {import("./size.js").Size|undefined} The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    getSize() {
      return (
        /** @type {import("./size.js").Size|undefined} */
        this.get(MapProperty_default.SIZE)
      );
    }
    /**
     * Get the view associated with this map. A view manages properties such as
     * center and resolution.
     * @return {View} The view that controls this map.
     * @observable
     * @api
     */
    getView() {
      return (
        /** @type {View} */
        this.get(MapProperty_default.VIEW)
      );
    }
    /**
     * Get the element that serves as the map viewport.
     * @return {HTMLElement} Viewport.
     * @api
     */
    getViewport() {
      return this.viewport_;
    }
    /**
     * Get the element that serves as the container for overlays.  Elements added to
     * this container will let mousedown and touchstart events through to the map,
     * so clicks and gestures on an overlay will trigger {@link module:ol/MapBrowserEvent~MapBrowserEvent}
     * events.
     * @return {!HTMLElement} The map's overlay container.
     */
    getOverlayContainer() {
      return this.overlayContainer_;
    }
    /**
     * Get the element that serves as a container for overlays that don't allow
     * event propagation. Elements added to this container won't let mousedown and
     * touchstart events through to the map, so clicks and gestures on an overlay
     * don't trigger any {@link module:ol/MapBrowserEvent~MapBrowserEvent}.
     * @return {!HTMLElement} The map's overlay container that stops events.
     */
    getOverlayContainerStopEvent() {
      return this.overlayContainerStopEvent_;
    }
    /**
     * @return {!Document} The document where the map is displayed.
     */
    getOwnerDocument() {
      const targetElement = this.getTargetElement();
      return targetElement ? targetElement.ownerDocument : document;
    }
    /**
     * @param {import("./Tile.js").default} tile Tile.
     * @param {string} tileSourceKey Tile source key.
     * @param {import("./coordinate.js").Coordinate} tileCenter Tile center.
     * @param {number} tileResolution Tile resolution.
     * @return {number} Tile priority.
     */
    getTilePriority(tile, tileSourceKey, tileCenter, tileResolution) {
      return getTilePriority(
        this.frameState_,
        tile,
        tileSourceKey,
        tileCenter,
        tileResolution
      );
    }
    /**
     * @param {UIEvent} browserEvent Browser event.
     * @param {string} [type] Type.
     */
    handleBrowserEvent(browserEvent, type) {
      type = type || browserEvent.type;
      const mapBrowserEvent = new MapBrowserEvent_default(type, this, browserEvent);
      this.handleMapBrowserEvent(mapBrowserEvent);
    }
    /**
     * @param {MapBrowserEvent} mapBrowserEvent The event to handle.
     */
    handleMapBrowserEvent(mapBrowserEvent) {
      if (!this.frameState_) {
        return;
      }
      const originalEvent = (
        /** @type {PointerEvent} */
        mapBrowserEvent.originalEvent
      );
      const eventType = originalEvent.type;
      if (eventType === EventType_default3.POINTERDOWN || eventType === EventType_default.WHEEL || eventType === EventType_default.KEYDOWN) {
        const doc = this.getOwnerDocument();
        const rootNode = this.viewport_.getRootNode ? this.viewport_.getRootNode() : doc;
        const target = (
          /** @type {Node} */
          originalEvent.target
        );
        if (
          // Abort if the target is a child of the container for elements whose events are not meant
          // to be handled by map interactions.
          this.overlayContainerStopEvent_.contains(target) || // Abort if the event target is a child of the container that is no longer in the page.
          // It's possible for the target to no longer be in the page if it has been removed in an
          // event listener, this might happen in a Control that recreates it's content based on
          // user interaction either manually or via a render in something like https://reactjs.org/
          !(rootNode === doc ? doc.documentElement : rootNode).contains(target)
        ) {
          return;
        }
      }
      mapBrowserEvent.frameState = this.frameState_;
      if (this.dispatchEvent(mapBrowserEvent) !== false) {
        const interactionsArray = this.getInteractions().getArray().slice();
        for (let i4 = interactionsArray.length - 1; i4 >= 0; i4--) {
          const interaction = interactionsArray[i4];
          if (interaction.getMap() !== this || !interaction.getActive() || !this.getTargetElement()) {
            continue;
          }
          const cont = interaction.handleEvent(mapBrowserEvent);
          if (!cont || mapBrowserEvent.propagationStopped) {
            break;
          }
        }
      }
    }
    /**
     * @protected
     */
    handlePostRender() {
      const frameState = this.frameState_;
      const tileQueue = this.tileQueue_;
      if (!tileQueue.isEmpty()) {
        let maxTotalLoading = this.maxTilesLoading_;
        let maxNewLoads = maxTotalLoading;
        if (frameState) {
          const hints = frameState.viewHints;
          if (hints[ViewHint_default.ANIMATING] || hints[ViewHint_default.INTERACTING]) {
            const lowOnFrameBudget = Date.now() - frameState.time > 8;
            maxTotalLoading = lowOnFrameBudget ? 0 : 8;
            maxNewLoads = lowOnFrameBudget ? 0 : 2;
          }
        }
        if (tileQueue.getTilesLoading() < maxTotalLoading) {
          tileQueue.reprioritize();
          tileQueue.loadMoreTiles(maxTotalLoading, maxNewLoads);
        }
      }
      if (frameState && this.renderer_ && !frameState.animate) {
        if (this.renderComplete_ === true) {
          if (this.hasListener(EventType_default2.RENDERCOMPLETE)) {
            this.renderer_.dispatchRenderEvent(
              EventType_default2.RENDERCOMPLETE,
              frameState
            );
          }
          if (this.loaded_ === false) {
            this.loaded_ = true;
            this.dispatchEvent(
              new MapEvent_default(MapEventType_default.LOADEND, this, frameState)
            );
          }
        } else if (this.loaded_ === true) {
          this.loaded_ = false;
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.LOADSTART, this, frameState)
          );
        }
      }
      const postRenderFunctions = this.postRenderFunctions_;
      for (let i4 = 0, ii = postRenderFunctions.length; i4 < ii; ++i4) {
        postRenderFunctions[i4](this, frameState);
      }
      postRenderFunctions.length = 0;
    }
    /**
     * @private
     */
    handleSizeChanged_() {
      if (this.getView() && !this.getView().getAnimating()) {
        this.getView().resolveConstraints(0);
      }
      this.render();
    }
    /**
     * @private
     */
    handleTargetChanged_() {
      if (this.mapBrowserEventHandler_) {
        for (let i4 = 0, ii = this.targetChangeHandlerKeys_.length; i4 < ii; ++i4) {
          unlistenByKey(this.targetChangeHandlerKeys_[i4]);
        }
        this.targetChangeHandlerKeys_ = null;
        this.viewport_.removeEventListener(
          EventType_default.CONTEXTMENU,
          this.boundHandleBrowserEvent_
        );
        this.viewport_.removeEventListener(
          EventType_default.WHEEL,
          this.boundHandleBrowserEvent_
        );
        this.mapBrowserEventHandler_.dispose();
        this.mapBrowserEventHandler_ = null;
        removeNode(this.viewport_);
      }
      if (this.targetElement_) {
        this.resizeObserver_.unobserve(this.targetElement_);
        const rootNode = this.targetElement_.getRootNode();
        if (rootNode instanceof ShadowRoot) {
          this.resizeObserver_.unobserve(rootNode.host);
        }
        this.setSize(void 0);
      }
      const target = this.getTarget();
      const targetElement = typeof target === "string" ? document.getElementById(target) : target;
      this.targetElement_ = targetElement;
      if (!targetElement) {
        if (this.renderer_) {
          clearTimeout(this.postRenderTimeoutHandle_);
          this.postRenderTimeoutHandle_ = void 0;
          this.postRenderFunctions_.length = 0;
          this.renderer_.dispose();
          this.renderer_ = null;
        }
        if (this.animationDelayKey_) {
          cancelAnimationFrame(this.animationDelayKey_);
          this.animationDelayKey_ = void 0;
        }
      } else {
        targetElement.appendChild(this.viewport_);
        if (!this.renderer_) {
          this.renderer_ = new Composite_default(this);
        }
        this.mapBrowserEventHandler_ = new MapBrowserEventHandler_default(
          this,
          this.moveTolerance_
        );
        for (const key in MapBrowserEventType_default) {
          this.mapBrowserEventHandler_.addEventListener(
            MapBrowserEventType_default[key],
            this.handleMapBrowserEvent.bind(this)
          );
        }
        this.viewport_.addEventListener(
          EventType_default.CONTEXTMENU,
          this.boundHandleBrowserEvent_,
          false
        );
        this.viewport_.addEventListener(
          EventType_default.WHEEL,
          this.boundHandleBrowserEvent_,
          PASSIVE_EVENT_LISTENERS ? { passive: false } : false
        );
        const keyboardEventTarget = !this.keyboardEventTarget_ ? targetElement : this.keyboardEventTarget_;
        this.targetChangeHandlerKeys_ = [
          listen(
            keyboardEventTarget,
            EventType_default.KEYDOWN,
            this.handleBrowserEvent,
            this
          ),
          listen(
            keyboardEventTarget,
            EventType_default.KEYPRESS,
            this.handleBrowserEvent,
            this
          )
        ];
        const rootNode = targetElement.getRootNode();
        if (rootNode instanceof ShadowRoot) {
          this.resizeObserver_.observe(rootNode.host);
        }
        this.resizeObserver_.observe(targetElement);
      }
      this.updateSize();
    }
    /**
     * @private
     */
    handleTileChange_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewPropertyChanged_() {
      this.render();
    }
    /**
     * @private
     */
    handleViewChanged_() {
      if (this.viewPropertyListenerKey_) {
        unlistenByKey(this.viewPropertyListenerKey_);
        this.viewPropertyListenerKey_ = null;
      }
      if (this.viewChangeListenerKey_) {
        unlistenByKey(this.viewChangeListenerKey_);
        this.viewChangeListenerKey_ = null;
      }
      const view = this.getView();
      if (view) {
        this.updateViewportSize_();
        this.viewPropertyListenerKey_ = listen(
          view,
          ObjectEventType_default.PROPERTYCHANGE,
          this.handleViewPropertyChanged_,
          this
        );
        this.viewChangeListenerKey_ = listen(
          view,
          EventType_default.CHANGE,
          this.handleViewPropertyChanged_,
          this
        );
        view.resolveConstraints(0);
      }
      this.render();
    }
    /**
     * @private
     */
    handleLayerGroupChanged_() {
      if (this.layerGroupPropertyListenerKeys_) {
        this.layerGroupPropertyListenerKeys_.forEach(unlistenByKey);
        this.layerGroupPropertyListenerKeys_ = null;
      }
      const layerGroup = this.getLayerGroup();
      if (layerGroup) {
        this.handleLayerAdd_(new GroupEvent("addlayer", layerGroup));
        this.layerGroupPropertyListenerKeys_ = [
          listen(layerGroup, ObjectEventType_default.PROPERTYCHANGE, this.render, this),
          listen(layerGroup, EventType_default.CHANGE, this.render, this),
          listen(layerGroup, "addlayer", this.handleLayerAdd_, this),
          listen(layerGroup, "removelayer", this.handleLayerRemove_, this)
        ];
      }
      this.render();
    }
    /**
     * @return {boolean} Is rendered.
     */
    isRendered() {
      return !!this.frameState_;
    }
    /**
     * @private
     */
    animationDelay_() {
      this.animationDelayKey_ = void 0;
      this.renderFrame_(Date.now());
    }
    /**
     * Requests an immediate render in a synchronous manner.
     * @api
     */
    renderSync() {
      if (this.animationDelayKey_) {
        cancelAnimationFrame(this.animationDelayKey_);
      }
      this.animationDelay_();
    }
    /**
     * Redraws all text after new fonts have loaded
     */
    redrawText() {
      const layerStates = this.getLayerGroup().getLayerStatesArray();
      for (let i4 = 0, ii = layerStates.length; i4 < ii; ++i4) {
        const layer = layerStates[i4].layer;
        if (layer.hasRenderer()) {
          layer.getRenderer().handleFontsChanged();
        }
      }
    }
    /**
     * Request a map rendering (at the next animation frame).
     * @api
     */
    render() {
      if (this.renderer_ && this.animationDelayKey_ === void 0) {
        this.animationDelayKey_ = requestAnimationFrame(this.animationDelay_);
      }
    }
    /**
     * This method is meant to be called in a layer's `prerender` listener. It causes all collected
     * declutter items to be decluttered and rendered on the map immediately. This is useful for
     * layers that need to appear entirely above the decluttered items of layers lower in the layer
     * stack.
     * @api
     */
    flushDeclutterItems() {
      const frameState = this.frameState_;
      if (!frameState) {
        return;
      }
      this.renderer_.flushDeclutterItems(frameState);
    }
    /**
     * Remove the given control from the map.
     * @param {import("./control/Control.js").default} control Control.
     * @return {import("./control/Control.js").default|undefined} The removed control (or undefined
     *     if the control was not found).
     * @api
     */
    removeControl(control) {
      return this.getControls().remove(control);
    }
    /**
     * Remove the given interaction from the map.
     * @param {import("./interaction/Interaction.js").default} interaction Interaction to remove.
     * @return {import("./interaction/Interaction.js").default|undefined} The removed interaction (or
     *     undefined if the interaction was not found).
     * @api
     */
    removeInteraction(interaction) {
      return this.getInteractions().remove(interaction);
    }
    /**
     * Removes the given layer from the map.
     * @param {import("./layer/Base.js").default} layer Layer.
     * @return {import("./layer/Base.js").default|undefined} The removed layer (or undefined if the
     *     layer was not found).
     * @api
     */
    removeLayer(layer) {
      const layers = this.getLayerGroup().getLayers();
      return layers.remove(layer);
    }
    /**
     * @param {import("./layer/Group.js").GroupEvent} event The layer remove event.
     * @private
     */
    handleLayerRemove_(event) {
      removeLayerMapProperty(event.layer);
    }
    /**
     * Remove the given overlay from the map.
     * @param {import("./Overlay.js").default} overlay Overlay.
     * @return {import("./Overlay.js").default|undefined} The removed overlay (or undefined
     *     if the overlay was not found).
     * @api
     */
    removeOverlay(overlay) {
      return this.getOverlays().remove(overlay);
    }
    /**
     * @param {number} time Time.
     * @private
     */
    renderFrame_(time) {
      const size = this.getSize();
      const view = this.getView();
      const previousFrameState = this.frameState_;
      let frameState = null;
      if (size !== void 0 && hasArea(size) && view && view.isDef()) {
        const viewHints = view.getHints(
          this.frameState_ ? this.frameState_.viewHints : void 0
        );
        const viewState = view.getState();
        frameState = {
          animate: false,
          coordinateToPixelTransform: this.coordinateToPixelTransform_,
          declutterTree: null,
          extent: getForViewAndSize(
            viewState.center,
            viewState.resolution,
            viewState.rotation,
            size
          ),
          index: this.frameIndex_++,
          layerIndex: 0,
          layerStatesArray: this.getLayerGroup().getLayerStatesArray(),
          pixelRatio: this.pixelRatio_,
          pixelToCoordinateTransform: this.pixelToCoordinateTransform_,
          postRenderFunctions: [],
          size,
          tileQueue: this.tileQueue_,
          time,
          usedTiles: {},
          viewState,
          viewHints,
          wantedTiles: {},
          mapId: getUid(this),
          renderTargets: {}
        };
        if (viewState.nextCenter && viewState.nextResolution) {
          const rotation = isNaN(viewState.nextRotation) ? viewState.rotation : viewState.nextRotation;
          frameState.nextExtent = getForViewAndSize(
            viewState.nextCenter,
            viewState.nextResolution,
            rotation,
            size
          );
        }
      }
      this.frameState_ = frameState;
      this.renderer_.renderFrame(frameState);
      if (frameState) {
        if (frameState.animate) {
          this.render();
        }
        Array.prototype.push.apply(
          this.postRenderFunctions_,
          frameState.postRenderFunctions
        );
        if (previousFrameState) {
          const moveStart = !this.previousExtent_ || !isEmpty2(this.previousExtent_) && !equals2(frameState.extent, this.previousExtent_);
          if (moveStart) {
            this.dispatchEvent(
              new MapEvent_default(MapEventType_default.MOVESTART, this, previousFrameState)
            );
            this.previousExtent_ = createOrUpdateEmpty(this.previousExtent_);
          }
        }
        const idle = this.previousExtent_ && !frameState.viewHints[ViewHint_default.ANIMATING] && !frameState.viewHints[ViewHint_default.INTERACTING] && !equals2(frameState.extent, this.previousExtent_);
        if (idle) {
          this.dispatchEvent(
            new MapEvent_default(MapEventType_default.MOVEEND, this, frameState)
          );
          clone(frameState.extent, this.previousExtent_);
        }
      }
      this.dispatchEvent(new MapEvent_default(MapEventType_default.POSTRENDER, this, frameState));
      this.renderComplete_ = this.hasListener(MapEventType_default.LOADSTART) || this.hasListener(MapEventType_default.LOADEND) || this.hasListener(EventType_default2.RENDERCOMPLETE) ? !this.tileQueue_.getTilesLoading() && !this.tileQueue_.getCount() && !this.getLoadingOrNotReady() : void 0;
      if (!this.postRenderTimeoutHandle_) {
        this.postRenderTimeoutHandle_ = setTimeout(() => {
          this.postRenderTimeoutHandle_ = void 0;
          this.handlePostRender();
        }, 0);
      }
    }
    /**
     * Sets the layergroup of this map.
     * @param {LayerGroup} layerGroup A layer group containing the layers in this map.
     * @observable
     * @api
     */
    setLayerGroup(layerGroup) {
      const oldLayerGroup = this.getLayerGroup();
      if (oldLayerGroup) {
        this.handleLayerRemove_(new GroupEvent("removelayer", oldLayerGroup));
      }
      this.set(MapProperty_default.LAYERGROUP, layerGroup);
    }
    /**
     * Set the size of this map.
     * @param {import("./size.js").Size|undefined} size The size in pixels of the map in the DOM.
     * @observable
     * @api
     */
    setSize(size) {
      this.set(MapProperty_default.SIZE, size);
    }
    /**
     * Set the target element to render this map into.
     * @param {HTMLElement|string} [target] The Element or id of the Element
     *     that the map is rendered in.
     * @observable
     * @api
     */
    setTarget(target) {
      this.set(MapProperty_default.TARGET, target);
    }
    /**
     * Set the view for this map.
     * @param {View|Promise<import("./View.js").ViewOptions>} view The view that controls this map.
     * It is also possible to pass a promise that resolves to options for constructing a view.  This
     * alternative allows view properties to be resolved by sources or other components that load
     * view-related metadata.
     * @observable
     * @api
     */
    setView(view) {
      if (!view || view instanceof View_default) {
        this.set(MapProperty_default.VIEW, view);
        return;
      }
      this.set(MapProperty_default.VIEW, new View_default());
      const map2 = this;
      view.then(function(viewOptions) {
        map2.setView(new View_default(viewOptions));
      });
    }
    /**
     * Force a recalculation of the map viewport size.  This should be called when
     * third-party code changes the size of the map viewport.
     * @api
     */
    updateSize() {
      const targetElement = this.getTargetElement();
      let size = void 0;
      if (targetElement) {
        const computedStyle = getComputedStyle(targetElement);
        const width = targetElement.offsetWidth - parseFloat(computedStyle["borderLeftWidth"]) - parseFloat(computedStyle["paddingLeft"]) - parseFloat(computedStyle["paddingRight"]) - parseFloat(computedStyle["borderRightWidth"]);
        const height = targetElement.offsetHeight - parseFloat(computedStyle["borderTopWidth"]) - parseFloat(computedStyle["paddingTop"]) - parseFloat(computedStyle["paddingBottom"]) - parseFloat(computedStyle["borderBottomWidth"]);
        if (!isNaN(width) && !isNaN(height)) {
          size = [width, height];
          if (!hasArea(size) && !!(targetElement.offsetWidth || targetElement.offsetHeight || targetElement.getClientRects().length)) {
            warn(
              "No map visible because the map container's width or height are 0."
            );
          }
        }
      }
      const oldSize = this.getSize();
      if (size && (!oldSize || !equals(size, oldSize))) {
        this.setSize(size);
        this.updateViewportSize_();
      }
    }
    /**
     * Recomputes the viewport size and save it on the view object (if any)
     * @private
     */
    updateViewportSize_() {
      const view = this.getView();
      if (view) {
        let size = void 0;
        const computedStyle = getComputedStyle(this.viewport_);
        if (computedStyle.width && computedStyle.height) {
          size = [
            parseInt(computedStyle.width, 10),
            parseInt(computedStyle.height, 10)
          ];
        }
        view.setViewportSize(size);
      }
    }
  };
  function createOptionsInternal(options) {
    let keyboardEventTarget = null;
    if (options.keyboardEventTarget !== void 0) {
      keyboardEventTarget = typeof options.keyboardEventTarget === "string" ? document.getElementById(options.keyboardEventTarget) : options.keyboardEventTarget;
    }
    const values = {};
    const layerGroup = options.layers && typeof /** @type {?} */
    options.layers.getLayers === "function" ? (
      /** @type {LayerGroup} */
      options.layers
    ) : new Group_default({
      layers: (
        /** @type {Collection<import("./layer/Base.js").default>|Array<import("./layer/Base.js").default>} */
        options.layers
      )
    });
    values[MapProperty_default.LAYERGROUP] = layerGroup;
    values[MapProperty_default.TARGET] = options.target;
    values[MapProperty_default.VIEW] = options.view instanceof View_default ? options.view : new View_default();
    let controls;
    if (options.controls !== void 0) {
      if (Array.isArray(options.controls)) {
        controls = new Collection_default(options.controls.slice());
      } else {
        assert(
          typeof /** @type {?} */
          options.controls.getArray === "function",
          "Expected `controls` to be an array or an `ol/Collection.js`"
        );
        controls = options.controls;
      }
    }
    let interactions;
    if (options.interactions !== void 0) {
      if (Array.isArray(options.interactions)) {
        interactions = new Collection_default(options.interactions.slice());
      } else {
        assert(
          typeof /** @type {?} */
          options.interactions.getArray === "function",
          "Expected `interactions` to be an array or an `ol/Collection.js`"
        );
        interactions = options.interactions;
      }
    }
    let overlays;
    if (options.overlays !== void 0) {
      if (Array.isArray(options.overlays)) {
        overlays = new Collection_default(options.overlays.slice());
      } else {
        assert(
          typeof /** @type {?} */
          options.overlays.getArray === "function",
          "Expected `overlays` to be an array or an `ol/Collection.js`"
        );
        overlays = options.overlays;
      }
    } else {
      overlays = new Collection_default();
    }
    return {
      controls,
      interactions,
      keyboardEventTarget,
      overlays,
      values
    };
  }
  var Map_default2 = Map2;

  // node_modules/ol/format/Feature.js
  var FeatureFormat = class {
    constructor() {
      this.dataProjection = void 0;
      this.defaultFeatureProjection = void 0;
      this.supportedMediaTypes = null;
    }
    /**
     * Adds the data projection to the read options.
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Options.
     * @return {ReadOptions|undefined} Options.
     * @protected
     */
    getReadOptions(source, options) {
      if (options) {
        let dataProjection = options.dataProjection ? get3(options.dataProjection) : this.readProjection(source);
        if (options.extent && dataProjection && dataProjection.getUnits() === "tile-pixels") {
          dataProjection = get3(dataProjection);
          dataProjection.setWorldExtent(options.extent);
        }
        options = {
          dataProjection,
          featureProjection: options.featureProjection
        };
      }
      return this.adaptOptions(options);
    }
    /**
     * Sets the `dataProjection` on the options, if no `dataProjection`
     * is set.
     * @param {WriteOptions|ReadOptions|undefined} options
     *     Options.
     * @protected
     * @return {WriteOptions|ReadOptions|undefined}
     *     Updated options.
     */
    adaptOptions(options) {
      return Object.assign(
        {
          dataProjection: this.dataProjection,
          featureProjection: this.defaultFeatureProjection
        },
        options
      );
    }
    /**
     * @abstract
     * @return {Type} The format type.
     */
    getType() {
      return abstract();
    }
    /**
     * Read a single feature from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../Feature.js").FeatureLike} Feature.
     */
    readFeature(source, options) {
      return abstract();
    }
    /**
     * Read all features from a source.
     *
     * @abstract
     * @param {Document|Element|ArrayBuffer|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {Array<import("../Feature.js").FeatureLike>} Features.
     */
    readFeatures(source, options) {
      return abstract();
    }
    /**
     * Read a single geometry from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @param {ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometry(source, options) {
      return abstract();
    }
    /**
     * Read the projection from a source.
     *
     * @abstract
     * @param {Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default|undefined} Projection.
     */
    readProjection(source) {
      return abstract();
    }
    /**
     * Encode a feature in this format.
     *
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeature(feature, options) {
      return abstract();
    }
    /**
     * Encode an array of features in this format.
     *
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeFeatures(features, options) {
      return abstract();
    }
    /**
     * Write a single geometry in this format.
     *
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {WriteOptions} [options] Write options.
     * @return {string|ArrayBuffer} Result.
     */
    writeGeometry(geometry, options) {
      return abstract();
    }
  };
  var Feature_default2 = FeatureFormat;
  function transformGeometryWithOptions(geometry, write, options) {
    const featureProjection = options ? get3(options.featureProjection) : null;
    const dataProjection = options ? get3(options.dataProjection) : null;
    let transformed;
    if (featureProjection && dataProjection && !equivalent(featureProjection, dataProjection)) {
      transformed = (write ? geometry.clone() : geometry).transform(
        write ? featureProjection : dataProjection,
        write ? dataProjection : featureProjection
      );
    } else {
      transformed = geometry;
    }
    if (write && options && /** @type {WriteOptions} */
    options.decimals !== void 0) {
      const power = Math.pow(
        10,
        /** @type {WriteOptions} */
        options.decimals
      );
      const transform2 = function(coordinates2) {
        for (let i4 = 0, ii = coordinates2.length; i4 < ii; ++i4) {
          coordinates2[i4] = Math.round(coordinates2[i4] * power) / power;
        }
        return coordinates2;
      };
      if (transformed === geometry) {
        transformed = geometry.clone();
      }
      transformed.applyTransform(transform2);
    }
    return transformed;
  }

  // node_modules/ol/format/JSONFeature.js
  var JSONFeature = class extends Feature_default2 {
    constructor() {
      super();
    }
    /**
     * @return {import("./Feature.js").Type} Format.
     */
    getType() {
      return "json";
    }
    /**
     * Read a feature.  Only works for a single feature. Use `readFeatures` to
     * read a feature collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../Feature.js").default} Feature.
     * @api
     */
    readFeature(source, options) {
      return this.readFeatureFromObject(
        getObject(source),
        this.getReadOptions(source, options)
      );
    }
    /**
     * Read all features.  Works with both a single feature and a feature
     * collection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {Array<import("../Feature.js").default>} Features.
     * @api
     */
    readFeatures(source, options) {
      return this.readFeaturesFromObject(
        getObject(source),
        this.getReadOptions(source, options)
      );
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromObject(object, options) {
      return abstract();
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<import("../Feature.js").default>} Features.
     */
    readFeaturesFromObject(object, options) {
      return abstract();
    }
    /**
     * Read a geometry.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @return {import("../geom/Geometry.js").default} Geometry.
     * @api
     */
    readGeometry(source, options) {
      return this.readGeometryFromObject(
        getObject(source),
        this.getReadOptions(source, options)
      );
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromObject(object, options) {
      return abstract();
    }
    /**
     * Read the projection.
     *
     * @param {ArrayBuffer|Document|Element|Object|string} source Source.
     * @return {import("../proj/Projection.js").default} Projection.
     * @api
     */
    readProjection(source) {
      return this.readProjectionFromObject(getObject(source));
    }
    /**
     * @abstract
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromObject(object) {
      return abstract();
    }
    /**
     * Encode a feature as string.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded feature.
     * @api
     */
    writeFeature(feature, options) {
      return JSON.stringify(this.writeFeatureObject(feature, options));
    }
    /**
     * @abstract
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeatureObject(feature, options) {
      return abstract();
    }
    /**
     * Encode an array of features as string.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded features.
     * @api
     */
    writeFeatures(features, options) {
      return JSON.stringify(this.writeFeaturesObject(features, options));
    }
    /**
     * @abstract
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeFeaturesObject(features, options) {
      return abstract();
    }
    /**
     * Encode a geometry as string.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {string} Encoded geometry.
     * @api
     */
    writeGeometry(geometry, options) {
      return JSON.stringify(this.writeGeometryObject(geometry, options));
    }
    /**
     * @abstract
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {Object} Object.
     */
    writeGeometryObject(geometry, options) {
      return abstract();
    }
  };
  function getObject(source) {
    if (typeof source === "string") {
      const object = JSON.parse(source);
      return object ? (
        /** @type {Object} */
        object
      ) : null;
    }
    if (source !== null) {
      return source;
    }
    return null;
  }
  var JSONFeature_default = JSONFeature;

  // node_modules/ol/format/GeoJSON.js
  var GeoJSON = class extends JSONFeature_default {
    /**
     * @param {Options} [options] Options.
     */
    constructor(options) {
      options = options ? options : {};
      super();
      this.dataProjection = get3(
        options.dataProjection ? options.dataProjection : "EPSG:4326"
      );
      if (options.featureProjection) {
        this.defaultFeatureProjection = get3(options.featureProjection);
      }
      this.geometryName_ = options.geometryName;
      this.extractGeometryName_ = options.extractGeometryName;
      this.supportedMediaTypes = [
        "application/geo+json",
        "application/vnd.geo+json"
      ];
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../Feature.js").default} Feature.
     */
    readFeatureFromObject(object, options) {
      let geoJSONFeature = null;
      if (object["type"] === "Feature") {
        geoJSONFeature = /** @type {GeoJSONFeature} */
        object;
      } else {
        geoJSONFeature = {
          "type": "Feature",
          "geometry": (
            /** @type {GeoJSONGeometry} */
            object
          ),
          "properties": null
        };
      }
      const geometry = readGeometry(geoJSONFeature["geometry"], options);
      const feature = new Feature_default();
      if (this.geometryName_) {
        feature.setGeometryName(this.geometryName_);
      } else if (this.extractGeometryName_ && "geometry_name" in geoJSONFeature !== void 0) {
        feature.setGeometryName(geoJSONFeature["geometry_name"]);
      }
      feature.setGeometry(geometry);
      if ("id" in geoJSONFeature) {
        feature.setId(geoJSONFeature["id"]);
      }
      if (geoJSONFeature["properties"]) {
        feature.setProperties(geoJSONFeature["properties"], true);
      }
      return feature;
    }
    /**
     * @param {Object} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {Array<Feature>} Features.
     */
    readFeaturesFromObject(object, options) {
      const geoJSONObject = (
        /** @type {GeoJSONObject} */
        object
      );
      let features = null;
      if (geoJSONObject["type"] === "FeatureCollection") {
        const geoJSONFeatureCollection = (
          /** @type {GeoJSONFeatureCollection} */
          object
        );
        features = [];
        const geoJSONFeatures = geoJSONFeatureCollection["features"];
        for (let i4 = 0, ii = geoJSONFeatures.length; i4 < ii; ++i4) {
          features.push(this.readFeatureFromObject(geoJSONFeatures[i4], options));
        }
      } else {
        features = [this.readFeatureFromObject(object, options)];
      }
      return features;
    }
    /**
     * @param {GeoJSONGeometry} object Object.
     * @param {import("./Feature.js").ReadOptions} [options] Read options.
     * @protected
     * @return {import("../geom/Geometry.js").default} Geometry.
     */
    readGeometryFromObject(object, options) {
      return readGeometry(object, options);
    }
    /**
     * @param {Object} object Object.
     * @protected
     * @return {import("../proj/Projection.js").default} Projection.
     */
    readProjectionFromObject(object) {
      const crs = object["crs"];
      let projection;
      if (crs) {
        if (crs["type"] == "name") {
          projection = get3(crs["properties"]["name"]);
        } else if (crs["type"] === "EPSG") {
          projection = get3("EPSG:" + crs["properties"]["code"]);
        } else {
          throw new Error("Unknown SRS type");
        }
      } else {
        projection = this.dataProjection;
      }
      return (
        /** @type {import("../proj/Projection.js").default} */
        projection
      );
    }
    /**
     * Encode a feature as a GeoJSON Feature object.
     *
     * @param {import("../Feature.js").default} feature Feature.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeature} Object.
     * @api
     */
    writeFeatureObject(feature, options) {
      options = this.adaptOptions(options);
      const object = {
        "type": "Feature",
        geometry: null,
        properties: null
      };
      const id = feature.getId();
      if (id !== void 0) {
        object.id = id;
      }
      if (!feature.hasProperties()) {
        return object;
      }
      const properties = feature.getProperties();
      const geometry = feature.getGeometry();
      if (geometry) {
        object.geometry = writeGeometry(geometry, options);
        delete properties[feature.getGeometryName()];
      }
      if (!isEmpty(properties)) {
        object.properties = properties;
      }
      return object;
    }
    /**
     * Encode an array of features as a GeoJSON object.
     *
     * @param {Array<import("../Feature.js").default>} features Features.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONFeatureCollection} GeoJSON Object.
     * @api
     */
    writeFeaturesObject(features, options) {
      options = this.adaptOptions(options);
      const objects = [];
      for (let i4 = 0, ii = features.length; i4 < ii; ++i4) {
        objects.push(this.writeFeatureObject(features[i4], options));
      }
      return {
        type: "FeatureCollection",
        features: objects
      };
    }
    /**
     * Encode a geometry as a GeoJSON object.
     *
     * @param {import("../geom/Geometry.js").default} geometry Geometry.
     * @param {import("./Feature.js").WriteOptions} [options] Write options.
     * @return {GeoJSONGeometry|GeoJSONGeometryCollection} Object.
     * @api
     */
    writeGeometryObject(geometry, options) {
      return writeGeometry(geometry, this.adaptOptions(options));
    }
  };
  function readGeometry(object, options) {
    if (!object) {
      return null;
    }
    let geometry;
    switch (object["type"]) {
      case "Point": {
        geometry = readPointGeometry(
          /** @type {GeoJSONPoint} */
          object
        );
        break;
      }
      case "LineString": {
        geometry = readLineStringGeometry(
          /** @type {GeoJSONLineString} */
          object
        );
        break;
      }
      case "Polygon": {
        geometry = readPolygonGeometry(
          /** @type {GeoJSONPolygon} */
          object
        );
        break;
      }
      case "MultiPoint": {
        geometry = readMultiPointGeometry(
          /** @type {GeoJSONMultiPoint} */
          object
        );
        break;
      }
      case "MultiLineString": {
        geometry = readMultiLineStringGeometry(
          /** @type {GeoJSONMultiLineString} */
          object
        );
        break;
      }
      case "MultiPolygon": {
        geometry = readMultiPolygonGeometry(
          /** @type {GeoJSONMultiPolygon} */
          object
        );
        break;
      }
      case "GeometryCollection": {
        geometry = readGeometryCollectionGeometry(
          /** @type {GeoJSONGeometryCollection} */
          object
        );
        break;
      }
      default: {
        throw new Error("Unsupported GeoJSON type: " + object["type"]);
      }
    }
    return transformGeometryWithOptions(geometry, false, options);
  }
  function readGeometryCollectionGeometry(object, options) {
    const geometries = object["geometries"].map(
      /**
       * @param {GeoJSONGeometry} geometry Geometry.
       * @return {import("../geom/Geometry.js").default} geometry Geometry.
       */
      function(geometry) {
        return readGeometry(geometry, options);
      }
    );
    return new GeometryCollection_default(geometries);
  }
  function readPointGeometry(object) {
    return new Point_default(object["coordinates"]);
  }
  function readLineStringGeometry(object) {
    return new LineString_default(object["coordinates"]);
  }
  function readMultiLineStringGeometry(object) {
    return new MultiLineString_default(object["coordinates"]);
  }
  function readMultiPointGeometry(object) {
    return new MultiPoint_default(object["coordinates"]);
  }
  function readMultiPolygonGeometry(object) {
    return new MultiPolygon_default(object["coordinates"]);
  }
  function readPolygonGeometry(object) {
    return new Polygon_default(object["coordinates"]);
  }
  function writeGeometry(geometry, options) {
    geometry = transformGeometryWithOptions(geometry, true, options);
    const type = geometry.getType();
    let geoJSON;
    switch (type) {
      case "Point": {
        geoJSON = writePointGeometry(
          /** @type {Point} */
          geometry,
          options
        );
        break;
      }
      case "LineString": {
        geoJSON = writeLineStringGeometry(
          /** @type {LineString} */
          geometry,
          options
        );
        break;
      }
      case "Polygon": {
        geoJSON = writePolygonGeometry(
          /** @type {Polygon} */
          geometry,
          options
        );
        break;
      }
      case "MultiPoint": {
        geoJSON = writeMultiPointGeometry(
          /** @type {MultiPoint} */
          geometry,
          options
        );
        break;
      }
      case "MultiLineString": {
        geoJSON = writeMultiLineStringGeometry(
          /** @type {MultiLineString} */
          geometry,
          options
        );
        break;
      }
      case "MultiPolygon": {
        geoJSON = writeMultiPolygonGeometry(
          /** @type {MultiPolygon} */
          geometry,
          options
        );
        break;
      }
      case "GeometryCollection": {
        geoJSON = writeGeometryCollectionGeometry(
          /** @type {GeometryCollection} */
          geometry,
          options
        );
        break;
      }
      case "Circle": {
        geoJSON = {
          type: "GeometryCollection",
          geometries: []
        };
        break;
      }
      default: {
        throw new Error("Unsupported geometry type: " + type);
      }
    }
    return geoJSON;
  }
  function writeGeometryCollectionGeometry(geometry, options) {
    options = Object.assign({}, options);
    delete options.featureProjection;
    const geometries = geometry.getGeometriesArray().map(function(geometry2) {
      return writeGeometry(geometry2, options);
    });
    return {
      type: "GeometryCollection",
      geometries
    };
  }
  function writeLineStringGeometry(geometry, options) {
    return {
      type: "LineString",
      coordinates: geometry.getCoordinates()
    };
  }
  function writeMultiLineStringGeometry(geometry, options) {
    return {
      type: "MultiLineString",
      coordinates: geometry.getCoordinates()
    };
  }
  function writeMultiPointGeometry(geometry, options) {
    return {
      type: "MultiPoint",
      coordinates: geometry.getCoordinates()
    };
  }
  function writeMultiPolygonGeometry(geometry, options) {
    let right;
    if (options) {
      right = options.rightHanded;
    }
    return {
      type: "MultiPolygon",
      coordinates: geometry.getCoordinates(right)
    };
  }
  function writePointGeometry(geometry, options) {
    return {
      type: "Point",
      coordinates: geometry.getCoordinates()
    };
  }
  function writePolygonGeometry(geometry, options) {
    let right;
    if (options) {
      right = options.rightHanded;
    }
    return {
      type: "Polygon",
      coordinates: geometry.getCoordinates(right)
    };
  }
  var GeoJSON_default = GeoJSON;

  // node_modules/uuid/dist/esm-browser/rng.js
  var getRandomValues;
  var rnds8 = new Uint8Array(16);
  function rng() {
    if (!getRandomValues) {
      getRandomValues = typeof crypto !== "undefined" && crypto.getRandomValues && crypto.getRandomValues.bind(crypto);
      if (!getRandomValues) {
        throw new Error("crypto.getRandomValues() not supported. See https://github.com/uuidjs/uuid#getrandomvalues-not-supported");
      }
    }
    return getRandomValues(rnds8);
  }

  // node_modules/uuid/dist/esm-browser/stringify.js
  var byteToHex = [];
  for (let i4 = 0; i4 < 256; ++i4) {
    byteToHex.push((i4 + 256).toString(16).slice(1));
  }
  function unsafeStringify(arr, offset2 = 0) {
    return byteToHex[arr[offset2 + 0]] + byteToHex[arr[offset2 + 1]] + byteToHex[arr[offset2 + 2]] + byteToHex[arr[offset2 + 3]] + "-" + byteToHex[arr[offset2 + 4]] + byteToHex[arr[offset2 + 5]] + "-" + byteToHex[arr[offset2 + 6]] + byteToHex[arr[offset2 + 7]] + "-" + byteToHex[arr[offset2 + 8]] + byteToHex[arr[offset2 + 9]] + "-" + byteToHex[arr[offset2 + 10]] + byteToHex[arr[offset2 + 11]] + byteToHex[arr[offset2 + 12]] + byteToHex[arr[offset2 + 13]] + byteToHex[arr[offset2 + 14]] + byteToHex[arr[offset2 + 15]];
  }

  // node_modules/uuid/dist/esm-browser/native.js
  var randomUUID = typeof crypto !== "undefined" && crypto.randomUUID && crypto.randomUUID.bind(crypto);
  var native_default = {
    randomUUID
  };

  // node_modules/uuid/dist/esm-browser/v4.js
  function v4(options, buf, offset2) {
    if (native_default.randomUUID && !buf && !options) {
      return native_default.randomUUID();
    }
    options = options || {};
    const rnds = options.random || (options.rng || rng)();
    rnds[6] = rnds[6] & 15 | 64;
    rnds[8] = rnds[8] & 63 | 128;
    if (buf) {
      offset2 = offset2 || 0;
      for (let i4 = 0; i4 < 16; ++i4) {
        buf[offset2 + i4] = rnds[i4];
      }
      return buf;
    }
    return unsafeStringify(rnds);
  }
  var v4_default = v4;

  // node_modules/mobility-toolbox-js/common/layers/LayerCommon.js
  var Layer2 = class extends Object_default {
    /**
     * Constructor
     *
     * @param {Object} options
     * @param {string} [options.key=uuid()] Identifier of the layer. Muste be unique. Default use a generated uuid.
     * @param {string} [options.name] Name of the layer.
     * @param {string[]} [options.copyrights] Array of copyrights.
     * @param {Array<Layer>} [options.children=[]] Sublayers, all child layers will have a parent property associated to this layer.
     * @param {boolean} [options.visible=true]  Define if the layer is currently display on the map.
     * @param {boolean} [options.disabled=false] Define if the layer is currently display on the map but can't be seen (extent, zoom ,data restrictions).
     * @param {number} [options.hitTolerance=5] Hit-detection tolerance in css pixels. Pixels inside the radius around the given position will be checked for features.
     * @param {Object} [options.properties={}] Application-specific layer properties.
     */
    constructor(options = {}) {
      super();
      this.properties = {};
      this.options = {};
      this.defineProperties(options);
      if (options.properties) {
        this.setProperties(options.properties);
      }
      this.options = options;
      this.visible = options.visible === void 0 ? true : !!options.visible;
      this.group = options.group;
      this.copyrights = options.copyrights;
      this.children = options.children;
      this.on(`change:visible:group`, (evt) => {
        if (this.group === evt.target.group && this !== evt.target && this.visible) {
          this.visible = false;
        } else if (this.children) {
          this.children.forEach((child) => child.dispatchEvent(evt));
        }
      });
    }
    /**
     * Define layer's properties that needs custom get and set.
     *
     * @ignore
     */
    defineProperties(options = {}) {
      const { name, key, properties, hitTolerance } = Object.assign({}, options);
      const uid = v4_default();
      Object.defineProperties(this, {
        /* Layer's information properties */
        name: {
          value: name
        },
        key: {
          value: key || name || uid
        },
        group: {
          get: () => this.get("group"),
          set: (newGroup) => {
            this.set("group", newGroup);
          }
        },
        copyrights: {
          get: () => this.get("copyrights"),
          set: (newCopyrights) => {
            const arrValue = newCopyrights && !Array.isArray(newCopyrights) ? [newCopyrights] : newCopyrights;
            this.set("copyrights", arrValue || []);
          }
        },
        // options is used for clone function.
        options: {
          value: options
        },
        map: {
          writable: true
        },
        /* Layer's state properties */
        visible: {
          get: () => this.get("visible"),
          set: (newVisible) => {
            if (newVisible === this.visible) {
              return;
            }
            this.set("visible", newVisible);
            if (this.visible) {
              if (this.parent) {
                this.parent.visible = true;
              }
              if (this.children && !this.children.some((child) => child.visible)) {
                this.children.forEach((child) => {
                  child.visible = true;
                });
              }
              if (this.parent && this.group) {
                let higherParent = this.parent;
                while (higherParent.parent) {
                  higherParent = higherParent.parent;
                }
                const evt = new Event_default(`change:visible:group`);
                evt.target = this;
                higherParent.dispatchEvent(evt);
              }
            } else if (!this.visible) {
              if (this.children) {
                this.children.forEach((child) => {
                  child.visible = false;
                });
              }
              if (this.parent && this.parent.visible && this.parent.children && !this.parent.children.find((child) => child.visible)) {
                this.parent.visible = false;
              }
            }
          }
        },
        disabled: {
          get: () => this.get("disabled"),
          set: (newValue) => {
            this.set("disabled", newValue);
          }
        },
        /* Layer's hierarchy properties */
        parent: {
          value: null,
          writable: true
        },
        children: {
          get: () => this.get("children") || [],
          set: (newValue) => {
            (this.children || []).forEach((child) => {
              child.parent = void 0;
            });
            if (Array.isArray(newValue)) {
              newValue.forEach((child) => {
                child.parent = this;
              });
            }
            this.set("children", newValue || []);
          }
        },
        /* Layer's query properties */
        hitTolerance: {
          value: hitTolerance || 5,
          writable: true
        },
        /* Custom app specific properties */
        properties: {
          value: Object.assign({}, properties || {})
        }
      });
    }
    /**
     * Initialize the layer with the map passed in parameters.
     *
     * @param {ol/Map~Map|mapboxgl.Map} map A map.
     */
    attachToMap(map2) {
      this.detachFromMap();
      this.map = map2;
      if (this.children) {
        this.children.forEach((child) => {
          child.attachToMap(map2);
        });
      }
    }
    /**
     * Terminate what was initialized in init function. Remove layer, events...
     */
    // eslint-disable-next-line class-methods-use-this
    detachFromMap() {
      this.map = void 0;
    }
    /**
     * Request feature information for a given coordinate.
     * This function must be implemented by inheriting layers.
     *
     * @param {ol/coordinate~Coordinate} coordinate Coordinate.
     * @param {Object} options Some options. See child classes to see which are supported.
     * @return {Promise<FeatureInfo>} An empty response.
     */
    // eslint-disable-next-line no-unused-vars,@typescript-eslint/no-unused-vars
    getFeatureInfoAtCoordinate(coordinate, options) {
      console.error("getFeatureInfoAtCoordinate must be implemented by inheriting layers", this.key);
      return Promise.resolve({
        layer: this,
        features: [],
        coordinate
      });
    }
    /**
     * Return the an array containing all the descendants of the layer in a flat array. Including the current layer.
     */
    flat() {
      return getLayersAsFlatArray_default(this);
    }
  };

  // node_modules/mobility-toolbox-js/common/mixins/UserInteractionsLayerMixin.js
  function UserInteractionsLayerMixin(Base) {
    return class extends Base {
      constructor(options = {}) {
        super(options);
        const { userInteractions = true, userClickInteractions = true, userHoverInteractions = true, defaultUserInteractions = true } = options;
        this.userInteractions = userInteractions;
        this.userClickInteractions = userClickInteractions;
        this.userHoverInteractions = userHoverInteractions;
        this.defaultUserInteractions = defaultUserInteractions;
        this.userClickCallbacks = [];
        this.userHoverCallbacks = [];
        this.userClickEventsKeys = [];
        this.userHoverEventsKeys = [];
        this.onUserClickCallback = this.onUserClickCallback.bind(this);
        this.onUserMoveCallback = this.onUserMoveCallback.bind(this);
        const { onClick, onHover } = options;
        if (this.userInteractions && this.userClickInteractions && onClick) {
          this.onClick(onClick);
        }
        if (this.userInteractions && this.userHoverInteractions && onHover) {
          this.onHover(onHover);
        }
      }
      attachToMap(map2) {
        super.attachToMap(map2);
        if (this.userInteractions && this.defaultUserInteractions && this.userClickInteractions && this.onFeatureClick) {
          this.onClick(this.onFeatureClick);
        }
        if (this.userInteractions && this.defaultUserInteractions && this.userHoverInteractions && this.onFeatureHover) {
          this.onHover(this.onFeatureHover);
        }
        this.listenEvents();
      }
      detachFromMap() {
        this.unlistenEvents();
        super.detachFromMap();
      }
      listenEvents() {
        this.unlistenEvents();
        this.userClickCallbacks.forEach((callback) => {
          this.userClickEventsKeys.push(this.on(
            // @ts-ignore
            "user:click",
            ({ target: { features, layer, coordinate, event } }) => {
              callback(features, layer, coordinate, event);
            }
          ));
        });
        this.userHoverCallbacks.forEach((callback) => {
          this.userHoverEventsKeys.push(this.on(
            // @ts-ignore
            "user:hover",
            ({ target: { features, layer, coordinate, event } }) => {
              callback(features, layer, coordinate, event);
            }
          ));
        });
      }
      unlistenEvents() {
        unByKey(this.userClickEventsKeys);
        unByKey(this.userHoverEventsKeys);
        this.userClickEventsKeys = [];
        this.userHoverEventsKeys = [];
      }
      /**
       * Listens to click events on the layer.
       * @param {function} callback Callback function, called with the clicked
       *   features,
       *   the layer instance and the click event.
       */
      onClick(callback) {
        this.userClickCallbacks.push(callback);
        this.activateUserInteractions();
        if (this.map) {
          this.listenEvents();
        }
      }
      /**
       * Listens to hover events on the layer.
       * @param {function} callback Callback function, called with the clicked
       *   features, the layer instance and the click event.
       */
      onHover(callback) {
        this.userHoverCallbacks.push(callback);
        this.activateUserInteractions();
        if (this.map) {
          this.listenEvents();
        }
      }
      /**
       * Unlistens to click events on the layer.
       * @param {function} callback Callback function, called with the clicked
       *   features,
       *   the layer instance and the click event.
       */
      unClick(callback) {
        const index = this.userClickCallbacks.indexOf(callback);
        if (index !== -1) {
          return;
        }
        this.userClickCallbacks = this.userClickCallbacks.slice(index, 1);
        if (this.map) {
          this.listenEvents();
        }
      }
      /**
       * Unlistens to hover events on the layer.
       * @param {function} callback Callback function, called with the clicked
       *   features, the layer instance and the click event.
       */
      unHover(callback) {
        const index = this.userHoverCallbacks.indexOf(callback);
        if (index !== -1) {
          return;
        }
        this.userHoverCallbacks = this.userHoverCallbacks.slice(index, 1);
        if (this.map) {
          this.listenEvents();
        }
      }
      /**
       * Function triggered when the user click the map.
       * @private
       */
      onUserClickCallback(evt) {
        const coordinate = evt.coordinate || fromLonLat(evt.lngLat.toArray());
        const emptyFeatureInfo = {
          features: [],
          layer: this,
          coordinate,
          event: evt
        };
        return this.getFeatureInfoAtCoordinate(coordinate).then((featureInfo) => {
          const event = new Event_default("user:click");
          event.target = featureInfo;
          this.dispatchEvent(event);
          return featureInfo;
        }).catch(() => emptyFeatureInfo);
      }
      /**
       * Function triggered when the user move the cursor.
       * @private
       */
      onUserMoveCallback(evt) {
        const coordinate = evt.coordinate || fromLonLat(evt.lngLat.toArray());
        const emptyFeatureInfo = {
          features: [],
          layer: this,
          coordinate,
          event: evt
        };
        return this.getFeatureInfoAtCoordinate(coordinate).then((featureInfo) => {
          const event = new Event_default("user:hover");
          event.target = featureInfo;
          this.dispatchEvent(event);
          return featureInfo;
        }).catch(() => emptyFeatureInfo);
      }
      activateUserInteractions() {
      }
      deactivateUserInteractions() {
      }
    };
  }
  var UserInteractionsLayerMixin_default = UserInteractionsLayerMixin;

  // node_modules/mobility-toolbox-js/ol/layers/Layer.js
  var Layer3 = class _Layer extends UserInteractionsLayerMixin_default(Layer2) {
    /**
     * Constructor.
     *
     * @param {LayerCommonOptions} options
     * @param {ol/layer/Layer~Layer} options.olLayer The layer (required).
     * @param {string} [options.name=uuid()] Layer name. Default use a generated uuid.
     * @param {string} [options.key=uuid().toLowerCase()] Layer key, will use options.name.toLowerCase() if not specified.
     * @param {string} [options.copyright=undefined] Copyright-Statement.
     * @param {Array<Layer>} [options.children=[]] Sublayers.
     * @param {Object} [options.properties={}] Application-specific layer properties.
     * @param {boolean} [options.visible=true] If true this layer is the currently visible layer on the map.
     */
    constructor(options) {
      var _a;
      super(options);
      (_a = this.olLayer) === null || _a === void 0 ? void 0 : _a.setVisible(this.visible);
    }
    /**
     * Define layer's properties.
     *
     * @ignore
     */
    defineProperties(options) {
      super.defineProperties(options);
      Object.defineProperties(this, {
        olLayer: { value: options.olLayer, writable: true },
        olListenersKeys: {
          value: []
        }
      });
    }
    /**
     * Initialize the layer and listen to feature clicks.
     * @param {ol/Map~Map} map
     */
    attachToMap(map2) {
      var _a, _b, _c, _d, _e;
      super.attachToMap(map2);
      if (!this.map) {
        return;
      }
      (_a = this.olLayer) === null || _a === void 0 ? void 0 : _a.setVisible(this.visible);
      if (this.olLayer && !((_d = (_c = (_b = this.map) === null || _b === void 0 ? void 0 : _b.getLayers()) === null || _c === void 0 ? void 0 : _c.getArray()) === null || _d === void 0 ? void 0 : _d.includes(this.olLayer))) {
        this.map.addLayer(this.olLayer);
      }
      this.olListenersKeys.push(
        // @ts-ignore
        this.on("change:visible", () => {
          if (this.olLayer) {
            this.olLayer.setVisible(this.visible);
          }
        })
      );
      this.olListenersKeys.push(
        // @ts-ignore
        this.on("change:minZoom", () => {
          if (this.olLayer && this.get("minZoom")) {
            this.olLayer.setMinZoom(this.get("minZoom"));
          }
        })
      );
      this.olListenersKeys.push(
        // @ts-ignore
        this.on("change:maxZoom", () => {
          if (this.olLayer && this.get("maxZoom")) {
            this.olLayer.setMaxZoom(this.get("maxZoom"));
          }
        })
      );
      this.olListenersKeys.push(this.map.getLayers().on("remove", (evt) => {
        if (evt.element === this.olLayer) {
          this.detachFromMap();
        }
      }));
      this.toggleVisibleListeners();
      this.olListenersKeys.push(
        // @ts-ignore
        this.on("change:visible", this.toggleVisibleListeners)
      );
      if (this.copyrights && this.olLayer) {
        const attributions = this.copyrights || [];
        if (this.olLayer.getLayers) {
          this.olLayer.getLayers().getArray().forEach((layer) => {
            var _a2;
            if (layer.getSource) {
              (_a2 = layer.getSource()) === null || _a2 === void 0 ? void 0 : _a2.setAttributions(attributions);
            }
          });
        } else if (this.olLayer.getSource) {
          (_e = this.olLayer.getSource()) === null || _e === void 0 ? void 0 : _e.setAttributions(attributions);
        }
      }
    }
    /**
     * Terminate what was initialized in init function. Remove layer, events...
     */
    detachFromMap() {
      var _a, _b, _c;
      this.deactivateUserInteractions();
      unByKey(this.olListenersKeys);
      if (this.olLayer && ((_c = (_b = (_a = this.map) === null || _a === void 0 ? void 0 : _a.getLayers()) === null || _b === void 0 ? void 0 : _b.getArray()) === null || _c === void 0 ? void 0 : _c.includes(this.olLayer))) {
        this.map.removeLayer(this.olLayer);
      }
      super.detachFromMap();
    }
    activateUserInteractions() {
      var _a, _b;
      this.deactivateUserInteractions();
      if (this.map && this.userInteractions && this.userClickInteractions && ((_a = this.userClickCallbacks) === null || _a === void 0 ? void 0 : _a.length)) {
        this.singleClickListenerKey = this.map.on("singleclick", this.onUserClickCallback);
        this.olListenersKeys.push(this.singleClickListenerKey);
      }
      if (this.map && this.userInteractions && this.userHoverInteractions && ((_b = this.userHoverCallbacks) === null || _b === void 0 ? void 0 : _b.length)) {
        this.pointerMoveListenerKey = this.map.on("pointermove", this.onUserMoveCallback);
      }
    }
    deactivateUserInteractions() {
      unByKey([this.pointerMoveListenerKey, this.singleClickListenerKey]);
    }
    /**
     * Toggle listeners needed when a layer is avisible or not.
     * @private
     */
    toggleVisibleListeners() {
      if (this.visible) {
        this.activateUserInteractions();
      } else {
        this.deactivateUserInteractions();
      }
    }
    /**
     * Create a copy of the Layer.
     * @param {Object} newOptions Options to override
     * @return {Layer} A Layer
     */
    clone(newOptions) {
      return new _Layer(Object.assign(Object.assign({}, this.options), newOptions));
    }
  };
  var Layer_default4 = Layer3;

  // node_modules/mobility-toolbox-js/ol/layers/MapGlLayer.js
  var MapGlLayer = class extends Layer_default4 {
    constructor(options) {
      super(options);
      this.olLayer = new Layer_default({
        source: new Source_default({}),
        render: this.getOlLayerRender()
      });
      this.styleUrl = options.url;
      this.apiKey = options.apiKey;
      this.apiKeyName = options.apiKeyName || "key";
      this.updateAttribution = this.updateAttribution.bind(this);
    }
    /**
     * Initialize the layer and listen to feature clicks.
     * @param {ol/Map~Map} map
     */
    attachToMap(map2) {
      super.attachToMap(map2);
      if (!this.map) {
        return;
      }
      this.format = new GeoJSON_default({
        featureProjection: this.map.getView().getProjection()
      });
      this.loadMbMap();
    }
    /**
     * Terminate what was initialized in init function. Remove layer, events...
     */
    detachFromMap() {
      if (this.mbMap) {
        this.mbMap.off("idle", this.updateAttribution);
        this.mbMap.triggerRepaint = () => {
        };
        this.mbMap.remove();
        this.mbMap = void 0;
      }
      this.loaded = false;
      super.detachFromMap();
    }
    /**
     * Create the mapbox map.
     * @private
     */
    loadMbMap() {
      var _a, _b, _c;
      this.olListenersKeys.push(
        // @ts-ignore
        (_a = this.map) === null || _a === void 0 ? void 0 : _a.on("change:target", () => {
          this.loadMbMap();
        })
      );
      if (!((_b = this.map) === null || _b === void 0 ? void 0 : _b.getTargetElement())) {
        return;
      }
      if (!this.visible) {
        this.olListenersKeys.push(
          // @ts-ignore
          this.once("change:visible", () => {
            this.loadMbMap();
          })
        );
        return;
      }
      const container = document.createElement("div");
      container.style.position = "absolute";
      container.style.width = "100%";
      container.style.height = "100%";
      if (!this.styleUrl) {
        console.error(`No styleUrl defined for mapbox layer: ${this.styleUrl}`);
        return;
      }
      if (!this.apiKey && !((_c = this.styleUrl) === null || _c === void 0 ? void 0 : _c.includes(this.apiKeyName))) {
        console.error(`No apiKey defined for mapbox layer with style url to ${this.styleUrl}`);
      }
      const Map5 = this.getMapboxMapClass();
      this.mbMap = new Map5(Object.assign({ style: getUrlWithParams_default(this.styleUrl, {
        [this.apiKeyName]: this.apiKey
      }).toString(), container, interactive: false, trackResize: false, attributionControl: false }, this.options.mapOptions || {}));
      this.mbMap.once("load", () => {
        this.loaded = true;
        this.dispatchEvent(new Event_default("load"));
      });
      this.mbMap.on("idle", this.updateAttribution);
    }
    /**
     * Update attributions of the source.
     * @private
     */
    updateAttribution(evt) {
      var _a, _b, _c;
      const newAttributions = getMapboxMapCopyrights_default(evt.target) || [];
      if (((_a = this.copyrights) === null || _a === void 0 ? void 0 : _a.toString()) !== newAttributions.toString()) {
        this.copyrights = newAttributions;
        (_c = (_b = this.olLayer) === null || _b === void 0 ? void 0 : _b.getSource()) === null || _c === void 0 ? void 0 : _c.setAttributions(newAttributions);
      }
    }
    /**
     * Request feature information for a given coordinate.
     * @param {ol/coordinate~Coordinate} coordinate Coordinate to request the information at.
     * @param {Object} options A [mapboxgl.Map#queryrenderedfeatures](https://docs.mapbox.com/mapbox-gl-js/api/map/#map#queryrenderedfeatures) options parameter.
     * @return {Promise<FeatureInfo>} Promise with features, layer and coordinate. The original Mapbox feature is available as a property named 'mapboxFeature'.
     */
    getFeatureInfoAtCoordinate(coordinate, options) {
      if (!options || !this.format || !this.mbMap || !this.mbMap.isStyleLoaded()) {
        return Promise.resolve({ coordinate, features: [], layer: this });
      }
      const pixel = coordinate && this.mbMap.project(toLonLat(coordinate));
      let pixels;
      if (this.hitTolerance) {
        const { x: x2, y: y2 } = pixel;
        pixels = [
          {
            x: x2 - this.hitTolerance,
            y: y2 - this.hitTolerance
          },
          {
            x: x2 + this.hitTolerance,
            y: y2 + this.hitTolerance
          }
        ];
      }
      const features = this.mbMap.queryRenderedFeatures(pixels || pixel, options).map((feature) => {
        const olFeature = this.format.readFeature(feature);
        if (olFeature) {
          olFeature.set("mapboxFeature", feature);
        }
        return olFeature;
      });
      return Promise.resolve({
        layer: this,
        features,
        coordinate
      });
    }
    /**
     * Return the render function function for the ol layer.
     *
     */
    // eslint-disable-next-line class-methods-use-this
    getOlLayerRender() {
      console.error("This function must be implemented in subclasses");
      const div = document.createElement("div");
      return () => div;
    }
    /**
     * Return the Class to instanciate for the mapbox map.
     *
     * @return {mapboxgl.Map|maplibregl.Map} map
     */
    // eslint-disable-next-line class-methods-use-this
    getMapboxMapClass() {
      console.error("This function must be implemented in subclasses");
      return null;
    }
  };
  var MapGlLayer_default = MapGlLayer;

  // node_modules/mobility-toolbox-js/ol/layers/MaplibreLayer.js
  var import_maplibre_gl = __toESM(require_maplibre_gl());
  var MaplibreLayer = class _MaplibreLayer extends MapGlLayer_default {
    getOlLayerRender() {
      return getMaplibreRender(this);
    }
    // eslint-disable-next-line class-methods-use-this
    getMapboxMapClass() {
      return import_maplibre_gl.Map;
    }
    /**
     * Create a copy of the MapboxLayer.
     * @param {Object} newOptions Options to override
     * @return {MapboxLayer} A MapboxLayer
     */
    clone(newOptions) {
      return new _MaplibreLayer(Object.assign(Object.assign({}, this.options), newOptions));
    }
  };

  // node_modules/mobility-toolbox-js/common/mixins/RealtimeLayerMixin.js
  var import_lodash = __toESM(require_lodash());
  var import_lodash2 = __toESM(require_lodash2());
  function RealtimeLayerMixin(Base) {
    return class Mixin extends Base {
      constructor(options) {
        super(Object.assign({ hitTolerance: 10 }, options));
        this.debug = options.debug || false;
        this.mode = options.mode || RealtimeModes.TOPOGRAPHIC;
        this.api = options.api || new RealtimeAPI_default(options);
        this.tenant = options.tenant || "";
        this.minZoomInterpolation = options.minZoomInterpolation || 8;
        this.format = new GeoJSON_default();
        this.onStart = options.onStart;
        this.onStop = options.onStop;
        const allMots = [
          "tram",
          "subway",
          "rail",
          "bus",
          "ferry",
          "cablecar",
          "gondola",
          "funicular",
          "coach"
        ];
        const onlyRail = ["rail"];
        const withoutCable = ["tram", "subway", "rail", "bus"];
        this.motsByZoom = options.motsByZoom || [
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          onlyRail,
          withoutCable,
          withoutCable,
          allMots,
          allMots,
          allMots,
          allMots
        ];
        this.getMotsByZoom = (zoom) => {
          return options.getMotsByZoom && options.getMotsByZoom(zoom, this.motsByZoom) || this.motsByZoom[zoom] || this.motsByZoom[this.motsByZoom.length - 1];
        };
        this.generalizationLevelByZoom = options.generalizationLevelByZoom || [
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          5,
          10,
          30,
          30,
          100,
          100,
          100
        ];
        this.getGeneralizationLevelByZoom = (zoom) => {
          return options.getGeneralizationLevelByZoom && options.getGeneralizationLevelByZoom(zoom, this.generalizationLevelByZoom) || this.generalizationLevelByZoom[zoom];
        };
        this.renderTimeIntervalByZoom = options.renderTimeIntervalByZoom || [
          1e5,
          5e4,
          4e4,
          3e4,
          2e4,
          15e3,
          1e4,
          5e3,
          2e3,
          1e3,
          400,
          300,
          250,
          180,
          90,
          60,
          50,
          50,
          50,
          50,
          50
        ];
        this.getRenderTimeIntervalByZoom = (zoom) => {
          return options.getRenderTimeIntervalByZoom && options.getRenderTimeIntervalByZoom(zoom, this.renderTimeIntervalByZoom) || this.renderTimeIntervalByZoom[zoom];
        };
        this.isUpdateBboxOnMoveEnd = options.isUpdateBboxOnMoveEnd !== false;
        this.throttleRenderTrajectories = (0, import_lodash2.default)(this.renderTrajectoriesInternal, 50, { leading: false, trailing: true });
        this.debounceRenderTrajectories = (0, import_lodash.default)(this.renderTrajectoriesInternal, 50, { leading: true, trailing: true, maxWait: 5e3 });
        this.onFeatureHover = this.onFeatureHover.bind(this);
        this.onFeatureClick = this.onFeatureClick.bind(this);
        this.renderTrajectoriesInternal = this.renderTrajectoriesInternal.bind(this);
        this.onTrajectoryMessage = this.onTrajectoryMessage.bind(this);
        this.onDeleteTrajectoryMessage = this.onDeleteTrajectoryMessage.bind(this);
        this.onDocumentVisibilityChange = this.onDocumentVisibilityChange.bind(this);
      }
      /**
       * Define layer's properties.
       *
       * @ignore
       */
      defineProperties(options) {
        const { style, speed, pixelRatio, hoverVehicleId, selectedVehicleId, filter, sort, time, live, canvas, styleOptions, mode } = options;
        let currCanvas = canvas;
        let currSpeed = speed || 1;
        let currTime = time || /* @__PURE__ */ new Date();
        let currMode = mode || RealtimeModes.TOPOGRAPHIC;
        let currStyle = style || realtimeDefaultStyle_default;
        super.defineProperties(options);
        Object.defineProperties(this, {
          isTrackerLayer: { value: true },
          canvas: {
            get: () => {
              if (!currCanvas) {
                currCanvas = document.createElement("canvas");
              }
              return currCanvas;
            },
            set: (cnvas) => {
              currCanvas = cnvas;
            }
          },
          /**
           * Style function used to render a vehicle.
           */
          mode: {
            get: () => currMode,
            set: (newMode) => {
              var _a, _b;
              if (newMode === currMode) {
                return;
              }
              currMode = newMode;
              if ((_b = (_a = this.api) === null || _a === void 0 ? void 0 : _a.wsApi) === null || _b === void 0 ? void 0 : _b.open) {
                this.stop();
                this.start();
              }
            }
          },
          /**
           * Style function used to render a vehicle.
           */
          style: {
            get: () => currStyle,
            set: (newStyle) => {
              currStyle = newStyle;
              this.renderTrajectories();
            }
          },
          /**
           * Custom options to pass as last parameter of the style function.
           */
          styleOptions: {
            value: Object.assign(Object.assign({}, realtimeConfig_exports), styleOptions || {})
          },
          /**
           * Speed of the wheel of time.
           * If live property is true. The speed is ignored.
           */
          speed: {
            get: () => currSpeed,
            set: (newSpeed) => {
              currSpeed = newSpeed;
              this.start();
            }
          },
          /**
           * Function to filter which vehicles to display.
           */
          filter: {
            value: filter,
            writable: true
          },
          /**
           * Function to sort the vehicles to display.
           */
          sort: {
            value: sort,
            writable: true
          },
          /**
           * If true. The layer will always use Date.now() on the next tick to render the trajectories.
           * When true, setting the time property has no effect.
           */
          live: {
            value: live === false ? live : true,
            writable: true
          },
          /**
           * Time used to display the trajectories. Can be a Date or a number in ms representing a Date.
           * If live property is true. The setter does nothing.
           */
          time: {
            get: () => currTime,
            set: (newTime) => {
              currTime = newTime && newTime.getTime ? newTime : new Date(newTime);
              this.renderTrajectories();
            }
          },
          /**
           * Keep track of which trajectories are stored.
           */
          trajectories: {
            value: {},
            writable: true
          },
          /**
           * Id of the hovered vehicle.
           */
          hoverVehicleId: {
            value: hoverVehicleId,
            writable: true
          },
          /**
           * Id of the selected vehicle.
           */
          selectedVehicleId: {
            value: selectedVehicleId,
            writable: true
          },
          /**
           * Id of the selected vehicle.
           */
          pixelRatio: {
            value: pixelRatio || (typeof window !== "undefined" ? window.devicePixelRatio : 1),
            writable: true
          },
          /**
           * If true, encapsulates the renderTrajectories calls in a requestAnimationFrame.
           */
          useRequestAnimationFrame: {
            value: options.useRequestAnimationFrame || false,
            writable: true
          },
          /**
           * If true, encapsulates the renderTrajectories calls in a throttle function. Default to true.
           */
          useThrottle: {
            value: options.useThrottle !== false,
            writable: true
          },
          /**
           * If true, encapsulates the renderTrajectories calls in a debounce function.
           */
          useDebounce: {
            value: options.useDebounce || false,
            writable: true
          }
          /**
           * Debug properties.
           */
          // Not used anymore, but could be useful for debugging.
          // showVehicleTraj: {
          //   value:
          //     options.showVehicleTraj !== undefined
          //       ? options.showVehicleTraj
          //       : true,
          //   writable: true,
          // },
        });
      }
      attachToMap(map2) {
        super.attachToMap(map2);
        if (this.visible) {
          this.start();
        }
        this.visibilityRef = this.on("change:visible", (evt) => {
          if (evt.target.visible) {
            this.start();
          } else {
            this.stop();
          }
        });
        document.addEventListener("visibilitychange", this.onDocumentVisibilityChange);
      }
      detachFromMap() {
        document.removeEventListener("visibilitychange", this.onDocumentVisibilityChange);
        this.stop();
        unByKey(this.visibilityRef);
        if (this.canvas) {
          const context = this.canvas.getContext("2d");
          if (context) {
            context.clearRect(0, 0, this.canvas.width, this.canvas.height);
          }
          super.detachFromMap();
        }
      }
      start() {
        this.stop();
        this.purgeOutOfDateTrajectories();
        this.renderTrajectories();
        this.startUpdateTime();
        this.api.open();
        this.api.subscribeTrajectory(this.mode, this.onTrajectoryMessage, void 0, this.isUpdateBboxOnMoveEnd);
        this.api.subscribeDeletedVehicles(this.mode, this.onDeleteTrajectoryMessage, void 0, this.isUpdateBboxOnMoveEnd);
        if (this.isUpdateBboxOnMoveEnd) {
          this.setBbox();
        }
        if (this.onStart) {
          this.onStart(this);
        }
      }
      /**
       * Start the clock.
       * @private
       */
      startUpdateTime() {
        this.stopUpdateTime();
        this.updateTimeDelay = this.getRefreshTimeInMs() || 0;
        this.updateTimeInterval = window.setInterval(() => {
          if (this.live) {
            this.time = /* @__PURE__ */ new Date();
          } else if (this.time && this.updateTimeDelay && this.speed) {
            this.time = new Date(this.time.getTime() + this.updateTimeDelay * this.speed);
          }
        }, this.updateTimeDelay);
      }
      stop() {
        this.api.unsubscribeTrajectory(this.onTrajectoryMessage);
        this.api.unsubscribeDeletedVehicles(this.onDeleteTrajectoryMessage);
        this.api.close();
        if (this.onStop) {
          this.onStop(this);
        }
      }
      /**
       * Stop the clock.
       * @private
       */
      stopUpdateTime() {
        if (this.updateTimeInterval) {
          clearInterval(this.updateTimeInterval);
          this.updateTimeInterval = void 0;
        }
      }
      /**
       * Launch renderTrajectories. it avoids duplicating code in renderTrajectories method.
       *
       * @param {object} viewState The view state of the map.
       * @param {number[2]} viewState.center Center coordinate of the map in mercator coordinate.
       * @param {number[4]} viewState.extent Extent of the map in mercator coordinates.
       * @param {number[2]} viewState.size Size ([width, height]) of the canvas to render.
       * @param {number} [viewState.rotation = 0] Rotation of the map to render.
       * @param {number} viewState.resolution Resolution of the map to render.
       * @param {boolean} noInterpolate If true trajectories are not interpolated but
       *   drawn at the last known coordinate. Use this for performance optimization
       *   during map navigation.
       * @private
       */
      renderTrajectoriesInternal(viewState, noInterpolate = false) {
        var _a;
        if (!this.map || !this.trajectories) {
          return false;
        }
        const time = this.live ? Date.now() : (_a = this.time) === null || _a === void 0 ? void 0 : _a.getTime();
        const trajectories = Object.values(this.trajectories);
        if (this.sort) {
          trajectories.sort(this.sort);
        }
        if (!this.canvas || !this.style) {
          return true;
        }
        this.renderState = renderTrajectories_default(this.canvas, trajectories, this.style, Object.assign(Object.assign({}, viewState), { pixelRatio: this.pixelRatio || 1, time }), Object.assign({ filter: this.filter, noInterpolate: (viewState.zoom || 0) < this.minZoomInterpolation ? true : noInterpolate, hoverVehicleId: this.hoverVehicleId, selectedVehicleId: this.selectedVehicleId }, this.styleOptions));
        return true;
      }
      /**
       * Render the trajectories requesting an animation frame and cancelling the previous one.
       * This function must be overrided by children to provide the correct parameters.
       *
       * @param {object} viewState The view state of the map.
       * @param {number[2]} viewState.center Center coordinate of the map in mercator coordinate.
       * @param {number[4]} viewState.extent Extent of the map in mercator coordinates.
       * @param {number[2]} viewState.size Size ([width, height]) of the canvas to render.
       * @param {number} [viewState.rotation = 0] Rotation of the map to render.
       * @param {number} viewState.resolution Resolution of the map to render.
       * @param {boolean} noInterpolate If true trajectories are not interpolated but
       *   drawn at the last known coordinate. Use this for performance optimization
       *   during map navigation.
       * @private
       */
      renderTrajectories(viewState, noInterpolate) {
        if (this.requestId) {
          cancelAnimationFrame(this.requestId);
          this.requestId = void 0;
        }
        if (!viewState) {
          return;
        }
        if (!noInterpolate && this.useRequestAnimationFrame) {
          this.requestId = requestAnimationFrame(() => {
            this.renderTrajectoriesInternal(viewState, noInterpolate);
          });
        } else if (!noInterpolate && this.useDebounce) {
          this.debounceRenderTrajectories(viewState, noInterpolate);
        } else if (!noInterpolate && this.useThrottle) {
          this.throttleRenderTrajectories(viewState, noInterpolate);
        } else {
          this.renderTrajectoriesInternal(viewState, noInterpolate);
        }
      }
      setBbox(extent, zoom) {
        if (this.trajectories && extent && zoom) {
          const keys = Object.keys(this.trajectories);
          for (let i4 = keys.length - 1; i4 >= 0; i4 -= 1) {
            this.purgeTrajectory(this.trajectories[keys[i4]], extent, zoom);
          }
        }
        if (!extent) {
          return;
        }
        const bbox = [...extent];
        if (this.isUpdateBboxOnMoveEnd && zoom) {
          bbox.push(zoom);
          this.generalizationLevel = this.getGeneralizationLevelByZoom(zoom);
          if (this.generalizationLevel) {
            bbox.push(`gen=${this.generalizationLevel}`);
          }
          this.mots = this.getMotsByZoom(zoom);
          if (this.mots) {
            bbox.push(`mots=${this.mots}`);
          }
        }
        if (this.tenant) {
          bbox.push(`tenant=${this.tenant}`);
        }
        this.api.bbox = bbox;
      }
      /**
       * Get the duration before the next update depending on zoom level.
       *
       * @private
       * @param {number} zoom
       */
      getRefreshTimeInMs(zoom = 0) {
        var _a;
        const roundedZoom = zoom !== void 0 ? Math.round(zoom) : -1;
        const timeStep = this.getRenderTimeIntervalByZoom(roundedZoom) || 25;
        const nextTick = Math.max(25, timeStep / (this.speed || 1));
        const nextThrottleTick = Math.min(nextTick, 500);
        if (this.useThrottle) {
          this.throttleRenderTrajectories = (0, import_lodash2.default)(this.renderTrajectoriesInternal, nextThrottleTick, { leading: true, trailing: true });
        } else if (this.useDebounce) {
          this.debounceRenderTrajectories = (0, import_lodash.default)(this.renderTrajectoriesInternal, nextThrottleTick, { leading: true, trailing: true, maxWait: 5e3 });
        }
        if ((_a = this.api) === null || _a === void 0 ? void 0 : _a.buffer) {
          const [, size] = this.api.buffer;
          this.api.buffer = [nextThrottleTick, size];
        }
        return nextTick;
      }
      /**
       * Get vehicle.
       * @param {function} filterFc A function use to filter results.
       * @return {Array<Object>} Array of vehicle.
       */
      getVehicle(filterFc) {
        return this.trajectories && // @ts-ignore
        Object.values(this.trajectories).filter(filterFc) || [];
      }
      /**
       * Request feature information for a given coordinate.
       *
       * @param {ol/coordinate~Coordinate} coordinate Coordinate.
       * @param {Object} options Options See child classes to see which options are supported.
       * @param {number} [options.resolution=1] The resolution of the map.
       * @param {number} [options.nb=Infinity] The max number of vehicles to return.
       * @return {Promise<FeatureInfo>} Promise with features, layer and coordinate.
       */
      getFeatureInfoAtCoordinate(coordinate, options) {
        const { resolution, nb } = options;
        const ext = buffer([...coordinate, ...coordinate], this.hitTolerance * resolution);
        let trajectories = Object.values(this.trajectories || {});
        if (this.sort) {
          trajectories = trajectories.sort(this.sort);
        }
        const vehicles = [];
        for (let i4 = 0; i4 < trajectories.length; i4 += 1) {
          if (trajectories[i4].properties.coordinate && containsCoordinate(ext, trajectories[i4].properties.coordinate)) {
            vehicles.push(trajectories[i4]);
          }
          if (vehicles.length === nb) {
            break;
          }
        }
        return Promise.resolve({
          layer: this,
          features: vehicles.map((vehicle) => this.format.readFeature(vehicle)),
          coordinate
        });
      }
      /**
       * Request the stopSequence and the fullTrajectory informations for a vehicle.
       *
       * @param {string} id The vehicle identifier (the  train_id property).
       * @return {Promise<{stopSequence: StopSequence, fullTrajectory: FullTrajectory>} A promise that will be resolved with the trajectory informations.
       */
      getTrajectoryInfos(id) {
        const promises = [
          this.api.getStopSequence(id),
          this.api.getFullTrajectory(id, this.mode, this.generalizationLevel)
        ];
        return Promise.all(promises).then(([stopSequence, fullTrajectory]) => {
          const response = {
            stopSequence,
            fullTrajectory
          };
          return response;
        });
      }
      /**
       * Remove all trajectories that are in the past.
       */
      purgeOutOfDateTrajectories() {
        Object.entries(this.trajectories || {}).forEach(([key, trajectory]) => {
          var _a;
          const timeIntervals = (_a = trajectory === null || trajectory === void 0 ? void 0 : trajectory.properties) === null || _a === void 0 ? void 0 : _a.time_intervals;
          if (this.time && timeIntervals.length) {
            const lastTimeInterval = timeIntervals[timeIntervals.length - 1][0];
            if (lastTimeInterval < this.time) {
              this.removeTrajectory(key);
            }
          }
        });
      }
      /**
       * Determine if the trajectory is useless and should be removed from the list or not.
       * By default, this function exclude vehicles:
       *  - that have their trajectory outside the current extent and
       *  - that aren't in the MOT list.
       *
       * @param {RealtimeTrajectory} trajectory
       * @param {Array<number>} extent
       * @param {number} zoom
       * @return {boolean} if the trajectory must be displayed or not.
       * @ignore
       */
      purgeTrajectory(trajectory, extent, zoom) {
        const { type, bounds } = trajectory.properties;
        if (this.isUpdateBboxOnMoveEnd && !intersects(extent, bounds) || this.mots && !this.mots.includes(type)) {
          this.removeTrajectory(trajectory);
          return true;
        }
        return false;
      }
      /**
       * Add a trajectory.
       * @param {RealtimeTrajectory} trajectory The trajectory to add.
       * @private
       */
      addTrajectory(trajectory) {
        if (!this.trajectories) {
          this.trajectories = {};
        }
        this.trajectories[trajectory.properties.train_id] = trajectory;
        this.renderTrajectories();
      }
      removeTrajectory(trajectoryOrId) {
        var _a;
        let id;
        if (typeof trajectoryOrId !== "string") {
          id = (_a = trajectoryOrId === null || trajectoryOrId === void 0 ? void 0 : trajectoryOrId.properties) === null || _a === void 0 ? void 0 : _a.train_id;
        } else {
          id = trajectoryOrId;
        }
        if (this.trajectories) {
          delete this.trajectories[id];
        }
      }
      /**
       * On zoomend we adjust the time interval of the update of vehicles positions.
       *
       * @param evt Event that triggered the function.
       * @private
       */
      onZoomEnd() {
        this.startUpdateTime();
      }
      onDocumentVisibilityChange() {
        if (!this.visible) {
          return;
        }
        if (document.hidden) {
          this.stop();
          this.trajectories = {};
        } else {
          this.start();
        }
      }
      /**
       * Callback on websocket's trajectory channel events.
       * It adds a trajectory to the list.
       *
       * @private
       */
      onTrajectoryMessage(data) {
        if (!data.content) {
          return;
        }
        const trajectory = data.content;
        const { geometry, properties: { train_id: id, time_since_update: timeSinceUpdate, raw_coordinates: rawCoordinates } } = trajectory;
        if (timeSinceUpdate < 0) {
          return;
        }
        if (this.purgeTrajectory(trajectory)) {
          return;
        }
        if (this.debug && this.mode === RealtimeModes.TOPOGRAPHIC && rawCoordinates) {
          trajectory.properties.olGeometry = this.format.readGeometry({
            type: "Point",
            coordinates: fromLonLat(rawCoordinates, this.map.getView().getProjection())
          });
        } else {
          trajectory.properties.olGeometry = this.format.readGeometry(geometry);
        }
        trajectory.properties.timeOffset = Date.now() - data.timestamp;
        this.addTrajectory(trajectory);
      }
      /**
       * Callback on websocket's deleted_vehicles channel events.
       * It removes the trajectory from the list.
       *
       * @private
       * @override
       */
      onDeleteTrajectoryMessage(data) {
        if (!data.content) {
          return;
        }
        this.removeTrajectory(data.content);
      }
      /**
       * Callback when user moves the mouse/pointer over the map.
       * It sets the layer's hoverVehicleId property with the current hovered vehicle's id.
       *
       * @private
       * @override
       */
      onFeatureHover(features, layer, coordinate) {
        const [feature] = features;
        let id = null;
        if (feature) {
          id = feature.get("train_id");
        }
        if (this.hoverVehicleId !== id) {
          this.hoverVehicleId = id;
          this.renderTrajectories(true);
        }
      }
      /**
       * Callback when user clicks on the map.
       * It sets the layer's selectedVehicleId property with the current selected vehicle's id.
       *
       * @private
       * @override
       */
      onFeatureClick(features, layer, coordinate) {
        const [feature] = features;
        let id = null;
        if (feature) {
          id = feature.get("train_id");
        }
        if (this.selectedVehicleId !== id) {
          this.selectedVehicleId = id;
          this.selectedVehicle = feature;
          this.renderTrajectories(true);
        }
      }
    };
  }
  var RealtimeLayerMixin_default = RealtimeLayerMixin;

  // node_modules/mobility-toolbox-js/ol/styles/fullTrajectoryStyle.js
  var borderStyle = new Style_default({
    zIndex: 2,
    image: new Circle_default({
      radius: 5,
      fill: new Fill_default({
        color: "#000000"
      })
    }),
    stroke: new Stroke_default({
      color: "#000000",
      width: 6
    })
  });
  var fullTrajectorystyle = (feature, resolution, options) => {
    let lineColor = "#ffffff";
    const type = feature.get("type");
    let stroke = feature.get("stroke");
    if (stroke && stroke[0] !== "#") {
      stroke = `#${stroke}`;
    }
    lineColor = stroke || (options === null || options === void 0 ? void 0 : options.getBgColor(type));
    lineColor = /#ffffff/i.test(lineColor) ? "#ff0000" : lineColor;
    const style = [
      borderStyle,
      new Style_default({
        zIndex: 3,
        image: new Circle_default({
          radius: 4,
          fill: new Fill_default({
            color: lineColor
          })
        }),
        stroke: new Stroke_default({
          color: lineColor,
          width: 4
        })
      })
    ];
    return style;
  };
  var fullTrajectoryStyle_default = fullTrajectorystyle;

  // node_modules/mobility-toolbox-js/ol/layers/RealtimeLayer.js
  var format = new GeoJSON_default();
  var RealtimeLayer = class _RealtimeLayer extends RealtimeLayerMixin_default(Layer_default4) {
    /**
     * Constructor.
     *
     * @param {Object} options
     * @private
     */
    constructor(options) {
      super(Object.assign({}, options));
      this.allowRenderWhenAnimating = false;
      this.allowRenderWhenAnimating = !!options.allowRenderWhenAnimating;
      this.olLayer = options.olLayer || new Group_default({
        layers: [
          new Vector_default({
            source: new Vector_default2({ features: [] }),
            style: (feature, resolution) => {
              return (options.fullTrajectoryStyle || fullTrajectoryStyle_default)(feature, resolution, this.styleOptions);
            }
          }),
          new Layer_default({
            source: new Source_default({}),
            render: (frameState) => {
              var _a, _b, _c;
              if (!this.container) {
                this.container = document.createElement("div");
                this.container.style.position = "absolute";
                this.container.style.width = "100%";
                this.container.style.height = "100%";
                this.transformContainer = document.createElement("div");
                this.transformContainer.style.position = "absolute";
                this.transformContainer.style.width = "100%";
                this.transformContainer.style.height = "100%";
                this.container.appendChild(this.transformContainer);
                if (this.canvas) {
                  this.canvas.style.position = "absolute";
                  this.canvas.style.top = "0";
                  this.canvas.style.left = "0";
                  this.canvas.style.transformOrigin = "top left";
                  this.transformContainer.appendChild(this.canvas);
                }
              }
              if (this.renderedViewState) {
                const { center, resolution, rotation } = frameState.viewState;
                const { center: renderedCenter, resolution: renderedResolution, rotation: renderedRotation } = this.renderedViewState;
                if (renderedResolution / resolution >= 3) {
                  const context = (_a = this.canvas) === null || _a === void 0 ? void 0 : _a.getContext("2d");
                  context === null || context === void 0 ? void 0 : context.clearRect(0, 0, (_b = this.canvas) === null || _b === void 0 ? void 0 : _b.width, (_c = this.canvas) === null || _c === void 0 ? void 0 : _c.height);
                } else {
                  const pixelCenterRendered = this.map.getPixelFromCoordinate(renderedCenter);
                  const pixelCenter = this.map.getPixelFromCoordinate(center);
                  this.transformContainer.style.transform = composeCssTransform(pixelCenterRendered[0] - pixelCenter[0], pixelCenterRendered[1] - pixelCenter[1], renderedResolution / resolution, renderedResolution / resolution, rotation - renderedRotation, 0, 0);
                }
              }
              return this.container;
            }
          })
        ]
      });
      this.vectorLayer = this.olLayer.getLayers().item(0);
      this.renderState = {
        center: [0, 0],
        zoom: void 0,
        rotation: 0
      };
    }
    attachToMap(map2) {
      super.attachToMap(map2);
      if (this.map) {
        this.olListenersKeys.push(...this.map.on(["moveend", "change:target"], (evt) => {
          const view = (evt.map || evt.target).getView();
          if (view.getAnimating() || view.getInteracting()) {
            return;
          }
          const zoom = view.getZoom();
          if (this.currentZoom !== zoom) {
            this.onZoomEnd();
          }
          this.currentZoom = zoom;
          this.onMoveEnd(evt);
        }));
      }
    }
    /**
     * Destroy the container of the tracker.
     */
    detachFromMap() {
      super.detachFromMap();
      this.container = null;
    }
    /**
     * Detect in the canvas if there is data to query at a specific coordinate.
     * @param {ol/coordinate~Coordinate}  coordinate The coordinate to test
     * @returns
     */
    hasFeatureInfoAtCoordinate(coordinate) {
      if (this.map && this.canvas) {
        const context = this.canvas.getContext("2d", {
          willReadFrequently: true
        });
        const pixel = this.map.getPixelFromCoordinate(coordinate);
        return !!(context === null || context === void 0 ? void 0 : context.getImageData(pixel[0] * (this.pixelRatio || 1), pixel[1] * (this.pixelRatio || 1), 1, 1).data[3]);
      }
      return false;
    }
    /**
     * Render the trajectories using current map's size, resolution and rotation.
     * @param {boolean} noInterpolate if true, renders the vehicles without interpolating theirs positions.
     * @overrides
     */
    // @ts-ignore
    renderTrajectories(noInterpolate) {
      if (!this.map) {
        return;
      }
      const view = this.map.getView();
      if (!view.getCenter()) {
        return;
      }
      super.renderTrajectories({
        size: this.map.getSize(),
        center: view.getCenter(),
        extent: view.calculateExtent(),
        resolution: view.getResolution(),
        rotation: view.getRotation(),
        zoom: view.getZoom(),
        pixelRatio: this.pixelRatio
      }, noInterpolate);
    }
    /**
     * Launch renderTrajectories. it avoids duplicating code in renderTrajectories methhod.
     * @private
     * @override
     */
    renderTrajectoriesInternal(viewState, noInterpolate) {
      if (!this.map) {
        return false;
      }
      let isRendered = false;
      const blockRendering = this.allowRenderWhenAnimating ? false : this.map.getView().getAnimating() || this.map.getView().getInteracting();
      isRendered = blockRendering ? false : super.renderTrajectoriesInternal(viewState, noInterpolate);
      if (isRendered) {
        this.renderedViewState = Object.assign({}, viewState);
        if (this.transformContainer) {
          this.transformContainer.style.transform = "";
        }
      }
      return isRendered;
    }
    /**
     * Return the delay in ms before the next rendering.
     */
    getRefreshTimeInMs() {
      return super.getRefreshTimeInMs(this.map.getView().getZoom());
    }
    getFeatureInfoAtCoordinate(coordinate, options = {}) {
      if (!this.map || !this.map.getView()) {
        return Promise.resolve({
          layer: this,
          features: [],
          coordinate
        });
      }
      const resolution = this.map.getView().getResolution();
      return super.getFeatureInfoAtCoordinate(coordinate, Object.assign({ resolution }, options));
    }
    /**
     * On move end we update the websocket with the new bbox.
     *
     * @private
     * @override
     */
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    onMoveEnd(evt) {
      if (this.visible && this.isUpdateBboxOnMoveEnd) {
        this.setBbox();
      }
      if (this.visible && this.isUpdateBboxOnMoveEnd && this.userClickInteractions && this.selectedVehicleId) {
        this.highlightTrajectory(this.selectedVehicleId);
      }
    }
    /**
     * Function called on moveend event only when the zoom has changed.
     *
     * @param {ol/MapEvent~MapEvent} evt Moveend event.
     * @private
     * @override
     */
    // eslint-disable-next-line no-unused-vars
    onZoomEnd() {
      super.onZoomEnd();
      if (this.visible && this.isUpdateBboxOnMoveEnd) {
        this.setBbox();
      }
      if (this.visible && this.isUpdateBboxOnMoveEnd && this.userClickInteractions && this.selectedVehicleId) {
        this.highlightTrajectory(this.selectedVehicleId);
      }
    }
    /**
     * Update the cursor style when hovering a vehicle.
     *
     * @private
     * @override
     */
    onFeatureHover(features, layer, coordinate) {
      super.onFeatureHover(features, layer, coordinate);
      this.map.getTargetElement().style.cursor = features.length ? "pointer" : "auto";
    }
    /**
     * Display the complete trajectory of the vehicle.
     *
     * @private
     * @override
     */
    onFeatureClick(features, layer, coordinate) {
      super.onFeatureClick(features, layer, coordinate);
      if (!features.length && this.vectorLayer) {
        this.vectorLayer.getSource().clear();
      }
      if (this.selectedVehicleId) {
        this.highlightTrajectory(this.selectedVehicleId);
      }
    }
    /**
     * Remove the trajectory form the list if necessary.
     *
     * @private
     */
    purgeTrajectory(trajectory, extent, zoom) {
      const center = this.map.getView().getCenter();
      if (!extent && !center) {
        return false;
      }
      return super.purgeTrajectory(trajectory, extent || this.map.getView().calculateExtent(), zoom || this.map.getView().getZoom());
    }
    /**
     * Send the current bbox to the websocket
     *
     * @private
     */
    setBbox(extent, zoom) {
      let newExtent = extent;
      let newZoom = zoom;
      if (!newExtent && this.isUpdateBboxOnMoveEnd) {
        newExtent = extent || this.map.getView().calculateExtent();
        newZoom = Math.floor(this.map.getView().getZoom());
      }
      super.setBbox(newExtent, newZoom);
    }
    /**
     * Highlight the trajectory of journey.
     * @private
     */
    highlightTrajectory(id) {
      return this.api.getFullTrajectory(id, this.mode, this.generalizationLevel).then((data) => {
        const fullTrajectory = data.content;
        this.vectorLayer.getSource().clear();
        if (!fullTrajectory || !fullTrajectory.features || !fullTrajectory.features.length) {
          return void 0;
        }
        const features = format.readFeatures(fullTrajectory);
        this.vectorLayer.getSource().addFeatures(features);
        return features;
      });
    }
    /**
     * Create a copy of the RealtimeLayer.
     * @param {Object} newOptions Options to override
     * @return {RealtimeLayer} A RealtimeLayer
     */
    clone(newOptions) {
      return new _RealtimeLayer(Object.assign(Object.assign({}, this.options), newOptions));
    }
  };
  var RealtimeLayer_default = RealtimeLayer;

  // node_modules/preact/hooks/dist/hooks.module.js
  var t2;
  var r3;
  var u3;
  var i3;
  var o2 = 0;
  var f2 = [];
  var c3 = [];
  var e2 = l.__b;
  var a3 = l.__r;
  var v2 = l.diffed;
  var l3 = l.__c;
  var m2 = l.unmount;
  function d2(t3, u4) {
    l.__h && l.__h(r3, t3, o2 || u4), o2 = 0;
    var i4 = r3.__H || (r3.__H = { __: [], __h: [] });
    return t3 >= i4.__.length && i4.__.push({ __V: c3 }), i4.__[t3];
  }
  function h2(n2) {
    return o2 = 1, s3(B2, n2);
  }
  function s3(n2, u4, i4) {
    var o4 = d2(t2++, 2);
    if (o4.t = n2, !o4.__c && (o4.__ = [i4 ? i4(u4) : B2(void 0, u4), function(n3) {
      var t3 = o4.__N ? o4.__N[0] : o4.__[0], r4 = o4.t(t3, n3);
      t3 !== r4 && (o4.__N = [r4, o4.__[1]], o4.__c.setState({}));
    }], o4.__c = r3, !r3.u)) {
      var f3 = function(n3, t3, r4) {
        if (!o4.__c.__H)
          return true;
        var u5 = o4.__c.__H.__.filter(function(n4) {
          return n4.__c;
        });
        if (u5.every(function(n4) {
          return !n4.__N;
        }))
          return !c4 || c4.call(this, n3, t3, r4);
        var i5 = false;
        return u5.forEach(function(n4) {
          if (n4.__N) {
            var t4 = n4.__[0];
            n4.__ = n4.__N, n4.__N = void 0, t4 !== n4.__[0] && (i5 = true);
          }
        }), !(!i5 && o4.__c.props === n3) && (!c4 || c4.call(this, n3, t3, r4));
      };
      r3.u = true;
      var c4 = r3.shouldComponentUpdate, e3 = r3.componentWillUpdate;
      r3.componentWillUpdate = function(n3, t3, r4) {
        if (this.__e) {
          var u5 = c4;
          c4 = void 0, f3(n3, t3, r4), c4 = u5;
        }
        e3 && e3.call(this, n3, t3, r4);
      }, r3.shouldComponentUpdate = f3;
    }
    return o4.__N || o4.__;
  }
  function p5(u4, i4) {
    var o4 = d2(t2++, 3);
    !l.__s && z2(o4.__H, i4) && (o4.__ = u4, o4.i = i4, r3.__H.__h.push(o4));
  }
  function _(n2) {
    return o2 = 5, F2(function() {
      return { current: n2 };
    }, []);
  }
  function F2(n2, r4) {
    var u4 = d2(t2++, 7);
    return z2(u4.__H, r4) ? (u4.__V = n2(), u4.i = r4, u4.__h = n2, u4.__V) : u4.__;
  }
  function q2(n2) {
    var u4 = r3.context[n2.__c], i4 = d2(t2++, 9);
    return i4.c = n2, u4 ? (null == i4.__ && (i4.__ = true, u4.sub(r3)), u4.props.value) : n2.__;
  }
  function b2() {
    for (var t3; t3 = f2.shift(); )
      if (t3.__P && t3.__H)
        try {
          t3.__H.__h.forEach(k2), t3.__H.__h.forEach(w2), t3.__H.__h = [];
        } catch (r4) {
          t3.__H.__h = [], l.__e(r4, t3.__v);
        }
  }
  l.__b = function(n2) {
    r3 = null, e2 && e2(n2);
  }, l.__r = function(n2) {
    a3 && a3(n2), t2 = 0;
    var i4 = (r3 = n2.__c).__H;
    i4 && (u3 === r3 ? (i4.__h = [], r3.__h = [], i4.__.forEach(function(n3) {
      n3.__N && (n3.__ = n3.__N), n3.__V = c3, n3.__N = n3.i = void 0;
    })) : (i4.__h.forEach(k2), i4.__h.forEach(w2), i4.__h = [], t2 = 0)), u3 = r3;
  }, l.diffed = function(t3) {
    v2 && v2(t3);
    var o4 = t3.__c;
    o4 && o4.__H && (o4.__H.__h.length && (1 !== f2.push(o4) && i3 === l.requestAnimationFrame || ((i3 = l.requestAnimationFrame) || j2)(b2)), o4.__H.__.forEach(function(n2) {
      n2.i && (n2.__H = n2.i), n2.__V !== c3 && (n2.__ = n2.__V), n2.i = void 0, n2.__V = c3;
    })), u3 = r3 = null;
  }, l.__c = function(t3, r4) {
    r4.some(function(t4) {
      try {
        t4.__h.forEach(k2), t4.__h = t4.__h.filter(function(n2) {
          return !n2.__ || w2(n2);
        });
      } catch (u4) {
        r4.some(function(n2) {
          n2.__h && (n2.__h = []);
        }), r4 = [], l.__e(u4, t4.__v);
      }
    }), l3 && l3(t3, r4);
  }, l.unmount = function(t3) {
    m2 && m2(t3);
    var r4, u4 = t3.__c;
    u4 && u4.__H && (u4.__H.__.forEach(function(n2) {
      try {
        k2(n2);
      } catch (n3) {
        r4 = n3;
      }
    }), u4.__H = void 0, r4 && l.__e(r4, u4.__v));
  };
  var g2 = "function" == typeof requestAnimationFrame;
  function j2(n2) {
    var t3, r4 = function() {
      clearTimeout(u4), g2 && cancelAnimationFrame(t3), setTimeout(n2);
    }, u4 = setTimeout(r4, 100);
    g2 && (t3 = requestAnimationFrame(r4));
  }
  function k2(n2) {
    var t3 = r3, u4 = n2.__c;
    "function" == typeof u4 && (n2.__c = void 0, u4()), r3 = t3;
  }
  function w2(n2) {
    var t3 = r3;
    n2.__c = n2.__(), r3 = t3;
  }
  function z2(n2, t3) {
    return !n2 || n2.length !== t3.length || t3.some(function(t4, r4) {
      return t4 !== n2[r4];
    });
  }
  function B2(n2, t3) {
    return "function" == typeof t3 ? t3(n2) : t3;
  }

  // node_modules/ol/ol.css
  var ol_default = `:root,
:host {
  --ol-background-color: white;
  --ol-accent-background-color: #F5F5F5;
  --ol-subtle-background-color: rgba(128, 128, 128, 0.25);
  --ol-partial-background-color: rgba(255, 255, 255, 0.75);
  --ol-foreground-color: #333333;
  --ol-subtle-foreground-color: #666666;
  --ol-brand-color: #00AAFF;
}

.ol-box {
  box-sizing: border-box;
  border-radius: 2px;
  border: 1.5px solid var(--ol-background-color);
  background-color: var(--ol-partial-background-color);
}

.ol-mouse-position {
  top: 8px;
  right: 8px;
  position: absolute;
}

.ol-scale-line {
  background: var(--ol-partial-background-color);
  border-radius: 4px;
  bottom: 8px;
  left: 8px;
  padding: 2px;
  position: absolute;
}

.ol-scale-line-inner {
  border: 1px solid var(--ol-subtle-foreground-color);
  border-top: none;
  color: var(--ol-foreground-color);
  font-size: 10px;
  text-align: center;
  margin: 1px;
  will-change: contents, width;
  transition: all 0.25s;
}

.ol-scale-bar {
  position: absolute;
  bottom: 8px;
  left: 8px;
}

.ol-scale-bar-inner {
  display: flex;
}

.ol-scale-step-marker {
  width: 1px;
  height: 15px;
  background-color: var(--ol-foreground-color);
  float: right;
  z-index: 10;
}

.ol-scale-step-text {
  position: absolute;
  bottom: -5px;
  font-size: 10px;
  z-index: 11;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-text {
  position: absolute;
  font-size: 12px;
  text-align: center;
  bottom: 25px;
  color: var(--ol-foreground-color);
  text-shadow: -1.5px 0 var(--ol-partial-background-color), 0 1.5px var(--ol-partial-background-color), 1.5px 0 var(--ol-partial-background-color), 0 -1.5px var(--ol-partial-background-color);
}

.ol-scale-singlebar {
  position: relative;
  height: 10px;
  z-index: 9;
  box-sizing: border-box;
  border: 1px solid var(--ol-foreground-color);
}

.ol-scale-singlebar-even {
  background-color: var(--ol-subtle-foreground-color);
}

.ol-scale-singlebar-odd {
  background-color: var(--ol-background-color);
}

.ol-unsupported {
  display: none;
}

.ol-viewport,
.ol-unselectable {
  -webkit-touch-callout: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  user-select: none;
  -webkit-tap-highlight-color: transparent;
}

.ol-viewport canvas {
  all: unset;
  overflow: hidden;
}

.ol-viewport {
  touch-action: none;
}

.ol-selectable {
  -webkit-touch-callout: default;
  -webkit-user-select: text;
  -moz-user-select: text;
  user-select: text;
}

.ol-grabbing {
  cursor: -webkit-grabbing;
  cursor: -moz-grabbing;
  cursor: grabbing;
}

.ol-grab {
  cursor: move;
  cursor: -webkit-grab;
  cursor: -moz-grab;
  cursor: grab;
}

.ol-control {
  position: absolute;
  background-color: var(--ol-subtle-background-color);
  border-radius: 4px;
}

.ol-zoom {
  top: .5em;
  left: .5em;
}

.ol-rotate {
  top: .5em;
  right: .5em;
  transition: opacity .25s linear, visibility 0s linear;
}

.ol-rotate.ol-hidden {
  opacity: 0;
  visibility: hidden;
  transition: opacity .25s linear, visibility 0s linear .25s;
}

.ol-zoom-extent {
  top: 4.643em;
  left: .5em;
}

.ol-full-screen {
  right: .5em;
  top: .5em;
}

.ol-control button {
  display: block;
  margin: 1px;
  padding: 0;
  color: var(--ol-subtle-foreground-color);
  font-weight: bold;
  text-decoration: none;
  font-size: inherit;
  text-align: center;
  height: 1.375em;
  width: 1.375em;
  line-height: .4em;
  background-color: var(--ol-background-color);
  border: none;
  border-radius: 2px;
}

.ol-control button::-moz-focus-inner {
  border: none;
  padding: 0;
}

.ol-zoom-extent button {
  line-height: 1.4em;
}

.ol-compass {
  display: block;
  font-weight: normal;
  will-change: transform;
}

.ol-touch .ol-control button {
  font-size: 1.5em;
}

.ol-touch .ol-zoom-extent {
  top: 5.5em;
}

.ol-control button:hover,
.ol-control button:focus {
  text-decoration: none;
  outline: 1px solid var(--ol-subtle-foreground-color);
  color: var(--ol-foreground-color);
}

.ol-zoom .ol-zoom-in {
  border-radius: 2px 2px 0 0;
}

.ol-zoom .ol-zoom-out {
  border-radius: 0 0 2px 2px;
}

.ol-attribution {
  text-align: right;
  bottom: .5em;
  right: .5em;
  max-width: calc(100% - 1.3em);
  display: flex;
  flex-flow: row-reverse;
  align-items: center;
}

.ol-attribution a {
  color: var(--ol-subtle-foreground-color);
  text-decoration: none;
}

.ol-attribution ul {
  margin: 0;
  padding: 1px .5em;
  color: var(--ol-foreground-color);
  text-shadow: 0 0 2px var(--ol-background-color);
  font-size: 12px;
}

.ol-attribution li {
  display: inline;
  list-style: none;
}

.ol-attribution li:not(:last-child):after {
  content: " ";
}

.ol-attribution img {
  max-height: 2em;
  max-width: inherit;
  vertical-align: middle;
}

.ol-attribution button {
  flex-shrink: 0;
}

.ol-attribution.ol-collapsed ul {
  display: none;
}

.ol-attribution:not(.ol-collapsed) {
  background: var(--ol-partial-background-color);
}

.ol-attribution.ol-uncollapsible {
  bottom: 0;
  right: 0;
  border-radius: 4px 0 0;
}

.ol-attribution.ol-uncollapsible img {
  margin-top: -.2em;
  max-height: 1.6em;
}

.ol-attribution.ol-uncollapsible button {
  display: none;
}

.ol-zoomslider {
  top: 4.5em;
  left: .5em;
  height: 200px;
}

.ol-zoomslider button {
  position: relative;
  height: 10px;
}

.ol-touch .ol-zoomslider {
  top: 5.5em;
}

.ol-overviewmap {
  left: 0.5em;
  bottom: 0.5em;
}

.ol-overviewmap.ol-uncollapsible {
  bottom: 0;
  left: 0;
  border-radius: 0 4px 0 0;
}

.ol-overviewmap .ol-overviewmap-map,
.ol-overviewmap button {
  display: block;
}

.ol-overviewmap .ol-overviewmap-map {
  border: 1px solid var(--ol-subtle-foreground-color);
  height: 150px;
  width: 150px;
}

.ol-overviewmap:not(.ol-collapsed) button {
  bottom: 0;
  left: 0;
  position: absolute;
}

.ol-overviewmap.ol-collapsed .ol-overviewmap-map,
.ol-overviewmap.ol-uncollapsible button {
  display: none;
}

.ol-overviewmap:not(.ol-collapsed) {
  background: var(--ol-subtle-background-color);
}

.ol-overviewmap-box {
  border: 1.5px dotted var(--ol-subtle-foreground-color);
}

.ol-overviewmap .ol-overviewmap-box:hover {
  cursor: move;
}
`;

  // src/style.css
  var style_default = `/*
! tailwindcss v3.3.3 | MIT License | https://tailwindcss.com
*/

/*
1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)
2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)
*/

*,
::before,
::after {
  box-sizing: border-box;
  /* 1 */
  border-width: 0;
  /* 2 */
  border-style: solid;
  /* 2 */
  border-color: #e5e7eb;
  /* 2 */
}

::before,
::after {
  --tw-content: '';
}

/*
1. Use a consistent sensible line-height in all browsers.
2. Prevent adjustments of font size after orientation changes in iOS.
3. Use a more readable tab size.
4. Use the user's configured \`sans\` font-family by default.
5. Use the user's configured \`sans\` font-feature-settings by default.
6. Use the user's configured \`sans\` font-variation-settings by default.
*/

html {
  line-height: 1.5;
  /* 1 */
  -webkit-text-size-adjust: 100%;
  /* 2 */
  -moz-tab-size: 4;
  /* 3 */
  -o-tab-size: 4;
     tab-size: 4;
  /* 3 */
  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol", "Noto Color Emoji";
  /* 4 */
  font-feature-settings: normal;
  /* 5 */
  font-variation-settings: normal;
  /* 6 */
}

/*
1. Remove the margin in all browsers.
2. Inherit line-height from \`html\` so users can set them as a class directly on the \`html\` element.
*/

body {
  margin: 0;
  /* 1 */
  line-height: inherit;
  /* 2 */
}

/*
1. Add the correct height in Firefox.
2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)
3. Ensure horizontal rules are visible by default.
*/

hr {
  height: 0;
  /* 1 */
  color: inherit;
  /* 2 */
  border-top-width: 1px;
  /* 3 */
}

/*
Add the correct text decoration in Chrome, Edge, and Safari.
*/

abbr:where([title]) {
  -webkit-text-decoration: underline dotted;
          text-decoration: underline dotted;
}

/*
Remove the default font size and weight for headings.
*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-size: inherit;
  font-weight: inherit;
}

/*
Reset links to optimize for opt-in styling instead of opt-out.
*/

a {
  color: inherit;
  text-decoration: inherit;
}

/*
Add the correct font weight in Edge and Safari.
*/

b,
strong {
  font-weight: bolder;
}

/*
1. Use the user's configured \`mono\` font family by default.
2. Correct the odd \`em\` font sizing in all browsers.
*/

code,
kbd,
samp,
pre {
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  /* 1 */
  font-size: 1em;
  /* 2 */
}

/*
Add the correct font size in all browsers.
*/

small {
  font-size: 80%;
}

/*
Prevent \`sub\` and \`sup\` elements from affecting the line height in all browsers.
*/

sub,
sup {
  font-size: 75%;
  line-height: 0;
  position: relative;
  vertical-align: baseline;
}

sub {
  bottom: -0.25em;
}

sup {
  top: -0.5em;
}

/*
1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)
2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)
3. Remove gaps between table borders by default.
*/

table {
  text-indent: 0;
  /* 1 */
  border-color: inherit;
  /* 2 */
  border-collapse: collapse;
  /* 3 */
}

/*
1. Change the font styles in all browsers.
2. Remove the margin in Firefox and Safari.
3. Remove default padding in all browsers.
*/

button,
input,
optgroup,
select,
textarea {
  font-family: inherit;
  /* 1 */
  font-feature-settings: inherit;
  /* 1 */
  font-variation-settings: inherit;
  /* 1 */
  font-size: 100%;
  /* 1 */
  font-weight: inherit;
  /* 1 */
  line-height: inherit;
  /* 1 */
  color: inherit;
  /* 1 */
  margin: 0;
  /* 2 */
  padding: 0;
  /* 3 */
}

/*
Remove the inheritance of text transform in Edge and Firefox.
*/

button,
select {
  text-transform: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Remove default button styles.
*/

button,
[type='button'],
[type='reset'],
[type='submit'] {
  -webkit-appearance: button;
  /* 1 */
  background-color: transparent;
  /* 2 */
  background-image: none;
  /* 2 */
}

/*
Use the modern Firefox focus style for all focusable elements.
*/

:-moz-focusring {
  outline: auto;
}

/*
Remove the additional \`:invalid\` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)
*/

:-moz-ui-invalid {
  box-shadow: none;
}

/*
Add the correct vertical alignment in Chrome and Firefox.
*/

progress {
  vertical-align: baseline;
}

/*
Correct the cursor style of increment and decrement buttons in Safari.
*/

::-webkit-inner-spin-button,
::-webkit-outer-spin-button {
  height: auto;
}

/*
1. Correct the odd appearance in Chrome and Safari.
2. Correct the outline style in Safari.
*/

[type='search'] {
  -webkit-appearance: textfield;
  /* 1 */
  outline-offset: -2px;
  /* 2 */
}

/*
Remove the inner padding in Chrome and Safari on macOS.
*/

::-webkit-search-decoration {
  -webkit-appearance: none;
}

/*
1. Correct the inability to style clickable types in iOS and Safari.
2. Change font properties to \`inherit\` in Safari.
*/

::-webkit-file-upload-button {
  -webkit-appearance: button;
  /* 1 */
  font: inherit;
  /* 2 */
}

/*
Add the correct display in Chrome and Safari.
*/

summary {
  display: list-item;
}

/*
Removes the default spacing and border for appropriate elements.
*/

blockquote,
dl,
dd,
h1,
h2,
h3,
h4,
h5,
h6,
hr,
figure,
p,
pre {
  margin: 0;
}

fieldset {
  margin: 0;
  padding: 0;
}

legend {
  padding: 0;
}

ol,
ul,
menu {
  list-style: none;
  margin: 0;
  padding: 0;
}

/*
Reset default styling for dialogs.
*/

dialog {
  padding: 0;
}

/*
Prevent resizing textareas horizontally by default.
*/

textarea {
  resize: vertical;
}

/*
1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)
2. Set the default placeholder color to the user's configured gray 400 color.
*/

input::-moz-placeholder, textarea::-moz-placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

input::placeholder,
textarea::placeholder {
  opacity: 1;
  /* 1 */
  color: #9ca3af;
  /* 2 */
}

/*
Set the default cursor for buttons.
*/

button,
[role="button"] {
  cursor: pointer;
}

/*
Make sure disabled buttons don't get the pointer cursor.
*/

:disabled {
  cursor: default;
}

/*
1. Make replaced elements \`display: block\` by default. (https://github.com/mozdevs/cssremedy/issues/14)
2. Add \`vertical-align: middle\` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)
   This can trigger a poorly considered lint error in some tools but is included by design.
*/

img,
svg,
video,
canvas,
audio,
iframe,
embed,
object {
  display: block;
  /* 1 */
  vertical-align: middle;
  /* 2 */
}

/*
Constrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)
*/

img,
video {
  max-width: 100%;
  height: auto;
}

/* Make elements with the HTML hidden attribute stay hidden by default */

[hidden] {
  display: none;
}

*, ::before, ::after {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

::backdrop {
  --tw-border-spacing-x: 0;
  --tw-border-spacing-y: 0;
  --tw-translate-x: 0;
  --tw-translate-y: 0;
  --tw-rotate: 0;
  --tw-skew-x: 0;
  --tw-skew-y: 0;
  --tw-scale-x: 1;
  --tw-scale-y: 1;
  --tw-pan-x:  ;
  --tw-pan-y:  ;
  --tw-pinch-zoom:  ;
  --tw-scroll-snap-strictness: proximity;
  --tw-gradient-from-position:  ;
  --tw-gradient-via-position:  ;
  --tw-gradient-to-position:  ;
  --tw-ordinal:  ;
  --tw-slashed-zero:  ;
  --tw-numeric-figure:  ;
  --tw-numeric-spacing:  ;
  --tw-numeric-fraction:  ;
  --tw-ring-inset:  ;
  --tw-ring-offset-width: 0px;
  --tw-ring-offset-color: #fff;
  --tw-ring-color: rgb(59 130 246 / 0.5);
  --tw-ring-offset-shadow: 0 0 #0000;
  --tw-ring-shadow: 0 0 #0000;
  --tw-shadow: 0 0 #0000;
  --tw-shadow-colored: 0 0 #0000;
  --tw-blur:  ;
  --tw-brightness:  ;
  --tw-contrast:  ;
  --tw-grayscale:  ;
  --tw-hue-rotate:  ;
  --tw-invert:  ;
  --tw-saturate:  ;
  --tw-sepia:  ;
  --tw-drop-shadow:  ;
  --tw-backdrop-blur:  ;
  --tw-backdrop-brightness:  ;
  --tw-backdrop-contrast:  ;
  --tw-backdrop-grayscale:  ;
  --tw-backdrop-hue-rotate:  ;
  --tw-backdrop-invert:  ;
  --tw-backdrop-opacity:  ;
  --tw-backdrop-saturate:  ;
  --tw-backdrop-sepia:  ;
}

.pointer-events-none {
  pointer-events: none;
}

.absolute {
  position: absolute;
}

.relative {
  position: relative;
}

.sticky {
  position: sticky;
}

.inset-0 {
  inset: 0px;
}

.bottom-0 {
  bottom: 0px;
}

.bottom-2 {
  bottom: 0.5rem;
}

.left-2 {
  left: 0.5rem;
}

.right-2 {
  right: 0.5rem;
}

.top-2 {
  top: 0.5rem;
}

.z-10 {
  z-index: 10;
}

.z-20 {
  z-index: 20;
}

.m-4 {
  margin: 1rem;
}

.mb-0 {
  margin-bottom: 0px;
}

.ml-4 {
  margin-left: 1rem;
}

.flex {
  display: flex;
}

.table {
  display: table;
}

.hidden {
  display: none;
}

.h-8 {
  height: 2rem;
}

.h-9 {
  height: 2.25rem;
}

.h-\\[38px\\] {
  height: 38px;
}

.h-\\[60px\\] {
  height: 60px;
}

.h-full {
  height: 100%;
}

.max-h-\\[70\\%\\] {
  max-height: 70%;
}

.min-h-\\[75px\\] {
  min-height: 75px;
}

.w-10 {
  width: 2.5rem;
}

.w-7 {
  width: 1.75rem;
}

.w-8 {
  width: 2rem;
}

.w-\\[38px\\] {
  width: 38px;
}

.w-full {
  width: 100%;
}

.min-w-\\[2\\.25rem\\] {
  min-width: 2.25rem;
}

.flex-1 {
  flex: 1 1 0%;
}

.flex-none {
  flex: none;
}

.flex-shrink-0 {
  flex-shrink: 0;
}

.flex-grow {
  flex-grow: 1;
}

@keyframes pulse {
  50% {
    opacity: .5;
  }
}

.animate-pulse {
  animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
}

.touch-none {
  touch-action: none;
}

.scroll-mt-\\[50px\\] {
  scroll-margin-top: 50px;
}

.flex-col {
  flex-direction: column;
}

.flex-wrap {
  flex-wrap: wrap;
}

.flex-wrap-reverse {
  flex-wrap: wrap-reverse;
}

.items-start {
  align-items: flex-start;
}

.items-end {
  align-items: flex-end;
}

.items-center {
  align-items: center;
}

.justify-end {
  justify-content: flex-end;
}

.justify-center {
  justify-content: center;
}

.justify-between {
  justify-content: space-between;
}

.gap-2 {
  gap: 0.5rem;
}

.gap-x-4 {
  -moz-column-gap: 1rem;
       column-gap: 1rem;
}

.overflow-hidden {
  overflow: hidden;
}

.overflow-y-auto {
  overflow-y: auto;
}

.overflow-x-hidden {
  overflow-x: hidden;
}

.whitespace-normal {
  white-space: normal;
}

.rounded {
  border-radius: 0.25rem;
}

.rounded-full {
  border-radius: 9999px;
}

.rounded-sm {
  border-radius: 0.125rem;
}

.border {
  border-width: 1px;
}

.border-2 {
  border-width: 2px;
}

.border-t {
  border-top-width: 1px;
}

.border-black {
  --tw-border-opacity: 1;
  border-color: rgb(0 0 0 / var(--tw-border-opacity));
}

.bg-gray-300 {
  --tw-bg-opacity: 1;
  background-color: rgb(209 213 219 / var(--tw-bg-opacity));
}

.bg-slate-100 {
  --tw-bg-opacity: 1;
  background-color: rgb(241 245 249 / var(--tw-bg-opacity));
}

.bg-slate-200 {
  --tw-bg-opacity: 1;
  background-color: rgb(226 232 240 / var(--tw-bg-opacity));
}

.bg-slate-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(248 250 252 / var(--tw-bg-opacity));
}

.bg-white {
  --tw-bg-opacity: 1;
  background-color: rgb(255 255 255 / var(--tw-bg-opacity));
}

.bg-opacity-70 {
  --tw-bg-opacity: 0.7;
}

.bg-gradient-to-b {
  background-image: linear-gradient(to bottom, var(--tw-gradient-stops));
}

.from-transparent {
  --tw-gradient-from: transparent var(--tw-gradient-from-position);
  --tw-gradient-to: rgb(0 0 0 / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.to-white {
  --tw-gradient-to: #fff var(--tw-gradient-to-position);
}

.stroke-gray-400 {
  stroke: #9ca3af;
}

.p-1 {
  padding: 0.25rem;
}

.p-1\\.5 {
  padding: 0.375rem;
}

.p-4 {
  padding: 1rem;
}

.px-0 {
  padding-left: 0px;
  padding-right: 0px;
}

.px-0\\.5 {
  padding-left: 0.125rem;
  padding-right: 0.125rem;
}

.px-1 {
  padding-left: 0.25rem;
  padding-right: 0.25rem;
}

.py-px {
  padding-top: 1px;
  padding-bottom: 1px;
}

.pr-2 {
  padding-right: 0.5rem;
}

.text-left {
  text-align: left;
}

.text-\\[10px\\] {
  font-size: 10px;
}

.text-sm {
  font-size: 0.875rem;
  line-height: 1.25rem;
}

.text-xs {
  font-size: 0.75rem;
  line-height: 1rem;
}

.font-bold {
  font-weight: 700;
}

.font-medium {
  font-weight: 500;
}

.text-amber-600 {
  --tw-text-opacity: 1;
  color: rgb(217 119 6 / var(--tw-text-opacity));
}

.text-black {
  --tw-text-opacity: 1;
  color: rgb(0 0 0 / var(--tw-text-opacity));
}

.text-gray-500 {
  --tw-text-opacity: 1;
  color: rgb(107 114 128 / var(--tw-text-opacity));
}

.text-gray-600 {
  --tw-text-opacity: 1;
  color: rgb(75 85 99 / var(--tw-text-opacity));
}

.text-green-600 {
  --tw-text-opacity: 1;
  color: rgb(22 163 74 / var(--tw-text-opacity));
}

.text-orange-600 {
  --tw-text-opacity: 1;
  color: rgb(234 88 12 / var(--tw-text-opacity));
}

.text-red-600 {
  --tw-text-opacity: 1;
  color: rgb(220 38 38 / var(--tw-text-opacity));
}

.text-yellow-600 {
  --tw-text-opacity: 1;
  color: rgb(202 138 4 / var(--tw-text-opacity));
}

.underline {
  text-decoration-line: underline;
}

.line-through {
  text-decoration-line: line-through;
}

.shadow {
  --tw-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 1px 3px 0 var(--tw-shadow-color), 0 1px 2px -1px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.shadow-lg {
  --tw-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
  --tw-shadow-colored: 0 10px 15px -3px var(--tw-shadow-color), 0 4px 6px -4px var(--tw-shadow-color);
  box-shadow: var(--tw-ring-offset-shadow, 0 0 #0000), var(--tw-ring-shadow, 0 0 #0000), var(--tw-shadow);
}

.\\@container\\/main {
  container-type: inline-size;
  container-name: main;
}

.hover\\:bg-slate-100:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(241 245 249 / var(--tw-bg-opacity));
}

.hover\\:bg-slate-300:hover {
  --tw-bg-opacity: 1;
  background-color: rgb(203 213 225 / var(--tw-bg-opacity));
}

.group:hover .group-hover\\:bg-slate-50 {
  --tw-bg-opacity: 1;
  background-color: rgb(248 250 252 / var(--tw-bg-opacity));
}

@container main (min-width: 32rem) {
  .\\@lg\\/main\\:flex-row-reverse {
    flex-direction: row-reverse;
  }
}

@container (min-width: 32rem) {
  .\\@lg\\:hidden {
    display: none;
  }

  .\\@lg\\:h-\\[100\\%\\!important\\] {
    height: 100% !important;
  }

  .\\@lg\\:max-h-full {
    max-height: 100%;
  }

  .\\@lg\\:w-\\[350px\\] {
    width: 350px;
  }

  .\\@lg\\:border-r {
    border-right-width: 1px;
  }
}`;

  // node_modules/ol/control/ScaleLine.js
  var UNITS_PROP = "units";
  var LEADING_DIGITS = [1, 2, 5];
  var DEFAULT_DPI = 25.4 / 0.28;
  var ScaleLine = class extends Control_default {
    /**
     * @param {Options} [options] Scale line options.
     */
    constructor(options) {
      options = options ? options : {};
      const element = document.createElement("div");
      element.style.pointerEvents = "none";
      super({
        element,
        render: options.render,
        target: options.target
      });
      this.on;
      this.once;
      this.un;
      const className = options.className !== void 0 ? options.className : options.bar ? "ol-scale-bar" : "ol-scale-line";
      this.innerElement_ = document.createElement("div");
      this.innerElement_.className = className + "-inner";
      this.element.className = className + " " + CLASS_UNSELECTABLE;
      this.element.appendChild(this.innerElement_);
      this.viewState_ = null;
      this.minWidth_ = options.minWidth !== void 0 ? options.minWidth : 64;
      this.maxWidth_ = options.maxWidth;
      this.renderedVisible_ = false;
      this.renderedWidth_ = void 0;
      this.renderedHTML_ = "";
      this.addChangeListener(UNITS_PROP, this.handleUnitsChanged_);
      this.setUnits(options.units || "metric");
      this.scaleBar_ = options.bar || false;
      this.scaleBarSteps_ = options.steps || 4;
      this.scaleBarText_ = options.text || false;
      this.dpi_ = options.dpi || void 0;
    }
    /**
     * Return the units to use in the scale line.
     * @return {Units} The units
     * to use in the scale line.
     * @observable
     * @api
     */
    getUnits() {
      return this.get(UNITS_PROP);
    }
    /**
     * @private
     */
    handleUnitsChanged_() {
      this.updateElement_();
    }
    /**
     * Set the units to use in the scale line.
     * @param {Units} units The units to use in the scale line.
     * @observable
     * @api
     */
    setUnits(units) {
      this.set(UNITS_PROP, units);
    }
    /**
     * Specify the dpi of output device such as printer.
     * @param {number|undefined} dpi The dpi of output device.
     * @api
     */
    setDpi(dpi) {
      this.dpi_ = dpi;
    }
    /**
     * @private
     */
    updateElement_() {
      const viewState = this.viewState_;
      if (!viewState) {
        if (this.renderedVisible_) {
          this.element.style.display = "none";
          this.renderedVisible_ = false;
        }
        return;
      }
      const center = viewState.center;
      const projection = viewState.projection;
      const units = this.getUnits();
      const pointResolutionUnits = units == "degrees" ? "degrees" : "m";
      let pointResolution = getPointResolution(
        projection,
        viewState.resolution,
        center,
        pointResolutionUnits
      );
      const minWidth = this.minWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI;
      const maxWidth = this.maxWidth_ !== void 0 ? this.maxWidth_ * (this.dpi_ || DEFAULT_DPI) / DEFAULT_DPI : void 0;
      let nominalCount = minWidth * pointResolution;
      let suffix = "";
      if (units == "degrees") {
        const metersPerDegree = METERS_PER_UNIT.degrees;
        nominalCount *= metersPerDegree;
        if (nominalCount < metersPerDegree / 60) {
          suffix = "\u2033";
          pointResolution *= 3600;
        } else if (nominalCount < metersPerDegree) {
          suffix = "\u2032";
          pointResolution *= 60;
        } else {
          suffix = "\xB0";
        }
      } else if (units == "imperial") {
        if (nominalCount < 0.9144) {
          suffix = "in";
          pointResolution /= 0.0254;
        } else if (nominalCount < 1609.344) {
          suffix = "ft";
          pointResolution /= 0.3048;
        } else {
          suffix = "mi";
          pointResolution /= 1609.344;
        }
      } else if (units == "nautical") {
        pointResolution /= 1852;
        suffix = "NM";
      } else if (units == "metric") {
        if (nominalCount < 1e-3) {
          suffix = "\u03BCm";
          pointResolution *= 1e6;
        } else if (nominalCount < 1) {
          suffix = "mm";
          pointResolution *= 1e3;
        } else if (nominalCount < 1e3) {
          suffix = "m";
        } else {
          suffix = "km";
          pointResolution /= 1e3;
        }
      } else if (units == "us") {
        if (nominalCount < 0.9144) {
          suffix = "in";
          pointResolution *= 39.37;
        } else if (nominalCount < 1609.344) {
          suffix = "ft";
          pointResolution /= 0.30480061;
        } else {
          suffix = "mi";
          pointResolution /= 1609.3472;
        }
      } else {
        throw new Error("Invalid units");
      }
      let i4 = 3 * Math.floor(Math.log(minWidth * pointResolution) / Math.log(10));
      let count, width, decimalCount;
      let previousCount, previousWidth, previousDecimalCount;
      while (true) {
        decimalCount = Math.floor(i4 / 3);
        const decimal = Math.pow(10, decimalCount);
        count = LEADING_DIGITS[(i4 % 3 + 3) % 3] * decimal;
        width = Math.round(count / pointResolution);
        if (isNaN(width)) {
          this.element.style.display = "none";
          this.renderedVisible_ = false;
          return;
        }
        if (maxWidth !== void 0 && width >= maxWidth) {
          count = previousCount;
          width = previousWidth;
          decimalCount = previousDecimalCount;
          break;
        } else if (width >= minWidth) {
          break;
        }
        previousCount = count;
        previousWidth = width;
        previousDecimalCount = decimalCount;
        ++i4;
      }
      const html = this.scaleBar_ ? this.createScaleBar(width, count, suffix) : count.toFixed(decimalCount < 0 ? -decimalCount : 0) + " " + suffix;
      if (this.renderedHTML_ != html) {
        this.innerElement_.innerHTML = html;
        this.renderedHTML_ = html;
      }
      if (this.renderedWidth_ != width) {
        this.innerElement_.style.width = width + "px";
        this.renderedWidth_ = width;
      }
      if (!this.renderedVisible_) {
        this.element.style.display = "";
        this.renderedVisible_ = true;
      }
    }
    /**
     * @private
     * @param {number} width The current width of the scalebar.
     * @param {number} scale The current scale.
     * @param {string} suffix The suffix to append to the scale text.
     * @return {string} The stringified HTML of the scalebar.
     */
    createScaleBar(width, scale3, suffix) {
      const resolutionScale = this.getScaleForResolution();
      const mapScale = resolutionScale < 1 ? Math.round(1 / resolutionScale).toLocaleString() + " : 1" : "1 : " + Math.round(resolutionScale).toLocaleString();
      const steps = this.scaleBarSteps_;
      const stepWidth = width / steps;
      const scaleSteps = [this.createMarker("absolute")];
      for (let i4 = 0; i4 < steps; ++i4) {
        const cls = i4 % 2 === 0 ? "ol-scale-singlebar-odd" : "ol-scale-singlebar-even";
        scaleSteps.push(
          `<div><div class="ol-scale-singlebar ${cls}" style="width: ${stepWidth}px;"></div>` + this.createMarker("relative") + // render text every second step, except when only 2 steps
          (i4 % 2 === 0 || steps === 2 ? this.createStepText(i4, width, false, scale3, suffix) : "") + "</div>"
        );
      }
      scaleSteps.push(this.createStepText(steps, width, true, scale3, suffix));
      const scaleBarText = this.scaleBarText_ ? `<div class="ol-scale-text" style="width: ${width}px;">` + mapScale + "</div>" : "";
      return scaleBarText + scaleSteps.join("");
    }
    /**
     * Creates a marker at given position
     * @param {'absolute'|'relative'} position The position, absolute or relative
     * @return {string} The stringified div containing the marker
     */
    createMarker(position) {
      const top = position === "absolute" ? 3 : -10;
      return `<div class="ol-scale-step-marker" style="position: ${position}; top: ${top}px;"></div>`;
    }
    /**
     * Creates the label for a marker marker at given position
     * @param {number} i The iterator
     * @param {number} width The width the scalebar will currently use
     * @param {boolean} isLast Flag indicating if we add the last step text
     * @param {number} scale The current scale for the whole scalebar
     * @param {string} suffix The suffix for the scale
     * @return {string} The stringified div containing the step text
     */
    createStepText(i4, width, isLast, scale3, suffix) {
      const length = i4 === 0 ? 0 : Math.round(scale3 / this.scaleBarSteps_ * i4 * 100) / 100;
      const lengthString = length + (i4 === 0 ? "" : " " + suffix);
      const margin = i4 === 0 ? -3 : width / this.scaleBarSteps_ * -1;
      const minWidth = i4 === 0 ? 0 : width / this.scaleBarSteps_ * 2;
      return `<div class="ol-scale-step-text" style="margin-left: ${margin}px;text-align: ${i4 === 0 ? "left" : "center"};min-width: ${minWidth}px;left: ${isLast ? width + "px" : "unset"};">` + lengthString + "</div>";
    }
    /**
     * Returns the appropriate scale for the given resolution and units.
     * @return {number} The appropriate scale.
     */
    getScaleForResolution() {
      const resolution = getPointResolution(
        this.viewState_.projection,
        this.viewState_.resolution,
        this.viewState_.center,
        "m"
      );
      const dpi = this.dpi_ || DEFAULT_DPI;
      const inchesPerMeter = 1e3 / 25.4;
      return resolution * inchesPerMeter * dpi;
    }
    /**
     * Update the scale line element.
     * @param {import("../MapEvent.js").default} mapEvent Map event.
     * @override
     */
    render(mapEvent) {
      const frameState = mapEvent.frameState;
      if (!frameState) {
        this.viewState_ = null;
      } else {
        this.viewState_ = frameState.viewState;
      }
      this.updateElement_();
    }
  };
  var ScaleLine_default = ScaleLine;

  // src/ScaleLine/index.css
  var ScaleLine_default2 = `.ol-scale-line  {
  position:relative;
  left: unset;
  bottom: unset;
  background:unset;
}`;

  // node_modules/preact/jsx-runtime/dist/jsxRuntime.module.js
  var _2 = 0;
  function o3(o4, e3, n2, t3, f3, l4) {
    var s4, u4, a4 = {};
    for (u4 in e3)
      "ref" == u4 ? s4 = e3[u4] : a4[u4] = e3[u4];
    var i4 = { type: o4, props: a4, key: n2, ref: s4, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, __h: null, constructor: void 0, __v: --_2, __source: f3, __self: l4 };
    if ("function" == typeof o4 && (s4 = o4.defaultProps))
      for (u4 in s4)
        void 0 === a4[u4] && (a4[u4] = s4[u4]);
    return l.vnode && l.vnode(i4), i4;
  }

  // src/ScaleLine/index.tsx
  function ScaleLine2({ map: map2, options, ...props }) {
    const [target, setTarget] = h2();
    const control = F2(() => {
      if (!target) {
        return null;
      }
      return new ScaleLine_default({ target, ...options });
    }, [options, target]);
    p5(() => {
      let keys = [];
      if (!map2 || !control) {
        return;
      }
      map2.addControl(control);
      return () => {
        if (map2 && control) {
          map2.removeControl(control);
        }
      };
    }, [map2, control]);
    return /* @__PURE__ */ o3(
      "div",
      {
        ref: (node) => {
          setTarget(node);
        },
        ...props,
        children: /* @__PURE__ */ o3("style", { children: ScaleLine_default2 })
      }
    );
  }
  var ScaleLine_default3 = ScaleLine2;

  // src/Copyright/index.css
  var Copyright_default = `a  {
  white-space: pre;
}`;

  // src/Copyright/index.tsx
  function Copyright({ map: map2, options, ...props }) {
    const [target, setTarget] = h2();
    const control = F2(() => {
      if (!target) {
        return null;
      }
      const div = document.createElement("div");
      div.className = "flex flex-wrap-reverse justify-end";
      return new CopyrightControl_default({
        target,
        element: div,
        ...options
      });
    }, [options, target]);
    p5(() => {
      let keys = [];
      if (!map2 || !control) {
        return;
      }
      control.attachToMap(map2);
      return () => {
        if (control) {
          control.detachFromMap();
        }
      };
    }, [map2, control]);
    return /* @__PURE__ */ o3(
      "div",
      {
        ref: (node) => {
          setTarget(node);
        },
        ...props,
        children: /* @__PURE__ */ o3("style", { children: Copyright_default })
      }
    );
  }
  var Copyright_default2 = Copyright;

  // node_modules/rosetta/dist/index.mjs
  var import_dlv = __toESM(require_dlv_umd(), 1);

  // node_modules/templite/dist/templite.mjs
  var RGX = /{{(.*?)}}/g;
  function templite_default(str, mix) {
    return str.replace(RGX, (x2, key, y2) => {
      x2 = 0;
      y2 = mix;
      key = key.trim().split(".");
      while (y2 && x2 < key.length) {
        y2 = y2[key[x2++]];
      }
      return y2 != null ? y2 : "";
    });
  }

  // node_modules/rosetta/dist/index.mjs
  function dist_default(obj) {
    var locale = "", tree = obj || {};
    return {
      set(lang, table) {
        tree[lang] = Object.assign(tree[lang] || {}, table);
      },
      locale(lang) {
        return locale = lang || locale;
      },
      table(lang) {
        return tree[lang];
      },
      t(key, params, lang) {
        var val = (0, import_dlv.default)(tree[lang || locale], key, "");
        if (typeof val === "function")
          return val(params);
        if (typeof val === "string")
          return templite_default(val, params);
        return val;
      }
    };
  }

  // src/GeolocationButton/index.tsx
  var TRACKING_ZOOM = 16;
  function GeolocationButton({ map: map2, isTracking, ...props }) {
    const geolocation = F2(() => {
      return new Geolocation_default();
    }, []);
    p5(() => {
      let keys = [];
      if (!map2 || !geolocation) {
        return;
      }
      keys = [
        // First time we zoom and center on the position
        geolocation.once("change:position", (evt) => {
          const position = evt.target.getPosition();
          if (evt.target.getPosition()) {
            map2.getView().setZoom(TRACKING_ZOOM);
            map2.getView().setCenter(fromLonLat(position, "EPSG:3857"));
          }
        }),
        // then we only center the map.
        geolocation.on("change:position", (evt) => {
          const position = evt.target.getPosition();
          if (evt.target.getPosition()) {
            map2.getView().setCenter(fromLonLat(position, "EPSG:3857"));
          }
        })
      ];
      return () => {
        unByKey(keys);
      };
    }, [map2, geolocation]);
    p5(() => {
      geolocation.setTracking(isTracking);
    }, [geolocation, isTracking]);
    return /* @__PURE__ */ o3("button", { className: "bg-white shadow-lg rounded-full p-1", ...props, children: /* @__PURE__ */ o3(
      "svg",
      {
        className: isTracking ? "animate-pulse" : "",
        stroke: "currentColor",
        fill: "currentColor",
        "stroke-width": "0",
        viewBox: "0 0 512 512",
        focusable: "false",
        height: "1.5em",
        width: "1.5em",
        xmlns: "http://www.w3.org/2000/svg",
        children: /* @__PURE__ */ o3("path", { d: "M256 56c110.532 0 200 89.451 200 200 0 110.532-89.451 200-200 200-110.532 0-200-89.451-200-200 0-110.532 89.451-200 200-200m0-48C119.033 8 8 119.033 8 256s111.033 248 248 248 248-111.033 248-248S392.967 8 256 8zm0 168c-44.183 0-80 35.817-80 80s35.817 80 80 80 80-35.817 80-80-35.817-80-80-80z" })
      }
    ) });
  }
  var GeolocationButton_default = GeolocationButton;

  // src/ScrollableHandler/index.tsx
  function ScrollableHandler(props) {
    const [elt, setElt] = h2();
    const [overlayElt, setOverlayElt] = h2();
    p5(() => {
      return () => {
        if (overlayElt) {
          overlayElt.style.height = "";
          overlayElt.style.maxHeight = "";
        }
      };
    }, [overlayElt]);
    return /* @__PURE__ */ o3(
      "div",
      {
        ref: (node) => {
          if (node) {
            setElt(node);
            setOverlayElt(node.parentElement);
          }
        },
        ...props,
        onPointerDown: (evt) => {
          const innerElt = overlayElt.querySelector(
            ".scrollable-inner"
          );
          elt.setPointerCapture(evt.pointerId);
          const mapRect = overlayElt.parentElement.getBoundingClientRect();
          const eltRect = elt.getBoundingClientRect();
          const deltaToTop = mapRect.top + (evt.clientY - eltRect.top);
          function onDragg(evt2) {
            overlayElt.style.height = `calc(100% - ${evt2.clientY - deltaToTop}px)`;
            overlayElt.style.maxHeight = `100%`;
          }
          function onDragStop(evt2) {
            evt2.target.releasePointerCapture(evt2.pointerId);
            document.removeEventListener("pointermove", onDragg);
            document.removeEventListener("pointerup", onDragStop);
          }
          document.addEventListener("pointerup", onDragStop);
          document.addEventListener("pointermove", onDragg);
          document.addEventListener("pointercancel", (evt2) => {
            console.log("pointercancel");
            document.removeEventListener("pointermove", onDragg);
            document.removeEventListener("pointerup", onDragStop);
            evt2.stopPropagation();
            evt2.preventDefault();
          });
        },
        children: props.children
      }
    );
  }
  var ScrollableHandler_default = ScrollableHandler;

  // src/RealtimeLayer/RouteSchedule/RouteSchedule.css
  var RouteSchedule_default = `
::-webkit-scrollbar {
  width: 3px;
}

::-webkit-scrollbar-thumb {
  background: lightgray;
  z-index: 5;
}

::-webkit-scrollbar-track {
  background: transparent;
}
`;

  // src/RealtimeLayer/RouteSchedule/index.tsx
  var pad = (integer) => {
    return integer < 10 ? `0${integer}` : integer;
  };
  var getHoursAndMinutes = (timeInMs) => {
    if (!timeInMs || timeInMs <= 0) {
      return "";
    }
    const date = new Date(timeInMs);
    return `${pad(date.getHours())}:${pad(date.getMinutes())}`;
  };
  var getDelayString = (delayInMs) => {
    let timeInMs = delayInMs;
    if (timeInMs < 0) {
      timeInMs = 0;
    }
    const h3 = Math.floor(timeInMs / 36e5);
    const m3 = Math.floor(timeInMs % 36e5 / 6e4);
    const s4 = Math.floor(timeInMs % 36e5 % 6e4 / 1e3);
    if (s4 === 0 && h3 === 0 && m3 === 0) {
      return "0";
    }
    if (s4 === 0 && h3 === 0) {
      return `${m3}m`;
    }
    if (s4 === 0) {
      return `${h3}h${m3}m`;
    }
    if (m3 === 0 && h3 === 0) {
      return `${s4}s`;
    }
    if (h3 === 0) {
      return `${m3}m${s4}s`;
    }
    return `${h3}h${m3}m${s4}s`;
  };
  var { getBgColor: getBgColor2 } = realtimeConfig_exports;
  var getDelayColor2 = (time) => {
    const secs = Math.round(time / 1800 / 2 * 3600 / 1e3);
    if (secs >= 3600) {
      return "text-red-600";
    }
    if (secs >= 500) {
      return "text-orange-600";
    }
    if (secs >= 300) {
      return "text-amber-600";
    }
    if (secs >= 180) {
      return "text-yellow-600";
    }
    return "text-green-600";
  };
  var isNotStop = (stop) => {
    return !stop.arrivalTime && !stop.departureTime;
  };
  var isPassed = (stop, time, stops, idx) => {
    if (isNotStop(stop)) {
      if (stops[idx - 1] && idx > 0) {
        return isPassed(stops[idx - 1], time, stops, idx);
      }
      return true;
    }
    const timeToCompare = stop.aimedDepartureTime || stop.aimedArrivalTime || 0;
    const delayToCompare = stop.departureDelay || stop.arrivalDelay || 0;
    return timeToCompare + delayToCompare <= time;
  };
  var RouteStop = ({
    lineInfos,
    onStationClick,
    trackerLayer,
    stop,
    idx,
    t: t3
  }) => {
    const {
      arrivalDelay,
      departureDelay,
      platform,
      state,
      stationName,
      aimedArrivalTime,
      aimedDepartureTime
    } = stop;
    const { stations, type, stroke, vehicleType } = lineInfos;
    const [isStationPassed, setIsStationPassed] = h2(false);
    const cancelled = state === "JOURNEY_CANCELLED" || state === "STOP_CANCELLED";
    const color = stroke || getBgColor2(type || vehicleType);
    const isFirstStation = idx === 0;
    const isLastStation = idx === stations.length - 1;
    const isInTransit = stations[idx - 1] && isPassed(stations[idx - 1], trackerLayer.time, stations, idx - 1) !== isStationPassed || stations[idx + 1] && isPassed(stations[idx + 1], trackerLayer.time, stations, idx + 1) !== isStationPassed ? true : false;
    const isNotRealtime = arrivalDelay === null;
    const hideDelay = isNotRealtime || isFirstStation || cancelled || isNotStop(stop) || isStationPassed;
    p5(() => {
      let timeout = null;
      const isStopPassed = isPassed(stop, trackerLayer.time, stations, idx);
      setIsStationPassed(isStopPassed);
      if (stop.state === "TIME_BASED" && !isStopPassed) {
        timeout = setInterval(() => {
          setIsStationPassed(isPassed(stop, trackerLayer.time, stations, idx));
        }, 2e4);
      }
      return () => {
        clearInterval(timeout);
      };
    }, [stop, trackerLayer, stations, idx]);
    console.log(lineInfos);
    return /* @__PURE__ */ o3(
      "button",
      {
        className: `w-full flex items-center hover:bg-slate-100 rounded scroll-mt-[50px] text-left ${isStationPassed ? "text-gray-500" : "text-gray-600"}`,
        "data-station-passed": isStationPassed,
        onClick: (e3) => onStationClick(stop, e3),
        children: [
          /* @__PURE__ */ o3("div", { className: "flex flex-col w-10 flex-shrink-0 items-start justify-center text-xs ml-4", children: [
            /* @__PURE__ */ o3(
              "span",
              {
                className: `${cancelled ? "text-red-600 line-through" : ""} ${isFirstStation ? "hidden" : ""}`,
                children: getHoursAndMinutes(aimedArrivalTime)
              }
            ),
            /* @__PURE__ */ o3(
              "span",
              {
                className: `${cancelled ? "text-red-600 line-through" : ""} ${isLastStation ? "hidden" : ""}`,
                children: getHoursAndMinutes(aimedDepartureTime)
              }
            )
          ] }),
          /* @__PURE__ */ o3("div", { className: "flex flex-col w-7 flex-shrink-0 justify-center text-xs", children: [
            hideDelay || isFirstStation ? "" : /* @__PURE__ */ o3("span", { className: getDelayColor2(arrivalDelay), children: `+${getDelayString(arrivalDelay)}` }),
            hideDelay || isLastStation ? "" : /* @__PURE__ */ o3("span", { className: getDelayColor2(departureDelay), children: `+${getDelayString(departureDelay)}` })
          ] }),
          /* @__PURE__ */ o3("div", { className: "flex flex-shrink-0 items-center justify-center w-8", children: /* @__PURE__ */ o3(
            "svg",
            {
              xmlns: "http://www.w3.org/2000/svg",
              width: "16",
              height: "58",
              viewBox: "0 0 14 58",
              fill: "none",
              className: isStationPassed ? "stroke-gray-400" : null,
              stroke: isStationPassed ? void 0 : color,
              children: [
                /* @__PURE__ */ o3(
                  "circle",
                  {
                    cx: "7",
                    cy: "29",
                    r: "5",
                    fill: "white",
                    "stroke-width": "6",
                    stroke: "black"
                  }
                ),
                /* @__PURE__ */ o3(
                  "line",
                  {
                    x1: "7",
                    y1: isFirstStation ? "29" : isInTransit && !isStationPassed ? "0" : "0",
                    x2: "7",
                    y2: isLastStation ? "29" : isInTransit && isStationPassed ? "58" : "58",
                    "stroke-width": "6",
                    stroke: "black"
                  }
                ),
                /* @__PURE__ */ o3(
                  "line",
                  {
                    x1: "7",
                    y1: isFirstStation ? "29" : isInTransit && !isStationPassed ? "0" : "0",
                    x2: "7",
                    y2: isLastStation ? "29" : isInTransit && isStationPassed ? "58" : "58",
                    "stroke-width": "4"
                  }
                ),
                /* @__PURE__ */ o3("circle", { cx: "7", cy: "29", r: "5", fill: "white", "stroke-width": "4" }),
                /* @__PURE__ */ o3(
                  "circle",
                  {
                    cx: "7",
                    cy: "29",
                    r: "3",
                    fill: "white",
                    "stroke-width": "1",
                    stroke: "black"
                  }
                )
              ]
            }
          ) }),
          /* @__PURE__ */ o3(
            "div",
            {
              className: `flex text-sm font-medium pr-2 justify-between flex-grow ${cancelled ? "text-red-600 line-through" : ""} ${isStationPassed ? "" : "text-black"}`,
              children: /* @__PURE__ */ o3("div", { className: "", children: [
                /* @__PURE__ */ o3("div", { children: stationName }),
                platform ? /* @__PURE__ */ o3(
                  "span",
                  {
                    className: `${isStationPassed ? "bg-slate-100" : "bg-slate-200"} rounded-sm text-xs py-px px-0.5 group-hover:bg-slate-50`,
                    children: [
                      t3(`depature_${type}`),
                      " ",
                      platform
                    ]
                  }
                ) : null
              ] })
            }
          )
        ]
      }
    );
  };
  var renderStation = (props) => {
    const { stationId, arrivalTime, departureTime, stationName } = props.stop;
    return /* @__PURE__ */ o3(
      RouteStop,
      {
        ...props
      },
      (stationId || stationName) + arrivalTime + departureTime
    );
  };
  var renderRouteIdentifier = ({ routeIdentifier, longName }) => {
    if (routeIdentifier) {
      console.log(routeIdentifier, longName);
      let id = routeIdentifier;
      if (/\./.test(routeIdentifier)) {
        id = routeIdentifier.split(".")[0];
      } else if (/\_/.test(routeIdentifier)) {
        id = routeIdentifier.split("_")[0];
      } else if (/\:/.test(routeIdentifier)) {
        id = routeIdentifier.split(":")[0];
      }
      if (/^\d*$/.test(id)) {
        id = parseInt(id, 10) + "";
      }
      if (!longName.includes(id)) {
        return ` (${id})`;
      }
    }
    return null;
  };
  var renderHeader = (props) => {
    const { lineInfos, isFollowing, onFollowButtonClick } = props;
    const {
      type,
      vehicleType,
      shortName,
      longName,
      stroke,
      destination,
      text_color: textColor
    } = lineInfos;
    const backgroundColor = stroke || getBgColor2(type || vehicleType);
    const color = textColor || "black";
    return /* @__PURE__ */ o3("div", { className: "bg-slate-100 p-4 flex gap-x-4 items-center", children: [
      /* @__PURE__ */ o3(
        "span",
        {
          className: "border-2 border-black rounded-full font-bold text-sm h-9 min-w-[2.25rem] px-1 flex items-center justify-center",
          style: {
            backgroundColor,
            color
          },
          children: shortName
        }
      ),
      /* @__PURE__ */ o3("div", { className: "flex-grow flex flex-col", children: [
        /* @__PURE__ */ o3("span", { className: "font-bold", children: destination }),
        /* @__PURE__ */ o3("span", { className: "text-sm", children: [
          longName,
          renderRouteIdentifier(lineInfos)
        ] })
      ] }),
      /* @__PURE__ */ o3(
        "button",
        {
          className: `flex flex-none bg-white shadow-lg rounded-full w-[38px] h-[38px] items-center justify-center p-1.5 ${isFollowing ? "animate-pulse" : ""}`,
          style: {
            /* stylelint-disable-next-line value-keyword-case */
            backgroundColor: isFollowing ? backgroundColor : "white",
            color: isFollowing ? color : "black"
          },
          onClick: onFollowButtonClick,
          children: /* @__PURE__ */ o3(
            "svg",
            {
              width: "24",
              height: "24",
              viewBox: "0 0 14 14",
              fill: "none",
              xmlns: "http://www.w3.org/2000/svg",
              part: "svg",
              children: [
                /* @__PURE__ */ o3(
                  "path",
                  {
                    "fill-rule": "evenodd",
                    "clip-rule": "evenodd",
                    fill: "currentColor",
                    d: "M7 0.333344C7.375 0.333344 7.66667 0.62501 7.66667 0.97921V2.35414C9.7292 2.66668 11.3333 4.27081 11.625 6.33334H13C13.375 6.33334 13.6667 6.62501 13.6667 7.00001C13.6667 7.37501 13.375 7.66668 13 7.66668H11.625C11.3333 9.70834 9.70833 11.3333 7.66667 11.625V13C7.66667 13.375 7.375 13.6667 7 13.6667C6.64587 13.6667 6.33333 13.375 6.33333 13V11.625C4.29167 11.3333 2.68747 9.70834 2.39587 7.66668H1C0.625 7.66668 0.333333 7.37501 0.333333 7.00001C0.333333 6.62501 0.625 6.33334 1 6.33334H2.39587C2.68747 4.27081 4.29167 2.66668 6.33333 2.35414V0.97921C6.33333 0.62501 6.64587 0.333344 7 0.333344ZM7 3.66668C5.16667 3.66668 3.66667 5.16668 3.66667 7.00001C3.66667 8.79168 5.08333 10.3125 7 10.3125C8.89587 10.3125 10.3333 8.81254 10.3333 7.00001C10.3333 5.16668 8.83333 3.66668 7 3.66668Z"
                  }
                ),
                /* @__PURE__ */ o3(
                  "path",
                  {
                    part: "circle",
                    "fill-rule": "evenodd",
                    "clip-rule": "evenodd",
                    fill: "currentColor",
                    d: "M5.66667 7.00001C5.66667 6.27081 6.2708 5.66668 7 5.66668C7.7292 5.66668 8.33333 6.27081 8.33333 7.00001C8.33333 7.72921 7.7292 8.33334 7 8.33334C6.2708 8.33334 5.66667 7.72921 5.66667 7.00001Z"
                  }
                )
              ]
            }
          )
        }
      )
    ] });
  };
  var renderFooter = (props) => {
    const { lineInfos } = props;
    if (!lineInfos.operator && !lineInfos.publisher) {
      return null;
    }
    return /* @__PURE__ */ o3(k, { children: [
      /* @__PURE__ */ o3("div", { className: "m-4 mb-0 text-sm text-gray-500  flex flex-wrap ", children: [
        lineInfos.operator && defaultRenderLink(lineInfos.operator, lineInfos.operatorUrl),
        lineInfos.operator && lineInfos.publisher && /* @__PURE__ */ o3("span", { children: "\xA0-\xA0" }),
        lineInfos.publisher && defaultRenderLink(lineInfos.publisher, lineInfos.publisherUrl),
        lineInfos.license && /* @__PURE__ */ o3("span", { children: "\xA0(" }),
        lineInfos.license && defaultRenderLink(lineInfos.license, lineInfos.licenseUrl),
        lineInfos.license && ")"
      ] }),
      /* @__PURE__ */ o3("div", { className: "bg-gradient-to-b from-transparent to-white h-8 sticky bottom-0 w-full pointer-events-none" })
    ] });
  };
  var defaultRenderLink = (text, url) => {
    return url ? /* @__PURE__ */ o3(
      "a",
      {
        href: url,
        target: "_blank",
        rel: "noreferrer",
        className: "underline whitespace-normal",
        children: text
      }
    ) : /* @__PURE__ */ o3(k, { children: text });
  };
  function RouteSchedule(props) {
    const { t: t3 } = q2(I18nContext);
    const ref = _();
    if (!props.lineInfos) {
      return null;
    }
    p5(() => {
      let timeout = null;
      const interval = window.setInterval(() => {
        const elt = ref.current;
        if (!elt) {
          return;
        }
        const nextStation = elt.querySelector("[data-station-passed=false]");
        if (nextStation) {
          nextStation.scrollIntoView({
            behavior: "smooth"
          });
        }
        clearInterval(interval);
      }, 300);
      return () => {
        clearTimeout(interval);
      };
    }, [props.lineInfos]);
    return /* @__PURE__ */ o3(k, { children: [
      renderHeader({ ...props }),
      /* @__PURE__ */ o3("div", { ref, className: props.className, children: [
        /* @__PURE__ */ o3("style", { children: RouteSchedule_default }),
        props.lineInfos.stations.map((stop, idx) => {
          return renderStation({ ...props, stop, idx, t: t3 });
        }),
        renderFooter({ ...props })
      ] })
    ] });
  }

  // src/utils/hooks/useMapContext.tsx
  var MapContext = G(null);
  var useMapContext = () => {
    const context = q2(MapContext);
    if (!context) {
      throw new Error("useMapContext must be used within a ContextProvider");
    }
    return context;
  };
  var useMapContext_default = useMapContext;

  // src/utils/hooks/useParams.ts
  var useParams = () => {
    const params = new URLSearchParams(window.location.search);
    return Object.fromEntries(new URLSearchParams(window.location.search));
  };
  var useParams_default = useParams;

  // src/utils/centerOnVehicle.ts
  var centerOnVehicle = async (vehicle, map2, targetZoom = 0) => {
    if (!vehicle) {
      return Promise.reject();
    }
    const {
      // @ts-ignore
      properties: { coordinate },
      geometry
    } = vehicle;
    const view = map2.getView();
    const zoom = targetZoom || view.getZoom();
    const resolution = zoom > 0 ? view.getResolutionForZoom(zoom) : void 0;
    let center = coordinate;
    if (!center && geometry) {
      const { coord } = getVehiclePosition_default(Date.now(), vehicle, true);
      center = coord;
    }
    if (!center) {
      return Promise.reject();
    }
    view.cancelAnimations();
    map2.renderSync();
    const promise = new Promise((resolve) => {
      view.animate(
        {
          center,
          resolution,
          duration: 1e3,
          easing: linear
        },
        (success) => {
          resolve(success);
        }
      );
    });
    return promise;
  };
  var centerOnVehicle_default = centerOnVehicle;

  // src/RealtimeLayer/RealtimeLayer.tsx
  var i18n = dist_default({
    de: {
      depature_rail: "Gleis",
      depature_ferry: "Steg",
      depature_other: "Kante"
    },
    en: {
      depature_rail: "platform",
      depature_ferry: "pier",
      depature_other: "stand"
    },
    fr: {
      depature_rail: "voie",
      depature_ferry: "quai",
      depature_other: "quai"
    },
    it: {
      depature_rail: "binario",
      depature_ferry: "imbarcadero",
      depature_other: "corsia"
    }
  });
  i18n.locale(
    navigator.languages.find((l4) => i18n.table(l4.split("-")[0]) !== void 0)?.split("-")[0] || "en"
  );
  var I18nContext = G(i18n);
  var TRACKING_ZOOM2 = 16;
  function RealtimeLayer2({
    apikey,
    mots: propMots,
    tenant,
    realtimeUrl = "wss://tralis-tracker-api.geops.io/ws"
  }) {
    const { map: map2 } = useMapContext_default();
    const {
      realtimeurl: paramsRealtimeUrl,
      tenant: paramsTenant,
      mots: paramsMots
    } = useParams_default();
    const [lineInfos, setLineInfos] = h2(null);
    const [isTracking, setIsTracking] = h2(false);
    const [isFollowing, setIsFollowing] = h2(false);
    const [feature, setFeature] = h2(null);
    const mots = paramsMots || propMots;
    const tracker = F2(() => {
      if (apikey) {
        return new RealtimeLayer_default({
          apiKey: apikey,
          url: paramsRealtimeUrl || realtimeUrl,
          getMotsByZoom: mots ? () => mots.split(",") : void 0,
          fullTrajectoryStyle: null,
          tenant: paramsTenant || tenant
        });
      }
    }, [apikey, mots, tenant]);
    p5(() => {
      if (!tracker) {
        return;
      }
      tracker.attachToMap(map2);
      tracker.onClick(([feature2]) => {
        setFeature(feature2);
      });
      return () => {
        map2.setTarget();
      };
    }, [tracker]);
    p5(() => {
      let vehicleId = null;
      if (feature) {
        vehicleId = feature.get("train_id");
        tracker.api.subscribeStopSequence(
          vehicleId,
          ({ content: [stopSequence] }) => {
            if (stopSequence) {
              setLineInfos(stopSequence);
            }
          }
        );
      } else {
        setLineInfos(null);
      }
      return () => {
        if (vehicleId) {
          tracker.api.unsubscribeStopSequence(vehicleId);
        }
      };
    }, [feature]);
    p5(() => {
      if (!lineInfos) {
        setIsFollowing(false);
      } else {
      }
    }, [lineInfos]);
    p5(() => {
      let olKeys = [];
      if (isTracking) {
        setIsFollowing(false);
      }
      return () => {
        unByKey(olKeys);
      };
    }, [isTracking]);
    p5(() => {
      let onMovestartKey = null;
      onMovestartKey = map2.getView().on("change:center", (evt) => {
        if (evt.target.getInteracting()) {
          setIsFollowing(false);
          setIsTracking(false);
        }
      });
      return () => {
        unByKey(onMovestartKey);
      };
    }, []);
    p5(() => {
      let interval = null;
      let interval2 = null;
      if (tracker) {
        tracker.useThrottle = !isFollowing;
        tracker.allowRenderWhenAnimating = !!isFollowing;
      }
      if (!isFollowing || !lineInfos || !map2 || !tracker) {
        return;
      }
      setIsTracking(false);
      const followVehicle = async (id) => {
        let vehicle = id && tracker?.trajectories?.[id];
        if (!vehicle) {
          vehicle = await tracker.api.getTrajectory(lineInfos.id, tracker.mode).then((message) => message.content);
        }
        const success = await centerOnVehicle_default(vehicle, map2, TRACKING_ZOOM2);
        if (success === true) {
          interval = setInterval(() => {
            centerOnVehicle_default(tracker?.trajectories?.[lineInfos.id], map2);
          }, 1e3);
        }
      };
      followVehicle(lineInfos.id);
      return () => {
        clearInterval(interval);
      };
    }, [isFollowing, map2, tracker, lineInfos]);
    return /* @__PURE__ */ o3(I18nContext.Provider, { value: i18n, children: [
      /* @__PURE__ */ o3("div", { className: "z-20 absolute right-2 top-2 flex flex-col gap-2", children: /* @__PURE__ */ o3(
        GeolocationButton_default,
        {
          map: map2,
          isTracking,
          onClick: () => {
            setIsTracking(!isTracking);
          }
        }
      ) }),
      /* @__PURE__ */ o3(
        "div",
        {
          className: `flex-0 relative overflow-hidden border-t @lg:borderstopSequence-t-0 @lg:border-r flex flex-col ${lineInfos ? "w-full min-h-[75px] max-h-[70%] @lg:w-[350px] @lg:max-h-full @lg:h-[100%!important]" : "hidden"}`,
          children: !!lineInfos && /* @__PURE__ */ o3(k, { children: [
            /* @__PURE__ */ o3(ScrollableHandler_default, { className: "z-10 absolute inset-0 w-full h-[60px] touch-none @lg:hidden flex justify-center ", children: /* @__PURE__ */ o3(
              "div",
              {
                className: "bg-gray-300",
                style: {
                  width: 32,
                  height: 4,
                  borderRadius: 2,
                  margin: 6
                }
              }
            ) }),
            /* @__PURE__ */ o3(
              RouteSchedule,
              {
                className: "z-5 relative overflow-x-hidden overflow-y-auto  scrollable-inner",
                lineInfos,
                trackerLayer: tracker,
                onStationClick: (station) => {
                  if (station.coordinate) {
                    const size = map2.getSize();
                    const extent = map2.getView().calculateExtent(size);
                    const offset2 = (extent[2] - extent[0]) / 5;
                    map2.getView().animate({
                      zoom: map2.getView().getZoom(),
                      center: [
                        station.coordinate[0] - offset2,
                        station.coordinate[1]
                      ]
                    });
                  }
                },
                isFollowing,
                onFollowButtonClick: () => {
                  setIsFollowing(!isFollowing);
                }
              }
            )
          ] })
        }
      )
    ] });
  }
  var RealtimeLayer_default2 = RealtimeLayer2;

  // src/utils/addSourceAndLayers.ts
  var addSourceAndLayers = (mapboxLayer, sourceId, sourceData, styleLayer, beforeLayerId) => {
    if (!mapboxLayer.loaded) {
      mapboxLayer.once("load", () => {
        addSourceAndLayers(
          mapboxLayer,
          sourceId,
          sourceData,
          styleLayer,
          beforeLayerId
        );
      });
      return;
    }
    const { mbMap } = mapboxLayer;
    if (sourceId && sourceData) {
      const source = mbMap.getSource(sourceId);
      if (source) {
        source.setData(sourceData.data);
      } else {
        mbMap.addSource(sourceId, sourceData);
      }
    }
    if (styleLayer) {
      let layer = mbMap.getLayer(sourceId);
      if (layer) {
        mbMap.removeLayer(layer.id);
      }
      let styleLayers = styleLayer;
      if (!Array.isArray(styleLayer)) {
        styleLayers = [styleLayer];
      }
      styleLayers.forEach((style) => {
        if (mbMap.getSource(style.source)) {
          layer = mbMap.getLayer(style.id);
          if (layer) {
            mbMap.removeLayer(layer.id);
          }
          mbMap.addLayer(style, beforeLayerId);
        } else {
          console.warn(
            `The source ${style.source} doesn't exist. This layer can't be added`,
            style
          );
        }
      });
    }
  };
  var addSourceAndLayers_default = addSourceAndLayers;

  // src/NotificationLayer/notificationUtils.ts
  var format2 = new GeoJSON_default();
  var getTime = (str) => parseInt(str?.substr(0, 8).replace(/:/g, ""), 10);
  var getNotificationsWithStatus = (notifications, now) => {
    return notifications.filter((n2) => {
      const notOutOfDate = n2.properties.affected_time_intervals.some((ati) => {
        return now < new Date(ati.end);
      });
      return notOutOfDate;
    }).map((n2) => {
      const isActive = n2.properties.affected_time_intervals.some((ati) => {
        const {
          time_of_day_start: dayTimeStart,
          time_of_day_end: dayTimeEnd,
          start,
          end
        } = ati;
        const nowTime = getTime(now.toTimeString());
        const startTime = getTime(dayTimeStart);
        const endTime = getTime(dayTimeEnd);
        const inRange = new Date(start) <= now && now <= new Date(end);
        return startTime && endTime ? inRange && startTime <= nowTime && nowTime <= endTime : inRange;
      });
      const next = n2.properties.affected_time_intervals.reduce((a4, b3) => {
        const aEnd = new Date(a4.end);
        const aStart = new Date(a4.start);
        const bStart = new Date(b3.start);
        return now < aEnd && aStart < bStart ? a4 : b3;
      }, []);
      const nextStartDate = new Date(next.start);
      let starts;
      if (now.toDateString() === nextStartDate.toDateString() || now.getTime() - nextStartDate.getTime() > 0) {
        if (next.time_of_day_start) {
          starts = `ab ${next.time_of_day_start.substr(0, 5)}`;
        } else {
          starts = `ab ${nextStartDate.toLocaleTimeString(["de"], {
            hour: "2-digit",
            minute: "2-digit",
            hour12: false
          })}`;
        }
      } else {
        starts = `ab ${nextStartDate.toLocaleDateString(["de-DE"], {
          month: "short",
          day: "numeric"
        })}`;
      }
      let iconRefPoint;
      const iconRef = n2.features.find((f3) => f3.properties.is_icon_ref);
      if (iconRef) {
        const iconRefFeature = format2.readFeature(iconRef, {
          dataProjection: "EPSG:4326",
          featureProjection: "EPSG:3857"
        });
        const center = getCenter(iconRefFeature.getGeometry().getExtent());
        iconRefPoint = iconRefFeature.getGeometry().getClosestPoint(center);
      }
      const properties = {
        ...n2.properties,
        iconRefPoint,
        isActive,
        starts
      };
      const features = n2.features.map((f3) => ({
        ...f3,
        properties: { ...f3.properties, ...properties }
      }));
      return {
        ...n2,
        features,
        properties
      };
    });
  };
  var getCurrentGraph = (mapping, zoom) => {
    const breakPoints = Object.keys(mapping).map((k3) => parseFloat(k3));
    const closest = breakPoints.reverse().find((bp) => bp <= Math.floor(zoom) - 1);
    return mapping[closest || Math.min(...breakPoints)];
  };
  var addNotificationsLayers = (mapboxLayer, notifications, beforeLayerId, zoom, graphMapping) => {
    if (!mapboxLayer) {
      return;
    }
    const features = notifications.map((n2) => n2.features).flat();
    addSourceAndLayers_default(
      mapboxLayer,
      "notifications",
      {
        type: "geojson",
        data: {
          type: "FeatureCollection",
          features
        }
      },
      [
        {
          id: "notificationsActive",
          source: "notifications",
          type: "line",
          paint: {
            "line-width": 5,
            "line-color": "rgba(255,0,0,1)",
            "line-dasharray": [2, 2]
          },
          layout: { visibility: "visible" },
          filter: [
            "all",
            ["==", ["get", "isActive"], true],
            ["==", ["get", "graph"], getCurrentGraph(graphMapping, zoom)],
            ["==", ["get", "disruption_type"], "DISRUPTION"]
          ]
        }
      ],
      beforeLayerId
    );
  };
  var parsePreviewNotification = (mocoPreviewObject) => {
    let properties = {};
    const features = Object.keys(mocoPreviewObject.graphs).map((graph) => {
      const feature = mocoPreviewObject.graphs[graph].features[0];
      properties = mocoPreviewObject.graphs[graph].properties;
      return { ...feature, properties: { ...feature.properties, graph } };
    });
    return {
      type: "FeatureCollection",
      properties,
      features
    };
  };

  // src/NotificationLayer/NotificationLayer.tsx
  var zoomTimeout = null;
  var abortCtrl = new AbortController();
  var useZoom = () => {
    const { map: map2 } = useMapContext_default();
    const [zoom, setZoom] = h2(map2.getView().getZoom());
    p5(() => {
      const view = map2.getView();
      const zoomListener = view.on("change:resolution", () => {
        clearTimeout(zoomTimeout);
        zoomTimeout = setTimeout(() => setZoom(view.getZoom()), 150);
      });
      return () => unByKey(zoomListener);
    }), [map2];
    return zoom;
  };
  var useNotifications = (notificationUrl, notificationBeforeLayerId) => {
    const {
      notificationurl: paramsNotificationUrl,
      notificationbeforelayerid: paramsNotificationBeforeLayerId,
      notificationat: paramsNotificationAt
    } = useParams_default();
    const { baseLayer } = useMapContext_default();
    const zoom = useZoom();
    const [notifications, setNotifications] = h2([]);
    const [previewNotification, setPreviewNotification] = h2(null);
    const [shouldAddPreviewNotifications, setShouldAddPreviewNotifications] = h2(true);
    const [styleMetadata, setStyleMetadata] = h2(
      baseLayer.mbMap?.getStyle()?.metadata
    );
    if (!styleMetadata || !baseLayer.loaded) {
      baseLayer.once(
        "load",
        () => setStyleMetadata(baseLayer.mbMap?.getStyle()?.metadata)
      );
    }
    const notificationsUrl = paramsNotificationUrl || notificationUrl;
    const beforeLayerId = paramsNotificationBeforeLayerId || notificationBeforeLayerId;
    const now = paramsNotificationAt ? new Date(paramsNotificationAt) : /* @__PURE__ */ new Date();
    const style = baseLayer.name.split("mwc.baselayer.")[1];
    const graphMapping = styleMetadata?.graphs || { 1: "osm" };
    const graphsString = [
      ...new Set(Object.keys(graphMapping || []).map((key) => graphMapping[key]))
    ].join(",");
    p5(() => {
      window.addEventListener("message", (event) => {
        if (event.data.notification) {
          setPreviewNotification(event.data.notification);
          setShouldAddPreviewNotifications(true);
        }
      });
    }, []);
    p5(() => {
      const fetchNotifications = async () => {
        const suffix = /\?/.test(notificationsUrl) ? "&" : "?";
        const url = `${notificationsUrl}${suffix}graph=${graphsString}`;
        abortCtrl.abort();
        abortCtrl = new AbortController();
        const response = await fetch(url, { signal: abortCtrl.signal });
        const data = await response.json();
        setNotifications(getNotificationsWithStatus(data, now));
        setShouldAddPreviewNotifications(true);
      };
      if (notificationsUrl && graphsString) {
        fetchNotifications();
      }
    }, [notificationsUrl, graphsString]);
    p5(() => {
      const newNotifications = [...notifications];
      if (shouldAddPreviewNotifications && previewNotification?.[style]) {
        const parsedPreviewNotification = parsePreviewNotification(
          previewNotification?.[style]
        );
        const index = newNotifications.findIndex(
          (n2) => n2.properties.id === previewNotification[style].id
        );
        if (index > -1) {
          newNotifications[index] = parsedPreviewNotification;
        } else {
          newNotifications.push(parsedPreviewNotification);
        }
        setNotifications(getNotificationsWithStatus(newNotifications, now));
        setShouldAddPreviewNotifications(false);
      }
    }, [
      previewNotification,
      notifications,
      shouldAddPreviewNotifications,
      style
    ]);
    p5(() => {
      if (styleMetadata && notifications?.length) {
        addNotificationsLayers(
          baseLayer,
          notifications,
          beforeLayerId,
          zoom,
          graphMapping
        );
      }
    }, [notifications, styleMetadata, zoom]);
    return notifications;
  };
  function NotificationLayer({
    notificationUrl,
    notificationBeforeLayerId
  }) {
    useNotifications(notificationUrl, notificationBeforeLayerId);
    return null;
  }

  // src/MobilityToolboxMap.tsx
  var map = new Map_default2({ controls: [] });
  var useBaseLayer = (style, apikey, map2, target) => {
    const { tilesurl } = useParams_default();
    const [baseLayer, setBaseLayer] = h2(null);
    p5(() => {
      if (apikey && target) {
        map2.setTarget(target);
        map2.updateSize();
        const layer = new MaplibreLayer({
          apiKey: apikey,
          url: `${tilesurl || "https://maps.geops.io"}/styles/${style}/style.json`,
          name: `mwc.baselayer.${style}`
        });
        layer.attachToMap(map2);
        setBaseLayer(layer);
      }
      return () => {
        map2.setTarget();
      };
    }, [style, target, apikey]);
    return baseLayer;
  };
  function MobilityToolboxMap({
    type = "basic",
    apikey,
    baselayer = "travic_v2",
    center = "831634,5933959",
    mots = "rail",
    tenant,
    zoom = "10",
    notificationurl,
    notificationbeforelayerid,
    realtimeurl,
    maxzoom,
    minzoom
  }) {
    const {
      type: paramsType,
      center: paramsCenter,
      baselayer: paramsBaseLayer,
      zoom: paramsZoom,
      maxzoom: paramsMaxZoom,
      minzoom: paramsMinZoom
    } = useParams_default();
    const [ref, setRef] = h2();
    const mapType = paramsType || type;
    const mapCenter = paramsCenter || center;
    const baseLayerStyle = paramsBaseLayer || baselayer;
    const baseLayer = useBaseLayer(baseLayerStyle, apikey, map, ref);
    const maximumZoom = (paramsMaxZoom || maxzoom) && parseFloat(paramsMaxZoom || maxzoom);
    const minimumZoom = (paramsMinZoom || minzoom) && parseFloat(paramsMinZoom || minzoom);
    p5(() => {
      map.getView().setCenter(mapCenter.split(",").map((c4) => parseInt(c4)));
      map.getView().setZoom(parseFloat(paramsZoom || zoom));
      map.getView().setMaxZoom(maximumZoom);
      map.getView().setMinZoom(minimumZoom);
    }, []);
    return /* @__PURE__ */ o3(MapContext.Provider, { value: { map, baseLayer }, children: [
      /* @__PURE__ */ o3("style", { children: ol_default }),
      /* @__PURE__ */ o3("style", { children: style_default }),
      /* @__PURE__ */ o3("div", { className: "@container/main w-full h-full relative border", children: /* @__PURE__ */ o3("div", { className: "w-full h-full relative flex flex-col @lg/main:flex-row-reverse", children: [
        /* @__PURE__ */ o3(
          "div",
          {
            ref: (el) => setRef(el),
            className: "flex-1 relative overflow-hidden",
            children: /* @__PURE__ */ o3("div", { className: "z-10 absolute left-2 right-2 text-[10px] bottom-2 flex justify-between items-end gap-2", children: [
              /* @__PURE__ */ o3(
                ScaleLine_default3,
                {
                  map,
                  className: "bg-slate-50 bg-opacity-70"
                }
              ),
              /* @__PURE__ */ o3(
                Copyright_default2,
                {
                  map,
                  className: "bg-slate-50 bg-opacity-70"
                }
              )
            ] })
          }
        ),
        baseLayer && mapType === "realtime" ? /* @__PURE__ */ o3(
          RealtimeLayer_default2,
          {
            apikey,
            mots,
            tenant,
            realtimeUrl: realtimeurl
          }
        ) : null,
        baseLayer && mapType === "notification" ? /* @__PURE__ */ o3(
          NotificationLayer,
          {
            notificationUrl: notificationurl,
            notificationBeforeLayerId: notificationbeforelayerid
          }
        ) : null
      ] }) })
    ] });
  }
  var MobilityToolboxMap_default = MobilityToolboxMap;

  // src/index.tsx
  preact_custom_element_esm_default(
    MobilityToolboxMap_default,
    "mobility-toolbox-map",
    [
      "apikey",
      "baselayer",
      "center",
      "mots",
      "tenant",
      "zoom",
      "type",
      "notificationurl",
      "notificationbeforelayerid",
      "realtimeurl",
      "maxzoom",
      "minzoom"
    ],
    { shadow: true }
  );
})();
//# sourceMappingURL=bundle.js.map
